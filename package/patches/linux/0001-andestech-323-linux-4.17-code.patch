From d122016354b46030c86e278fcbb34fea7e85d75d Mon Sep 17 00:00:00 2001
From: wangjianxin <wangjianxin@canaan-creative.com>
Date: Wed, 27 Apr 2022 11:17:04 +0800
Subject: [PATCH 1/2] andestech-323-linux-4.17-code

---
 Documentation/.gitignore                      |    2 -
 Documentation/arm/SH-Mobile/.gitignore        |    1 -
 .../bindings/clock/sifive,gemgxl-mgmt.txt     |   26 +
 .../bindings/clock/sifive,u54-prci.txt        |   44 +
 .../interrupt-controller/riscv,cpu-intc.txt   |   41 +
 .../interrupt-controller/riscv,plic0.txt      |   55 +
 .../devicetree/bindings/riscv/cpus.txt        |   13 +-
 .../devicetree/bindings/spi/spi-sifive.txt    |   29 +
 Documentation/driver-api/infrastructure.rst   |    4 +-
 .../io/dma-api-debug/arch-support.txt         |   31 -
 Documentation/media/.gitignore                |    3 -
 Documentation/riscv/pmu.txt                   |  249 ++
 Documentation/vm/.gitignore                   |    2 -
 MAINTAINERS                                   |   17 +-
 arch/.gitignore                               |    2 -
 arch/Kconfig                                  |    3 -
 arch/alpha/Kconfig                            |   14 +-
 arch/alpha/kernel/.gitignore                  |    1 -
 arch/arc/Kconfig                              |    7 +-
 arch/arc/boot/.gitignore                      |    1 -
 arch/arc/kernel/.gitignore                    |    1 -
 arch/arm/Kconfig                              |   30 +-
 arch/arm/boot/.gitignore                      |    5 -
 arch/arm/boot/compressed/.gitignore           |   17 -
 arch/arm/crypto/.gitignore                    |    3 -
 arch/arm/include/asm/irq.h                    |    5 -
 arch/arm/include/asm/mach/arch.h              |    2 +-
 arch/arm/kernel/.gitignore                    |    1 -
 arch/arm/kernel/entry-armv.S                  |   10 +-
 arch/arm/kernel/irq.c                         |   10 -
 arch/arm/kernel/setup.c                       |    4 +-
 arch/arm/mach-axxia/Kconfig                   |    1 -
 arch/arm/mach-bcm/Kconfig                     |    1 -
 arch/arm/mach-exynos/Kconfig                  |    1 -
 arch/arm/mach-highbank/Kconfig                |    1 -
 arch/arm/mach-rockchip/Kconfig                |    1 -
 arch/arm/mach-shmobile/Kconfig                |    1 -
 arch/arm/mach-tegra/Kconfig                   |    1 -
 arch/arm/mm/Kconfig                           |    7 +-
 arch/arm/mm/dma-mapping-nommu.c               |    9 -
 arch/arm/mm/dma-mapping.c                     |    9 -
 arch/arm/vdso/.gitignore                      |    3 -
 arch/arm64/Kconfig                            |   26 +-
 arch/arm64/boot/.gitignore                    |    2 -
 arch/arm64/crypto/.gitignore                  |    2 -
 arch/arm64/include/asm/irq.h                  |    2 -
 arch/arm64/kernel/.gitignore                  |    1 -
 arch/arm64/kernel/irq.c                       |   10 -
 arch/arm64/kernel/vdso/.gitignore             |    1 -
 arch/arm64/mm/dma-mapping.c                   |   10 -
 arch/c6x/Kconfig                              |    1 -
 arch/c6x/kernel/dma.c                         |   11 -
 arch/ia64/Kconfig                             |   23 +-
 arch/ia64/kernel/.gitignore                   |    2 -
 arch/ia64/kernel/dma-mapping.c                |   10 -
 arch/m68k/kernel/.gitignore                   |    1 -
 arch/microblaze/Kconfig                       |    1 -
 arch/microblaze/boot/.gitignore               |    2 -
 arch/microblaze/kernel/.gitignore             |    1 -
 arch/microblaze/kernel/dma.c                  |   11 -
 arch/mips/Kconfig                             |   22 +-
 arch/mips/boot/.gitignore                     |    7 -
 arch/mips/boot/compressed/.gitignore          |    2 -
 arch/mips/boot/tools/.gitignore               |    1 -
 arch/mips/cavium-octeon/Kconfig               |   12 -
 arch/mips/kernel/.gitignore                   |    1 -
 arch/mips/loongson64/Kconfig                  |   15 -
 arch/mips/mm/dma-default.c                    |   10 -
 arch/mips/netlogic/Kconfig                    |    3 -
 arch/mips/vdso/.gitignore                     |    4 -
 arch/nds32/Kconfig                            |   15 +-
 arch/nds32/include/asm/Kbuild                 |    1 +
 arch/nds32/include/asm/dma-mapping.h          |   14 -
 arch/nds32/kernel/dma.c                       |  196 +-
 arch/nios2/boot/.gitignore                    |    1 -
 arch/nios2/kernel/.gitignore                  |    1 -
 arch/openrisc/Kconfig                         |    5 +-
 arch/openrisc/include/asm/irq.h               |    2 -
 arch/openrisc/kernel/.gitignore               |    1 -
 arch/openrisc/kernel/dma.c                    |   11 -
 arch/openrisc/kernel/irq.c                    |    7 -
 arch/parisc/Kconfig                           |    8 +-
 arch/parisc/boot/.gitignore                   |    2 -
 arch/parisc/boot/compressed/.gitignore        |    3 -
 arch/parisc/kernel/.gitignore                 |    1 -
 arch/powerpc/Kconfig                          |   21 +-
 arch/powerpc/boot/.gitignore                  |   47 -
 arch/powerpc/kernel/.gitignore                |    1 -
 arch/powerpc/kernel/dma.c                     |    3 -
 arch/powerpc/kernel/vdso32/.gitignore         |    2 -
 arch/powerpc/kernel/vdso64/.gitignore         |    2 -
 arch/powerpc/platforms/Kconfig.cputype        |    1 +
 arch/powerpc/platforms/cell/spufs/.gitignore  |    2 -
 arch/powerpc/purgatory/.gitignore             |    2 -
 arch/riscv/Kconfig                            |  162 +-
 arch/riscv/Kconfig-upstream                   |  397 +++
 arch/riscv/Makefile                           |   31 +-
 arch/riscv/andesv5/Makefile                   |    3 +
 arch/riscv/andesv5/cache.c                    |  407 +++
 arch/riscv/andesv5/cctl.c                     |  248 ++
 arch/riscv/andesv5/noncache_dma.c             |  257 ++
 arch/riscv/boot/dts/ae350_c1_32.dts           |  302 ++
 arch/riscv/boot/dts/ae350_c1_32_d.dts         |  302 ++
 arch/riscv/boot/dts/ae350_c1_32_d_dsp.dts     |  302 ++
 arch/riscv/boot/dts/ae350_c1_32_dsp.dts       |  302 ++
 arch/riscv/boot/dts/ae350_c1_64.dts           |  302 ++
 arch/riscv/boot/dts/ae350_c1_64_d.dts         |  302 ++
 arch/riscv/boot/dts/ae350_c1_64_d_dsp.dts     |  302 ++
 arch/riscv/boot/dts/ae350_c1_64_dsp.dts       |  302 ++
 .../boot/dts/ae350_c1_noncoherent_32.dts      |  288 ++
 .../boot/dts/ae350_c1_noncoherent_32_d.dts    |  288 ++
 .../dts/ae350_c1_noncoherent_32_d_dsp.dts     |  288 ++
 .../boot/dts/ae350_c1_noncoherent_32_dsp.dts  |  288 ++
 .../boot/dts/ae350_c1_noncoherent_64.dts      |  288 ++
 .../boot/dts/ae350_c1_noncoherent_64_d.dts    |  288 ++
 .../dts/ae350_c1_noncoherent_64_d_dsp.dts     |  288 ++
 .../boot/dts/ae350_c1_noncoherent_64_dsp.dts  |  288 ++
 arch/riscv/boot/dts/ae350_c2_32.dts           |  326 +++
 arch/riscv/boot/dts/ae350_c2_32_d.dts         |  326 +++
 arch/riscv/boot/dts/ae350_c2_32_d_dsp.dts     |  326 +++
 arch/riscv/boot/dts/ae350_c2_32_dsp.dts       |  326 +++
 arch/riscv/boot/dts/ae350_c2_64.dts           |  326 +++
 arch/riscv/boot/dts/ae350_c2_64_d.dts         |  326 +++
 arch/riscv/boot/dts/ae350_c2_64_d_dsp.dts     |  326 +++
 arch/riscv/boot/dts/ae350_c2_64_dsp.dts       |  326 +++
 arch/riscv/boot/dts/ae350_c4_32.dts           |  374 +++
 arch/riscv/boot/dts/ae350_c4_32_d.dts         |  374 +++
 arch/riscv/boot/dts/ae350_c4_32_d_dsp.dts     |  374 +++
 arch/riscv/boot/dts/ae350_c4_32_dsp.dts       |  374 +++
 arch/riscv/boot/dts/ae350_c4_64.dts           |  374 +++
 arch/riscv/boot/dts/ae350_c4_64_d.dts         |  374 +++
 arch/riscv/boot/dts/ae350_c4_64_d_dsp.dts     |  374 +++
 arch/riscv/boot/dts/ae350_c4_64_dsp.dts       |  374 +++
 arch/riscv/boot/dts/ae350_rv32_coherent.dts   |  286 ++
 .../riscv/boot/dts/ae350_rv32_noncoherent.dts |  272 ++
 .../boot/dts/ae350_rv32_smp_coherent.dts      |  309 ++
 arch/riscv/boot/dts/ae350_rv64_coherent.dts   |  287 ++
 .../riscv/boot/dts/ae350_rv64_noncoherent.dts |  273 ++
 .../boot/dts/ae350_rv64_smp_coherent.dts      |  309 ++
 arch/riscv/configs/ae350_rv32_smp_defconfig   |  131 +
 arch/riscv/configs/ae350_rv32_up_defconfig    |  129 +
 arch/riscv/configs/ae350_rv64_smp_defconfig   |  128 +
 arch/riscv/configs/ae350_rv64_up_defconfig    |  126 +
 arch/riscv/configs/defconfig                  |    1 +
 arch/riscv/include/asm/Kbuild                 |    1 +
 arch/riscv/include/asm/andesv5/csr.h          |   89 +
 arch/riscv/include/asm/andesv5/proc.h         |   28 +
 arch/riscv/include/asm/andesv5/smu.h          |   86 +
 arch/riscv/include/asm/atcdmac300.h           |  544 ++++
 arch/riscv/include/asm/bug.h                  |   35 +-
 arch/riscv/include/asm/cacheflush.h           |   24 +-
 arch/riscv/include/asm/csr.h                  |    1 +
 arch/riscv/include/asm/device.h               |   11 +
 arch/riscv/include/asm/dma-mapping.h          |   21 +
 arch/riscv/include/asm/dmad.h                 |   71 +
 arch/riscv/include/asm/elf.h                  |   31 +-
 arch/riscv/include/asm/fixmap.h               |   30 +
 arch/riscv/include/asm/highmem.h              |   52 +
 arch/riscv/include/asm/hwcap.h                |    7 +-
 arch/riscv/include/asm/io.h                   |   13 +-
 arch/riscv/include/asm/irq.h                  |   12 +-
 arch/riscv/include/asm/kasan.h                |   26 +
 arch/riscv/include/asm/module.h               |   28 +-
 arch/riscv/include/asm/perf_event.h           |  198 ++
 arch/riscv/include/asm/pgalloc.h              |    3 +
 arch/riscv/include/asm/pgtable-bits.h         |    2 +
 arch/riscv/include/asm/pgtable.h              |   38 +-
 arch/riscv/include/asm/processor.h            |    8 +-
 arch/riscv/include/asm/ptrace.h               |    1 +
 arch/riscv/include/asm/sbi.h                  |   56 +
 arch/riscv/include/asm/seccomp.h              |   17 +
 arch/riscv/include/asm/smp.h                  |   23 +-
 arch/riscv/include/asm/string.h               |   10 +
 arch/riscv/include/asm/switch_to.h            |   42 +-
 arch/riscv/include/asm/syscall.h              |    6 +
 arch/riscv/include/asm/thread_info.h          |    6 +
 arch/riscv/include/asm/timex.h                |    6 +-
 arch/riscv/include/asm/tlbflush.h             |    2 +
 arch/riscv/include/asm/uaccess.h              |    2 +-
 arch/riscv/include/uapi/asm/elf.h             |   32 +-
 arch/riscv/include/uapi/asm/ptrace.h          |    6 +
 arch/riscv/include/uapi/asm/sigcontext.h      |    3 +
 arch/riscv/kernel/.gitignore                  |    1 -
 arch/riscv/kernel/Makefile                    |    9 +
 arch/riscv/kernel/asm-offsets.c               |    1 +
 arch/riscv/kernel/cpufeature.c                |   49 +-
 arch/riscv/kernel/elf.c                       |  610 ++++
 arch/riscv/kernel/entry.S                     |  116 +-
 arch/riscv/kernel/fpu.S                       |  106 +
 arch/riscv/kernel/head.S                      |   30 +
 arch/riscv/kernel/module-sections.c           |   30 +-
 arch/riscv/kernel/module.c                    |   81 +-
 arch/riscv/kernel/perf_event.c                | 1044 +++++++
 arch/riscv/kernel/pm.c                        |  103 +
 arch/riscv/kernel/process.c                   |   16 +-
 arch/riscv/kernel/ptrace.c                    |  102 +-
 arch/riscv/kernel/riscv_ksyms.c               |    4 +
 arch/riscv/kernel/setup.c                     |   94 +-
 arch/riscv/kernel/signal.c                    |  104 +-
 arch/riscv/kernel/sleep.S                     |  108 +
 arch/riscv/kernel/smpboot.c                   |   99 +-
 arch/riscv/kernel/time.c                      |   31 +-
 arch/riscv/kernel/traps.c                     |   29 +-
 arch/riscv/kernel/vdso/.gitignore             |    2 -
 arch/riscv/kernel/vmlinux.lds.S               |    3 +-
 arch/riscv/lib/Makefile                       |    3 +-
 arch/riscv/lib/delay.c                        |    9 +-
 arch/riscv/lib/memcpy.S                       |    5 +-
 arch/riscv/lib/memmove.S                      |   64 +
 arch/riscv/lib/memset.S                       |    5 +-
 arch/riscv/lib/uaccess.S                      |   64 +-
 arch/riscv/lib/udivdi3.S                      |   38 -
 arch/riscv/mm/Makefile                        |    5 +
 arch/riscv/mm/dma-mapping.c                   |  106 +
 arch/riscv/mm/fault.c                         |    3 +
 arch/riscv/mm/highmem.c                       |   75 +
 arch/riscv/mm/init.c                          |  104 +-
 arch/riscv/mm/ioremap.c                       |   55 +-
 arch/riscv/mm/kasan_init.c                    |   93 +
 arch/riscv/platforms/Kconfig                  |   26 +
 arch/riscv/platforms/Makefile                 |    2 +
 arch/riscv/platforms/ae350/Kconfig            |   10 +
 arch/riscv/platforms/ae350/Makefile           |    2 +
 arch/riscv/platforms/ae350/atcdmac300.c       | 2531 +++++++++++++++++
 arch/riscv/platforms/ae350/atcsmu.c           |  252 ++
 arch/riscv/platforms/dmad_intc.c              |   49 +
 arch/s390/Kconfig                             |   17 +-
 arch/s390/boot/.gitignore                     |    2 -
 arch/s390/boot/compressed/.gitignore          |    4 -
 arch/s390/kernel/.gitignore                   |    1 -
 arch/s390/kernel/vdso32/.gitignore            |    1 -
 arch/s390/kernel/vdso64/.gitignore            |    1 -
 arch/s390/pci/pci_dma.c                       |    9 -
 arch/s390/purgatory/.gitignore                |    2 -
 arch/s390/tools/.gitignore                    |    2 -
 arch/sh/Kconfig                               |   10 +-
 arch/sh/boot/.gitignore                       |    3 -
 arch/sh/boot/compressed/.gitignore            |    6 -
 arch/sh/kernel/.gitignore                     |    1 -
 arch/sh/kernel/vsyscall/.gitignore            |    1 -
 arch/sh/mm/consistent.c                       |    9 -
 arch/sparc/Kconfig                            |   18 +-
 arch/sparc/boot/.gitignore                    |    8 -
 arch/sparc/include/asm/iommu-common.h         |   53 +
 arch/sparc/include/asm/iommu_64.h             |    2 +-
 arch/sparc/kernel/.gitignore                  |    1 -
 arch/sparc/kernel/Makefile                    |    4 +-
 arch/sparc/kernel/dma.c                       |   13 -
 arch/sparc/kernel/iommu-common.c              |  264 ++
 arch/sparc/kernel/iommu.c                     |    2 +-
 arch/sparc/kernel/ldc.c                       |    2 +-
 arch/sparc/kernel/pci_sun4v.c                 |    2 +-
 arch/sparc/vdso/.gitignore                    |    3 -
 arch/sparc/vdso/vdso32/.gitignore             |    1 -
 arch/um/.gitignore                            |    3 -
 arch/unicore32/.gitignore                     |   21 -
 arch/unicore32/Kconfig                        |    5 +-
 arch/unicore32/mm/Kconfig                     |   11 -
 arch/x86/.gitignore                           |    7 -
 arch/x86/Kconfig                              |   35 +-
 arch/x86/boot/.gitignore                      |   12 -
 arch/x86/boot/compressed/.gitignore           |    6 -
 arch/x86/boot/tools/.gitignore                |    1 -
 arch/x86/entry/vdso/.gitignore                |    7 -
 arch/x86/entry/vdso/vdso32/.gitignore         |    1 -
 arch/x86/include/asm/dma-mapping.h            |    2 +-
 arch/x86/kernel/.gitignore                    |    3 -
 arch/x86/kernel/cpu/.gitignore                |    1 -
 arch/x86/kernel/pci-dma.c                     |    6 +-
 arch/x86/lib/.gitignore                       |    1 -
 arch/x86/realmode/rm/.gitignore               |    3 -
 arch/x86/tools/.gitignore                     |    1 -
 arch/x86/um/vdso/.gitignore                   |    2 -
 arch/xtensa/Kconfig                           |    1 -
 arch/xtensa/boot/.gitignore                   |    2 -
 arch/xtensa/boot/boot-elf/.gitignore          |    1 -
 arch/xtensa/boot/lib/.gitignore               |    3 -
 arch/xtensa/kernel/.gitignore                 |    1 -
 arch/xtensa/kernel/pci-dma.c                  |    9 -
 certs/.gitignore                              |    4 -
 drivers/amba/bus.c                            |    5 +-
 drivers/atm/.gitignore                        |    5 -
 drivers/base/Makefile                         |    3 -
 drivers/base/dma-coherent.c                   |  434 ---
 drivers/base/dma-contiguous.c                 |  278 --
 drivers/base/dma-mapping.c                    |  368 ---
 drivers/base/init.c                           |    2 +-
 drivers/base/platform.c                       |   18 +-
 drivers/bcma/main.c                           |    2 +-
 drivers/clk/Kconfig                           |    2 +
 drivers/clk/Makefile                          |    1 +
 drivers/clk/sifive/Kconfig                    |   10 +
 drivers/clk/sifive/Makefile                   |    2 +
 drivers/clk/sifive/gemgxl-mgmt.c              |  129 +
 drivers/clk/sifive/u54-prci.c                 |  314 ++
 drivers/clocksource/Kconfig                   |   10 +
 drivers/clocksource/Makefile                  |    1 +
 drivers/clocksource/riscv_timer.c             |  135 +
 drivers/cpufreq/Makefile                      |    4 +
 drivers/cpufreq/riscv-cpufreq.c               |  176 ++
 drivers/crypto/vmx/.gitignore                 |    2 -
 drivers/dma/qcom/hidma_mgmt.c                 |    2 +-
 drivers/eisa/.gitignore                       |    1 -
 drivers/gpio/Kconfig                          |   10 +
 drivers/gpio/Makefile                         |    1 +
 drivers/gpio/gpio-atcgpio100.c                |  308 ++
 drivers/gpu/drm/radeon/.gitignore             |    3 -
 drivers/gpu/host1x/bus.c                      |    9 +-
 drivers/i2c/busses/Kconfig                    |   25 +
 drivers/i2c/busses/Makefile                   |    1 +
 drivers/i2c/busses/i2c-atciic100.c            |  554 ++++
 drivers/iommu/Kconfig                         |    1 +
 drivers/irqchip/Kconfig                       |   41 +-
 drivers/irqchip/Makefile                      |    2 +
 drivers/irqchip/irq-riscv-intc.c              |  231 ++
 drivers/irqchip/irq-riscv-plic.c              |  593 ++++
 drivers/mmc/host/Kconfig                      |    8 +
 drivers/mmc/host/Makefile                     |    1 +
 drivers/mmc/host/ftsdc010.c                   | 1557 ++++++++++
 drivers/mmc/host/ftsdc010.h                   |  257 ++
 drivers/mtd/spi-nor/spi-nor.c                 |   61 +-
 drivers/net/ethernet/faraday/Kconfig          |    7 +-
 drivers/net/ethernet/faraday/ftmac100.c       |  164 +-
 drivers/net/ethernet/faraday/ftmac100.h       |   14 +-
 drivers/net/wan/.gitignore                    |    1 -
 drivers/of/device.c                           |    6 +-
 drivers/of/of_reserved_mem.c                  |    2 +-
 drivers/parisc/Kconfig                        |    5 -
 drivers/pci/host/Kconfig                      |    2 +-
 drivers/pci/pci-driver.c                      |   33 +-
 drivers/pwm/Kconfig                           |    9 +
 drivers/pwm/Makefile                          |    1 +
 drivers/pwm/pwm-atcpit100.c                   |  246 ++
 drivers/pwm/sysfs.c                           |    1 -
 drivers/rtc/Kconfig                           |   10 +
 drivers/rtc/Makefile                          |    1 +
 drivers/rtc/rtc-atcrtc100.c                   |  379 +++
 drivers/scsi/.gitignore                       |    2 -
 drivers/scsi/aic7xxx/.gitignore               |    6 -
 drivers/spi/Kconfig                           |   12 +
 drivers/spi/Makefile                          |    2 +
 drivers/spi/spi-atcspi200.c                   |  426 +++
 drivers/spi/spi-atcspi200_cb.c                |  475 ++++
 drivers/spi/spi-sifive.c                      |  423 +++
 drivers/staging/greybus/tools/.gitignore      |    1 -
 drivers/tty/serial/Kconfig                    |   23 +
 drivers/tty/serial/Makefile                   |    1 +
 drivers/tty/serial/sifive.c                   | 1051 +++++++
 drivers/tty/vt/.gitignore                     |    2 -
 drivers/video/fbdev/FTLCDC100/Kconfig         |   74 +
 drivers/video/fbdev/FTLCDC100/Makefile        |    1 +
 .../video/fbdev/FTLCDC100/faradayfb-main.c    |  833 ++++++
 drivers/video/fbdev/FTLCDC100/faradayfb.h     |  215 ++
 drivers/video/fbdev/FTLCDC100/lcd-info.c      |  264 ++
 .../video/fbdev/FTLCDC100/pingpong-module.c   |  603 ++++
 drivers/video/fbdev/Kconfig                   |    2 +
 drivers/video/fbdev/Makefile                  |    1 +
 drivers/video/logo/.gitignore                 |    7 -
 drivers/watchdog/Kconfig                      |   13 +
 drivers/watchdog/Makefile                     |    1 +
 drivers/watchdog/atcwdt200_wdt.c              |  310 ++
 drivers/zorro/.gitignore                      |    2 -
 firmware/.gitignore                           |    6 -
 fs/binfmt_elf.c                               |    2 +-
 include/asm-generic/dma-mapping.h             |    9 +
 include/asm-generic/module.h                  |    9 +
 include/linux/cpuhotplug.h                    |    1 +
 include/linux/device.h                        |   11 +-
 include/linux/dma-contiguous.h                |    2 +-
 include/linux/dma-debug.h                     |    6 -
 include/linux/dma-direct.h                    |    7 +-
 include/linux/dma-mapping.h                   |    7 +-
 include/linux/dma-noncoherent.h               |   47 +
 include/linux/elf.h                           |    2 +
 include/linux/iommu-common.h                  |   53 -
 include/linux/iommu-helper.h                  |   13 +-
 include/linux/irqchip/irq-riscv-intc.h        |   19 +
 include/linux/mtd/spi-nor.h                   |    2 +
 include/linux/of_device.h                     |    8 +-
 include/linux/platform_device.h               |    2 +
 include/linux/pwm.h                           |    2 +-
 include/linux/timer_riscv.h                   |   34 +
 include/uapi/linux/audit.h                    |    1 +
 include/uapi/linux/elf-em.h                   |    1 +
 include/uapi/linux/perf_event.h               |    3 +-
 include/uapi/linux/serial_core.h              |    3 +
 init/Kconfig                                  |    4 -
 kernel/.gitignore                             |    7 -
 kernel/Makefile                               |    1 +
 kernel/debug/kdb/.gitignore                   |    1 -
 kernel/dma/Kconfig                            |   50 +
 kernel/dma/Makefile                           |   11 +
 kernel/dma/coherent.c                         |  434 +++
 kernel/dma/contiguous.c                       |  278 ++
 kernel/dma/debug.c                            | 1745 ++++++++++++
 kernel/dma/direct.c                           |  205 ++
 kernel/dma/mapping.c                          |  345 +++
 kernel/dma/noncoherent.c                      |  102 +
 kernel/dma/swiotlb.c                          | 1088 +++++++
 kernel/dma/virt.c                             |   59 +
 kernel/irq/Kconfig                            |    1 -
 kernel/sysctl.c                               |    9 +
 lib/.gitignore                                |    6 -
 lib/Kconfig                                   |   17 +-
 lib/Kconfig.debug                             |    2 +-
 lib/Makefile                                  |    8 +-
 lib/dma-debug.c                               | 1752 ------------
 lib/dma-direct.c                              |  185 --
 lib/dma-virt.c                                |   61 -
 lib/iommu-common.c                            |  267 --
 lib/iommu-helper.c                            |   14 +-
 lib/raid6/.gitignore                          |    7 -
 lib/swiotlb.c                                 | 1092 -------
 lib/udivmoddi4.c                              |  310 ++
 lib/umoddi3.c                                 |   32 +
 mm/Kconfig                                    |    2 +-
 net/wireless/.gitignore                       |    2 -
 samples/auxdisplay/.gitignore                 |    1 -
 samples/connector/.gitignore                  |    1 -
 samples/hidraw/.gitignore                     |    1 -
 samples/mei/.gitignore                        |    1 -
 samples/mic/mpssd/.gitignore                  |    1 -
 samples/seccomp/.gitignore                    |    3 -
 samples/timers/.gitignore                     |    1 -
 samples/watchdog/.gitignore                   |    1 -
 scripts/.gitignore                            |   15 -
 scripts/basic/.gitignore                      |    2 -
 scripts/dtc/.gitignore                        |    1 -
 scripts/gcc-plugins/.gitignore                |    1 -
 scripts/gdb/linux/.gitignore                  |    3 -
 scripts/genksyms/.gitignore                   |    1 -
 scripts/kconfig/.gitignore                    |   17 -
 scripts/kconfig/lxdialog/.gitignore           |    4 -
 scripts/mod/.gitignore                        |    4 -
 scripts/selinux/genheaders/.gitignore         |    1 -
 scripts/selinux/mdp/.gitignore                |    2 -
 security/apparmor/.gitignore                  |    6 -
 security/selinux/.gitignore                   |    2 -
 security/tomoyo/.gitignore                    |    2 -
 sound/Kconfig                                 |    2 +
 sound/Makefile                                |    2 +-
 sound/oss/.gitignore                          |    3 -
 sound/v5/FTSSP010_ALSA.c                      | 1457 ++++++++++
 sound/v5/FTSSP010_UDA1345TS.h                 |   86 +
 sound/v5/FTSSP010_W83972D.h                   |   17 +
 sound/v5/FTSSP010_lib.c                       |  538 ++++
 sound/v5/Kconfig                              |   22 +
 sound/v5/Makefile                             |   10 +
 tools/accounting/.gitignore                   |    1 -
 tools/build/.gitignore                        |    1 -
 tools/build/feature/.gitignore                |    3 -
 tools/cgroup/.gitignore                       |    1 -
 tools/gpio/.gitignore                         |    4 -
 tools/include/asm/barrier.h                   |    2 +
 tools/include/uapi/linux/perf_event.h         |    3 +-
 tools/laptop/dslm/.gitignore                  |    1 -
 tools/leds/.gitignore                         |    1 -
 tools/lib/bpf/.gitignore                      |    2 -
 tools/lib/lockdep/.gitignore                  |    1 -
 tools/lib/traceevent/.gitignore               |    3 -
 tools/objtool/.gitignore                      |    3 -
 tools/pcmcia/.gitignore                       |    1 -
 tools/perf/.gitignore                         |   36 -
 tools/perf/arch/riscv/Build                   |    1 +
 tools/perf/arch/riscv/util/Build              |    1 +
 tools/perf/arch/riscv/util/header.c           |   43 +
 .../perf/pmu-events/arch/riscv/AX25/l2c.json  |  122 +
 .../pmu-events/arch/riscv/AX25/riscvstd.json  |  252 ++
 tools/perf/pmu-events/arch/riscv/mapfile.csv  |   15 +
 tools/perf/tests/.gitignore                   |    4 -
 tools/perf/util/parse-events.c                |   18 +-
 tools/perf/util/parse-events.l                |    2 +-
 tools/perf/util/symbol-elf.c                  |    4 +-
 tools/power/acpi/.gitignore                   |    4 -
 tools/power/cpupower/.gitignore               |   28 -
 tools/power/x86/turbostat/.gitignore          |    1 -
 tools/spi/.gitignore                          |    2 -
 tools/testing/radix-tree/.gitignore           |    6 -
 tools/testing/selftests/.gitignore            |    5 -
 .../testing/selftests/android/ion/.gitignore  |    3 -
 tools/testing/selftests/bpf/.gitignore        |   17 -
 .../testing/selftests/breakpoints/.gitignore  |    2 -
 .../testing/selftests/capabilities/.gitignore |    2 -
 tools/testing/selftests/efivarfs/.gitignore   |    2 -
 tools/testing/selftests/exec/.gitignore       |    9 -
 .../testing/selftests/filesystems/.gitignore  |    2 -
 tools/testing/selftests/ftrace/.gitignore     |    1 -
 .../selftests/futex/functional/.gitignore     |    7 -
 tools/testing/selftests/gpio/.gitignore       |    1 -
 tools/testing/selftests/ia64/.gitignore       |    1 -
 .../testing/selftests/intel_pstate/.gitignore |    2 -
 tools/testing/selftests/ipc/.gitignore        |    2 -
 tools/testing/selftests/kcmp/.gitignore       |    2 -
 .../testing/selftests/media_tests/.gitignore  |    3 -
 tools/testing/selftests/membarrier/.gitignore |    1 -
 tools/testing/selftests/memfd/.gitignore      |    4 -
 tools/testing/selftests/mount/.gitignore      |    1 -
 tools/testing/selftests/mqueue/.gitignore     |    2 -
 tools/testing/selftests/net/.gitignore        |    9 -
 .../selftests/net/forwarding/.gitignore       |    1 -
 .../networking/timestamping/.gitignore        |    4 -
 tools/testing/selftests/nsfs/.gitignore       |    2 -
 .../selftests/powerpc/alignment/.gitignore    |    5 -
 .../selftests/powerpc/benchmarks/.gitignore   |    7 -
 .../selftests/powerpc/cache_shape/.gitignore  |    1 -
 .../powerpc/context_switch/.gitignore         |    1 -
 .../selftests/powerpc/copyloops/.gitignore    |    4 -
 .../testing/selftests/powerpc/dscr/.gitignore |    7 -
 .../testing/selftests/powerpc/math/.gitignore |    7 -
 tools/testing/selftests/powerpc/mm/.gitignore |    5 -
 .../testing/selftests/powerpc/pmu/.gitignore  |    3 -
 .../selftests/powerpc/pmu/ebb/.gitignore      |   22 -
 .../selftests/powerpc/primitives/.gitignore   |    1 -
 .../selftests/powerpc/ptrace/.gitignore       |   10 -
 .../selftests/powerpc/signal/.gitignore       |    2 -
 .../selftests/powerpc/stringloops/.gitignore  |    1 -
 .../powerpc/switch_endian/.gitignore          |    2 -
 .../selftests/powerpc/syscalls/.gitignore     |    1 -
 tools/testing/selftests/powerpc/tm/.gitignore |   16 -
 .../testing/selftests/powerpc/vphn/.gitignore |    1 -
 tools/testing/selftests/prctl/.gitignore      |    3 -
 tools/testing/selftests/proc/.gitignore       |    8 -
 tools/testing/selftests/pstore/.gitignore     |    2 -
 tools/testing/selftests/ptp/.gitignore        |    1 -
 tools/testing/selftests/ptrace/.gitignore     |    1 -
 tools/testing/selftests/rcutorture/.gitignore |    4 -
 .../rcutorture/formal/srcu-cbmc/.gitignore    |    1 -
 .../formal/srcu-cbmc/include/linux/.gitignore |    1 -
 .../tests/store_buffering/.gitignore          |    1 -
 tools/testing/selftests/seccomp/.gitignore    |    2 -
 .../testing/selftests/sigaltstack/.gitignore  |    1 -
 tools/testing/selftests/size/.gitignore       |    1 -
 tools/testing/selftests/splice/.gitignore     |    1 -
 tools/testing/selftests/sync/.gitignore       |    1 -
 tools/testing/selftests/tc-testing/.gitignore |    2 -
 tools/testing/selftests/timers/.gitignore     |   22 -
 tools/testing/selftests/vDSO/.gitignore       |    2 -
 tools/testing/selftests/vm/.gitignore         |   14 -
 tools/testing/selftests/watchdog/.gitignore   |    1 -
 tools/testing/selftests/x86/.gitignore        |   15 -
 tools/testing/vsock/.gitignore                |    2 -
 tools/thermal/tmon/.gitignore                 |    1 -
 tools/usb/.gitignore                          |    2 -
 tools/usb/usbip/.gitignore                    |   32 -
 tools/virtio/.gitignore                       |    3 -
 tools/vm/.gitignore                           |    2 -
 usr/.gitignore                                |   10 -
 547 files changed, 39829 insertions(+), 6529 deletions(-)
 delete mode 100644 Documentation/.gitignore
 delete mode 100644 Documentation/arm/SH-Mobile/.gitignore
 create mode 100644 Documentation/devicetree/bindings/clock/sifive,gemgxl-mgmt.txt
 create mode 100644 Documentation/devicetree/bindings/clock/sifive,u54-prci.txt
 create mode 100644 Documentation/devicetree/bindings/interrupt-controller/riscv,cpu-intc.txt
 create mode 100644 Documentation/devicetree/bindings/interrupt-controller/riscv,plic0.txt
 create mode 100644 Documentation/devicetree/bindings/spi/spi-sifive.txt
 delete mode 100644 Documentation/features/io/dma-api-debug/arch-support.txt
 delete mode 100644 Documentation/media/.gitignore
 create mode 100644 Documentation/riscv/pmu.txt
 delete mode 100644 Documentation/vm/.gitignore
 delete mode 100644 arch/.gitignore
 delete mode 100644 arch/alpha/kernel/.gitignore
 delete mode 100644 arch/arc/boot/.gitignore
 delete mode 100644 arch/arc/kernel/.gitignore
 delete mode 100644 arch/arm/boot/.gitignore
 delete mode 100644 arch/arm/boot/compressed/.gitignore
 delete mode 100644 arch/arm/crypto/.gitignore
 delete mode 100644 arch/arm/kernel/.gitignore
 delete mode 100644 arch/arm/vdso/.gitignore
 delete mode 100644 arch/arm64/boot/.gitignore
 delete mode 100644 arch/arm64/crypto/.gitignore
 delete mode 100644 arch/arm64/kernel/.gitignore
 delete mode 100644 arch/arm64/kernel/vdso/.gitignore
 delete mode 100644 arch/ia64/kernel/.gitignore
 delete mode 100644 arch/m68k/kernel/.gitignore
 delete mode 100644 arch/microblaze/boot/.gitignore
 delete mode 100644 arch/microblaze/kernel/.gitignore
 delete mode 100644 arch/mips/boot/.gitignore
 delete mode 100644 arch/mips/boot/compressed/.gitignore
 delete mode 100644 arch/mips/boot/tools/.gitignore
 delete mode 100644 arch/mips/kernel/.gitignore
 delete mode 100644 arch/mips/vdso/.gitignore
 delete mode 100644 arch/nds32/include/asm/dma-mapping.h
 delete mode 100644 arch/nios2/boot/.gitignore
 delete mode 100644 arch/nios2/kernel/.gitignore
 delete mode 100644 arch/openrisc/kernel/.gitignore
 delete mode 100644 arch/parisc/boot/.gitignore
 delete mode 100644 arch/parisc/boot/compressed/.gitignore
 delete mode 100644 arch/parisc/kernel/.gitignore
 delete mode 100644 arch/powerpc/boot/.gitignore
 delete mode 100644 arch/powerpc/kernel/.gitignore
 delete mode 100644 arch/powerpc/kernel/vdso32/.gitignore
 delete mode 100644 arch/powerpc/kernel/vdso64/.gitignore
 delete mode 100644 arch/powerpc/platforms/cell/spufs/.gitignore
 delete mode 100644 arch/powerpc/purgatory/.gitignore
 create mode 100644 arch/riscv/Kconfig-upstream
 create mode 100644 arch/riscv/andesv5/Makefile
 create mode 100644 arch/riscv/andesv5/cache.c
 create mode 100644 arch/riscv/andesv5/cctl.c
 create mode 100644 arch/riscv/andesv5/noncache_dma.c
 create mode 100644 arch/riscv/boot/dts/ae350_c1_32.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_32_d.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_32_d_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_32_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_64.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_64_d.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_64_d_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_64_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_noncoherent_32.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_noncoherent_32_d.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_noncoherent_32_d_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_noncoherent_32_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_noncoherent_64.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_noncoherent_64_d.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_noncoherent_64_d_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c1_noncoherent_64_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c2_32.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c2_32_d.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c2_32_d_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c2_32_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c2_64.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c2_64_d.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c2_64_d_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c2_64_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c4_32.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c4_32_d.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c4_32_d_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c4_32_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c4_64.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c4_64_d.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c4_64_d_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_c4_64_dsp.dts
 create mode 100644 arch/riscv/boot/dts/ae350_rv32_coherent.dts
 create mode 100644 arch/riscv/boot/dts/ae350_rv32_noncoherent.dts
 create mode 100644 arch/riscv/boot/dts/ae350_rv32_smp_coherent.dts
 create mode 100644 arch/riscv/boot/dts/ae350_rv64_coherent.dts
 create mode 100644 arch/riscv/boot/dts/ae350_rv64_noncoherent.dts
 create mode 100644 arch/riscv/boot/dts/ae350_rv64_smp_coherent.dts
 create mode 100755 arch/riscv/configs/ae350_rv32_smp_defconfig
 create mode 100755 arch/riscv/configs/ae350_rv32_up_defconfig
 create mode 100755 arch/riscv/configs/ae350_rv64_smp_defconfig
 create mode 100755 arch/riscv/configs/ae350_rv64_up_defconfig
 create mode 100644 arch/riscv/include/asm/andesv5/csr.h
 create mode 100644 arch/riscv/include/asm/andesv5/proc.h
 create mode 100644 arch/riscv/include/asm/andesv5/smu.h
 create mode 100644 arch/riscv/include/asm/atcdmac300.h
 create mode 100644 arch/riscv/include/asm/device.h
 create mode 100644 arch/riscv/include/asm/dma-mapping.h
 create mode 100644 arch/riscv/include/asm/dmad.h
 create mode 100644 arch/riscv/include/asm/fixmap.h
 create mode 100644 arch/riscv/include/asm/highmem.h
 create mode 100644 arch/riscv/include/asm/kasan.h
 create mode 100644 arch/riscv/include/asm/perf_event.h
 create mode 100644 arch/riscv/include/asm/seccomp.h
 delete mode 100644 arch/riscv/kernel/.gitignore
 create mode 100644 arch/riscv/kernel/elf.c
 create mode 100644 arch/riscv/kernel/fpu.S
 create mode 100644 arch/riscv/kernel/perf_event.c
 create mode 100644 arch/riscv/kernel/pm.c
 create mode 100644 arch/riscv/kernel/sleep.S
 delete mode 100644 arch/riscv/kernel/vdso/.gitignore
 create mode 100644 arch/riscv/lib/memmove.S
 delete mode 100644 arch/riscv/lib/udivdi3.S
 create mode 100644 arch/riscv/mm/dma-mapping.c
 create mode 100644 arch/riscv/mm/highmem.c
 create mode 100644 arch/riscv/mm/kasan_init.c
 create mode 100644 arch/riscv/platforms/Kconfig
 create mode 100644 arch/riscv/platforms/Makefile
 create mode 100644 arch/riscv/platforms/ae350/Kconfig
 create mode 100644 arch/riscv/platforms/ae350/Makefile
 create mode 100644 arch/riscv/platforms/ae350/atcdmac300.c
 create mode 100644 arch/riscv/platforms/ae350/atcsmu.c
 create mode 100644 arch/riscv/platforms/dmad_intc.c
 delete mode 100644 arch/s390/boot/.gitignore
 delete mode 100644 arch/s390/boot/compressed/.gitignore
 delete mode 100644 arch/s390/kernel/.gitignore
 delete mode 100644 arch/s390/kernel/vdso32/.gitignore
 delete mode 100644 arch/s390/kernel/vdso64/.gitignore
 delete mode 100644 arch/s390/purgatory/.gitignore
 delete mode 100644 arch/s390/tools/.gitignore
 delete mode 100644 arch/sh/boot/.gitignore
 delete mode 100644 arch/sh/boot/compressed/.gitignore
 delete mode 100644 arch/sh/kernel/.gitignore
 delete mode 100644 arch/sh/kernel/vsyscall/.gitignore
 delete mode 100644 arch/sparc/boot/.gitignore
 create mode 100644 arch/sparc/include/asm/iommu-common.h
 delete mode 100644 arch/sparc/kernel/.gitignore
 delete mode 100644 arch/sparc/kernel/dma.c
 create mode 100644 arch/sparc/kernel/iommu-common.c
 delete mode 100644 arch/sparc/vdso/.gitignore
 delete mode 100644 arch/sparc/vdso/vdso32/.gitignore
 delete mode 100644 arch/um/.gitignore
 delete mode 100644 arch/unicore32/.gitignore
 delete mode 100644 arch/x86/.gitignore
 delete mode 100644 arch/x86/boot/.gitignore
 delete mode 100644 arch/x86/boot/compressed/.gitignore
 delete mode 100644 arch/x86/boot/tools/.gitignore
 delete mode 100644 arch/x86/entry/vdso/.gitignore
 delete mode 100644 arch/x86/entry/vdso/vdso32/.gitignore
 delete mode 100644 arch/x86/kernel/.gitignore
 delete mode 100644 arch/x86/kernel/cpu/.gitignore
 delete mode 100644 arch/x86/lib/.gitignore
 delete mode 100644 arch/x86/realmode/rm/.gitignore
 delete mode 100644 arch/x86/tools/.gitignore
 delete mode 100644 arch/x86/um/vdso/.gitignore
 delete mode 100644 arch/xtensa/boot/.gitignore
 delete mode 100644 arch/xtensa/boot/boot-elf/.gitignore
 delete mode 100644 arch/xtensa/boot/lib/.gitignore
 delete mode 100644 arch/xtensa/kernel/.gitignore
 delete mode 100644 certs/.gitignore
 delete mode 100644 drivers/atm/.gitignore
 delete mode 100644 drivers/base/dma-coherent.c
 delete mode 100644 drivers/base/dma-contiguous.c
 delete mode 100644 drivers/base/dma-mapping.c
 create mode 100644 drivers/clk/sifive/Kconfig
 create mode 100644 drivers/clk/sifive/Makefile
 create mode 100644 drivers/clk/sifive/gemgxl-mgmt.c
 create mode 100644 drivers/clk/sifive/u54-prci.c
 create mode 100644 drivers/clocksource/riscv_timer.c
 create mode 100644 drivers/cpufreq/riscv-cpufreq.c
 delete mode 100644 drivers/crypto/vmx/.gitignore
 delete mode 100644 drivers/eisa/.gitignore
 create mode 100644 drivers/gpio/gpio-atcgpio100.c
 delete mode 100644 drivers/gpu/drm/radeon/.gitignore
 create mode 100755 drivers/i2c/busses/i2c-atciic100.c
 create mode 100644 drivers/irqchip/irq-riscv-intc.c
 create mode 100644 drivers/irqchip/irq-riscv-plic.c
 create mode 100644 drivers/mmc/host/ftsdc010.c
 create mode 100644 drivers/mmc/host/ftsdc010.h
 delete mode 100644 drivers/net/wan/.gitignore
 create mode 100644 drivers/pwm/pwm-atcpit100.c
 create mode 100644 drivers/rtc/rtc-atcrtc100.c
 delete mode 100644 drivers/scsi/.gitignore
 delete mode 100644 drivers/scsi/aic7xxx/.gitignore
 create mode 100644 drivers/spi/spi-atcspi200.c
 create mode 100644 drivers/spi/spi-atcspi200_cb.c
 create mode 100644 drivers/spi/spi-sifive.c
 delete mode 100644 drivers/staging/greybus/tools/.gitignore
 create mode 100644 drivers/tty/serial/sifive.c
 delete mode 100644 drivers/tty/vt/.gitignore
 create mode 100644 drivers/video/fbdev/FTLCDC100/Kconfig
 create mode 100644 drivers/video/fbdev/FTLCDC100/Makefile
 create mode 100644 drivers/video/fbdev/FTLCDC100/faradayfb-main.c
 create mode 100644 drivers/video/fbdev/FTLCDC100/faradayfb.h
 create mode 100644 drivers/video/fbdev/FTLCDC100/lcd-info.c
 create mode 100644 drivers/video/fbdev/FTLCDC100/pingpong-module.c
 delete mode 100644 drivers/video/logo/.gitignore
 create mode 100644 drivers/watchdog/atcwdt200_wdt.c
 delete mode 100644 drivers/zorro/.gitignore
 delete mode 100644 firmware/.gitignore
 create mode 100644 include/linux/dma-noncoherent.h
 delete mode 100644 include/linux/iommu-common.h
 create mode 100644 include/linux/irqchip/irq-riscv-intc.h
 mode change 100644 => 100755 include/linux/pwm.h
 create mode 100644 include/linux/timer_riscv.h
 delete mode 100644 kernel/.gitignore
 delete mode 100644 kernel/debug/kdb/.gitignore
 create mode 100644 kernel/dma/Kconfig
 create mode 100644 kernel/dma/Makefile
 create mode 100644 kernel/dma/coherent.c
 create mode 100644 kernel/dma/contiguous.c
 create mode 100644 kernel/dma/debug.c
 create mode 100644 kernel/dma/direct.c
 create mode 100644 kernel/dma/mapping.c
 create mode 100644 kernel/dma/noncoherent.c
 create mode 100644 kernel/dma/swiotlb.c
 create mode 100644 kernel/dma/virt.c
 delete mode 100644 lib/.gitignore
 delete mode 100644 lib/dma-debug.c
 delete mode 100644 lib/dma-direct.c
 delete mode 100644 lib/dma-virt.c
 delete mode 100644 lib/iommu-common.c
 delete mode 100644 lib/raid6/.gitignore
 delete mode 100644 lib/swiotlb.c
 create mode 100644 lib/udivmoddi4.c
 create mode 100644 lib/umoddi3.c
 delete mode 100644 net/wireless/.gitignore
 delete mode 100644 samples/auxdisplay/.gitignore
 delete mode 100644 samples/connector/.gitignore
 delete mode 100644 samples/hidraw/.gitignore
 delete mode 100644 samples/mei/.gitignore
 delete mode 100644 samples/mic/mpssd/.gitignore
 delete mode 100644 samples/seccomp/.gitignore
 delete mode 100644 samples/timers/.gitignore
 delete mode 100644 samples/watchdog/.gitignore
 delete mode 100644 scripts/.gitignore
 delete mode 100644 scripts/basic/.gitignore
 delete mode 100644 scripts/dtc/.gitignore
 delete mode 100644 scripts/gcc-plugins/.gitignore
 delete mode 100644 scripts/gdb/linux/.gitignore
 delete mode 100644 scripts/genksyms/.gitignore
 delete mode 100644 scripts/kconfig/.gitignore
 delete mode 100644 scripts/kconfig/lxdialog/.gitignore
 delete mode 100644 scripts/mod/.gitignore
 delete mode 100644 scripts/selinux/genheaders/.gitignore
 delete mode 100644 scripts/selinux/mdp/.gitignore
 delete mode 100644 security/apparmor/.gitignore
 delete mode 100644 security/selinux/.gitignore
 delete mode 100644 security/tomoyo/.gitignore
 delete mode 100644 sound/oss/.gitignore
 create mode 100644 sound/v5/FTSSP010_ALSA.c
 create mode 100644 sound/v5/FTSSP010_UDA1345TS.h
 create mode 100644 sound/v5/FTSSP010_W83972D.h
 create mode 100644 sound/v5/FTSSP010_lib.c
 create mode 100644 sound/v5/Kconfig
 create mode 100644 sound/v5/Makefile
 delete mode 100644 tools/accounting/.gitignore
 delete mode 100644 tools/build/.gitignore
 delete mode 100644 tools/build/feature/.gitignore
 delete mode 100644 tools/cgroup/.gitignore
 delete mode 100644 tools/gpio/.gitignore
 delete mode 100644 tools/laptop/dslm/.gitignore
 delete mode 100644 tools/leds/.gitignore
 delete mode 100644 tools/lib/bpf/.gitignore
 delete mode 100644 tools/lib/lockdep/.gitignore
 delete mode 100644 tools/lib/traceevent/.gitignore
 delete mode 100644 tools/objtool/.gitignore
 delete mode 100644 tools/pcmcia/.gitignore
 delete mode 100644 tools/perf/.gitignore
 create mode 100644 tools/perf/arch/riscv/Build
 create mode 100644 tools/perf/arch/riscv/util/Build
 create mode 100644 tools/perf/arch/riscv/util/header.c
 create mode 100644 tools/perf/pmu-events/arch/riscv/AX25/l2c.json
 create mode 100644 tools/perf/pmu-events/arch/riscv/AX25/riscvstd.json
 create mode 100644 tools/perf/pmu-events/arch/riscv/mapfile.csv
 delete mode 100644 tools/perf/tests/.gitignore
 delete mode 100644 tools/power/acpi/.gitignore
 delete mode 100644 tools/power/cpupower/.gitignore
 delete mode 100644 tools/power/x86/turbostat/.gitignore
 delete mode 100644 tools/spi/.gitignore
 delete mode 100644 tools/testing/radix-tree/.gitignore
 delete mode 100644 tools/testing/selftests/.gitignore
 delete mode 100644 tools/testing/selftests/android/ion/.gitignore
 delete mode 100644 tools/testing/selftests/bpf/.gitignore
 delete mode 100644 tools/testing/selftests/breakpoints/.gitignore
 delete mode 100644 tools/testing/selftests/capabilities/.gitignore
 delete mode 100644 tools/testing/selftests/efivarfs/.gitignore
 delete mode 100644 tools/testing/selftests/exec/.gitignore
 delete mode 100644 tools/testing/selftests/filesystems/.gitignore
 delete mode 100644 tools/testing/selftests/ftrace/.gitignore
 delete mode 100644 tools/testing/selftests/futex/functional/.gitignore
 delete mode 100644 tools/testing/selftests/gpio/.gitignore
 delete mode 100644 tools/testing/selftests/ia64/.gitignore
 delete mode 100644 tools/testing/selftests/intel_pstate/.gitignore
 delete mode 100644 tools/testing/selftests/ipc/.gitignore
 delete mode 100644 tools/testing/selftests/kcmp/.gitignore
 delete mode 100644 tools/testing/selftests/media_tests/.gitignore
 delete mode 100644 tools/testing/selftests/membarrier/.gitignore
 delete mode 100644 tools/testing/selftests/memfd/.gitignore
 delete mode 100644 tools/testing/selftests/mount/.gitignore
 delete mode 100644 tools/testing/selftests/mqueue/.gitignore
 delete mode 100644 tools/testing/selftests/net/.gitignore
 delete mode 100644 tools/testing/selftests/net/forwarding/.gitignore
 delete mode 100644 tools/testing/selftests/networking/timestamping/.gitignore
 delete mode 100644 tools/testing/selftests/nsfs/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/alignment/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/benchmarks/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/cache_shape/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/context_switch/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/copyloops/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/dscr/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/math/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/mm/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/pmu/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/pmu/ebb/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/primitives/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/ptrace/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/signal/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/stringloops/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/switch_endian/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/syscalls/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/tm/.gitignore
 delete mode 100644 tools/testing/selftests/powerpc/vphn/.gitignore
 delete mode 100644 tools/testing/selftests/prctl/.gitignore
 delete mode 100644 tools/testing/selftests/proc/.gitignore
 delete mode 100644 tools/testing/selftests/pstore/.gitignore
 delete mode 100644 tools/testing/selftests/ptp/.gitignore
 delete mode 100644 tools/testing/selftests/ptrace/.gitignore
 delete mode 100644 tools/testing/selftests/rcutorture/.gitignore
 delete mode 100644 tools/testing/selftests/rcutorture/formal/srcu-cbmc/.gitignore
 delete mode 100644 tools/testing/selftests/rcutorture/formal/srcu-cbmc/include/linux/.gitignore
 delete mode 100644 tools/testing/selftests/rcutorture/formal/srcu-cbmc/tests/store_buffering/.gitignore
 delete mode 100644 tools/testing/selftests/seccomp/.gitignore
 delete mode 100644 tools/testing/selftests/sigaltstack/.gitignore
 delete mode 100644 tools/testing/selftests/size/.gitignore
 delete mode 100644 tools/testing/selftests/splice/.gitignore
 delete mode 100644 tools/testing/selftests/sync/.gitignore
 delete mode 100644 tools/testing/selftests/tc-testing/.gitignore
 delete mode 100644 tools/testing/selftests/timers/.gitignore
 delete mode 100644 tools/testing/selftests/vDSO/.gitignore
 delete mode 100644 tools/testing/selftests/vm/.gitignore
 delete mode 100644 tools/testing/selftests/watchdog/.gitignore
 delete mode 100644 tools/testing/selftests/x86/.gitignore
 delete mode 100644 tools/testing/vsock/.gitignore
 delete mode 100644 tools/thermal/tmon/.gitignore
 delete mode 100644 tools/usb/.gitignore
 delete mode 100644 tools/usb/usbip/.gitignore
 delete mode 100644 tools/virtio/.gitignore
 delete mode 100644 tools/vm/.gitignore
 delete mode 100644 usr/.gitignore

diff --git a/Documentation/.gitignore b/Documentation/.gitignore
deleted file mode 100644
index e74fec86..00000000
--- a/Documentation/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-output
-*.pyc
diff --git a/Documentation/arm/SH-Mobile/.gitignore b/Documentation/arm/SH-Mobile/.gitignore
deleted file mode 100644
index c928dbf3..00000000
--- a/Documentation/arm/SH-Mobile/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vrl4
diff --git a/Documentation/devicetree/bindings/clock/sifive,gemgxl-mgmt.txt b/Documentation/devicetree/bindings/clock/sifive,gemgxl-mgmt.txt
new file mode 100644
index 00000000..349489e3
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/sifive,gemgxl-mgmt.txt
@@ -0,0 +1,26 @@
+TX clock switch for GEMGXL in U540 SoCs
+
+This binding uses the common clock binding:
+    Documentation/devicetree/bindings/clock/clock-bindings.txt
+
+The U54 includes a clock mux to control the ethernet TX frequenecy. It
+switches between the local TX clock (125MHz) and PHY TX clocks. This is
+necessary to toggle between 1Gb and 100/10Mb speeds.
+
+Required properties:
+- compatible:	Should be "sifive,cadencegemgxlmgmt0"
+- #clock-cells:	Should be <0>
+- reg:		Specifies base physical address and size of the registers
+
+Example:
+
+	mgmt: cadence-gemgxl-mgmt@100a00000 {
+		compatible = "sifive,cadencegemgxlmgmt0";
+		#clock-cells = <0>;
+		reg = <0x0 0x100a0000 0x0 0x1000>;
+	};
+
+	ethernet@10090000 {
+		...
+		clocks = <&mgmt>; /* TX clock */
+	};
diff --git a/Documentation/devicetree/bindings/clock/sifive,u54-prci.txt b/Documentation/devicetree/bindings/clock/sifive,u54-prci.txt
new file mode 100644
index 00000000..88682c5e
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/sifive,u54-prci.txt
@@ -0,0 +1,44 @@
+SiFive U54 SoC clocks
+
+This binding uses the common clock binding:
+    Documentation/devicetree/bindings/clock/clock-bindings.txt
+
+The U54 PRCI controller generates clocks for the U54 SoC. There is
+a core PLL that sets the processor frequency and PLLs for ethernet
+and DDR. It takes an input clock from the board, typically an oscillator
+or crystal.
+
+Required properties:
+- compatible:	Should be "sifive,aloeprci0"
+- #clock-cells:	Should be <1>
+- reg:		Specifies base physical address and size of the registers
+- clocks:	phandles to the parent clock used as input
+
+Example:
+
+	refclk: refclk {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <33333333>;
+		clock-output-names = "xtal";
+	};
+
+	u54: prci@10000000 {
+		compatible = "sifive,aloeprci0";
+		reg = <0x0 0x10000000 0x0 0x1000>;
+		clocks = <&refclk>;
+		#clock-cells = <1>;
+	};
+
+	tlclk: tlclk {
+		compatible = "fixed-factor-clock";
+		clocks = <&u54 0>; /* Core frequency */
+		#clock-cells = <0>;
+		clock-div = <2>;
+		clock-mult = <1>;
+	};
+
+	ethernet@10090000 {
+		...
+		clocks = <&prci 1>; /* TX clock */
+	};
diff --git a/Documentation/devicetree/bindings/interrupt-controller/riscv,cpu-intc.txt b/Documentation/devicetree/bindings/interrupt-controller/riscv,cpu-intc.txt
new file mode 100644
index 00000000..61900e2e
--- /dev/null
+++ b/Documentation/devicetree/bindings/interrupt-controller/riscv,cpu-intc.txt
@@ -0,0 +1,41 @@
+RISC-V Hart-Level Interrupt Controller (HLIC)
+---------------------------------------------
+
+RISC-V cores include Control Status Registers (CSRs) which are local to each
+hart and can be read or written by software. Some of these CSRs are used to
+control local interrupts connected to the core.  Every interrupt is ultimately
+routed through a hart's HLIC before it interrupts that hart.
+
+The RISC-V supervisor ISA manual specifies three interrupt sources that are
+attached to every HLIC: software interrupts, the timer interrupt, and external
+interrupts.  Software interrupts are used to send IPIs between cores.  The
+timer interrupt comes from an architecturally mandated real-time timer that is
+controller via SBI calls and CSR reads.  External interrupts connect all other
+device interrupts to the HLIC, which are routed via the platform-level
+interrupt controller (PLIC).
+
+All RISC-V systems that conform to the supervisor ISA specification are
+required to have a HLIC with these three interrupt sources present.  Since the
+interrupt map is defined by the ISA it's not listed in the HLIC's device tree
+entry, though external interrupt controllers (like the PLIC, for example) will
+need to define how their interrupts map to the relevant HLICs.
+
+Required properties:
+- compatible : "riscv,cpu-intc"
+- #interrupt-cells : should be <1>
+- interrupt-controller : Identifies the node as an interrupt controller
+
+Furthermore, this interrupt-controller MUST be embedded inside the cpu
+definition of the hart whose CSRs control these local interrupts.
+
+An example device tree entry for a HLIC is show below.
+
+	cpu1: cpu@1 {
+		compatible = "riscv";
+		...
+		cpu1-intc: interrupt-controller {
+			#interrupt-cells = <1>;
+			compatible = "riscv,cpu-intc";
+			interrupt-controller;
+		};
+	};
diff --git a/Documentation/devicetree/bindings/interrupt-controller/riscv,plic0.txt b/Documentation/devicetree/bindings/interrupt-controller/riscv,plic0.txt
new file mode 100644
index 00000000..99cd359d
--- /dev/null
+++ b/Documentation/devicetree/bindings/interrupt-controller/riscv,plic0.txt
@@ -0,0 +1,55 @@
+RISC-V Platform-Level Interrupt Controller (PLIC)
+-------------------------------------------------
+
+The RISC-V supervisor ISA specification allows for the presence of a
+platform-level interrupt controller (PLIC).   The PLIC connects all external
+interrupts in the system to all hart contexts in the system, via the external
+interrupt source in each hart's hart-local interrupt controller (HLIC).  A hart
+context is a privilege mode in a hardware execution thread.  For example, in
+an 4 core system with 2-way SMT, you have 8 harts and probably at least two
+privilege modes per hart; machine mode and supervisor mode.
+
+Each interrupt can be enabled on per-context basis. Any context can claim
+a pending enabled interrupt and then release it once it has been handled.
+
+Each interrupt has a configurable priority. Higher priority interrupts are
+serviced firs. Each context can specify a priority threshold. Interrupts
+with priority below this threshold will not cause the PLIC to raise its
+interrupt line leading to the context.
+
+While the PLIC supports both edge-triggered and level-triggered interrupts,
+interrupt handlers are oblivious to this distinction and therefor it is not
+specific in the PLIC device-tree binding.
+
+While the RISC-V ISA doesn't specify a memory layout for the PLIC, the
+"riscv,plic0" device is a concrete implementation of the PLIC that contains a
+specific memory layout.  More details about the memory layout of the
+"riscv,plic0" device can be found as a comment in the device driver, or as part
+of the SiFive U5 Coreplex Series Manual (page 22 of the PDF of version 1.0)
+<https://www.sifive.com/documentation/coreplex/u5-coreplex-series-manual/>
+
+Required properties:
+- compatible : "riscv,plic0"
+- #address-cells : should be <0>
+- #interrupt-cells : should be <1>
+- interrupt-controller : Identifies the node as an interrupt controller
+- reg : Should contain 1 register range (address and length)
+- interrupts-extended : Specifies which contexts are connected to the PLIC,
+  with "-1" specifying that a context is not present.
+
+Example:
+
+	plic: interrupt-controller@c000000 {
+		#address-cells = <0>;
+		#interrupt-cells = <1>;
+		compatible = "riscv,plic0";
+		interrupt-controller;
+		interrupts-extended = <
+			&cpu0-intc 11
+			&cpu1-intc 11 &cpu1-intc 9
+			&cpu2-intc 11 &cpu2-intc 9
+			&cpu3-intc 11 &cpu3-intc 9
+			&cpu4-intc 11 &cpu4-intc 9>;
+		reg = <0xc000000 0x4000000>;
+		riscv,ndev = <10>;
+	};
diff --git a/Documentation/devicetree/bindings/riscv/cpus.txt b/Documentation/devicetree/bindings/riscv/cpus.txt
index adf7b7af..6aa9cd07 100644
--- a/Documentation/devicetree/bindings/riscv/cpus.txt
+++ b/Documentation/devicetree/bindings/riscv/cpus.txt
@@ -82,6 +82,15 @@ described below.
                 Value type: <string>
                 Definition: Contains the RISC-V ISA string of this hart.  These
                             ISA strings are defined by the RISC-V ISA manual.
+        - cpu-enable-method:
+                Usage: optional
+                Value type: <stringlist>
+                Definition: When absent, default is either "always-disabled"
+                            "always-enabled", depending on the current state
+                            of the CPU.
+                            Must be one of:
+                                * "always-disabled": This CPU cannot be enabled.
+                                * "always-enabled": This CPU cannot be disabled.
 
 Example: SiFive Freedom U540G Development Kit
 ---------------------------------------------
@@ -93,9 +102,9 @@ Linux is allowed to run on.
         cpus {
                 #address-cells = <1>;
                 #size-cells = <0>;
-                timebase-frequency = <1000000>;
                 cpu@0 {
                         clock-frequency = <1600000000>;
+                        timebase-frequency = <1000000>;
                         compatible = "sifive,rocket0", "riscv";
                         device_type = "cpu";
                         i-cache-block-size = <64>;
@@ -113,6 +122,7 @@ Linux is allowed to run on.
                 };
                 cpu@1 {
                         clock-frequency = <1600000000>;
+                        timebase-frequency = <1000000>;
                         compatible = "sifive,rocket0", "riscv";
                         d-cache-block-size = <64>;
                         d-cache-sets = <64>;
@@ -145,6 +155,7 @@ Example: Spike ISA Simulator with 1 Hart
 This device tree matches the Spike ISA golden model as run with `spike -p1`.
 
         cpus {
+                timebase-frequency = <1000000>;
                 cpu@0 {
                         device_type = "cpu";
                         reg = <0x00000000>;
diff --git a/Documentation/devicetree/bindings/spi/spi-sifive.txt b/Documentation/devicetree/bindings/spi/spi-sifive.txt
new file mode 100644
index 00000000..94554324
--- /dev/null
+++ b/Documentation/devicetree/bindings/spi/spi-sifive.txt
@@ -0,0 +1,29 @@
+SiFive SPI controller Device Tree Bindings
+-------------------------------------------------
+
+Required properties:
+- compatible		: Should be "sifive,spi0"
+- reg			: Physical base address and size of SPI registers map
+			  A second (optional) range can indicate memory mapped flash
+- interrupts		: Must contain one entry
+- interrupt-parent	: Must be core interrupt controller
+- clocks		: Must reference the frequency given to the controller
+- #address-cells	: Must be '1', indicating which CS to use
+- #size-cells		: Must be '0'
+
+Optional properties:
+- sifive,buffer-size	: Depth of hardware queues; defaults to 8
+- sifive,bits-per-word	: Maximum bits per word; defaults to 8
+
+Example:
+	spi: spi@10040000 {
+		compatible = "sifive,spi0";
+		reg = <0x0 0x10040000 0x0 0x1000 0x0 0x20000000 0x0 0x10000000>;
+		interrupt-parent = <&plic>;
+		interrupts = <51>;
+		clocks = <&tlclk>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		sifive,buffer-size = <8>;
+		sifive,bits-per-word = <8>;
+	};
diff --git a/Documentation/driver-api/infrastructure.rst b/Documentation/driver-api/infrastructure.rst
index bee1b9a1..6172f3cc 100644
--- a/Documentation/driver-api/infrastructure.rst
+++ b/Documentation/driver-api/infrastructure.rst
@@ -49,10 +49,10 @@ Device Drivers Base
 Device Drivers DMA Management
 -----------------------------
 
-.. kernel-doc:: drivers/base/dma-coherent.c
+.. kernel-doc:: kernel/dma/coherent.c
    :export:
 
-.. kernel-doc:: drivers/base/dma-mapping.c
+.. kernel-doc:: kernel/dma/mapping.c
    :export:
 
 Device drivers PnP support
diff --git a/Documentation/features/io/dma-api-debug/arch-support.txt b/Documentation/features/io/dma-api-debug/arch-support.txt
deleted file mode 100644
index e438ed67..00000000
--- a/Documentation/features/io/dma-api-debug/arch-support.txt
+++ /dev/null
@@ -1,31 +0,0 @@
-#
-# Feature name:          dma-api-debug
-#         Kconfig:       HAVE_DMA_API_DEBUG
-#         description:   arch supports DMA debug facilities
-#
-    -----------------------
-    |         arch |status|
-    -----------------------
-    |       alpha: | TODO |
-    |         arc: | TODO |
-    |         arm: |  ok  |
-    |       arm64: |  ok  |
-    |         c6x: |  ok  |
-    |       h8300: | TODO |
-    |     hexagon: | TODO |
-    |        ia64: |  ok  |
-    |        m68k: | TODO |
-    |  microblaze: |  ok  |
-    |        mips: |  ok  |
-    |       nios2: | TODO |
-    |    openrisc: | TODO |
-    |      parisc: | TODO |
-    |     powerpc: |  ok  |
-    |        s390: |  ok  |
-    |          sh: |  ok  |
-    |       sparc: |  ok  |
-    |          um: | TODO |
-    |   unicore32: | TODO |
-    |         x86: |  ok  |
-    |      xtensa: |  ok  |
-    -----------------------
diff --git a/Documentation/media/.gitignore b/Documentation/media/.gitignore
deleted file mode 100644
index 08b21de3..00000000
--- a/Documentation/media/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-*.pdf
-# Files generated from *.dot
-uapi/v4l/pipeline.svg
diff --git a/Documentation/riscv/pmu.txt b/Documentation/riscv/pmu.txt
new file mode 100644
index 00000000..b29f03a6
--- /dev/null
+++ b/Documentation/riscv/pmu.txt
@@ -0,0 +1,249 @@
+Supporting PMUs on RISC-V platforms
+==========================================
+Alan Kao <alankao@andestech.com>, Mar 2018
+
+Introduction
+------------
+
+As of this writing, perf_event-related features mentioned in The RISC-V ISA
+Privileged Version 1.10 are as follows:
+(please check the manual for more details)
+
+* [m|s]counteren
+* mcycle[h], cycle[h]
+* minstret[h], instret[h]
+* mhpeventx, mhpcounterx[h]
+
+With such function set only, porting perf would require a lot of work, due to
+the lack of the following general architectural performance monitoring features:
+
+* Enabling/Disabling counters
+  Counters are just free-running all the time in our case.
+* Interrupt caused by counter overflow
+  No such feature in the spec.
+* Interrupt indicator
+  It is not possible to have many interrupt ports for all counters, so an
+  interrupt indicator is required for software to tell which counter has
+  just overflowed.
+* Writing to counters
+  There will be an SBI to support this since the kernel cannot modify the
+  counters [1].  Alternatively, some vendor considers to implement
+  hardware-extension for M-S-U model machines to write counters directly.
+
+This document aims to provide developers a quick guide on supporting their
+PMUs in the kernel.  The following sections briefly explain perf' mechanism
+and todos.
+
+You may check previous discussions here [1][2].  Also, it might be helpful
+to check the appendix for related kernel structures.
+
+
+1. Initialization
+-----------------
+
+*riscv_pmu* is a global pointer of type *struct riscv_pmu*, which contains
+various methods according to perf's internal convention and PMU-specific
+parameters.  One should declare such instance to represent the PMU.  By default,
+*riscv_pmu* points to a constant structure *riscv_base_pmu*, which has very
+basic support to a baseline QEMU model.
+
+Then he/she can either assign the instance's pointer to *riscv_pmu* so that
+the minimal and already-implemented logic can be leveraged, or invent his/her
+own *riscv_init_platform_pmu* implementation.
+
+In other words, existing sources of *riscv_base_pmu* merely provide a
+reference implementation.  Developers can flexibly decide how many parts they
+can leverage, and in the most extreme case, they can customize every function
+according to their needs.
+
+
+2. Event Initialization
+-----------------------
+
+When a user launches a perf command to monitor some events, it is first
+interpreted by the userspace perf tool into multiple *perf_event_open*
+system calls, and then each of them calls to the body of *event_init*
+member function that was assigned in the previous step.  In *riscv_base_pmu*'s
+case, it is *riscv_event_init*.
+
+The main purpose of this function is to translate the event provided by user
+into bitmap, so that HW-related control registers or counters can directly be
+manipulated.  The translation is based on the mappings and methods provided in
+*riscv_pmu*.
+
+Note that some features can be done in this stage as well:
+
+(1) interrupt setting, which is stated in the next section;
+(2) privilege level setting (user space only, kernel space only, both);
+(3) destructor setting.  Normally it is sufficient to apply *riscv_destroy_event*;
+(4) tweaks for non-sampling events, which will be utilized by functions such as
+*perf_adjust_period*, usually something like the follows:
+
+if (!is_sampling_event(event)) {
+        hwc->sample_period = x86_pmu.max_period;
+        hwc->last_period = hwc->sample_period;
+        local64_set(&hwc->period_left, hwc->sample_period);
+}
+
+In the case of *riscv_base_pmu*, only (3) is provided for now.
+
+
+3. Interrupt
+------------
+
+3.1. Interrupt Initialization
+
+This often occurs at the beginning of the *event_init* method. In common
+practice, this should be a code segment like
+
+int x86_reserve_hardware(void)
+{
+        int err = 0;
+
+        if (!atomic_inc_not_zero(&pmc_refcount)) {
+                mutex_lock(&pmc_reserve_mutex);
+                if (atomic_read(&pmc_refcount) == 0) {
+                        if (!reserve_pmc_hardware())
+                                err = -EBUSY;
+                        else
+                                reserve_ds_buffers();
+                }
+                if (!err)
+                        atomic_inc(&pmc_refcount);
+                mutex_unlock(&pmc_reserve_mutex);
+        }
+
+        return err;
+}
+
+And the magic is in *reserve_pmc_hardware*, which usually does atomic
+operations to make implemented IRQ accessible from some global function pointer.
+*release_pmc_hardware* serves the opposite purpose, and it is used in event
+destructors mentioned in previous section.
+
+(Note: From the implementations in all the architectures, the *reserve/release*
+pair are always IRQ settings, so the *pmc_hardware* seems somehow misleading.
+It does NOT deal with the binding between an event and a physical counter,
+which will be introduced in the next section.)
+
+3.2. IRQ Structure
+
+Basically, a IRQ runs the following pseudo code:
+
+for each hardware counter that triggered this overflow
+
+    get the event of this counter
+
+    // following two steps are defined as *read()*,
+    // check the section Reading/Writing Counters for details.
+    count the delta value since previous interrupt
+    update the event->count (# event occurs) by adding delta, and
+               event->hw.period_left by subtracting delta
+
+    if the event overflows
+        sample data
+        set the counter appropriately for the next overflow
+
+        if the event overflows again
+            too frequently, throttle this event
+        fi
+    fi
+
+end for
+
+However as of this writing, none of the RISC-V implementations have designed an
+interrupt for perf, so the details are to be completed in the future.
+
+4. Reading/Writing Counters
+---------------------------
+
+They seem symmetric but perf treats them quite differently.  For reading, there
+is a *read* interface in *struct pmu*, but it serves more than just reading.
+According to the context, the *read* function not only reads the content of the
+counter (event->count), but also updates the left period to the next interrupt
+(event->hw.period_left).
+
+But the core of perf does not need direct write to counters.  Writing counters
+is hidden behind the abstraction of 1) *pmu->start*, literally start counting so one
+has to set the counter to a good value for the next interrupt; 2) inside the IRQ
+it should set the counter to the same resonable value.
+
+Reading is not a problem in RISC-V but writing would need some effort, since
+counters are not allowed to be written by S-mode.
+
+
+5. add()/del()/start()/stop()
+-----------------------------
+
+Basic idea: add()/del() adds/deletes events to/from a PMU, and start()/stop()
+starts/stop the counter of some event in the PMU.  All of them take the same
+arguments: *struct perf_event *event* and *int flag*.
+
+Consider perf as a state machine, then you will find that these functions serve
+as the state transition process between those states.
+Three states (event->hw.state) are defined:
+
+* PERF_HES_STOPPED:	the counter is stopped
+* PERF_HES_UPTODATE:	the event->count is up-to-date
+* PERF_HES_ARCH:	arch-dependent usage ... we don't need this for now
+
+A normal flow of these state transitions are as follows:
+
+* A user launches a perf event, resulting in calling to *event_init*.
+* When being context-switched in, *add* is called by the perf core, with a flag
+  PERF_EF_START, which means that the event should be started after it is added.
+  At this stage, a general event is bound to a physical counter, if any.
+  The state changes to PERF_HES_STOPPED and PERF_HES_UPTODATE, because it is now
+  stopped, and the (software) event count does not need updating.
+** *start* is then called, and the counter is enabled.
+   With flag PERF_EF_RELOAD, it writes an appropriate value to the counter (check
+   previous section for detail).
+   Nothing is written if the flag does not contain PERF_EF_RELOAD.
+   The state now is reset to none, because it is neither stopped nor updated
+   (the counting already started)
+* When being context-switched out, *del* is called.  It then checks out all the
+  events in the PMU and calls *stop* to update their counts.
+** *stop* is called by *del*
+   and the perf core with flag PERF_EF_UPDATE, and it often shares the same
+   subroutine as *read* with the same logic.
+   The state changes to PERF_HES_STOPPED and PERF_HES_UPTODATE, again.
+
+** Life cycle of these two pairs: *add* and *del* are called repeatedly as
+  tasks switch in-and-out; *start* and *stop* is also called when the perf core
+  needs a quick stop-and-start, for instance, when the interrupt period is being
+  adjusted.
+
+Current implementation is sufficient for now and can be easily extended to
+features in the future.
+
+A. Related Structures
+---------------------
+
+* struct pmu: include/linux/perf_event.h
+* struct riscv_pmu: arch/riscv/include/asm/perf_event.h
+
+  Both structures are designed to be read-only.
+
+  *struct pmu* defines some function pointer interfaces, and most of them take
+*struct perf_event* as a main argument, dealing with perf events according to
+perf's internal state machine (check kernel/events/core.c for details).
+
+  *struct riscv_pmu* defines PMU-specific parameters.  The naming follows the
+convention of all other architectures.
+
+* struct perf_event: include/linux/perf_event.h
+* struct hw_perf_event
+
+  The generic structure that represents perf events, and the hardware-related
+details.
+
+* struct riscv_hw_events: arch/riscv/include/asm/perf_event.h
+
+  The structure that holds the status of events, has two fixed members:
+the number of events and the array of the events.
+
+References
+----------
+
+[1] https://github.com/riscv/riscv-linux/pull/124
+[2] https://groups.google.com/a/groups.riscv.org/forum/#!topic/sw-dev/f19TmCNP6yA
diff --git a/Documentation/vm/.gitignore b/Documentation/vm/.gitignore
deleted file mode 100644
index 09b164a5..00000000
--- a/Documentation/vm/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-page-types
-slabinfo
diff --git a/MAINTAINERS b/MAINTAINERS
index 9c125f70..4ebe53e2 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -4328,14 +4328,11 @@ L:	iommu@lists.linux-foundation.org
 T:	git git://git.infradead.org/users/hch/dma-mapping.git
 W:	http://git.infradead.org/users/hch/dma-mapping.git
 S:	Supported
-F:	lib/dma-debug.c
-F:	lib/dma-direct.c
-F:	lib/dma-virt.c
-F:	drivers/base/dma-mapping.c
-F:	drivers/base/dma-coherent.c
+F:	kernel/dma/
 F:	include/asm-generic/dma-mapping.h
 F:	include/linux/dma-direct.h
 F:	include/linux/dma-mapping.h
+F:	include/linux/dma-noncoherent.h
 
 DME1737 HARDWARE MONITOR DRIVER
 M:	Juerg Haefliger <juergh@gmail.com>
@@ -12764,6 +12761,14 @@ F:	drivers/media/usb/siano/
 F:	drivers/media/usb/siano/
 F:	drivers/media/mmc/siano/
 
+SIFIVE DRIVERS
+M:	Palmer Dabbelt <palmer@sifive.com>
+L:	linux-riscv@lists.infradead.org
+T:	git git://git.kernel.org/pub/scm/linux/kernel/git/palmer/riscv-linux.git
+S:	Supported
+K:	sifive
+N:	sifive
+
 SILEAD TOUCHSCREEN DRIVER
 M:	Hans de Goede <hdegoede@redhat.com>
 L:	linux-input@vger.kernel.org
@@ -13465,7 +13470,7 @@ M:	Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
 L:	iommu@lists.linux-foundation.org
 T:	git git://git.kernel.org/pub/scm/linux/kernel/git/konrad/swiotlb.git
 S:	Supported
-F:	lib/swiotlb.c
+F:	kernel/dma/swiotlb.c
 F:	arch/*/kernel/pci-swiotlb.c
 F:	include/linux/swiotlb.h
 
diff --git a/arch/.gitignore b/arch/.gitignore
deleted file mode 100644
index 74146892..00000000
--- a/arch/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-i386
-x86_64
diff --git a/arch/Kconfig b/arch/Kconfig
index 75dd23ac..b624634d 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -278,9 +278,6 @@ config HAVE_CLK
 	  The <linux/clk.h> calls support software clock gating and
 	  thus are a key power management tool on many systems.
 
-config HAVE_DMA_API_DEBUG
-	bool
-
 config HAVE_HW_BREAKPOINT
 	bool
 	depends on PERF_EVENTS
diff --git a/arch/alpha/Kconfig b/arch/alpha/Kconfig
index f19dc312..94af0c7f 100644
--- a/arch/alpha/Kconfig
+++ b/arch/alpha/Kconfig
@@ -10,6 +10,8 @@ config ALPHA
 	select HAVE_OPROFILE
 	select HAVE_PCSPKR_PLATFORM
 	select HAVE_PERF_EVENTS
+	select NEED_DMA_MAP_STATE
+	select NEED_SG_DMA_LENGTH
 	select VIRT_TO_BUS
 	select GENERIC_IRQ_PROBE
 	select AUTO_IRQ_AFFINITY if SMP
@@ -64,15 +66,6 @@ config ZONE_DMA
 	bool
 	default y
 
-config ARCH_DMA_ADDR_T_64BIT
-	def_bool y
-
-config NEED_DMA_MAP_STATE
-       def_bool y
-
-config NEED_SG_DMA_LENGTH
-	def_bool y
-
 config GENERIC_ISA_DMA
 	bool
 	default y
@@ -346,9 +339,6 @@ config PCI_DOMAINS
 config PCI_SYSCALL
 	def_bool PCI
 
-config IOMMU_HELPER
-	def_bool PCI
-
 config ALPHA_NONAME
 	bool
 	depends on ALPHA_BOOK1 || ALPHA_NONAME_CH
diff --git a/arch/alpha/kernel/.gitignore b/arch/alpha/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/alpha/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/arc/Kconfig b/arch/arc/Kconfig
index d76bf4a8..7498aca4 100644
--- a/arch/arc/Kconfig
+++ b/arch/arc/Kconfig
@@ -453,16 +453,11 @@ config ARC_HAS_PAE40
 	default n
 	depends on ISA_ARCV2
 	select HIGHMEM
+	select PHYS_ADDR_T_64BIT
 	help
 	  Enable access to physical memory beyond 4G, only supported on
 	  ARC cores with 40 bit Physical Addressing support
 
-config ARCH_PHYS_ADDR_T_64BIT
-	def_bool ARC_HAS_PAE40
-
-config ARCH_DMA_ADDR_T_64BIT
-	bool
-
 config ARC_KVADDR_SIZE
 	int "Kernel Virtual Address Space size (MB)"
 	range 0 512
diff --git a/arch/arc/boot/.gitignore b/arch/arc/boot/.gitignore
deleted file mode 100644
index c4c5fd52..00000000
--- a/arch/arc/boot/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-uImage
diff --git a/arch/arc/kernel/.gitignore b/arch/arc/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/arc/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index a7f8e7f4..13ef66b6 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -60,7 +60,6 @@ config ARM
 	select HAVE_CONTEXT_TRACKING
 	select HAVE_C_RECORDMCOUNT
 	select HAVE_DEBUG_KMEMLEAK
-	select HAVE_DMA_API_DEBUG
 	select HAVE_DMA_CONTIGUOUS if MMU
 	select HAVE_DYNAMIC_FTRACE if (!XIP_KERNEL) && !CPU_ENDIAN_BE32 && MMU
 	select HAVE_DYNAMIC_FTRACE_WITH_REGS if HAVE_DYNAMIC_FTRACE
@@ -96,6 +95,7 @@ config ARM
 	select HAVE_VIRT_CPU_ACCOUNTING_GEN
 	select IRQ_FORCED_THREADING
 	select MODULES_USE_ELF_REL
+	select NEED_DMA_MAP_STATE
 	select NO_BOOTMEM
 	select OF_EARLY_FLATTREE if OF
 	select OF_RESERVED_MEM if OF
@@ -224,9 +224,6 @@ config ARCH_MAY_HAVE_PC_FDC
 config ZONE_DMA
 	bool
 
-config NEED_DMA_MAP_STATE
-       def_bool y
-
 config ARCH_SUPPORTS_UPROBES
 	def_bool y
 
@@ -340,8 +337,8 @@ config ARCH_MULTIPLATFORM
 	select TIMER_OF
 	select COMMON_CLK
 	select GENERIC_CLOCKEVENTS
+	select GENERIC_IRQ_MULTI_HANDLER
 	select MIGHT_HAVE_PCI
-	select MULTI_IRQ_HANDLER
 	select PCI_DOMAINS if PCI
 	select SPARSE_IRQ
 	select USE_OF
@@ -468,9 +465,9 @@ config ARCH_DOVE
 	bool "Marvell Dove"
 	select CPU_PJ4
 	select GENERIC_CLOCKEVENTS
+	select GENERIC_IRQ_MULTI_HANDLER
 	select GPIOLIB
 	select MIGHT_HAVE_PCI
-	select MULTI_IRQ_HANDLER
 	select MVEBU_MBUS
 	select PINCTRL
 	select PINCTRL_DOVE
@@ -515,8 +512,8 @@ config ARCH_LPC32XX
 	select COMMON_CLK
 	select CPU_ARM926T
 	select GENERIC_CLOCKEVENTS
+	select GENERIC_IRQ_MULTI_HANDLER
 	select GPIOLIB
-	select MULTI_IRQ_HANDLER
 	select SPARSE_IRQ
 	select USE_OF
 	help
@@ -535,11 +532,11 @@ config ARCH_PXA
 	select TIMER_OF
 	select CPU_XSCALE if !CPU_XSC3
 	select GENERIC_CLOCKEVENTS
+	select GENERIC_IRQ_MULTI_HANDLER
 	select GPIO_PXA
 	select GPIOLIB
 	select HAVE_IDE
 	select IRQ_DOMAIN
-	select MULTI_IRQ_HANDLER
 	select PLAT_PXA
 	select SPARSE_IRQ
 	help
@@ -575,11 +572,11 @@ config ARCH_SA1100
 	select CPU_FREQ
 	select CPU_SA1100
 	select GENERIC_CLOCKEVENTS
+	select GENERIC_IRQ_MULTI_HANDLER
 	select GPIOLIB
 	select HAVE_IDE
 	select IRQ_DOMAIN
 	select ISA
-	select MULTI_IRQ_HANDLER
 	select NEED_MACH_MEMORY_H
 	select SPARSE_IRQ
 	help
@@ -593,10 +590,10 @@ config ARCH_S3C24XX
 	select GENERIC_CLOCKEVENTS
 	select GPIO_SAMSUNG
 	select GPIOLIB
+	select GENERIC_IRQ_MULTI_HANDLER
 	select HAVE_S3C2410_I2C if I2C
 	select HAVE_S3C2410_WATCHDOG if WATCHDOG
 	select HAVE_S3C_RTC if RTC_CLASS
-	select MULTI_IRQ_HANDLER
 	select NEED_MACH_IO_H
 	select SAMSUNG_ATAGS
 	select USE_OF
@@ -630,10 +627,10 @@ config ARCH_OMAP1
 	select CLKSRC_MMIO
 	select GENERIC_CLOCKEVENTS
 	select GENERIC_IRQ_CHIP
+	select GENERIC_IRQ_MULTI_HANDLER
 	select GPIOLIB
 	select HAVE_IDE
 	select IRQ_DOMAIN
-	select MULTI_IRQ_HANDLER
 	select NEED_MACH_IO_H if PCCARD
 	select NEED_MACH_MEMORY_H
 	select SPARSE_IRQ
@@ -924,11 +921,6 @@ config IWMMXT
 	  Enable support for iWMMXt context switching at run time if
 	  running on a CPU that supports it.
 
-config MULTI_IRQ_HANDLER
-	bool
-	help
-	  Allow each machine to specify it's own IRQ handler at run time.
-
 if !MMU
 source "arch/arm/Kconfig-nommu"
 endif
@@ -1778,12 +1770,6 @@ config SECCOMP
 	  and the task is only allowed to execute a few safe syscalls
 	  defined by each seccomp mode.
 
-config SWIOTLB
-	def_bool y
-
-config IOMMU_HELPER
-	def_bool SWIOTLB
-
 config PARAVIRT
 	bool "Enable paravirtualization code"
 	help
diff --git a/arch/arm/boot/.gitignore b/arch/arm/boot/.gitignore
deleted file mode 100644
index ce1c5ff7..00000000
--- a/arch/arm/boot/.gitignore
+++ /dev/null
@@ -1,5 +0,0 @@
-Image
-zImage
-xipImage
-bootpImage
-uImage
diff --git a/arch/arm/boot/compressed/.gitignore b/arch/arm/boot/compressed/.gitignore
deleted file mode 100644
index 86b2f5d2..00000000
--- a/arch/arm/boot/compressed/.gitignore
+++ /dev/null
@@ -1,17 +0,0 @@
-ashldi3.S
-bswapsdi2.S
-font.c
-lib1funcs.S
-hyp-stub.S
-piggy_data
-vmlinux
-vmlinux.lds
-
-# borrowed libfdt files
-fdt.c
-fdt.h
-fdt_ro.c
-fdt_rw.c
-fdt_wip.c
-libfdt.h
-libfdt_internal.h
diff --git a/arch/arm/crypto/.gitignore b/arch/arm/crypto/.gitignore
deleted file mode 100644
index 31e1f538..00000000
--- a/arch/arm/crypto/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-aesbs-core.S
-sha256-core.S
-sha512-core.S
diff --git a/arch/arm/include/asm/irq.h b/arch/arm/include/asm/irq.h
index b6f31960..c883fcbe 100644
--- a/arch/arm/include/asm/irq.h
+++ b/arch/arm/include/asm/irq.h
@@ -31,11 +31,6 @@ extern void asm_do_IRQ(unsigned int, struct pt_regs *);
 void handle_IRQ(unsigned int, struct pt_regs *);
 void init_IRQ(void);
 
-#ifdef CONFIG_MULTI_IRQ_HANDLER
-extern void (*handle_arch_irq)(struct pt_regs *);
-extern void set_handle_irq(void (*handle_irq)(struct pt_regs *));
-#endif
-
 #ifdef CONFIG_SMP
 extern void arch_trigger_cpumask_backtrace(const cpumask_t *mask,
 					   bool exclude_self);
diff --git a/arch/arm/include/asm/mach/arch.h b/arch/arm/include/asm/mach/arch.h
index 5c1ad11a..bb885120 100644
--- a/arch/arm/include/asm/mach/arch.h
+++ b/arch/arm/include/asm/mach/arch.h
@@ -59,7 +59,7 @@ struct machine_desc {
 	void			(*init_time)(void);
 	void			(*init_machine)(void);
 	void			(*init_late)(void);
-#ifdef CONFIG_MULTI_IRQ_HANDLER
+#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER
 	void			(*handle_irq)(struct pt_regs *);
 #endif
 	void			(*restart)(enum reboot_mode, const char *);
diff --git a/arch/arm/kernel/.gitignore b/arch/arm/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/arm/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/arm/kernel/entry-armv.S b/arch/arm/kernel/entry-armv.S
index 1752033b..7eeb1f57 100644
--- a/arch/arm/kernel/entry-armv.S
+++ b/arch/arm/kernel/entry-armv.S
@@ -22,7 +22,7 @@
 #include <asm/glue-df.h>
 #include <asm/glue-pf.h>
 #include <asm/vfpmacros.h>
-#ifndef CONFIG_MULTI_IRQ_HANDLER
+#ifndef CONFIG_GENERIC_IRQ_MULTI_HANDLER
 #include <mach/entry-macro.S>
 #endif
 #include <asm/thread_notify.h>
@@ -39,7 +39,7 @@
  * Interrupt handling.
  */
 	.macro	irq_handler
-#ifdef CONFIG_MULTI_IRQ_HANDLER
+#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER
 	ldr	r1, =handle_arch_irq
 	mov	r0, sp
 	badr	lr, 9997f
@@ -1226,9 +1226,3 @@ vector_addrexcptn:
 	.globl	cr_alignment
 cr_alignment:
 	.space	4
-
-#ifdef CONFIG_MULTI_IRQ_HANDLER
-	.globl	handle_arch_irq
-handle_arch_irq:
-	.space	4
-#endif
diff --git a/arch/arm/kernel/irq.c b/arch/arm/kernel/irq.c
index ece04a45..9908dacf 100644
--- a/arch/arm/kernel/irq.c
+++ b/arch/arm/kernel/irq.c
@@ -102,16 +102,6 @@ void __init init_IRQ(void)
 	uniphier_cache_init();
 }
 
-#ifdef CONFIG_MULTI_IRQ_HANDLER
-void __init set_handle_irq(void (*handle_irq)(struct pt_regs *))
-{
-	if (handle_arch_irq)
-		return;
-
-	handle_arch_irq = handle_irq;
-}
-#endif
-
 #ifdef CONFIG_SPARSE_IRQ
 int __init arch_probe_nr_irqs(void)
 {
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index fc40a2b4..4c249cb2 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -754,7 +754,7 @@ int __init arm_add_memory(u64 start, u64 size)
 	else
 		size -= aligned_start - start;
 
-#ifndef CONFIG_ARCH_PHYS_ADDR_T_64BIT
+#ifndef CONFIG_PHYS_ADDR_T_64BIT
 	if (aligned_start > ULONG_MAX) {
 		pr_crit("Ignoring memory at 0x%08llx outside 32-bit physical address space\n",
 			(long long)start);
@@ -1145,7 +1145,7 @@ void __init setup_arch(char **cmdline_p)
 
 	reserve_crashkernel();
 
-#ifdef CONFIG_MULTI_IRQ_HANDLER
+#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER
 	handle_arch_irq = mdesc->handle_irq;
 #endif
 
diff --git a/arch/arm/mach-axxia/Kconfig b/arch/arm/mach-axxia/Kconfig
index bb2ce1c6..d3eae603 100644
--- a/arch/arm/mach-axxia/Kconfig
+++ b/arch/arm/mach-axxia/Kconfig
@@ -2,7 +2,6 @@
 config ARCH_AXXIA
 	bool "LSI Axxia platforms"
 	depends on ARCH_MULTI_V7 && ARM_LPAE
-	select ARCH_DMA_ADDR_T_64BIT
 	select ARM_AMBA
 	select ARM_GIC
 	select ARM_TIMER_SP804
diff --git a/arch/arm/mach-bcm/Kconfig b/arch/arm/mach-bcm/Kconfig
index c2f3b0d2..c46a728d 100644
--- a/arch/arm/mach-bcm/Kconfig
+++ b/arch/arm/mach-bcm/Kconfig
@@ -211,7 +211,6 @@ config ARCH_BRCMSTB
 	select BRCMSTB_L2_IRQ
 	select BCM7120_L2_IRQ
 	select ARCH_HAS_HOLES_MEMORYMODEL
-	select ARCH_DMA_ADDR_T_64BIT if ARM_LPAE
 	select ZONE_DMA if ARM_LPAE
 	select SOC_BRCMSTB
 	select SOC_BUS
diff --git a/arch/arm/mach-exynos/Kconfig b/arch/arm/mach-exynos/Kconfig
index 647c319f..2ca40581 100644
--- a/arch/arm/mach-exynos/Kconfig
+++ b/arch/arm/mach-exynos/Kconfig
@@ -112,7 +112,6 @@ config SOC_EXYNOS5440
 	bool "SAMSUNG EXYNOS5440"
 	default y
 	depends on ARCH_EXYNOS5
-	select ARCH_DMA_ADDR_T_64BIT if ARM_LPAE
 	select HAVE_ARM_ARCH_TIMER
 	select AUTO_ZRELADDR
 	select PINCTRL_EXYNOS5440
diff --git a/arch/arm/mach-highbank/Kconfig b/arch/arm/mach-highbank/Kconfig
index 81110ec3..5552968f 100644
--- a/arch/arm/mach-highbank/Kconfig
+++ b/arch/arm/mach-highbank/Kconfig
@@ -1,7 +1,6 @@
 config ARCH_HIGHBANK
 	bool "Calxeda ECX-1000/2000 (Highbank/Midway)"
 	depends on ARCH_MULTI_V7
-	select ARCH_DMA_ADDR_T_64BIT if ARM_LPAE
 	select ARCH_HAS_HOLES_MEMORYMODEL
 	select ARCH_SUPPORTS_BIG_ENDIAN
 	select ARM_AMBA
diff --git a/arch/arm/mach-rockchip/Kconfig b/arch/arm/mach-rockchip/Kconfig
index a4065966..fafd3d7f 100644
--- a/arch/arm/mach-rockchip/Kconfig
+++ b/arch/arm/mach-rockchip/Kconfig
@@ -3,7 +3,6 @@ config ARCH_ROCKCHIP
 	depends on ARCH_MULTI_V7
 	select PINCTRL
 	select PINCTRL_ROCKCHIP
-	select ARCH_DMA_ADDR_T_64BIT if ARM_LPAE
 	select ARCH_HAS_RESET_CONTROLLER
 	select ARM_AMBA
 	select ARM_GIC
diff --git a/arch/arm/mach-shmobile/Kconfig b/arch/arm/mach-shmobile/Kconfig
index 280e7312..fe60cd09 100644
--- a/arch/arm/mach-shmobile/Kconfig
+++ b/arch/arm/mach-shmobile/Kconfig
@@ -29,7 +29,6 @@ config ARCH_RMOBILE
 menuconfig ARCH_RENESAS
 	bool "Renesas ARM SoCs"
 	depends on ARCH_MULTI_V7 && MMU
-	select ARCH_DMA_ADDR_T_64BIT if ARM_LPAE
 	select ARCH_SHMOBILE
 	select ARM_GIC
 	select GPIOLIB
diff --git a/arch/arm/mach-tegra/Kconfig b/arch/arm/mach-tegra/Kconfig
index 1e0aeb47..7f3b83e0 100644
--- a/arch/arm/mach-tegra/Kconfig
+++ b/arch/arm/mach-tegra/Kconfig
@@ -15,6 +15,5 @@ menuconfig ARCH_TEGRA
 	select RESET_CONTROLLER
 	select SOC_BUS
 	select ZONE_DMA if ARM_LPAE
-	select ARCH_DMA_ADDR_T_64BIT if ARM_LPAE
 	help
 	  This enables support for NVIDIA Tegra based systems.
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 7f14acf6..5a016bc8 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -661,6 +661,7 @@ config ARM_LPAE
 	bool "Support for the Large Physical Address Extension"
 	depends on MMU && CPU_32v7 && !CPU_32v6 && !CPU_32v5 && \
 		!CPU_32v4 && !CPU_32v3
+	select PHYS_ADDR_T_64BIT
 	help
 	  Say Y if you have an ARMv7 processor supporting the LPAE page
 	  table format and you would like to access memory beyond the
@@ -673,12 +674,6 @@ config ARM_PV_FIXUP
 	def_bool y
 	depends on ARM_LPAE && ARM_PATCH_PHYS_VIRT && ARCH_KEYSTONE
 
-config ARCH_PHYS_ADDR_T_64BIT
-	def_bool ARM_LPAE
-
-config ARCH_DMA_ADDR_T_64BIT
-	bool
-
 config ARM_THUMB
 	bool "Support Thumb user binaries" if !CPU_THUMBONLY && EXPERT
 	depends on CPU_THUMB_CAPABLE
diff --git a/arch/arm/mm/dma-mapping-nommu.c b/arch/arm/mm/dma-mapping-nommu.c
index 619f24a4..f448a066 100644
--- a/arch/arm/mm/dma-mapping-nommu.c
+++ b/arch/arm/mm/dma-mapping-nommu.c
@@ -241,12 +241,3 @@ void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
 void arch_teardown_dma_ops(struct device *dev)
 {
 }
-
-#define PREALLOC_DMA_DEBUG_ENTRIES	4096
-
-static int __init dma_debug_do_init(void)
-{
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
-	return 0;
-}
-core_initcall(dma_debug_do_init);
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index ada8eb20..4b6613b5 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -1151,15 +1151,6 @@ int arm_dma_supported(struct device *dev, u64 mask)
 	return __dma_supported(dev, mask, false);
 }
 
-#define PREALLOC_DMA_DEBUG_ENTRIES	4096
-
-static int __init dma_debug_do_init(void)
-{
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
-	return 0;
-}
-core_initcall(dma_debug_do_init);
-
 #ifdef CONFIG_ARM_DMA_USE_IOMMU
 
 static int __dma_info_to_prot(enum dma_data_direction dir, unsigned long attrs)
diff --git a/arch/arm/vdso/.gitignore b/arch/arm/vdso/.gitignore
deleted file mode 100644
index 6b47f6e0..00000000
--- a/arch/arm/vdso/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-vdso.lds
-vdso.so.raw
-vdsomunge
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index eb2cf493..ddb2220e 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -70,6 +70,7 @@ config ARM64
 	select GENERIC_CPU_AUTOPROBE
 	select GENERIC_EARLY_IOREMAP
 	select GENERIC_IDLE_POLL_SETUP
+	select GENERIC_IRQ_MULTI_HANDLER
 	select GENERIC_IRQ_PROBE
 	select GENERIC_IRQ_SHOW
 	select GENERIC_IRQ_SHOW_LEVEL
@@ -105,7 +106,6 @@ config ARM64
 	select HAVE_CONTEXT_TRACKING
 	select HAVE_DEBUG_BUGVERBOSE
 	select HAVE_DEBUG_KMEMLEAK
-	select HAVE_DMA_API_DEBUG
 	select HAVE_DMA_CONTIGUOUS
 	select HAVE_DYNAMIC_FTRACE
 	select HAVE_EFFICIENT_UNALIGNED_ACCESS
@@ -133,6 +133,8 @@ config ARM64
 	select IRQ_FORCED_THREADING
 	select MODULES_USE_ELF_RELA
 	select MULTI_IRQ_HANDLER
+	select NEED_DMA_MAP_STATE
+	select NEED_SG_DMA_LENGTH
 	select NO_BOOTMEM
 	select OF
 	select OF_EARLY_FLATTREE
@@ -142,6 +144,7 @@ config ARM64
 	select POWER_SUPPLY
 	select REFCOUNT_FULL
 	select SPARSE_IRQ
+	select SWIOTLB
 	select SYSCTL_EXCEPTION_TRACE
 	select THREAD_INFO_IN_TASK
 	help
@@ -150,9 +153,6 @@ config ARM64
 config 64BIT
 	def_bool y
 
-config ARCH_PHYS_ADDR_T_64BIT
-	def_bool y
-
 config MMU
 	def_bool y
 
@@ -237,24 +237,9 @@ config ZONE_DMA32
 config HAVE_GENERIC_GUP
 	def_bool y
 
-config ARCH_DMA_ADDR_T_64BIT
-	def_bool y
-
-config NEED_DMA_MAP_STATE
-	def_bool y
-
-config NEED_SG_DMA_LENGTH
-	def_bool y
-
 config SMP
 	def_bool y
 
-config SWIOTLB
-	def_bool y
-
-config IOMMU_HELPER
-	def_bool SWIOTLB
-
 config KERNEL_MODE_NEON
 	def_bool y
 
@@ -276,9 +261,6 @@ config ARCH_SUPPORTS_UPROBES
 config ARCH_PROC_KCORE_TEXT
 	def_bool y
 
-config MULTI_IRQ_HANDLER
-	def_bool y
-
 source "init/Kconfig"
 
 source "kernel/Kconfig.freezer"
diff --git a/arch/arm64/boot/.gitignore b/arch/arm64/boot/.gitignore
deleted file mode 100644
index 8dab0bb6..00000000
--- a/arch/arm64/boot/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-Image
-Image.gz
diff --git a/arch/arm64/crypto/.gitignore b/arch/arm64/crypto/.gitignore
deleted file mode 100644
index 879df878..00000000
--- a/arch/arm64/crypto/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-sha256-core.S
-sha512-core.S
diff --git a/arch/arm64/include/asm/irq.h b/arch/arm64/include/asm/irq.h
index a0fee698..b2b0c640 100644
--- a/arch/arm64/include/asm/irq.h
+++ b/arch/arm64/include/asm/irq.h
@@ -8,8 +8,6 @@
 
 struct pt_regs;
 
-extern void set_handle_irq(void (*handle_irq)(struct pt_regs *));
-
 static inline int nr_legacy_irqs(void)
 {
 	return 0;
diff --git a/arch/arm64/kernel/.gitignore b/arch/arm64/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/arm64/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/arm64/kernel/irq.c b/arch/arm64/kernel/irq.c
index 60e5fc66..780a12f5 100644
--- a/arch/arm64/kernel/irq.c
+++ b/arch/arm64/kernel/irq.c
@@ -42,16 +42,6 @@ int arch_show_interrupts(struct seq_file *p, int prec)
 	return 0;
 }
 
-void (*handle_arch_irq)(struct pt_regs *) = NULL;
-
-void __init set_handle_irq(void (*handle_irq)(struct pt_regs *))
-{
-	if (handle_arch_irq)
-		return;
-
-	handle_arch_irq = handle_irq;
-}
-
 #ifdef CONFIG_VMAP_STACK
 static void init_irq_stacks(void)
 {
diff --git a/arch/arm64/kernel/vdso/.gitignore b/arch/arm64/kernel/vdso/.gitignore
deleted file mode 100644
index f8b69d84..00000000
--- a/arch/arm64/kernel/vdso/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vdso.lds
diff --git a/arch/arm64/mm/dma-mapping.c b/arch/arm64/mm/dma-mapping.c
index a96ec018..db01f270 100644
--- a/arch/arm64/mm/dma-mapping.c
+++ b/arch/arm64/mm/dma-mapping.c
@@ -508,16 +508,6 @@ static int __init arm64_dma_init(void)
 }
 arch_initcall(arm64_dma_init);
 
-#define PREALLOC_DMA_DEBUG_ENTRIES	4096
-
-static int __init dma_debug_do_init(void)
-{
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
-	return 0;
-}
-fs_initcall(dma_debug_do_init);
-
-
 #ifdef CONFIG_IOMMU_DMA
 #include <linux/dma-iommu.h>
 #include <linux/platform_device.h>
diff --git a/arch/c6x/Kconfig b/arch/c6x/Kconfig
index c6b4dd14..8c088b96 100644
--- a/arch/c6x/Kconfig
+++ b/arch/c6x/Kconfig
@@ -10,7 +10,6 @@ config C6X
 	select GENERIC_ATOMIC64
 	select GENERIC_IRQ_SHOW
 	select HAVE_ARCH_TRACEHOOK
-	select HAVE_DMA_API_DEBUG
 	select HAVE_MEMBLOCK
 	select SPARSE_IRQ
 	select IRQ_DOMAIN
diff --git a/arch/c6x/kernel/dma.c b/arch/c6x/kernel/dma.c
index 9fff8be7..31e1a9ec 100644
--- a/arch/c6x/kernel/dma.c
+++ b/arch/c6x/kernel/dma.c
@@ -136,14 +136,3 @@ const struct dma_map_ops c6x_dma_ops = {
 	.sync_sg_for_cpu	= c6x_dma_sync_sg_for_cpu,
 };
 EXPORT_SYMBOL(c6x_dma_ops);
-
-/* Number of entries preallocated for DMA-API debugging */
-#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)
-
-static int __init dma_init(void)
-{
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
-
-	return 0;
-}
-fs_initcall(dma_init);
diff --git a/arch/ia64/Kconfig b/arch/ia64/Kconfig
index bbe12a03..2067289f 100644
--- a/arch/ia64/Kconfig
+++ b/arch/ia64/Kconfig
@@ -29,7 +29,6 @@ config IA64
 	select HAVE_FUNCTION_TRACER
 	select TTY
 	select HAVE_ARCH_TRACEHOOK
-	select HAVE_DMA_API_DEBUG
 	select HAVE_MEMBLOCK
 	select HAVE_MEMBLOCK_NODE_MAP
 	select HAVE_VIRT_CPU_ACCOUNTING
@@ -54,6 +53,8 @@ config IA64
 	select MODULES_USE_ELF_RELA
 	select ARCH_USE_CMPXCHG_LOCKREF
 	select HAVE_ARCH_AUDITSYSCALL
+	select NEED_DMA_MAP_STATE
+	select NEED_SG_DMA_LENGTH
 	default y
 	help
 	  The Itanium Processor Family is Intel's 64-bit successor to
@@ -78,18 +79,6 @@ config MMU
 	bool
 	default y
 
-config ARCH_DMA_ADDR_T_64BIT
-	def_bool y
-
-config NEED_DMA_MAP_STATE
-	def_bool y
-
-config NEED_SG_DMA_LENGTH
-	def_bool y
-
-config SWIOTLB
-       bool
-
 config STACKTRACE_SUPPORT
 	def_bool y
 
@@ -146,7 +135,6 @@ config IA64_GENERIC
 	bool "generic"
 	select NUMA
 	select ACPI_NUMA
-	select DMA_DIRECT_OPS
 	select SWIOTLB
 	select PCI_MSI
 	help
@@ -167,7 +155,6 @@ config IA64_GENERIC
 
 config IA64_DIG
 	bool "DIG-compliant"
-	select DMA_DIRECT_OPS
 	select SWIOTLB
 
 config IA64_DIG_VTD
@@ -183,7 +170,6 @@ config IA64_HP_ZX1
 
 config IA64_HP_ZX1_SWIOTLB
 	bool "HP-zx1/sx1000 with software I/O TLB"
-	select DMA_DIRECT_OPS
 	select SWIOTLB
 	help
 	  Build a kernel that runs on HP zx1 and sx1000 systems even when they
@@ -207,7 +193,6 @@ config IA64_SGI_UV
 	bool "SGI-UV"
 	select NUMA
 	select ACPI_NUMA
-	select DMA_DIRECT_OPS
 	select SWIOTLB
 	help
 	  Selecting this option will optimize the kernel for use on UV based
@@ -218,7 +203,6 @@ config IA64_SGI_UV
 
 config IA64_HP_SIM
 	bool "Ski-simulator"
-	select DMA_DIRECT_OPS
 	select SWIOTLB
 	depends on !PM
 
@@ -613,6 +597,3 @@ source "security/Kconfig"
 source "crypto/Kconfig"
 
 source "lib/Kconfig"
-
-config IOMMU_HELPER
-	def_bool (IA64_HP_ZX1 || IA64_HP_ZX1_SWIOTLB || IA64_GENERIC || SWIOTLB)
diff --git a/arch/ia64/kernel/.gitignore b/arch/ia64/kernel/.gitignore
deleted file mode 100644
index 21cb0da5..00000000
--- a/arch/ia64/kernel/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-gate.lds
-vmlinux.lds
diff --git a/arch/ia64/kernel/dma-mapping.c b/arch/ia64/kernel/dma-mapping.c
index f2d57e66..7a471d8d 100644
--- a/arch/ia64/kernel/dma-mapping.c
+++ b/arch/ia64/kernel/dma-mapping.c
@@ -9,16 +9,6 @@ int iommu_detected __read_mostly;
 const struct dma_map_ops *dma_ops;
 EXPORT_SYMBOL(dma_ops);
 
-#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)
-
-static int __init dma_init(void)
-{
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
-
-	return 0;
-}
-fs_initcall(dma_init);
-
 const struct dma_map_ops *dma_get_ops(struct device *dev)
 {
 	return dma_ops;
diff --git a/arch/m68k/kernel/.gitignore b/arch/m68k/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/m68k/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/microblaze/Kconfig b/arch/microblaze/Kconfig
index 3817a3e2..d1478210 100644
--- a/arch/microblaze/Kconfig
+++ b/arch/microblaze/Kconfig
@@ -19,7 +19,6 @@ config MICROBLAZE
 	select HAVE_ARCH_HASH
 	select HAVE_ARCH_KGDB
 	select HAVE_DEBUG_KMEMLEAK
-	select HAVE_DMA_API_DEBUG
 	select HAVE_DYNAMIC_FTRACE
 	select HAVE_FTRACE_MCOUNT_RECORD
 	select HAVE_FUNCTION_GRAPH_TRACER
diff --git a/arch/microblaze/boot/.gitignore b/arch/microblaze/boot/.gitignore
deleted file mode 100644
index 679502d6..00000000
--- a/arch/microblaze/boot/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-linux.bin*
-simpleImage.*
diff --git a/arch/microblaze/kernel/.gitignore b/arch/microblaze/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/microblaze/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/microblaze/kernel/dma.c b/arch/microblaze/kernel/dma.c
index c91e8cef..3145e7dc 100644
--- a/arch/microblaze/kernel/dma.c
+++ b/arch/microblaze/kernel/dma.c
@@ -184,14 +184,3 @@ const struct dma_map_ops dma_nommu_ops = {
 	.sync_sg_for_device	= dma_nommu_sync_sg_for_device,
 };
 EXPORT_SYMBOL(dma_nommu_ops);
-
-/* Number of entries preallocated for DMA-API debugging */
-#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)
-
-static int __init dma_init(void)
-{
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
-
-	return 0;
-}
-fs_initcall(dma_init);
diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 225c95da..2dcdc13c 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -42,7 +42,6 @@ config MIPS
 	select HAVE_C_RECORDMCOUNT
 	select HAVE_DEBUG_KMEMLEAK
 	select HAVE_DEBUG_STACKOVERFLOW
-	select HAVE_DMA_API_DEBUG
 	select HAVE_DMA_CONTIGUOUS
 	select HAVE_DYNAMIC_FTRACE
 	select HAVE_EXIT_THREAD
@@ -132,7 +131,7 @@ config MIPS_GENERIC
 
 config MIPS_ALCHEMY
 	bool "Alchemy processor based machines"
-	select ARCH_PHYS_ADDR_T_64BIT
+	select PHYS_ADDR_T_64BIT
 	select CEVT_R4K
 	select CSRC_R4K
 	select IRQ_MIPS_CPU
@@ -890,7 +889,7 @@ config CAVIUM_OCTEON_SOC
 	bool "Cavium Networks Octeon SoC based boards"
 	select CEVT_R4K
 	select ARCH_HAS_PHYS_TO_DMA
-	select ARCH_PHYS_ADDR_T_64BIT
+	select PHYS_ADDR_T_64BIT
 	select DMA_COHERENT
 	select SYS_SUPPORTS_64BIT_KERNEL
 	select SYS_SUPPORTS_BIG_ENDIAN
@@ -912,6 +911,7 @@ config CAVIUM_OCTEON_SOC
 	select MIPS_NR_CPU_NR_MAP_1024
 	select BUILTIN_DTB
 	select MTD_COMPLEX_MAPPINGS
+	select SWIOTLB
 	select SYS_SUPPORTS_RELOCATABLE
 	help
 	  This option supports all of the Octeon reference boards from Cavium
@@ -936,7 +936,7 @@ config NLM_XLR_BOARD
 	select SWAP_IO_SPACE
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
-	select ARCH_PHYS_ADDR_T_64BIT
+	select PHYS_ADDR_T_64BIT
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select SYS_SUPPORTS_HIGHMEM
 	select DMA_COHERENT
@@ -962,7 +962,7 @@ config NLM_XLP_BOARD
 	select HW_HAS_PCI
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
-	select ARCH_PHYS_ADDR_T_64BIT
+	select PHYS_ADDR_T_64BIT
 	select GPIOLIB
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select SYS_SUPPORTS_LITTLE_ENDIAN
@@ -1101,9 +1101,6 @@ config GPIO_TXX9
 config FW_CFE
 	bool
 
-config ARCH_DMA_ADDR_T_64BIT
-	def_bool (HIGHMEM && ARCH_PHYS_ADDR_T_64BIT) || 64BIT
-
 config ARCH_SUPPORTS_UPROBES
 	bool
 
@@ -1122,9 +1119,6 @@ config DMA_NONCOHERENT
 	bool
 	select NEED_DMA_MAP_STATE
 
-config NEED_DMA_MAP_STATE
-	bool
-
 config SYS_HAS_EARLY_PRINTK
 	bool
 
@@ -1373,6 +1367,7 @@ config CPU_LOONGSON3
 	select MIPS_PGD_C0_CONTEXT
 	select MIPS_L1_CACHE_SHIFT_6
 	select GPIOLIB
+	select SWIOTLB
 	help
 		The Loongson 3 processor implements the MIPS64R2 instruction
 		set with many extensions.
@@ -1770,7 +1765,7 @@ config CPU_MIPS32_R5_XPA
 	depends on SYS_SUPPORTS_HIGHMEM
 	select XPA
 	select HIGHMEM
-	select ARCH_PHYS_ADDR_T_64BIT
+	select PHYS_ADDR_T_64BIT
 	default n
 	help
 	  Choose this option if you want to enable the Extended Physical
@@ -2402,9 +2397,6 @@ config SB1_PASS_2_1_WORKAROUNDS
 	default y
 
 
-config ARCH_PHYS_ADDR_T_64BIT
-       bool
-
 choice
 	prompt "SmartMIPS or microMIPS ASE support"
 
diff --git a/arch/mips/boot/.gitignore b/arch/mips/boot/.gitignore
deleted file mode 100644
index a73d6e2c..00000000
--- a/arch/mips/boot/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-mkboot
-elf2ecoff
-vmlinux.*
-zImage
-zImage.tmp
-calc_vmlinuz_load_addr
-uImage
diff --git a/arch/mips/boot/compressed/.gitignore b/arch/mips/boot/compressed/.gitignore
deleted file mode 100644
index ebae133f..00000000
--- a/arch/mips/boot/compressed/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-ashldi3.c
-bswapsi.c
diff --git a/arch/mips/boot/tools/.gitignore b/arch/mips/boot/tools/.gitignore
deleted file mode 100644
index be0ed065..00000000
--- a/arch/mips/boot/tools/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-relocs
diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index b5eee1a5..4984e462 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -67,18 +67,6 @@ config CAVIUM_OCTEON_LOCK_L2_MEMCPY
 	help
 	  Lock the kernel's implementation of memcpy() into L2.
 
-config IOMMU_HELPER
-	bool
-
-config NEED_SG_DMA_LENGTH
-	bool
-
-config SWIOTLB
-	def_bool y
-	select DMA_DIRECT_OPS
-	select IOMMU_HELPER
-	select NEED_SG_DMA_LENGTH
-
 config OCTEON_ILM
 	tristate "Module to measure interrupt latency using Octeon CIU Timer"
 	help
diff --git a/arch/mips/kernel/.gitignore b/arch/mips/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/mips/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/mips/loongson64/Kconfig b/arch/mips/loongson64/Kconfig
index 72af0c18..c79e6a56 100644
--- a/arch/mips/loongson64/Kconfig
+++ b/arch/mips/loongson64/Kconfig
@@ -130,21 +130,6 @@ config LOONGSON_UART_BASE
 	default y
 	depends on EARLY_PRINTK || SERIAL_8250
 
-config IOMMU_HELPER
-	bool
-
-config NEED_SG_DMA_LENGTH
-	bool
-
-config SWIOTLB
-	bool "Soft IOMMU Support for All-Memory DMA"
-	default y
-	depends on CPU_LOONGSON3
-	select DMA_DIRECT_OPS
-	select IOMMU_HELPER
-	select NEED_SG_DMA_LENGTH
-	select NEED_DMA_MAP_STATE
-
 config PHYS48_TO_HT40
 	bool
 	default y if CPU_LOONGSON3
diff --git a/arch/mips/mm/dma-default.c b/arch/mips/mm/dma-default.c
index dcafa436..f9fef002 100644
--- a/arch/mips/mm/dma-default.c
+++ b/arch/mips/mm/dma-default.c
@@ -402,13 +402,3 @@ static const struct dma_map_ops mips_default_dma_map_ops = {
 
 const struct dma_map_ops *mips_dma_map_ops = &mips_default_dma_map_ops;
 EXPORT_SYMBOL(mips_dma_map_ops);
-
-#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)
-
-static int __init mips_dma_init(void)
-{
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
-
-	return 0;
-}
-fs_initcall(mips_dma_init);
diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index 7fcfc7fe..5c5ee0e0 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -83,9 +83,6 @@ endif
 config NLM_COMMON
 	bool
 
-config IOMMU_HELPER
-	bool
-
 config NEED_SG_DMA_LENGTH
 	bool
 
diff --git a/arch/mips/vdso/.gitignore b/arch/mips/vdso/.gitignore
deleted file mode 100644
index 5286a7d7..00000000
--- a/arch/mips/vdso/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-*.so*
-vdso-*image.c
-genvdso
-vdso*.lds
diff --git a/arch/nds32/Kconfig b/arch/nds32/Kconfig
index b7404f2d..34f7222c 100644
--- a/arch/nds32/Kconfig
+++ b/arch/nds32/Kconfig
@@ -5,21 +5,24 @@
 
 config NDS32
         def_bool y
+	select ARCH_HAS_SYNC_DMA_FOR_CPU
+	select ARCH_HAS_SYNC_DMA_FOR_DEVICE
 	select ARCH_WANT_FRAME_POINTERS if FTRACE
 	select CLKSRC_MMIO
 	select CLONE_BACKWARDS
 	select COMMON_CLK
-	select GENERIC_ASHLDI3
-	select GENERIC_ASHRDI3
-	select GENERIC_LSHRDI3
-	select GENERIC_CMPDI2
-	select GENERIC_MULDI3
-	select GENERIC_UCMPDI2
+	select DMA_NONCOHERENT_OPS
 	select GENERIC_ATOMIC64
 	select GENERIC_CPU_DEVICES
 	select GENERIC_CLOCKEVENTS
 	select GENERIC_IRQ_CHIP
 	select GENERIC_IRQ_SHOW
+	select GENERIC_LIB_ASHLDI3
+	select GENERIC_LIB_ASHRDI3
+	select GENERIC_LIB_CMPDI2
+	select GENERIC_LIB_LSHRDI3
+	select GENERIC_LIB_MULDI3
+	select GENERIC_LIB_UCMPDI2
 	select GENERIC_STRNCPY_FROM_USER
 	select GENERIC_STRNLEN_USER
 	select GENERIC_TIME_VSYSCALL
diff --git a/arch/nds32/include/asm/Kbuild b/arch/nds32/include/asm/Kbuild
index 142e612a..6f5cc29e 100644
--- a/arch/nds32/include/asm/Kbuild
+++ b/arch/nds32/include/asm/Kbuild
@@ -13,6 +13,7 @@ generic-y += cputime.h
 generic-y += device.h
 generic-y += div64.h
 generic-y += dma.h
+generic-y += dma-mapping.h
 generic-y += emergency-restart.h
 generic-y += errno.h
 generic-y += exec.h
diff --git a/arch/nds32/include/asm/dma-mapping.h b/arch/nds32/include/asm/dma-mapping.h
deleted file mode 100644
index 2dd47d24..00000000
--- a/arch/nds32/include/asm/dma-mapping.h
+++ /dev/null
@@ -1,14 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-// Copyright (C) 2005-2017 Andes Technology Corporation
-
-#ifndef ASMNDS32_DMA_MAPPING_H
-#define ASMNDS32_DMA_MAPPING_H
-
-extern struct dma_map_ops nds32_dma_ops;
-
-static inline struct dma_map_ops *get_arch_dma_ops(struct bus_type *bus)
-{
-	return &nds32_dma_ops;
-}
-
-#endif
diff --git a/arch/nds32/kernel/dma.c b/arch/nds32/kernel/dma.c
index d291800f..d0dbd4fe 100644
--- a/arch/nds32/kernel/dma.c
+++ b/arch/nds32/kernel/dma.c
@@ -3,17 +3,14 @@
 
 #include <linux/types.h>
 #include <linux/mm.h>
-#include <linux/export.h>
 #include <linux/string.h>
-#include <linux/scatterlist.h>
-#include <linux/dma-mapping.h>
+#include <linux/dma-noncoherent.h>
 #include <linux/io.h>
 #include <linux/cache.h>
 #include <linux/highmem.h>
 #include <linux/slab.h>
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
-#include <asm/dma-mapping.h>
 #include <asm/proc-fns.h>
 
 /*
@@ -22,11 +19,6 @@
 static pte_t *consistent_pte;
 static DEFINE_RAW_SPINLOCK(consistent_lock);
 
-enum master_type {
-	FOR_CPU = 0,
-	FOR_DEVICE = 1,
-};
-
 /*
  * VM region handling support.
  *
@@ -124,10 +116,8 @@ static struct arch_vm_region *vm_region_find(struct arch_vm_region *head,
 	return c;
 }
 
-/* FIXME: attrs is not used. */
-static void *nds32_dma_alloc_coherent(struct device *dev, size_t size,
-				      dma_addr_t * handle, gfp_t gfp,
-				      unsigned long attrs)
+void *arch_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
+		gfp_t gfp, unsigned long attrs)
 {
 	struct page *page;
 	struct arch_vm_region *c;
@@ -232,8 +222,8 @@ static void *nds32_dma_alloc_coherent(struct device *dev, size_t size,
 	return NULL;
 }
 
-static void nds32_dma_free(struct device *dev, size_t size, void *cpu_addr,
-			   dma_addr_t handle, unsigned long attrs)
+void arch_dma_free(struct device *dev, size_t size, void *cpu_addr,
+		dma_addr_t handle, unsigned long attrs)
 {
 	struct arch_vm_region *c;
 	unsigned long flags, addr;
@@ -333,145 +323,69 @@ static int __init consistent_init(void)
 }
 
 core_initcall(consistent_init);
-static void consistent_sync(void *vaddr, size_t size, int direction, int master_type);
-static dma_addr_t nds32_dma_map_page(struct device *dev, struct page *page,
-				     unsigned long offset, size_t size,
-				     enum dma_data_direction dir,
-				     unsigned long attrs)
-{
-	if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))
-		consistent_sync((void *)(page_address(page) + offset), size, dir, FOR_DEVICE);
-	return page_to_phys(page) + offset;
-}
-
-static void nds32_dma_unmap_page(struct device *dev, dma_addr_t handle,
-				 size_t size, enum dma_data_direction dir,
-				 unsigned long attrs)
-{
-	if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))
-		consistent_sync(phys_to_virt(handle), size, dir, FOR_CPU);
-}
-
-/*
- * Make an area consistent for devices.
- */
-static void consistent_sync(void *vaddr, size_t size, int direction, int master_type)
-{
-	unsigned long start = (unsigned long)vaddr;
-	unsigned long end = start + size;
-
-	if (master_type == FOR_CPU) {
-		switch (direction) {
-		case DMA_TO_DEVICE:
-			break;
-		case DMA_FROM_DEVICE:
-		case DMA_BIDIRECTIONAL:
-			cpu_dma_inval_range(start, end);
-			break;
-		default:
-			BUG();
-		}
-	} else {
-		/* FOR_DEVICE */
-		switch (direction) {
-		case DMA_FROM_DEVICE:
-			break;
-		case DMA_TO_DEVICE:
-		case DMA_BIDIRECTIONAL:
-			cpu_dma_wb_range(start, end);
-			break;
-		default:
-			BUG();
-		}
-	}
-}
 
-static int nds32_dma_map_sg(struct device *dev, struct scatterlist *sg,
-			    int nents, enum dma_data_direction dir,
-			    unsigned long attrs)
+static inline void cache_op(phys_addr_t paddr, size_t size,
+		void (*fn)(unsigned long start, unsigned long end))
 {
-	int i;
+	struct page *page = pfn_to_page(paddr >> PAGE_SHIFT);
+	unsigned offset = paddr & ~PAGE_MASK;
+	size_t left = size;
+	unsigned long start;
 
-	for (i = 0; i < nents; i++, sg++) {
-		void *virt;
-		unsigned long pfn;
-		struct page *page = sg_page(sg);
+	do {
+		size_t len = left;
 
-		sg->dma_address = sg_phys(sg);
-		pfn = page_to_pfn(page) + sg->offset / PAGE_SIZE;
-		page = pfn_to_page(pfn);
 		if (PageHighMem(page)) {
-			virt = kmap_atomic(page);
-			consistent_sync(virt, sg->length, dir, FOR_CPU);
-			kunmap_atomic(virt);
+			void *addr;
+
+			if (offset + len > PAGE_SIZE) {
+				if (offset >= PAGE_SIZE) {
+					page += offset >> PAGE_SHIFT;
+					offset &= ~PAGE_MASK;
+				}
+				len = PAGE_SIZE - offset;
+			}
+
+			addr = kmap_atomic(page);
+			start = (unsigned long)(addr + offset);
+			fn(start, start + len);
+			kunmap_atomic(addr);
 		} else {
-			if (sg->offset > PAGE_SIZE)
-				panic("sg->offset:%08x > PAGE_SIZE\n",
-				      sg->offset);
-			virt = page_address(page) + sg->offset;
-			consistent_sync(virt, sg->length, dir, FOR_CPU);
+			start = (unsigned long)phys_to_virt(paddr);
+			fn(start, start + size);
 		}
-	}
-	return nents;
+		offset = 0;
+		page++;
+		left -= len;
+	} while (left);
 }
 
-static void nds32_dma_unmap_sg(struct device *dev, struct scatterlist *sg,
-			       int nhwentries, enum dma_data_direction dir,
-			       unsigned long attrs)
+void arch_sync_dma_for_device(struct device *dev, phys_addr_t paddr,
+		size_t size, enum dma_data_direction dir)
 {
-}
-
-static void
-nds32_dma_sync_single_for_cpu(struct device *dev, dma_addr_t handle,
-			      size_t size, enum dma_data_direction dir)
-{
-	consistent_sync((void *)phys_to_virt(handle), size, dir, FOR_CPU);
-}
-
-static void
-nds32_dma_sync_single_for_device(struct device *dev, dma_addr_t handle,
-				 size_t size, enum dma_data_direction dir)
-{
-	consistent_sync((void *)phys_to_virt(handle), size, dir, FOR_DEVICE);
-}
-
-static void
-nds32_dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg, int nents,
-			  enum dma_data_direction dir)
-{
-	int i;
-
-	for (i = 0; i < nents; i++, sg++) {
-		char *virt =
-		    page_address((struct page *)sg->page_link) + sg->offset;
-		consistent_sync(virt, sg->length, dir, FOR_CPU);
+	switch (dir) {
+	case DMA_FROM_DEVICE:
+		break;
+	case DMA_TO_DEVICE:
+	case DMA_BIDIRECTIONAL:
+		cache_op(paddr, size, cpu_dma_wb_range);
+		break;
+	default:
+		BUG();
 	}
 }
 
-static void
-nds32_dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
-			     int nents, enum dma_data_direction dir)
+void arch_sync_dma_for_cpu(struct device *dev, phys_addr_t paddr,
+		size_t size, enum dma_data_direction dir)
 {
-	int i;
-
-	for (i = 0; i < nents; i++, sg++) {
-		char *virt =
-		    page_address((struct page *)sg->page_link) + sg->offset;
-		consistent_sync(virt, sg->length, dir, FOR_DEVICE);
+	switch (dir) {
+	case DMA_TO_DEVICE:
+		break;
+	case DMA_FROM_DEVICE:
+	case DMA_BIDIRECTIONAL:
+		cache_op(paddr, size, cpu_dma_inval_range);
+		break;
+	default:
+		BUG();
 	}
 }
-
-struct dma_map_ops nds32_dma_ops = {
-	.alloc = nds32_dma_alloc_coherent,
-	.free = nds32_dma_free,
-	.map_page = nds32_dma_map_page,
-	.unmap_page = nds32_dma_unmap_page,
-	.map_sg = nds32_dma_map_sg,
-	.unmap_sg = nds32_dma_unmap_sg,
-	.sync_single_for_device = nds32_dma_sync_single_for_device,
-	.sync_single_for_cpu = nds32_dma_sync_single_for_cpu,
-	.sync_sg_for_cpu = nds32_dma_sync_sg_for_cpu,
-	.sync_sg_for_device = nds32_dma_sync_sg_for_device,
-};
-
-EXPORT_SYMBOL(nds32_dma_ops);
diff --git a/arch/nios2/boot/.gitignore b/arch/nios2/boot/.gitignore
deleted file mode 100644
index 64386a8d..00000000
--- a/arch/nios2/boot/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmImage
diff --git a/arch/nios2/kernel/.gitignore b/arch/nios2/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/nios2/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/openrisc/Kconfig b/arch/openrisc/Kconfig
index 9ecad05b..dfb6a79b 100644
--- a/arch/openrisc/Kconfig
+++ b/arch/openrisc/Kconfig
@@ -27,7 +27,6 @@ config OPENRISC
 	select GENERIC_STRNLEN_USER
 	select GENERIC_SMP_IDLE_THREAD
 	select MODULES_USE_ELF_RELA
-	select MULTI_IRQ_HANDLER
 	select HAVE_DEBUG_STACKOVERFLOW
 	select OR1K_PIC
 	select CPU_NO_EFFICIENT_FFS if !OPENRISC_HAVE_INST_FF1
@@ -36,6 +35,7 @@ config OPENRISC
 	select ARCH_USE_QUEUED_RWLOCKS
 	select OMPIC if SMP
 	select ARCH_WANT_FRAME_POINTERS
+	select GENERIC_IRQ_MULTI_HANDLER
 
 config CPU_BIG_ENDIAN
 	def_bool y
@@ -69,9 +69,6 @@ config STACKTRACE_SUPPORT
 config LOCKDEP_SUPPORT
 	def_bool  y
 
-config MULTI_IRQ_HANDLER
-	def_bool y
-
 source "init/Kconfig"
 
 source "kernel/Kconfig.freezer"
diff --git a/arch/openrisc/include/asm/irq.h b/arch/openrisc/include/asm/irq.h
index d9eee0a2..eb612b18 100644
--- a/arch/openrisc/include/asm/irq.h
+++ b/arch/openrisc/include/asm/irq.h
@@ -24,6 +24,4 @@
 
 #define NO_IRQ		(-1)
 
-extern void set_handle_irq(void (*handle_irq)(struct pt_regs *));
-
 #endif /* __ASM_OPENRISC_IRQ_H__ */
diff --git a/arch/openrisc/kernel/.gitignore b/arch/openrisc/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/openrisc/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/openrisc/kernel/dma.c b/arch/openrisc/kernel/dma.c
index a945f000..ec7fd457 100644
--- a/arch/openrisc/kernel/dma.c
+++ b/arch/openrisc/kernel/dma.c
@@ -247,14 +247,3 @@ const struct dma_map_ops or1k_dma_map_ops = {
 	.sync_single_for_device = or1k_sync_single_for_device,
 };
 EXPORT_SYMBOL(or1k_dma_map_ops);
-
-/* Number of entries preallocated for DMA-API debugging */
-#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)
-
-static int __init dma_init(void)
-{
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
-
-	return 0;
-}
-fs_initcall(dma_init);
diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
index 35e478a9..5f9445ef 100644
--- a/arch/openrisc/kernel/irq.c
+++ b/arch/openrisc/kernel/irq.c
@@ -41,13 +41,6 @@ void __init init_IRQ(void)
 	irqchip_init();
 }
 
-static void (*handle_arch_irq)(struct pt_regs *);
-
-void __init set_handle_irq(void (*handle_irq)(struct pt_regs *))
-{
-	handle_arch_irq = handle_irq;
-}
-
 void __irq_entry do_IRQ(struct pt_regs *regs)
 {
 	handle_arch_irq(regs);
diff --git a/arch/parisc/Kconfig b/arch/parisc/Kconfig
index fc5a574c..4d8f64d4 100644
--- a/arch/parisc/Kconfig
+++ b/arch/parisc/Kconfig
@@ -51,6 +51,8 @@ config PARISC
 	select GENERIC_CLOCKEVENTS
 	select ARCH_NO_COHERENT_DMA_MMAP
 	select CPU_NO_EFFICIENT_FFS
+	select NEED_DMA_MAP_STATE
+	select NEED_SG_DMA_LENGTH
 
 	help
 	  The PA-RISC microprocessor is designed by Hewlett-Packard and used
@@ -111,12 +113,6 @@ config PM
 config STACKTRACE_SUPPORT
 	def_bool y
 
-config NEED_DMA_MAP_STATE
-	def_bool y
-
-config NEED_SG_DMA_LENGTH
-	def_bool y
-
 config ISA_DMA_API
 	bool
 
diff --git a/arch/parisc/boot/.gitignore b/arch/parisc/boot/.gitignore
deleted file mode 100644
index 017d5912..00000000
--- a/arch/parisc/boot/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-image
-bzImage
diff --git a/arch/parisc/boot/compressed/.gitignore b/arch/parisc/boot/compressed/.gitignore
deleted file mode 100644
index ae06b9b4..00000000
--- a/arch/parisc/boot/compressed/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-sizes.h
-vmlinux
-vmlinux.lds
diff --git a/arch/parisc/kernel/.gitignore b/arch/parisc/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/parisc/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index c32a181a..0087d885 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -13,12 +13,6 @@ config 64BIT
 	bool
 	default y if PPC64
 
-config ARCH_PHYS_ADDR_T_64BIT
-       def_bool PPC64 || PHYS_64BIT
-
-config ARCH_DMA_ADDR_T_64BIT
-	def_bool ARCH_PHYS_ADDR_T_64BIT
-
 config MMU
 	bool
 	default y
@@ -187,7 +181,6 @@ config PPC
 	select HAVE_CONTEXT_TRACKING		if PPC64
 	select HAVE_DEBUG_KMEMLEAK
 	select HAVE_DEBUG_STACKOVERFLOW
-	select HAVE_DMA_API_DEBUG
 	select HAVE_DYNAMIC_FTRACE
 	select HAVE_DYNAMIC_FTRACE_WITH_REGS	if MPROFILE_KERNEL
 	select HAVE_EBPF_JIT			if PPC64
@@ -223,6 +216,7 @@ config PPC
 	select HAVE_SYSCALL_TRACEPOINTS
 	select HAVE_VIRT_CPU_ACCOUNTING
 	select HAVE_IRQ_TIME_ACCOUNTING
+	select IOMMU_HELPER			if PPC64
 	select IRQ_DOMAIN
 	select IRQ_FORCED_THREADING
 	select MODULES_USE_ELF_RELA
@@ -478,19 +472,6 @@ config MPROFILE_KERNEL
 	depends on PPC64 && CPU_LITTLE_ENDIAN
 	def_bool !DISABLE_MPROFILE_KERNEL
 
-config IOMMU_HELPER
-	def_bool PPC64
-
-config SWIOTLB
-	bool "SWIOTLB support"
-	default n
-	select IOMMU_HELPER
-	---help---
-	  Support for IO bounce buffering for systems without an IOMMU.
-	  This allows us to DMA to the full physical address space on
-	  platforms where the size of a physical address is larger
-	  than the bus address.  Not all platforms support this.
-
 config HOTPLUG_CPU
 	bool "Support for enabling/disabling CPUs"
 	depends on SMP && (PPC_PSERIES || \
diff --git a/arch/powerpc/boot/.gitignore b/arch/powerpc/boot/.gitignore
deleted file mode 100644
index f92d0530..00000000
--- a/arch/powerpc/boot/.gitignore
+++ /dev/null
@@ -1,47 +0,0 @@
-addnote
-decompress_inflate.c
-empty.c
-hack-coff
-inffast.c
-inffast.h
-inffixed.h
-inflate.c
-inflate.h
-inftrees.c
-inftrees.h
-infutil.c
-infutil.h
-kernel-vmlinux.strip.c
-kernel-vmlinux.strip.gz
-mktree
-otheros.bld
-uImage
-cuImage.*
-dtbImage.*
-treeImage.*
-vmlinux.strip
-zImage
-zImage.initrd
-zImage.bin.*
-zImage.chrp
-zImage.coff
-zImage.epapr
-zImage.holly
-zImage.*lds
-zImage.maple
-zImage.miboot
-zImage.pmac
-zImage.pseries
-zconf.h
-zlib.h
-zutil.h
-fdt.c
-fdt.h
-fdt_ro.c
-fdt_rw.c
-fdt_strerror.c
-fdt_sw.c
-fdt_wip.c
-libfdt.h
-libfdt_internal.h
-
diff --git a/arch/powerpc/kernel/.gitignore b/arch/powerpc/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/powerpc/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/powerpc/kernel/dma.c b/arch/powerpc/kernel/dma.c
index da20569d..138157de 100644
--- a/arch/powerpc/kernel/dma.c
+++ b/arch/powerpc/kernel/dma.c
@@ -309,8 +309,6 @@ int dma_set_coherent_mask(struct device *dev, u64 mask)
 }
 EXPORT_SYMBOL(dma_set_coherent_mask);
 
-#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)
-
 int dma_set_mask(struct device *dev, u64 dma_mask)
 {
 	if (ppc_md.dma_set_mask)
@@ -361,7 +359,6 @@ EXPORT_SYMBOL_GPL(dma_get_required_mask);
 
 static int __init dma_init(void)
 {
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
 #ifdef CONFIG_PCI
 	dma_debug_add_bus(&pci_bus_type);
 #endif
diff --git a/arch/powerpc/kernel/vdso32/.gitignore b/arch/powerpc/kernel/vdso32/.gitignore
deleted file mode 100644
index fea58098..00000000
--- a/arch/powerpc/kernel/vdso32/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-vdso32.lds
-vdso32.so.dbg
diff --git a/arch/powerpc/kernel/vdso64/.gitignore b/arch/powerpc/kernel/vdso64/.gitignore
deleted file mode 100644
index 77a0b423..00000000
--- a/arch/powerpc/kernel/vdso64/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-vdso64.lds
-vdso64.so.dbg
diff --git a/arch/powerpc/platforms/Kconfig.cputype b/arch/powerpc/platforms/Kconfig.cputype
index 67d3125d..84b58abc 100644
--- a/arch/powerpc/platforms/Kconfig.cputype
+++ b/arch/powerpc/platforms/Kconfig.cputype
@@ -222,6 +222,7 @@ config PTE_64BIT
 config PHYS_64BIT
 	bool 'Large physical address support' if E500 || PPC_86xx
 	depends on (44x || E500 || PPC_86xx) && !PPC_83xx && !PPC_82xx
+	select PHYS_ADDR_T_64BIT
 	---help---
 	  This option enables kernel support for larger than 32-bit physical
 	  addresses.  This feature may not be available on all cores.
diff --git a/arch/powerpc/platforms/cell/spufs/.gitignore b/arch/powerpc/platforms/cell/spufs/.gitignore
deleted file mode 100644
index a09ee8d8..00000000
--- a/arch/powerpc/platforms/cell/spufs/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-spu_save_dump.h
-spu_restore_dump.h
diff --git a/arch/powerpc/purgatory/.gitignore b/arch/powerpc/purgatory/.gitignore
deleted file mode 100644
index e9e66f17..00000000
--- a/arch/powerpc/purgatory/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-kexec-purgatory.c
-purgatory.ro
diff --git a/arch/riscv/Kconfig b/arch/riscv/Kconfig
index cd4fd85f..e203b543 100644
--- a/arch/riscv/Kconfig
+++ b/arch/riscv/Kconfig
@@ -3,28 +3,41 @@
 # see Documentation/kbuild/kconfig-language.txt.
 #
 
+config 64BIT
+	bool
+
+config 32BIT
+	bool
+
 config RISCV
 	def_bool y
+	# even on 32-bit, physical (and DMA) addresses are > 32-bits
+	select PHYS_ADDR_T_64BIT
 	select OF
 	select OF_EARLY_FLATTREE
 	select OF_IRQ
 	select ARCH_WANT_FRAME_POINTERS
+	select ARCH_SUPPORTS_INT128
 	select CLONE_BACKWARDS
 	select COMMON_CLK
 	select DMA_DIRECT_OPS
 	select GENERIC_CLOCKEVENTS
-	select GENERIC_CPU_DEVICES
 	select GENERIC_IRQ_SHOW
 	select GENERIC_PCI_IOMAP
 	select GENERIC_STRNCPY_FROM_USER
 	select GENERIC_STRNLEN_USER
+	select GENERIC_SCHED_CLOCK
 	select GENERIC_SMP_IDLE_THREAD
 	select GENERIC_ATOMIC64 if !64BIT || !RISCV_ISA_A
+	select HAVE_ARCH_SECCOMP_FILTER
 	select HAVE_MEMBLOCK
 	select HAVE_MEMBLOCK_NODE_MAP
-	select HAVE_DMA_API_DEBUG
 	select HAVE_DMA_CONTIGUOUS
+	# XXX: needs a proper implementation for SMP
+	select HAVE_FUTEX_CMPXCHG if !SMP
 	select HAVE_GENERIC_DMA_COHERENT
+	select HAVE_PERF_EVENTS
+	select ARCH_BINFMT_ELF_STATE
 	select IRQ_DOMAIN
 	select NO_BOOTMEM
 	select RISCV_ISA_A if SMP
@@ -35,21 +48,29 @@ config RISCV
 	select THREAD_INFO_IN_TASK
 	select RISCV_TIMER
 	select GENERIC_IRQ_MULTI_HANDLER
+	select MODULE_SECTIONS if MODULES
+	select GENERIC_STRNCPY_FROM_USER if KASAN
+	select HAVE_ARCH_KASAN if MMU
+	select SWIOTLB
 
-config MMU
+config CPU_FREQ
 	def_bool y
 
-# even on 32-bit, physical (and DMA) addresses are > 32-bits
-config ARCH_PHYS_ADDR_T_64BIT
+config CPU_FREQ_GOV_POWERSAVE
 	def_bool y
+	depends on CPU_FREQ
 
-config ZONE_DMA32
-	bool
-	default y
+config CPU_FREQ_DEFAULT_GOV_POWERSAVE
+	def_bool y
+	depends on CPU_FREQ
 
-config ARCH_DMA_ADDR_T_64BIT
+config MMU
 	def_bool y
 
+config ZONE_DMA32
+	bool
+	default y if 64BIT
+
 config PAGE_OFFSET
 	hex
 	default 0xC0000000 if 32BIT && MAXPHYSMEM_2GB
@@ -65,6 +86,14 @@ config TRACE_IRQFLAGS_SUPPORT
 config RWSEM_GENERIC_SPINLOCK
 	def_bool y
 
+config HOTPLUG_CPU
+	def_bool y
+	depends on SMP
+
+config GENERIC_IRQ_MIGRATION
+	def_bool y
+	depends on SMP
+
 config GENERIC_BUG
 	def_bool y
 	depends on BUG
@@ -101,15 +130,19 @@ choice
 
 config ARCH_RV32I
 	bool "RV32I"
-	select CPU_SUPPORTS_32BIT_KERNEL
 	select 32BIT
 	select GENERIC_ASHLDI3
 	select GENERIC_ASHRDI3
 	select GENERIC_LSHRDI3
+	select GENERIC_UCMPDI2
+	select GENERIC_UMODDI3
+	select DMA_NONCOHERENT_OPS
+	select ARCH_HAS_SYNC_DMA_FOR_CPU
+        select ARCH_HAS_SYNC_DMA_FOR_DEVICE
+
 
 config ARCH_RV64I
 	bool "RV64I"
-	select CPU_SUPPORTS_64BIT_KERNEL
 	select 64BIT
 	select HAVE_FUNCTION_TRACER
 	select HAVE_FUNCTION_GRAPH_TRACER
@@ -147,7 +180,6 @@ choice
 		bool "2GiB"
 	config MAXPHYSMEM_128GB
 		depends on 64BIT && CMODEL_MEDANY
-		select MODULE_SECTIONS if MODULES
 		bool "128GiB"
 endchoice
 
@@ -171,11 +203,6 @@ config NR_CPUS
 	depends on SMP
 	default "8"
 
-config CPU_SUPPORTS_32BIT_KERNEL
-	bool
-config CPU_SUPPORTS_64BIT_KERNEL
-	bool
-
 choice
 	prompt "CPU Tuning"
 	default TUNE_GENERIC
@@ -198,27 +225,68 @@ config RISCV_ISA_C
 config RISCV_ISA_A
 	def_bool y
 
-endmenu
+choice
+	prompt "supported PMU type"
+	depends on PERF_EVENTS
+	default RISCV_BASE_PMU
 
-menu "Kernel type"
+config RISCV_BASE_PMU
+	bool "Base Performance Monitoring Unit"
+	help
+	  A base PMU that serves as a reference implementation and has limited
+	  feature of perf.  It can run on any RISC-V machines so serves as the
+	  fallback, but this option can also be disable to reduce kernel size.
 
-choice
-	prompt "Kernel code model"
-	default 64BIT
+config ANDES_PMU
+	bool "ANDES Performance Monitoring Unit"
+	help
+	  Andes PMU provide extension registers for Performance counter.
+endchoice
 
-config 32BIT
-	bool "32-bit kernel"
-	depends on CPU_SUPPORTS_32BIT_KERNEL
+config DSP
+       bool "DSP support"
+       default y
+       help
+         Say N here if you want to disable DSP support
+
+config FPU
+	bool "FPU support"
+	default y
 	help
-	  Select this option to build a 32-bit kernel.
+	  Say N here if you want to disable all floating-point related procedure
+	  in the kernel.
+	  If you don't know what to do here, say Y.
 
-config 64BIT
-	bool "64-bit kernel"
-	depends on CPU_SUPPORTS_64BIT_KERNEL
+config HIGHMEM
+    bool "High Memory Support"
+	default n
+    help
+      The address space of Andes A25MP processors is only 4 Gigabytes large
+      and it has to accommodate user address space, kernel address
+      space as well as some memory mapped IO. That means that, if you
+      have a large amount of physical memory and/or IO, not all of the
+      memory can be "permanently mapped" by the kernel. The physical
+      memory that is not permanently mapped is called "high memory".
+
+      Depending on the selected kernel/user memory split, minimum
+      vmalloc space and actual amount of RAM, you may not need this
+      option which should result in a slightly faster kernel.
+
+      If unsure, say n.
+
+config PMA
+	bool "PMA support"
+	default y
 	help
-	  Select this option to build a 64-bit kernel.
+	  Since 27 series we have PMA support to control non-cacheable
+	  region.  It is transparent to user.  If you want to reduce
+	  marginal code size, say N.
 
-endchoice
+endmenu
+
+menu "Kernel type"
+
+source "arch/riscv/platforms/Kconfig"
 
 source "mm/Kconfig"
 
@@ -240,6 +308,19 @@ config PCI
 
 	  If you don't know what to do here, say Y.
 
+config PCI_DMA_32
+	bool "Support broken PCIe controllers"
+	depends on PCI
+	default PCIE_XILINX
+	help
+	  If you use a PCIe host controller which can only address 32 bits,
+	  enabling this option will cause all DMA to use the low 32 bits.
+
+	  These controllers then work, but hurt system performance.
+
+	  If you don't know what to do here, say N.
+
+
 config PCI_DOMAINS
 	def_bool PCI
 
@@ -261,7 +342,8 @@ source "fs/Kconfig.binfmt"
 endmenu
 
 menu "Power management options"
-
+config ARCH_SUSPEND_POSSIBLE
+	def_bool y
 source kernel/power/Kconfig
 
 endmenu
@@ -308,6 +390,22 @@ config CMDLINE_FORCE
 
 	  If you don't know what to do here, say N.
 
+config SECCOMP
+	bool
+	prompt "Enable seccomp to safely compute untrusted bytecode"
+	---help---
+	  This kernel feature is useful for number crunching applications
+	  that may need to compute untrusted bytecode during their
+	  execution. By using pipes or other transports made available to
+	  the process as file descriptors supporting the read/write
+	  syscalls, it's possible to isolate those applications in
+	  their own address space using seccomp. Once seccomp is
+	  enabled via prctl(PR_SET_SECCOMP), it cannot be disabled
+	  and the task is only allowed to execute a few safe syscalls
+	  defined by each seccomp mode.
+
+	  If unsure, say Y. Only embedded should say N here.
+
 config EARLY_PRINTK
 	def_bool y
 
diff --git a/arch/riscv/Kconfig-upstream b/arch/riscv/Kconfig-upstream
new file mode 100644
index 00000000..a25da2b9
--- /dev/null
+++ b/arch/riscv/Kconfig-upstream
@@ -0,0 +1,397 @@
+#
+# For a description of the syntax of this configuration file,
+# see Documentation/kbuild/kconfig-language.txt.
+#
+
+config 64BIT
+	bool
+
+config 32BIT
+	bool
+
+config RISCV
+	def_bool y
+	# even on 32-bit, physical (and DMA) addresses are > 32-bits
+	select PHYS_ADDR_T_64BIT
+	select OF
+	select OF_EARLY_FLATTREE
+	select OF_IRQ
+	select ARCH_WANT_FRAME_POINTERS
+	select ARCH_SUPPORTS_INT128
+	select CLONE_BACKWARDS
+	select COMMON_CLK
+	select DMA_DIRECT_OPS
+	select GENERIC_CLOCKEVENTS
+	select GENERIC_IRQ_SHOW
+	select GENERIC_PCI_IOMAP
+	select GENERIC_STRNCPY_FROM_USER
+	select GENERIC_STRNLEN_USER
+	select GENERIC_SCHED_CLOCK
+	select GENERIC_SMP_IDLE_THREAD
+	select GENERIC_ATOMIC64 if !64BIT || !RISCV_ISA_A
+	select HAVE_ARCH_SECCOMP_FILTER
+	select HAVE_MEMBLOCK
+	select HAVE_MEMBLOCK_NODE_MAP
+	select HAVE_DMA_CONTIGUOUS
+	# XXX: needs a proper implementation for SMP
+	select HAVE_FUTEX_CMPXCHG if !SMP
+	select HAVE_GENERIC_DMA_COHERENT
+	#select HAVE_PERF_EVENTS
+	select ARCH_BINFMT_ELF_STATE
+	select IRQ_DOMAIN
+	select NO_BOOTMEM
+	select RISCV_ISA_A if SMP
+	select SPARSE_IRQ
+	select SYSCTL_EXCEPTION_TRACE
+	select HAVE_ARCH_TRACEHOOK
+	select MODULES_USE_ELF_RELA if MODULES
+	select THREAD_INFO_IN_TASK
+	select RISCV_TIMER
+	select GENERIC_IRQ_MULTI_HANDLER
+	select MODULE_SECTIONS if MODULES
+	select GENERIC_STRNCPY_FROM_USER if KASAN
+	select HAVE_ARCH_KASAN if MMU
+
+config CPU_FREQ
+	def_bool y
+
+config CPU_FREQ_GOV_POWERSAVE
+	def_bool y
+	depends on CPU_FREQ
+
+config CPU_FREQ_DEFAULT_GOV_POWERSAVE
+	def_bool y
+	depends on CPU_FREQ
+
+config MMU
+	def_bool y
+
+config ZONE_DMA32
+	bool
+	default y if 64BIT
+
+config PAGE_OFFSET
+	hex
+	default 0xC0000000 if 32BIT && MAXPHYSMEM_2GB
+	default 0xffffffff80000000 if 64BIT && MAXPHYSMEM_2GB
+	default 0xffffffe000000000 if 64BIT && MAXPHYSMEM_128GB
+
+config STACKTRACE_SUPPORT
+	def_bool y
+
+config TRACE_IRQFLAGS_SUPPORT
+	def_bool y
+
+config RWSEM_GENERIC_SPINLOCK
+	def_bool y
+
+config HOTPLUG_CPU
+	def_bool y
+	depends on SMP
+
+config GENERIC_IRQ_MIGRATION
+	def_bool y
+	depends on SMP
+
+config GENERIC_BUG
+	def_bool y
+	depends on BUG
+	select GENERIC_BUG_RELATIVE_POINTERS if 64BIT
+
+config GENERIC_BUG_RELATIVE_POINTERS
+	bool
+
+config GENERIC_CALIBRATE_DELAY
+	def_bool y
+
+config GENERIC_CSUM
+	def_bool y
+
+config GENERIC_HWEIGHT
+	def_bool y
+
+config PGTABLE_LEVELS
+	int
+	default 3 if 64BIT
+	default 2
+
+config HAVE_KPROBES
+	def_bool n
+
+menu "Platform type"
+
+choice
+	prompt "Base ISA"
+	default ARCH_RV64I
+	help
+	  This selects the base ISA that this kernel will traget and must match
+	  the target platform.
+
+config ARCH_RV32I
+	bool "RV32I"
+	select 32BIT
+	select GENERIC_ASHLDI3
+	select GENERIC_ASHRDI3
+	select GENERIC_LSHRDI3
+	select GENERIC_UCMPDI2
+	select GENERIC_UMODDI3
+	select DMA_NONCOHERENT_OPS
+	select ARCH_HAS_SYNC_DMA_FOR_CPU
+        select ARCH_HAS_SYNC_DMA_FOR_DEVICE
+
+
+config ARCH_RV64I
+	bool "RV64I"
+	select 64BIT
+	select HAVE_FUNCTION_TRACER
+	select HAVE_FUNCTION_GRAPH_TRACER
+	select HAVE_FTRACE_MCOUNT_RECORD
+	select HAVE_DYNAMIC_FTRACE
+	select HAVE_DYNAMIC_FTRACE_WITH_REGS
+	select SWIOTLB
+
+endchoice
+
+# We must be able to map all physical memory into the kernel, but the compiler
+# is still a bit more efficient when generating code if it's setup in a manner
+# such that it can only map 2GiB of memory.
+choice
+	prompt "Kernel Code Model"
+	default CMODEL_MEDLOW if 32BIT
+	default CMODEL_MEDANY if 64BIT
+
+	config CMODEL_MEDLOW
+		bool "medium low code model"
+	config CMODEL_MEDANY
+		bool "medium any code model"
+endchoice
+
+config MODULE_SECTIONS
+	bool
+	select HAVE_MOD_ARCH_SPECIFIC
+
+choice
+	prompt "Maximum Physical Memory"
+	default MAXPHYSMEM_2GB if 32BIT
+	default MAXPHYSMEM_2GB if 64BIT && CMODEL_MEDLOW
+	default MAXPHYSMEM_128GB if 64BIT && CMODEL_MEDANY
+
+	config MAXPHYSMEM_2GB
+		bool "2GiB"
+	config MAXPHYSMEM_128GB
+		depends on 64BIT && CMODEL_MEDANY
+		bool "128GiB"
+endchoice
+
+
+config SMP
+	bool "Symmetric Multi-Processing"
+	help
+	  This enables support for systems with more than one CPU.  If
+	  you say N here, the kernel will run on single and
+	  multiprocessor machines, but will use only one CPU of a
+	  multiprocessor machine. If you say Y here, the kernel will run
+	  on many, but not all, single processor machines. On a single
+	  processor machine, the kernel will run faster if you say N
+	  here.
+
+	  If you don't know what to do here, say N.
+
+config NR_CPUS
+	int "Maximum number of CPUs (2-32)"
+	range 2 32
+	depends on SMP
+	default "8"
+
+choice
+	prompt "CPU Tuning"
+	default TUNE_GENERIC
+
+config TUNE_GENERIC
+	bool "generic"
+
+endchoice
+
+config RISCV_ISA_C
+	bool "Emit compressed instructions when building Linux"
+	default y
+	help
+	   Adds "C" to the ISA subsets that the toolchain is allowed to emit
+	   when building Linux, which results in compressed instructions in the
+	   Linux binary.
+
+	   If you don't know what to do here, say Y.
+
+config RISCV_ISA_A
+	def_bool y
+
+choice
+	prompt "supported PMU type"
+	depends on PERF_EVENTS
+	default RISCV_BASE_PMU
+
+config RISCV_BASE_PMU
+	bool "Base Performance Monitoring Unit"
+	help
+	  A base PMU that serves as a reference implementation and has limited
+	  feature of perf.  It can run on any RISC-V machines so serves as the
+	  fallback, but this option can also be disable to reduce kernel size.
+
+config ANDES_PMU
+	bool "ANDES Performance Monitoring Unit"
+	help
+	  Andes PMU provide extension registers for Performance counter.
+endchoice
+
+config DSP
+       bool "DSP support"
+       default n
+       help
+         Say N here if you want to disable DSP support
+
+config FPU
+	bool "FPU support"
+	default n
+	help
+	  Say N here if you want to disable all floating-point related procedure
+	  in the kernel.
+	  If you don't know what to do here, say Y.
+
+endmenu
+
+menu "Kernel type"
+
+source "arch/riscv/platforms/Kconfig"
+
+source "mm/Kconfig"
+
+source "kernel/Kconfig.preempt"
+
+source "kernel/Kconfig.hz"
+
+endmenu
+
+menu "Bus support"
+
+config PCI
+	bool "PCI support"
+	select PCI_MSI
+	help
+	  This feature enables support for PCI bus system. If you say Y
+	  here, the kernel will include drivers and infrastructure code
+	  to support PCI bus devices.
+
+	  If you don't know what to do here, say Y.
+
+config PCI_DMA_32
+	bool "Support broken PCIe controllers"
+	depends on PCI
+	default PCIE_XILINX
+	help
+	  If you use a PCIe host controller which can only address 32 bits,
+	  enabling this option will cause all DMA to use the low 32 bits.
+
+	  These controllers then work, but hurt system performance.
+
+	  If you don't know what to do here, say N.
+
+
+config PCI_DOMAINS
+	def_bool PCI
+
+config PCI_DOMAINS_GENERIC
+	def_bool PCI
+
+source "drivers/pci/Kconfig"
+
+endmenu
+
+source "init/Kconfig"
+
+source "kernel/Kconfig.freezer"
+
+menu "Executable file formats"
+
+source "fs/Kconfig.binfmt"
+
+endmenu
+
+menu "Power management options"
+config ARCH_SUSPEND_POSSIBLE
+	def_bool y
+source kernel/power/Kconfig
+
+endmenu
+
+source "net/Kconfig"
+
+source "drivers/Kconfig"
+
+source "fs/Kconfig"
+
+menu "Kernel hacking"
+
+config CMDLINE_BOOL
+	bool "Built-in kernel command line"
+	help
+	  For most platforms, it is firmware or second stage bootloader
+	  that by default specifies the kernel command line options.
+	  However, it might be necessary or advantageous to either override
+	  the default kernel command line or add a few extra options to it.
+	  For such cases, this option allows hardcoding command line options
+	  directly into the kernel.
+
+	  For that, choose 'Y' here and fill in the extra boot parameters
+	  in CONFIG_CMDLINE.
+
+	  The built-in options will be concatenated to the default command
+	  line if CMDLINE_FORCE is set to 'N'. Otherwise, the default
+	  command line will be ignored and replaced by the built-in string.
+
+config CMDLINE
+	string "Built-in kernel command string"
+	depends on CMDLINE_BOOL
+	default ""
+	help
+	  Supply command-line options at build time by entering them here.
+
+config CMDLINE_FORCE
+	bool "Built-in command line overrides bootloader arguments"
+	depends on CMDLINE_BOOL
+	help
+	  Set this option to 'Y' to have the kernel ignore the bootloader
+	  or firmware command line.  Instead, the built-in command line
+	  will be used exclusively.
+
+	  If you don't know what to do here, say N.
+
+config SECCOMP
+	bool
+	prompt "Enable seccomp to safely compute untrusted bytecode"
+	---help---
+	  This kernel feature is useful for number crunching applications
+	  that may need to compute untrusted bytecode during their
+	  execution. By using pipes or other transports made available to
+	  the process as file descriptors supporting the read/write
+	  syscalls, it's possible to isolate those applications in
+	  their own address space using seccomp. Once seccomp is
+	  enabled via prctl(PR_SET_SECCOMP), it cannot be disabled
+	  and the task is only allowed to execute a few safe syscalls
+	  defined by each seccomp mode.
+
+	  If unsure, say Y. Only embedded should say N here.
+
+config EARLY_PRINTK
+	def_bool y
+
+source "lib/Kconfig.debug"
+
+config CMDLINE_BOOL
+	bool
+endmenu
+
+source "security/Kconfig"
+
+source "crypto/Kconfig"
+
+source "lib/Kconfig"
diff --git a/arch/riscv/Makefile b/arch/riscv/Makefile
index 76e958a5..a5c58079 100644
--- a/arch/riscv/Makefile
+++ b/arch/riscv/Makefile
@@ -8,11 +8,12 @@
 # for more details.
 #
 
-LDFLAGS         :=
 OBJCOPYFLAGS    := -O binary
 LDFLAGS_vmlinux :=
 ifeq ($(CONFIG_DYNAMIC_FTRACE),y)
 	LDFLAGS_vmlinux := --no-relax
+	KBUILD_CFLAGS += -mno-relax
+	KBUILD_AFLAGS += -mno-relax
 endif
 KBUILD_AFLAGS_MODULE += -fPIC
 KBUILD_CFLAGS_MODULE += -fPIC
@@ -26,30 +27,30 @@ ifeq ($(CONFIG_ARCH_RV64I),y)
 
 	KBUILD_CFLAGS += -mabi=lp64
 	KBUILD_AFLAGS += -mabi=lp64
-	KBUILD_MARCH = rv64im
-	LDFLAGS += -melf64lriscv
+
+	KBUILD_CFLAGS	+= $(call cc-ifversion, -ge, 0500, -DCONFIG_ARCH_SUPPORTS_INT128)
+
+	KBUILD_LDFLAGS += -melf64lriscv
 else
 	BITS := 32
 	UTS_MACHINE := riscv32
 
 	KBUILD_CFLAGS += -mabi=ilp32
 	KBUILD_AFLAGS += -mabi=ilp32
-	KBUILD_MARCH = rv32im
-	LDFLAGS += -melf32lriscv
+	KBUILD_LDFLAGS += -melf32lriscv
 endif
 
 KBUILD_CFLAGS += -Wall
 
-ifeq ($(CONFIG_RISCV_ISA_A),y)
-	KBUILD_ARCH_A = a
-endif
-ifeq ($(CONFIG_RISCV_ISA_C),y)
-	KBUILD_ARCH_C = c
-endif
-
-KBUILD_AFLAGS += -march=$(KBUILD_MARCH)$(KBUILD_ARCH_A)fd$(KBUILD_ARCH_C)
+# ISA string setting
+riscv-march-$(CONFIG_ARCH_RV32I)	:= rv32im
+riscv-march-$(CONFIG_ARCH_RV64I)	:= rv64im
+riscv-march-$(CONFIG_RISCV_ISA_A)	:= $(riscv-march-y)a
+riscv-march-$(CONFIG_FPU)		:= $(riscv-march-y)fd
+riscv-march-$(CONFIG_RISCV_ISA_C)	:= $(riscv-march-y)c
+KBUILD_CFLAGS += -march=$(subst fd,,$(riscv-march-y))
+KBUILD_AFLAGS += -march=$(riscv-march-y)
 
-KBUILD_CFLAGS += -march=$(KBUILD_MARCH)$(KBUILD_ARCH_A)$(KBUILD_ARCH_C)
 KBUILD_CFLAGS += -mno-save-restore
 KBUILD_CFLAGS += -DCONFIG_PAGE_OFFSET=$(CONFIG_PAGE_OFFSET)
 
@@ -73,7 +74,7 @@ KBUILD_CFLAGS += $(call cc-option,-mstrict-align)
 
 head-y := arch/riscv/kernel/head.o
 
-core-y += arch/riscv/kernel/ arch/riscv/mm/
+core-y += arch/riscv/kernel/ arch/riscv/mm/ arch/riscv/platforms/ arch/riscv/andesv5/
 
 libs-y += arch/riscv/lib/
 
diff --git a/arch/riscv/andesv5/Makefile b/arch/riscv/andesv5/Makefile
new file mode 100644
index 00000000..68db79eb
--- /dev/null
+++ b/arch/riscv/andesv5/Makefile
@@ -0,0 +1,3 @@
+obj-y += cctl.o
+obj-y += cache.o
+obj-y += noncache_dma.o
diff --git a/arch/riscv/andesv5/cache.c b/arch/riscv/andesv5/cache.c
new file mode 100644
index 00000000..de399b07
--- /dev/null
+++ b/arch/riscv/andesv5/cache.c
@@ -0,0 +1,407 @@
+#include <linux/irqflags.h>
+#include <linux/module.h>
+#include <linux/cpu.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/cacheinfo.h>
+#include <linux/sizes.h>
+#include <linux/smp.h>
+#include <asm/csr.h>
+#include <asm/sbi.h>
+#include <asm/io.h>
+#include <asm/andesv5/proc.h>
+#include <asm/andesv5/csr.h>
+#ifdef CONFIG_PERF_EVENTS
+#include <asm/perf_event.h>
+#endif
+
+#define MAX_CACHE_LINE_SIZE 256
+#define EVSEL_MASK	0xff
+#define SEL_PER_CTL	8
+#define SEL_OFF(id)	(8 * (id % 8))
+
+void __iomem *l2c_base;
+
+DEFINE_PER_CPU(struct andesv5_cache_info, cpu_cache_info) = {
+	.init_done = 0,
+	.dcache_line_size = SZ_32
+};
+static void fill_cpu_cache_info(struct andesv5_cache_info *cpu_ci)
+{
+    int ncpu = get_cpu();
+	struct cpu_cacheinfo *this_cpu_ci =
+			get_cpu_cacheinfo(ncpu);
+	struct cacheinfo *this_leaf = this_cpu_ci->info_list;
+	unsigned int i = 0;
+
+	for(; i< this_cpu_ci->num_leaves ; i++, this_leaf++)
+		if(this_leaf->type == CACHE_TYPE_DATA) {
+			cpu_ci->dcache_line_size = this_leaf->coherency_line_size;
+		}
+	cpu_ci->init_done = true;
+    put_cpu();
+}
+
+
+inline int get_cache_line_size(void)
+{
+    int ncpu = get_cpu();
+	struct andesv5_cache_info *cpu_ci =
+		&per_cpu(cpu_cache_info, ncpu);
+
+	if(unlikely(cpu_ci->init_done == false))
+		fill_cpu_cache_info(cpu_ci);
+    put_cpu();
+	return cpu_ci->dcache_line_size;
+}
+
+static uint32_t cpu_l2c_get_cctl_status(void)
+{
+	return readl((void*)(l2c_base + L2C_REG_STATUS_OFFSET));
+}
+
+void cpu_dcache_wb_range(unsigned long start, unsigned long end, int line_size)
+{
+	int mhartid = get_cpu();
+	unsigned long pa;
+	while (end > start) {
+		custom_csr_write(CCTL_REG_UCCTLBEGINADDR_NUM, start);
+		custom_csr_write(CCTL_REG_UCCTLCOMMAND_NUM, CCTL_L1D_VA_WB);
+
+		if (l2c_base) {
+			pa = virt_to_phys(start);
+			writel(pa, (void*)(l2c_base + L2C_REG_CN_ACC_OFFSET(mhartid)));
+			writel(CCTL_L2_PA_WB, (void*)(l2c_base + L2C_REG_CN_CMD_OFFSET(mhartid)));
+			while ((cpu_l2c_get_cctl_status() & CCTL_L2_STATUS_CN_MASK(mhartid))
+				!= CCTL_L2_STATUS_IDLE);
+		}
+
+		start += line_size;
+	}
+    put_cpu();
+}
+
+void cpu_dcache_inval_range(unsigned long start, unsigned long end, int line_size)
+{
+	int mhartid = get_cpu();
+	unsigned long pa;
+	while (end > start) {
+		custom_csr_write(CCTL_REG_UCCTLBEGINADDR_NUM, start);
+		custom_csr_write(CCTL_REG_UCCTLCOMMAND_NUM, CCTL_L1D_VA_INVAL);
+
+		if (l2c_base) {
+			pa = virt_to_phys(start);
+			writel(pa, (void*)(l2c_base + L2C_REG_CN_ACC_OFFSET(mhartid)));
+			writel(CCTL_L2_PA_INVAL, (void*)(l2c_base + L2C_REG_CN_CMD_OFFSET(mhartid)));
+			while ((cpu_l2c_get_cctl_status() & CCTL_L2_STATUS_CN_MASK(mhartid))
+				!= CCTL_L2_STATUS_IDLE);
+		}
+
+		start += line_size;
+	}
+    put_cpu();
+}
+void cpu_dma_inval_range(unsigned long start, unsigned long end)
+{
+        unsigned long flags;
+        unsigned long line_size = get_cache_line_size();
+	unsigned long old_start = start;
+	unsigned long old_end = end;
+	char cache_buf[2][MAX_CACHE_LINE_SIZE]={0};
+
+	if (unlikely(start == end))
+		return;
+
+	start = start & (~(line_size - 1));
+	end = ((end + line_size - 1) & (~(line_size - 1)));
+
+        local_irq_save(flags);
+	if (unlikely(start != old_start)) {
+		memcpy(&cache_buf[0][0], (void *)start, line_size);
+	}
+	if (unlikely(end != old_end)) {
+		memcpy(&cache_buf[1][0], (void *)(old_end & (~(line_size - 1))), line_size);
+	}
+	cpu_dcache_inval_range(start, end, line_size);
+	if (unlikely(start != old_start)) {
+		memcpy((void *)start, &cache_buf[0][0], (old_start & (line_size - 1)));
+	}
+	if (unlikely(end != old_end)) {
+		memcpy((void *)(old_end + 1), &cache_buf[1][(old_end & (line_size - 1)) + 1], end - old_end - 1);
+	}
+        local_irq_restore(flags);
+
+}
+EXPORT_SYMBOL(cpu_dma_inval_range);
+
+void cpu_dma_wb_range(unsigned long start, unsigned long end)
+{
+	unsigned long flags;
+	unsigned long line_size = get_cache_line_size();
+
+        local_irq_save(flags);
+	start = start & (~(line_size - 1));
+	cpu_dcache_wb_range(start, end, line_size);
+        local_irq_restore(flags);
+}
+EXPORT_SYMBOL(cpu_dma_wb_range);
+
+/* L1 Cache */
+int cpu_l1c_status(void)
+{
+	return SBI_CALL_0(SBI_L1CACHE_STATUS);
+}
+
+void cpu_icache_enable(void *info)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	SBI_CALL_1(SBI_ICACHE_OP, 1);
+    local_irq_restore(flags);
+}
+
+void cpu_icache_disable(void *info)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	SBI_CALL_1(SBI_ICACHE_OP, 0);
+    local_irq_restore(flags);
+}
+
+void cpu_dcache_enable(void *info)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	SBI_CALL_1(SBI_DCACHE_OP, 1);
+    local_irq_restore(flags);
+}
+
+void cpu_dcache_disable(void *info)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	SBI_CALL_1(SBI_DCACHE_OP, 0);
+	local_irq_restore(flags);
+}
+
+/* L2 Cache */
+uint32_t cpu_l2c_ctl_status(void)
+{
+	return readl((void*)(l2c_base + L2C_REG_CTL_OFFSET));
+}
+
+void cpu_l2c_disable(void)
+{
+#ifdef CONFIG_SMP
+	int mhartid = get_cpu();
+#else
+	int mhartid = 0;
+#endif
+	unsigned int val;
+	unsigned long flags;
+
+	/*No l2 cache */
+	if(!l2c_base)
+		return;
+
+	/*l2 cache has disabled*/
+	if(!(cpu_l2c_ctl_status() & L2_CACHE_CTL_mskCEN))
+		return;
+
+	local_irq_save(flags);
+
+	/*Disable L2 cache*/
+	val = readl((void*)(l2c_base + L2C_REG_CTL_OFFSET));
+	val &= (~L2_CACHE_CTL_mskCEN);
+
+	writel(val, (void*)(l2c_base + L2C_REG_CTL_OFFSET));
+	while ((cpu_l2c_get_cctl_status() & CCTL_L2_STATUS_CN_MASK(mhartid))
+	       != CCTL_L2_STATUS_IDLE);
+
+	/*L2 write-back and invalidate all*/
+	writel(CCTL_L2_WBINVAL_ALL, (void*)(l2c_base + L2C_REG_CN_CMD_OFFSET(mhartid)));
+	while ((cpu_l2c_get_cctl_status() & CCTL_L2_STATUS_CN_MASK(mhartid))
+	       != CCTL_L2_STATUS_IDLE);
+
+	local_irq_restore(flags);
+    #ifdef CONFIG_SMP
+    put_cpu();
+    #endif
+}
+
+#ifndef CONFIG_SMP
+void cpu_l2c_inval_range(unsigned long pa, unsigned long size)
+{
+	unsigned long line_size = get_cache_line_size();
+    unsigned long start = pa, end = pa + size;
+    unsigned long align_start, align_end;
+
+    align_start = start & ~(line_size - 1);
+    align_end  = (end + line_size - 1) & ~(line_size - 1);
+
+    while(align_end > align_start){
+        writel(align_start, (void*)(l2c_base + L2C_REG_C0_ACC_OFFSET));
+        writel(CCTL_L2_PA_INVAL, (void*)(l2c_base + L2C_REG_C0_CMD_OFFSET));
+        while ((cpu_l2c_get_cctl_status() & CCTL_L2_STATUS_C0_MASK)
+                != CCTL_L2_STATUS_IDLE);
+        align_start += line_size;
+	}
+}
+EXPORT_SYMBOL(cpu_l2c_inval_range);
+
+void cpu_l2c_wb_range(unsigned long pa, unsigned long size)
+{
+    unsigned long line_size = get_cache_line_size();
+    unsigned long start = pa, end = pa + size;
+    unsigned long align_start, align_end;
+
+    align_start = start & ~(line_size - 1);
+    align_end  = (end + line_size - 1) & ~(line_size - 1);
+
+    while(align_end > align_start){
+        writel(align_start, (void*)(l2c_base + L2C_REG_C0_ACC_OFFSET));
+        writel(CCTL_L2_PA_WB, (void*)(l2c_base + L2C_REG_C0_CMD_OFFSET));
+        while ((cpu_l2c_get_cctl_status() & CCTL_L2_STATUS_C0_MASK)
+                != CCTL_L2_STATUS_IDLE);
+        align_start += line_size;
+    }
+}
+EXPORT_SYMBOL(cpu_l2c_wb_range);
+#else
+void cpu_l2c_inval_range(unsigned long pa, unsigned long size)
+{
+    int mhartid = get_cpu();
+    unsigned long line_size = get_cache_line_size();
+    unsigned long start = pa, end = pa + size;
+    unsigned long align_start, align_end;
+
+    align_start = start & ~(line_size - 1);
+    align_end  = (end + line_size - 1) & ~(line_size - 1);
+
+    while(align_end > align_start){
+        writel(align_start, (void*)(l2c_base + L2C_REG_CN_ACC_OFFSET(mhartid)));
+        writel(CCTL_L2_PA_INVAL, (void*)(l2c_base + L2C_REG_CN_CMD_OFFSET(mhartid)));
+        while ((cpu_l2c_get_cctl_status() & CCTL_L2_STATUS_CN_MASK(mhartid))
+                != CCTL_L2_STATUS_IDLE);
+        align_start += line_size;
+    }
+    put_cpu();
+}
+EXPORT_SYMBOL(cpu_l2c_inval_range);
+
+void cpu_l2c_wb_range(unsigned long pa, unsigned long size)
+{
+    int mhartid = get_cpu();
+    unsigned long line_size = get_cache_line_size();
+    unsigned long start = pa, end = pa + size;
+    unsigned long align_start, align_end;
+
+    align_start = start & ~(line_size - 1);
+    align_end  = (end + line_size - 1) & ~(line_size - 1);
+
+    while(align_end > align_start){
+        writel(align_start, (void*)(l2c_base + L2C_REG_CN_ACC_OFFSET(mhartid)));
+        writel(CCTL_L2_PA_WB, (void*)(l2c_base + L2C_REG_CN_CMD_OFFSET(mhartid)));
+        while ((cpu_l2c_get_cctl_status() & CCTL_L2_STATUS_CN_MASK(mhartid))
+                != CCTL_L2_STATUS_IDLE);
+        align_start += line_size;
+    }
+    put_cpu();
+}
+EXPORT_SYMBOL(cpu_l2c_wb_range);
+#endif
+
+#ifdef CONFIG_PERF_EVENTS
+int cpu_l2c_get_counter_idx(struct l2c_hw_events *l2c)
+{
+	int idx;
+
+	idx = find_next_zero_bit(l2c->used_mask, L2C_MAX_COUNTERS - 1, 0);
+	return idx;
+}
+
+void l2c_write_counter(int idx, u64 value)
+{
+	u32 vall = value;
+	u32 valh = value >> 32;
+
+	writel(vall, (void*)(l2c_base + L2C_REG_CN_HPM_OFFSET(idx)));
+	writel(valh, (void*)(l2c_base + L2C_REG_CN_HPM_OFFSET(idx) + 0x4));
+}
+
+u64 l2c_read_counter(int idx)
+{
+	u32 vall = readl((void*)(l2c_base + L2C_REG_CN_HPM_OFFSET(idx)));
+	u32 valh = readl((void*)(l2c_base + L2C_REG_CN_HPM_OFFSET(idx) + 0x4));
+	u64 val = ((u64)valh << 32) | vall;
+
+	return val;
+}
+
+void l2c_pmu_disable_counter(int idx)
+{
+	int n = idx / SEL_PER_CTL;
+	u32 vall = readl((void*)(l2c_base + L2C_HPM_CN_CTL_OFFSET(n)));
+	u32 valh = readl((void*)(l2c_base + L2C_HPM_CN_CTL_OFFSET(n) + 0x4));
+	u64 val = ((u64)valh << 32) | vall;
+
+	val |= (EVSEL_MASK << SEL_OFF(idx));
+	vall = val;
+	valh = val >> 32;
+	writel(vall, (void*)(l2c_base + L2C_HPM_CN_CTL_OFFSET(n)));
+	writel(valh, (void*)(l2c_base + L2C_HPM_CN_CTL_OFFSET(n) + 0x4));
+}
+
+#ifndef CONFIG_SMP
+void l2c_pmu_event_enable(u64 config, int idx)
+{
+	int n = idx / SEL_PER_CTL;
+	u32 vall = readl((void*)(l2c_base + L2C_HPM_CN_CTL_OFFSET(n)));
+	u32 valh = readl((void*)(l2c_base + L2C_HPM_CN_CTL_OFFSET(n) + 0x4));
+	u64 val = ((u64)valh << 32) | vall;
+
+	val = val & ~(EVSEL_MASK << SEL_OFF(idx));
+	val = val | (config << SEL_OFF(idx));
+	vall = val;
+	valh = val >> 32;
+	writel(vall, (void*)(l2c_base + L2C_HPM_CN_CTL_OFFSET(n)));
+	writel(valh, (void*)(l2c_base + L2C_HPM_CN_CTL_OFFSET(n) + 0x4));
+}
+#else
+void l2c_pmu_event_enable(u64 config, int idx)
+{
+	int n = idx / SEL_PER_CTL;
+	int mhartid = get_cpu();
+	u32 vall = readl((void*)(l2c_base + L2C_HPM_CN_CTL_OFFSET(n)));
+	u32 valh = readl((void*)(l2c_base + L2C_HPM_CN_CTL_OFFSET(n) + 0x4));
+	u64 val = ((u64)valh << 32) | vall;
+
+	if (config <= (CN_RECV_SNOOP_DATA(NR_CPUS - 1) & EVSEL_MASK))
+		config = config + mhartid * L2C_REG_PER_CORE_OFFSET;
+
+	val = val & ~(EVSEL_MASK << SEL_OFF(idx));
+	val = val | (config << SEL_OFF(idx));
+	vall = val;
+	valh = val >> 32;
+	writel(vall, (void*)(l2c_base + L2C_HPM_CN_CTL_OFFSET(n)));
+	writel(valh, (void*)(l2c_base + L2C_HPM_CN_CTL_OFFSET(n) + 0x4));
+    put_cpu();
+}
+#endif
+#endif
+
+int __init l2c_init(void)
+{
+	struct device_node *node ;
+
+	node = of_find_compatible_node(NULL, NULL, "cache");
+	l2c_base = of_iomap(node, 0);
+
+	return 0;
+}
+arch_initcall(l2c_init)
diff --git a/arch/riscv/andesv5/cctl.c b/arch/riscv/andesv5/cctl.c
new file mode 100644
index 00000000..6e6ded0c
--- /dev/null
+++ b/arch/riscv/andesv5/cctl.c
@@ -0,0 +1,248 @@
+/*
+ *  Copyright (C) 2009 Andes Technology Corporation
+ *  Copyright (C) 2019 Andes Technology Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/blkdev.h>
+#include <linux/proc_fs.h>
+#include <asm/andesv5/csr.h>
+#include <asm/andesv5/proc.h>
+
+#define INPUTLEN 32
+
+struct entry_struct{
+
+	char *name;
+	int perm;
+	struct file_operations *fops;
+};
+
+static struct proc_dir_entry *proc_cctl;
+
+#define DEBUG( enable, tagged, ...)				\
+	do{							\
+		if(enable){					\
+			if(tagged)				\
+			printk( "[ %30s() ] ", __func__);	\
+			printk( __VA_ARGS__);			\
+		}						\
+	} while( 0)
+
+static int debug = 0;
+module_param(debug, int, 0);
+
+void cpu_icache_smp_enable(void)
+{
+    int cpu_num = num_online_cpus();
+    int id = smp_processor_id();
+    int i, ret;
+
+    for(i = 0; i < cpu_num; i++){
+		if(i == id)
+			continue;
+        ret = smp_call_function_single(i, cpu_icache_enable,
+                                        NULL, true);
+        if(ret)
+            pr_err("Core %d enable I-cache Fail\n"
+                    "Error Code:%d \n", i, ret);
+    }
+    cpu_icache_enable(NULL);
+}
+
+void cpu_icache_smp_disable(void)
+{
+    int cpu_num = num_online_cpus();
+    int id = smp_processor_id();
+    int i, ret;
+
+    for(i = 0; i < cpu_num; i++){
+        if(i == id)
+            continue;
+        ret = smp_call_function_single(i, cpu_icache_disable,
+                                        NULL, true);
+        if(ret)
+            pr_err("Core %d disable I-cache Fail \n"
+                    "Error Code:%d \n", i, ret);
+    }
+    cpu_icache_disable(NULL);
+}
+
+void cpu_dcache_smp_enable(void)
+{
+    int cpu_num = num_online_cpus();
+    int id = smp_processor_id();
+    int i, ret;
+
+    for(i = 0; i < cpu_num; i++){
+        if(i == id)
+            continue;
+        ret = smp_call_function_single(i, cpu_dcache_enable,
+                                        NULL, true);
+        if(ret)
+            pr_err("Core %d disable D-cache Fail \n"
+                    "Error Code:%d \n", i, ret);
+    }
+    cpu_dcache_enable(NULL);
+}
+
+void cpu_dcache_smp_disable(void)
+{
+    int cpu_num = num_online_cpus();
+    int id = smp_processor_id();
+    int i, ret;
+
+    for(i = 0; i < cpu_num; i++){
+        if(i == id)
+            continue;
+        ret = smp_call_function_single(i, cpu_dcache_disable,
+                                        NULL, true);
+        if(ret)
+            pr_err("Core %d disable D-cache Fail \n"
+                    "Error Code:%d \n", i, ret);
+    }
+    cpu_dcache_disable(NULL);
+}
+
+static ssize_t proc_read_cache_en(struct file *file, char __user *userbuf,
+						size_t count, loff_t *ppos)
+{
+    int ret;
+    char buf[18];
+    if (!strncmp(file->f_path.dentry->d_name.name, "ic_en", 7))
+        ret = sprintf(buf, "I-cache: %s\n", (cpu_l1c_status() & CACHE_CTL_mskIC_EN) ? "Enabled" : "Disabled");
+    else if(!strncmp(file->f_path.dentry->d_name.name, "dc_en", 7))
+        ret = sprintf(buf, "D-cache: %s\n", (cpu_l1c_status() & CACHE_CTL_mskDC_EN) ? "Enabled" : "Disabled");
+	else
+		return -EFAULT;
+
+    return simple_read_from_buffer(userbuf, count, ppos, buf, ret);
+}
+
+static ssize_t proc_write_cache_en(struct file *file,
+			const char __user *buffer, size_t count, loff_t *ppos)
+{
+
+	unsigned long en;
+	char inbuf[INPUTLEN];
+
+	if (count > INPUTLEN - 1)
+		count = INPUTLEN - 1;
+
+	if (copy_from_user(inbuf, buffer, count))
+		return -EFAULT;
+
+	inbuf[count] = '\0';
+
+	if (!sscanf(inbuf, "%lu", &en) || en > 1)
+		return -EFAULT;
+
+	if (!strncmp(file->f_path.dentry->d_name.name, "ic_en", 7)) {
+		if (en && !(cpu_l1c_status() & CACHE_CTL_mskIC_EN)) {
+#ifdef CONFIG_SMP
+			cpu_icache_smp_enable();
+#else
+			cpu_icache_enable(NULL);
+#endif
+			DEBUG(debug, 1, "I-cache: Enabled\n");
+		} else if (!en && (cpu_l1c_status() & CACHE_CTL_mskIC_EN)) {
+#ifdef CONFIG_SMP
+			cpu_icache_smp_disable();
+#else
+			cpu_icache_disable(NULL);
+#endif
+			DEBUG(debug, 1, "I-cache: Disabled\n");
+		}
+	} else if(!strncmp(file->f_path.dentry->d_name.name, "dc_en", 7)) {
+		if (en && !(cpu_l1c_status() & CACHE_CTL_mskDC_EN)) {
+#ifdef CONFIG_SMP
+			cpu_dcache_smp_enable();
+#else
+			cpu_dcache_enable(NULL);
+#endif
+			DEBUG(debug, 1, "D-cache: Enabled\n");
+		} else if (!en && (cpu_l1c_status() & CACHE_CTL_mskDC_EN)) {
+#ifdef CONFIG_SMP
+			cpu_dcache_smp_disable();
+#else
+			cpu_dcache_disable(NULL);
+#endif
+			DEBUG(debug, 1, "D-cache: Disabled\n");
+		}
+	}else{
+		return -EFAULT;
+	}
+
+	return count;
+}
+
+static struct file_operations en_fops = {
+	.open = simple_open,
+	.read = proc_read_cache_en,
+	.write = proc_write_cache_en,
+};
+
+static void create_seq_entry(struct entry_struct *e, mode_t mode,
+			     struct proc_dir_entry *parent)
+{
+
+	struct proc_dir_entry *entry = proc_create(e->name, mode, parent, e->fops);
+
+	if (!entry)
+		printk(KERN_ERR "invalid %s register.\n", e->name);
+}
+
+static void install_proc_table(struct entry_struct *table)
+{
+	while (table->name) {
+
+		create_seq_entry(table, table->perm, proc_cctl);
+		table++;
+	}
+}
+
+static void remove_proc_table(struct entry_struct *table)
+{
+
+	while (table->name) {
+		remove_proc_entry(table->name, proc_cctl);
+		table++;
+	}
+}
+
+struct entry_struct proc_table_cache[] = {
+
+	{"ic_en", 0644, &en_fops},
+	{"dc_en", 0644, &en_fops},
+};
+static int __init init_cctl(void)
+{
+
+	DEBUG(debug, 0, "CCTL module registered\n");
+
+	if(!(proc_cctl = proc_mkdir("cctl", NULL)))
+		return -ENOMEM;
+
+	install_proc_table(proc_table_cache);
+
+	return 0;
+}
+
+static void __exit cleanup_cctl(void)
+{
+
+	remove_proc_table(proc_table_cache);
+	remove_proc_entry("cctl", NULL);
+
+	DEBUG(debug, 1, "CCTL module unregistered\n");
+}
+
+module_init(init_cctl);
+module_exit(cleanup_cctl);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Userspace Cache Control Module");
diff --git a/arch/riscv/andesv5/noncache_dma.c b/arch/riscv/andesv5/noncache_dma.c
new file mode 100644
index 00000000..42826aed
--- /dev/null
+++ b/arch/riscv/andesv5/noncache_dma.c
@@ -0,0 +1,257 @@
+/*
+ * Copyright (C) 2017 SiFive
+ *   Wesley Terpstra <wesley@sifive.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ */
+
+#include <linux/gfp.h>
+#include <linux/mm.h>
+#include <linux/swiotlb.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-direct.h>
+#include <linux/scatterlist.h>
+#include <linux/highmem.h>
+#include <asm/andesv5/proc.h>
+
+static void dma_flush_page(struct page *page, size_t size)
+{
+	unsigned long k_d_vaddr;
+	/*
+	 * Invalidate any data that might be lurking in the
+	 * kernel direct-mapped region for device DMA.
+	 */
+	k_d_vaddr = (unsigned long)page_address(page);
+	memset((void *)k_d_vaddr, 0, size);
+	cpu_dma_wb_range(k_d_vaddr, k_d_vaddr + size);
+	cpu_dma_inval_range(k_d_vaddr, k_d_vaddr + size);
+
+}
+
+
+static inline void cache_op(phys_addr_t paddr, size_t size,
+		void (*fn)(unsigned long start, unsigned long end))
+{
+    struct page *page = pfn_to_page(paddr >> PAGE_SHIFT);
+    unsigned offset = paddr & ~PAGE_MASK;
+    size_t left = size;
+    unsigned long start;
+
+    do {
+        size_t len = left;
+
+        if (PageHighMem(page)) {
+            void *addr;
+
+            if (offset + len > PAGE_SIZE) {
+                if (offset >= PAGE_SIZE) {
+                    page += offset >> PAGE_SHIFT;
+                    offset &= ~PAGE_MASK;
+                }
+                len = PAGE_SIZE - offset;
+            }
+
+            addr = kmap_atomic(page);
+            start = (unsigned long)(addr + offset);
+            fn(start, start + len);
+            kunmap_atomic(addr);
+        } else {
+            start = (unsigned long)phys_to_virt(paddr);
+            fn(start, start + size);
+        }
+        offset = 0;
+        page++;
+        left -= len;
+    } while (left);
+}
+
+void arch_sync_dma_for_device(struct device *dev, phys_addr_t paddr,
+		size_t size, enum dma_data_direction dir)
+{
+	switch (dir) {
+	case DMA_FROM_DEVICE:
+		cache_op(paddr, size, cpu_dma_inval_range);
+		break;
+	case DMA_TO_DEVICE:
+	case DMA_BIDIRECTIONAL:
+		cache_op(paddr, size, cpu_dma_wb_range);
+		break;
+	default:
+		BUG();
+	}
+}
+
+void arch_sync_dma_for_cpu(struct device *dev, phys_addr_t paddr,
+		size_t size, enum dma_data_direction dir)
+{
+	switch (dir) {
+	case DMA_TO_DEVICE:
+		break;
+	case DMA_FROM_DEVICE:
+	case DMA_BIDIRECTIONAL:
+		cache_op(paddr, size, cpu_dma_inval_range);
+		break;
+	default:
+		BUG();
+	}
+}
+
+void *arch_dma_alloc(struct device *dev, size_t size,
+			      dma_addr_t * handle, gfp_t gfp,
+				      unsigned long attrs)
+{
+	void* kvaddr, *coherent_kvaddr;
+	size = PAGE_ALIGN(size);
+
+	kvaddr = swiotlb_alloc(dev, size, handle, gfp, attrs);
+	if (!kvaddr)
+		goto no_mem;
+	coherent_kvaddr = ioremap_nocache(dma_to_phys(dev, *handle), size);
+	if (!coherent_kvaddr)
+		goto no_map;
+
+	dma_flush_page(virt_to_page(kvaddr),size);
+	return coherent_kvaddr;
+no_map:
+	swiotlb_free(dev, size, kvaddr, *handle, attrs);
+no_mem:
+	return NULL;
+}
+
+void arch_dma_free(struct device *dev, size_t size, void *vaddr,
+			   dma_addr_t handle, unsigned long attrs)
+{
+	void *swiotlb_addr = phys_to_virt(dma_to_phys(dev, handle));
+
+	size = PAGE_ALIGN(size);
+	iounmap(vaddr);
+	swiotlb_free(dev, size, swiotlb_addr, handle, attrs);
+
+	return;
+}
+
+
+static dma_addr_t dma_riscv_swiotlb_map_page(struct device *dev, 
+				     struct page *page,
+				     unsigned long offset, size_t size,
+				     enum dma_data_direction dir,
+				     unsigned long attrs)
+{
+	dma_addr_t dev_addr;
+
+	dev_addr = swiotlb_map_page(dev, page, offset, size, dir, attrs);
+	if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+                arch_sync_dma_for_device(dev, dma_to_phys(dev, dev_addr),
+                                         size, dir);
+
+	return dev_addr;
+}
+static int dma_riscv_swiotlb_map_sg(struct device *dev,
+				  struct scatterlist *sgl,
+				  int nelems, enum dma_data_direction dir,
+				  unsigned long attrs)
+{
+	struct scatterlist *sg;
+	int i, ret;
+
+	ret = swiotlb_map_sg_attrs(dev, sgl, nelems, dir, attrs);
+	if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+		for_each_sg(sgl, sg, ret, i)
+			arch_sync_dma_for_device(dev,
+				       dma_to_phys(dev, sg->dma_address),
+				       sg->length, dir);
+
+	return ret;
+}
+static void dma_riscv_swiotlb_unmap_page(struct device *dev, dma_addr_t dev_addr,
+				 size_t size, enum dma_data_direction dir,
+				 unsigned long attrs)
+{
+	if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+		arch_sync_dma_for_cpu(dev, dma_to_phys(dev, dev_addr),
+					size, dir);
+	swiotlb_unmap_page(dev, dev_addr, size, dir, attrs);
+}
+static void dma_riscv_swiotlb_unmap_sg(struct device *dev,
+				     struct scatterlist *sgl, int nelems,
+				     enum dma_data_direction dir,
+				     unsigned long attrs)
+{
+	struct scatterlist *sg;
+	int i;
+
+	if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+		for_each_sg(sgl, sg, nelems, i)
+			arch_sync_dma_for_cpu(dev,
+					dma_to_phys(dev, sg->dma_address),
+					 sg->length, dir);
+	swiotlb_unmap_sg_attrs(dev, sgl, nelems, dir, attrs);
+}
+static void dma_riscv_swiotlb_sync_single_for_cpu(struct device *dev,
+					  dma_addr_t dev_addr, size_t size,
+					  enum dma_data_direction dir)
+{
+	arch_sync_dma_for_cpu(dev, dma_to_phys(dev, dev_addr),
+					size, dir);
+	swiotlb_sync_single_for_cpu(dev, dev_addr, size, dir);
+}
+static void dma_riscv_swiotlb_sync_single_for_device(struct device *dev,
+					     dma_addr_t dev_addr, size_t size,
+					     enum dma_data_direction dir)
+{
+	swiotlb_sync_single_for_device(dev, dev_addr, size, dir);
+	arch_sync_dma_for_device(dev, dma_to_phys(dev, dev_addr), size, dir);
+}
+
+static void dma_riscv_swiotlb_sync_sg_for_cpu(struct device *dev,
+				      struct scatterlist *sgl, int nelems,
+				      enum dma_data_direction dir)
+{
+	struct scatterlist *sg;
+	int i;
+
+	for_each_sg(sgl, sg, nelems, i)
+		arch_sync_dma_for_cpu(dev,dma_to_phys(dev, sg->dma_address),
+					 sg->length, dir);
+	swiotlb_sync_sg_for_cpu(dev, sgl, nelems, dir);
+}
+
+static void dma_riscv_swiotlb_sync_sg_for_device(struct device *dev,
+					 struct scatterlist *sgl, int nelems,
+					 enum dma_data_direction dir)
+{
+	struct scatterlist *sg;
+	int i;
+
+	swiotlb_sync_sg_for_device(dev, sgl, nelems, dir);
+	for_each_sg(sgl, sg, nelems, i)
+		arch_sync_dma_for_device(dev,dma_to_phys(dev, sg->dma_address),
+				       sg->length, dir);
+}
+const struct dma_map_ops swiotlb_noncoh_dma_ops = {
+	.alloc			= arch_dma_alloc,
+	.free			= arch_dma_free,
+	.dma_supported	     	= swiotlb_dma_supported,
+	.map_page		= dma_riscv_swiotlb_map_page,
+	.map_sg			= dma_riscv_swiotlb_map_sg,
+	.unmap_page		= dma_riscv_swiotlb_unmap_page,
+	.unmap_sg		= dma_riscv_swiotlb_unmap_sg,
+	.sync_single_for_cpu	= dma_riscv_swiotlb_sync_single_for_cpu,
+	.sync_single_for_device	= dma_riscv_swiotlb_sync_single_for_device,
+	.sync_sg_for_cpu	= dma_riscv_swiotlb_sync_sg_for_cpu,
+	.sync_sg_for_device	= dma_riscv_swiotlb_sync_sg_for_device,
+};
+
+EXPORT_SYMBOL(swiotlb_noncoh_dma_ops);
diff --git a/arch/riscv/boot/dts/ae350_c1_32.dts b/arch/riscv/boot/dts/ae350_c1_32.dts
new file mode 100644
index 00000000..7f40ee56
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_32.dts
@@ -0,0 +1,302 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9>;
+			phandle = <0x3>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x2 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x4>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x3>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x3>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x3>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x3>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x3>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x4>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x3>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_32_d.dts b/arch/riscv/boot/dts/ae350_c1_32_d.dts
new file mode 100644
index 00000000..fe73c9b6
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_32_d.dts
@@ -0,0 +1,302 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9>;
+			phandle = <0x3>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x2 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x4>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x3>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x3>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x3>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x3>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x3>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x4>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x3>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_32_d_dsp.dts b/arch/riscv/boot/dts/ae350_c1_32_d_dsp.dts
new file mode 100644
index 00000000..e961d6cf
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_32_d_dsp.dts
@@ -0,0 +1,302 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9>;
+			phandle = <0x3>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x2 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x4>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x3>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x3>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x3>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x3>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x3>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x4>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x3>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_32_dsp.dts b/arch/riscv/boot/dts/ae350_c1_32_dsp.dts
new file mode 100644
index 00000000..5d751caa
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_32_dsp.dts
@@ -0,0 +1,302 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9>;
+			phandle = <0x3>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x2 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x4>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x3>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x3>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x3>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x3>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x3>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x4>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x3>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_64.dts b/arch/riscv/boot/dts/ae350_c1_64.dts
new file mode 100644
index 00000000..42a81680
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_64.dts
@@ -0,0 +1,302 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9>;
+			phandle = <0x3>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x2 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x4>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x3>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x3>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x3>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x3>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x3>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x4>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x3>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_64_d.dts b/arch/riscv/boot/dts/ae350_c1_64_d.dts
new file mode 100644
index 00000000..75a7e628
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_64_d.dts
@@ -0,0 +1,302 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9>;
+			phandle = <0x3>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x2 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x4>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x3>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x3>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x3>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x3>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x3>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x4>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x3>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_64_d_dsp.dts b/arch/riscv/boot/dts/ae350_c1_64_d_dsp.dts
new file mode 100644
index 00000000..2f81b501
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_64_d_dsp.dts
@@ -0,0 +1,302 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9>;
+			phandle = <0x3>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x2 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x4>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x3>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x3>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x3>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x3>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x3>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x4>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x3>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_64_dsp.dts b/arch/riscv/boot/dts/ae350_c1_64_dsp.dts
new file mode 100644
index 00000000..ea879088
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_64_dsp.dts
@@ -0,0 +1,302 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9>;
+			phandle = <0x3>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x2 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x4>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x3>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x3>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x3>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x3>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x3>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x4>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x3>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x3>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x3>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_noncoherent_32.dts b/arch/riscv/boot/dts/ae350_c1_noncoherent_32.dts
new file mode 100644
index 00000000..2fbb1f51
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_noncoherent_32.dts
@@ -0,0 +1,288 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x1>;
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x1 0xb 0x1 0x9>;
+			phandle = <0x2>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x1 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x1 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x3>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x2>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x2>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x2>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x2>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x2>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x3>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x2>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_noncoherent_32_d.dts b/arch/riscv/boot/dts/ae350_c1_noncoherent_32_d.dts
new file mode 100644
index 00000000..b26c822d
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_noncoherent_32_d.dts
@@ -0,0 +1,288 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x1>;
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x1 0xb 0x1 0x9>;
+			phandle = <0x2>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x1 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x1 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x3>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x2>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x2>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x2>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x2>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x2>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x3>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x2>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_noncoherent_32_d_dsp.dts b/arch/riscv/boot/dts/ae350_c1_noncoherent_32_d_dsp.dts
new file mode 100644
index 00000000..8c9143ca
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_noncoherent_32_d_dsp.dts
@@ -0,0 +1,288 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x1>;
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x1 0xb 0x1 0x9>;
+			phandle = <0x2>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x1 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x1 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x3>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x2>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x2>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x2>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x2>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x2>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x3>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x2>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_noncoherent_32_dsp.dts b/arch/riscv/boot/dts/ae350_c1_noncoherent_32_dsp.dts
new file mode 100644
index 00000000..2f5ed46f
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_noncoherent_32_dsp.dts
@@ -0,0 +1,288 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x1>;
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x1 0xb 0x1 0x9>;
+			phandle = <0x2>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x1 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x1 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x3>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x2>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x2>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x2>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x2>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x2>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x3>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x2>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_noncoherent_64.dts b/arch/riscv/boot/dts/ae350_c1_noncoherent_64.dts
new file mode 100644
index 00000000..4a2ecb43
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_noncoherent_64.dts
@@ -0,0 +1,288 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x1>;
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x1 0xb 0x1 0x9>;
+			phandle = <0x2>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x1 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x1 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x3>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x2>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x2>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x2>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x2>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x2>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x3>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x2>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_noncoherent_64_d.dts b/arch/riscv/boot/dts/ae350_c1_noncoherent_64_d.dts
new file mode 100644
index 00000000..6062fe73
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_noncoherent_64_d.dts
@@ -0,0 +1,288 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x1>;
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x1 0xb 0x1 0x9>;
+			phandle = <0x2>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x1 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x1 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x3>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x2>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x2>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x2>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x2>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x2>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x3>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x2>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_noncoherent_64_d_dsp.dts b/arch/riscv/boot/dts/ae350_c1_noncoherent_64_d_dsp.dts
new file mode 100644
index 00000000..d6080603
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_noncoherent_64_d_dsp.dts
@@ -0,0 +1,288 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x1>;
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x1 0xb 0x1 0x9>;
+			phandle = <0x2>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x1 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x1 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x3>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x2>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x2>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x2>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x2>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x2>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x3>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x2>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c1_noncoherent_64_dsp.dts b/arch/riscv/boot/dts/ae350_c1_noncoherent_64_dsp.dts
new file mode 100644
index 00000000..91adcc81
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c1_noncoherent_64_dsp.dts
@@ -0,0 +1,288 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x1>;
+			};
+		};
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x1 0xb 0x1 0x9>;
+			phandle = <0x2>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x1>;
+			interrupts-extended = <0x1 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x1 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x3>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x2>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x2>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x2>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x2>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x2>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x3>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x2>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x2>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x2>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c2_32.dts b/arch/riscv/boot/dts/ae350_c2_32.dts
new file mode 100644
index 00000000..473ed03e
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c2_32.dts
@@ -0,0 +1,326 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9>;
+			phandle = <0x4>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x2>;
+			interrupts-extended = <0x2 0x3 0x3 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x5>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x4>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x4>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x4>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x4>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x4>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x5>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x4>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c2_32_d.dts b/arch/riscv/boot/dts/ae350_c2_32_d.dts
new file mode 100644
index 00000000..fb0f5c36
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c2_32_d.dts
@@ -0,0 +1,326 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9>;
+			phandle = <0x4>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x2>;
+			interrupts-extended = <0x2 0x3 0x3 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x5>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x4>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x4>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x4>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x4>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x4>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x5>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x4>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c2_32_d_dsp.dts b/arch/riscv/boot/dts/ae350_c2_32_d_dsp.dts
new file mode 100644
index 00000000..6194814f
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c2_32_d_dsp.dts
@@ -0,0 +1,326 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9>;
+			phandle = <0x4>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x2>;
+			interrupts-extended = <0x2 0x3 0x3 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x5>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x4>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x4>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x4>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x4>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x4>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x5>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x4>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c2_32_dsp.dts b/arch/riscv/boot/dts/ae350_c2_32_dsp.dts
new file mode 100644
index 00000000..64f87b58
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c2_32_dsp.dts
@@ -0,0 +1,326 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9>;
+			phandle = <0x4>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x2>;
+			interrupts-extended = <0x2 0x3 0x3 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x5>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x4>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x4>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x4>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x4>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x4>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x5>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x4>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c2_64.dts b/arch/riscv/boot/dts/ae350_c2_64.dts
new file mode 100644
index 00000000..4b37b606
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c2_64.dts
@@ -0,0 +1,326 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9>;
+			phandle = <0x4>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x2>;
+			interrupts-extended = <0x2 0x3 0x3 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x5>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x4>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x4>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x4>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x4>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x4>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x5>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x4>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c2_64_d.dts b/arch/riscv/boot/dts/ae350_c2_64_d.dts
new file mode 100644
index 00000000..5b6438bc
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c2_64_d.dts
@@ -0,0 +1,326 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9>;
+			phandle = <0x4>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x2>;
+			interrupts-extended = <0x2 0x3 0x3 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x5>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x4>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x4>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x4>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x4>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x4>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x5>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x4>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c2_64_d_dsp.dts b/arch/riscv/boot/dts/ae350_c2_64_d_dsp.dts
new file mode 100644
index 00000000..a8a3ccf1
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c2_64_d_dsp.dts
@@ -0,0 +1,326 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9>;
+			phandle = <0x4>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x2>;
+			interrupts-extended = <0x2 0x3 0x3 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x5>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x4>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x4>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x4>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x4>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x4>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x5>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x4>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c2_64_dsp.dts b/arch/riscv/boot/dts/ae350_c2_64_dsp.dts
new file mode 100644
index 00000000..44f995fc
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c2_64_dsp.dts
@@ -0,0 +1,326 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9>;
+			phandle = <0x4>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x2>;
+			interrupts-extended = <0x2 0x3 0x3 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x5>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x4>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x4>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x4>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x4>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x4>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x5>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x4>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x4>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x4>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c4_32.dts b/arch/riscv/boot/dts/ae350_c4_32.dts
new file mode 100644
index 00000000..ba96dbad
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c4_32.dts
@@ -0,0 +1,374 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+
+		cpu@2 {
+			device_type = "cpu";
+			reg = <0x2>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x4>;
+			};
+		};
+
+		cpu@3 {
+			device_type = "cpu";
+			reg = <0x3>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x5>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9 0x4 0xb 0x4 0x9 0x5 0xb 0x5 0x9>;
+			phandle = <0x6>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x4>;
+			interrupts-extended = <0x2 0x3 0x3 0x3 0x4 0x3 0x5 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7 0x4 0x7 0x5 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x7>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x6>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x6>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x6>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x6>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x6>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x7>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x6>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c4_32_d.dts b/arch/riscv/boot/dts/ae350_c4_32_d.dts
new file mode 100644
index 00000000..4f4071b2
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c4_32_d.dts
@@ -0,0 +1,374 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+
+		cpu@2 {
+			device_type = "cpu";
+			reg = <0x2>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x4>;
+			};
+		};
+
+		cpu@3 {
+			device_type = "cpu";
+			reg = <0x3>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x5>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9 0x4 0xb 0x4 0x9 0x5 0xb 0x5 0x9>;
+			phandle = <0x6>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x4>;
+			interrupts-extended = <0x2 0x3 0x3 0x3 0x4 0x3 0x5 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7 0x4 0x7 0x5 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x7>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x6>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x6>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x6>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x6>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x6>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x7>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x6>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c4_32_d_dsp.dts b/arch/riscv/boot/dts/ae350_c4_32_d_dsp.dts
new file mode 100644
index 00000000..ab120d74
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c4_32_d_dsp.dts
@@ -0,0 +1,374 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+
+		cpu@2 {
+			device_type = "cpu";
+			reg = <0x2>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x4>;
+			};
+		};
+
+		cpu@3 {
+			device_type = "cpu";
+			reg = <0x3>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x5>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9 0x4 0xb 0x4 0x9 0x5 0xb 0x5 0x9>;
+			phandle = <0x6>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x4>;
+			interrupts-extended = <0x2 0x3 0x3 0x3 0x4 0x3 0x5 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7 0x4 0x7 0x5 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x7>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x6>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x6>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x6>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x6>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x6>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x7>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x6>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c4_32_dsp.dts b/arch/riscv/boot/dts/ae350_c4_32_dsp.dts
new file mode 100644
index 00000000..4f4f7d1c
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c4_32_dsp.dts
@@ -0,0 +1,374 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+
+		cpu@2 {
+			device_type = "cpu";
+			reg = <0x2>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x4>;
+			};
+		};
+
+		cpu@3 {
+			device_type = "cpu";
+			reg = <0x3>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv32i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv32";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x5>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9 0x4 0xb 0x4 0x9 0x5 0xb 0x5 0x9>;
+			phandle = <0x6>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x4>;
+			interrupts-extended = <0x2 0x3 0x3 0x3 0x4 0x3 0x5 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7 0x4 0x7 0x5 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x7>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x6>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x6>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x6>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x6>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x6>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x7>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x6>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c4_64.dts b/arch/riscv/boot/dts/ae350_c4_64.dts
new file mode 100644
index 00000000..fed14760
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c4_64.dts
@@ -0,0 +1,374 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+
+		cpu@2 {
+			device_type = "cpu";
+			reg = <0x2>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x4>;
+			};
+		};
+
+		cpu@3 {
+			device_type = "cpu";
+			reg = <0x3>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x5>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9 0x4 0xb 0x4 0x9 0x5 0xb 0x5 0x9>;
+			phandle = <0x6>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x4>;
+			interrupts-extended = <0x2 0x3 0x3 0x3 0x4 0x3 0x5 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7 0x4 0x7 0x5 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x7>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x6>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x6>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x6>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x6>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x6>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x7>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x6>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c4_64_d.dts b/arch/riscv/boot/dts/ae350_c4_64_d.dts
new file mode 100644
index 00000000..4fded8d4
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c4_64_d.dts
@@ -0,0 +1,374 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+
+		cpu@2 {
+			device_type = "cpu";
+			reg = <0x2>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x4>;
+			};
+		};
+
+		cpu@3 {
+			device_type = "cpu";
+			reg = <0x3>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x5>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9 0x4 0xb 0x4 0x9 0x5 0xb 0x5 0x9>;
+			phandle = <0x6>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x4>;
+			interrupts-extended = <0x2 0x3 0x3 0x3 0x4 0x3 0x5 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7 0x4 0x7 0x5 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x7>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x6>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x6>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x6>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x6>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x6>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x7>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x6>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c4_64_d_dsp.dts b/arch/riscv/boot/dts/ae350_c4_64_d_dsp.dts
new file mode 100644
index 00000000..db77d181
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c4_64_d_dsp.dts
@@ -0,0 +1,374 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+
+		cpu@2 {
+			device_type = "cpu";
+			reg = <0x2>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x4>;
+			};
+		};
+
+		cpu@3 {
+			device_type = "cpu";
+			reg = <0x3>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x5>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9 0x4 0xb 0x4 0x9 0x5 0xb 0x5 0x9>;
+			phandle = <0x6>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x4>;
+			interrupts-extended = <0x2 0x3 0x3 0x3 0x4 0x3 0x5 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7 0x4 0x7 0x5 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x7>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x6>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x6>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x6>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x6>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x6>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x7>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x6>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_c4_64_dsp.dts b/arch/riscv/boot/dts/ae350_c4_64_dsp.dts
new file mode 100644
index 00000000..fe9fc1be
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_c4_64_dsp.dts
@@ -0,0 +1,374 @@
+/dts-v1/;
+
+/ {
+	compatible = "andestech,ae350";
+	#address-cells = <0x2>;
+	#size-cells = <0x2>;
+	dma-coherent;
+
+	cpus {
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		timebase-frequency = <0x3938700>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x2>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x3>;
+			};
+		};
+
+		cpu@2 {
+			device_type = "cpu";
+			reg = <0x2>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x4>;
+			};
+		};
+
+		cpu@3 {
+			device_type = "cpu";
+			reg = <0x3>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64i2p0m2p0a2p0c2p0xv5-0p0xdsp0p0";
+			riscv,priv-major = <0x1>;
+			riscv,priv-minor = <0xa>;
+			mmu-type = "riscv,sv39";
+			clock-frequency = <0x3938700>;
+			i-cache-size = <0x8000>;
+			i-cache-line-size = <0x20>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <0x20>;
+			next-level-cache = <0x1>;
+
+			interrupt-controller {
+				#interrupt-cells = <0x1>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x5>;
+			};
+		};
+	};
+
+	l2-cache@e0500000 {
+		compatible = "cache";
+		cache-level = <0x2>;
+		cache-size = <0x40000>;
+		reg = <0x0 0xe0500000 0x0 0x40000>;
+		andes,inst-prefetch = <0x3>;
+		andes,data-prefetch = <0x3>;
+		andes,tag-ram-ctl = <0x0 0x0>;
+		andes,data-ram-ctl = <0x0 0x0>;
+		phandle = <0x1>;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x40000000>;
+	};
+
+	soc {
+		#address-cells = <0x2>;
+		#size-cells = <0x2>;
+		compatible = "andestech,riscv-ae350-soc";
+		ranges;
+
+		interrupt-controller@e4000000 {
+			compatible = "riscv,plic0";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe4000000 0x0 0x2000000>;
+			riscv,ndev = <0x47>;
+			interrupts-extended = <0x2 0xb 0x2 0x9 0x3 0xb 0x3 0x9 0x4 0xb 0x4 0x9 0x5 0xb 0x5 0x9>;
+			phandle = <0x6>;
+		};
+
+		interrupt-controller@e6400000 {
+			compatible = "riscv,plic1";
+			#address-cells = <0x2>;
+			#interrupt-cells = <0x2>;
+			interrupt-controller;
+			reg = <0x0 0xe6400000 0x0 0x400000>;
+			riscv,ndev = <0x4>;
+			interrupts-extended = <0x2 0x3 0x3 0x3 0x4 0x3 0x5 0x3>;
+		};
+
+		plmt0@e6000000 {
+			compatible = "riscv,plmt0";
+			reg = <0x0 0xe6000000 0x0 0x100000>;
+			interrupts-extended = <0x2 0x7 0x3 0x7 0x4 0x7 0x5 0x7>;
+		};
+	};
+
+	virt_100mhz {
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x5f5e100>;
+		phandle = <0x7>;
+	};
+
+	smu@f0100000 {
+		compatible = "andestech,atcsmu";
+		reg = <0x0 0xf0100000 0x0 0x1000>;
+	};
+
+	wdt@f0500000 {
+		compatible = "andestech,atcwdt200";
+		interrupts = <0x0 0x4>;
+		reg = <0x0 0xf0500000 0x0 0x1000>;
+		clock-frequency = <0xe4e1c0>;
+		interrupt-parent = <0x6>;
+	};
+
+	timer@f0400000 {
+		compatible = "andestech,atcpit100";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	serial@f0300000 {
+		compatible = "andestech,uart16550", "ns16550a";
+		reg = <0x0 0xf0300000 0x0 0x1000>;
+		interrupts = <0x9 0x4>;
+		clock-frequency = <0x12c0000>;
+		reg-shift = <0x2>;
+		reg-offset = <0x20>;
+		no-loopback-test = <0x1>;
+		interrupt-parent = <0x6>;
+	};
+
+	gpio@f0700000 {
+		compatible = "andestech,atcgpio100";
+		reg = <0x0 0xf0700000 0x0 0x1000>;
+		interrupts = <0x7 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	rtc@f0600000 {
+		compatible = "andestech,atcrtc100";
+		reg = <0x0 0xf0600000 0x0 0x1000>;
+		interrupts = <0x1 0x4 0x2 0x4>;
+		interrupt-parent = <0x6>;
+		wakeup-source;
+	};
+
+	mac@e0100000 {
+		compatible = "andestech,atmac100";
+		reg = <0x0 0xe0100000 0x0 0x1000>;
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	mmc@f0e00000 {
+		compatible = "andestech,atfsdc010";
+		max-frequency = <0x5f5e100>;
+		clock-freq-min-max = <0x61a80 0x5f5e100>;
+		fifo-depth = <0x10>;
+		reg = <0x0 0xf0e00000 0x0 0x1000>;
+		interrupts = <0x12 0x4>;
+		cap-sd-highspeed;
+		interrupt-parent = <0x6>;
+	};
+
+	dma@f0c00000 {
+		compatible = "andestech,atcdmac300";
+		reg = <0x0 0xf0c00000 0x0 0x1000>;
+		interrupts = <0xa 0x4 0x40 0x4 0x41 0x4 0x42 0x4 0x43 0x4 0x44 0x4 0x45 0x4 0x46 0x4 0x47 0x4>;
+		dma-channels = <0x8>;
+		interrupt-parent = <0x6>;
+	};
+
+	lcd@e0200000 {
+		compatible = "andestech,atflcdc100";
+		reg = <0x0 0xe0200000 0x0 0x1000>;
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	smc@e0400000 {
+		compatible = "andestech,atfsmc020";
+		reg = <0x0 0xe0400000 0x0 0x1000>;
+	};
+
+	snd@f0d00000 {
+		compatible = "andestech,atfac97";
+		reg = <0x0 0xf0d00000 0x0 0x1000>;
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	pmu {
+		device_type = "pmu";
+		compatible = "riscv,andes-pmu";
+	};
+
+	virtio_mmio@fe007000 {
+		interrupts = <0x17 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe007000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe006000 {
+		interrupts = <0x16 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe006000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe005000 {
+		interrupts = <0x15 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe005000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe004000 {
+		interrupts = <0x14 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe004000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe003000 {
+		interrupts = <0x13 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe003000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe002000 {
+		interrupts = <0x12 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe002000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe001000 {
+		interrupts = <0x11 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe001000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	virtio_mmio@fe000000 {
+		interrupts = <0x10 0x4>;
+		interrupt-parent = <0x2>;
+		reg = <0x0 0xfe000000 0x0 0x1000>;
+		compatible = "virtio,mmio";
+	};
+
+	nor@0,0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x88000000 0x0 0x1000>;
+		bank-width = <0x2>;
+		device-width = <0x1>;
+	};
+
+	spi@f0b00000 {
+		compatible = "andestech,atcspi200";
+		reg = <0x0 0xf0b00000 0x0 0x1000>;
+		#address-cells = <0x1>;
+		#size-cells = <0x0>;
+		num-cs = <0x1>;
+		clocks = <0x7>;
+		interrupts = <0x4 0x4>;
+		interrupt-parent = <0x6>;
+
+		flash@0 {
+			compatible = "mx25u1635e", "jedec,spi-nor";
+			spi-max-frequency = <0x2faf080>;
+			reg = <0x0>;
+			spi-cpol;
+			spi-cpha;
+		};
+	};
+
+	pwm@f0400000 {
+		compatible = "andestech,atcpit100-pwm";
+		reg = <0x0 0xf0400000 0x0 0x1000>;
+		clock-frequency = <0x3938700>;
+		interrupts = <0x3 0x4>;
+		interrupt-parent = <0x6>;
+		pwm-cells = <0x2>;
+	};
+
+	i2c@f0a00000 {
+		compatible = "andestech,atciic100";
+		reg = <0x0 0xf0a00000 0x0 0x1000>;
+		interrupts = <0x6 0x4>;
+		interrupt-parent = <0x6>;
+	};
+
+	aliases {
+		uart0 = "/serial@f0300000";
+		spi0 = "/spi@f0b00000";
+		i2c0 = "/i2c@f0a00000";
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+		stdout-path = "uart0:38400n8";
+	};
+};
diff --git a/arch/riscv/boot/dts/ae350_rv32_coherent.dts b/arch/riscv/boot/dts/ae350_rv32_coherent.dts
new file mode 100644
index 00000000..a1c17280
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_rv32_coherent.dts
@@ -0,0 +1,286 @@
+/dts-v1/;
+
+/ {
+  #address-cells = <1>;
+  #size-cells = <1>;
+  compatible = "andestech,a25";
+  model = "andestech,a25";
+  dma-coherent;
+
+  aliases {
+    uart0 = &serial0;
+    spi0 = &spi;
+  } ;
+
+  chosen {
+    bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+    stdout-path = "uart0:38400n8";
+  };
+
+  cpus {
+    #address-cells = <1>;
+    #size-cells = <0>;
+    timebase-frequency = <60000000>;
+    CPU0: cpu@0 {
+      device_type = "cpu";
+      reg = <0>;
+      status = "okay";
+      compatible = "riscv";
+      riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+      riscv,priv-major = <1>;
+      riscv,priv-minor = <10>;
+      mmu-type = "riscv,sv32";
+      clock-frequency = <60000000>;
+      i-cache-size = <0x8000>;
+      i-cache-line-size = <32>;
+      d-cache-size = <0x8000>;
+      d-cache-line-size = <32>;
+      next-level-cache = <&L2>;
+      CPU0_intc: interrupt-controller {
+        #interrupt-cells = <1>;
+        interrupt-controller;
+        compatible = "riscv,cpu-intc";
+      };
+    };
+  };
+
+  L2: l2-cache@e0500000 {
+    compatible = "cache";
+    cache-level = <2>;
+    cache-size = <0x40000>;
+    reg = <0xe0500000 0x40000>;
+    andes,inst-prefetch = <3>;
+    andes,data-prefetch = <3>;
+    // The value format is <XRAMOCTL XRAMICTL>
+    andes,tag-ram-ctl = <0 0>;
+    andes,data-ram-ctl = <0 0>;
+  };
+
+  memory@0 {
+    device_type = "memory";
+    reg = <0x00000000 0x40000000>;
+  };
+
+  soc {
+    #address-cells = <1>;
+    #size-cells = <1>;
+    compatible = "simple-bus";
+    ranges;
+
+    plic0: interrupt-controller@e4000000 {
+      compatible = "riscv,plic0";
+      #address-cells = <1>;
+      #interrupt-cells = <2>;
+      interrupt-controller;
+      reg = <0xe4000000 0x2000000>;
+      riscv,ndev=<71>;
+      interrupts-extended = <&CPU0_intc 11 &CPU0_intc 9>;
+    };
+
+    plic1: interrupt-controller@e6400000 {
+      compatible = "riscv,plic1";
+      #address-cells = <1>;
+      #interrupt-cells = <1>;
+      interrupt-controller;
+      reg = <0xe6400000 0x400000>;
+      riscv,ndev=<1>;
+      interrupts-extended = <&CPU0_intc 3>;
+    };
+
+    plmt0@e6000000 {
+      compatible = "riscv,plmt0";
+      interrupts-extended = <&CPU0_intc 7>;
+      reg = <0xe6000000 0x100000>;
+    };
+  };
+
+  spiclk: virt_100mhz {
+    #clock-cells = <0>;
+    compatible = "fixed-clock";
+    clock-frequency = <100000000>;
+  };
+
+  smu: smu@f0100000 {
+    compatible = "andestech,atcsmu";
+    reg = <0xf0100000 0x1000>;
+  };
+
+  wdt0: wdt@f0500000 {
+    compatible = "andestech,atcwdt200";
+    reg = <0xf0500000 0x1000>;
+    clock-frequency = <15000000>;
+    interrupt-parent = <&plic0>;
+  };
+
+  timer0: timer@f0400000 {
+    compatible = "andestech,atcpit100";
+    reg = <0xf0400000 0x1000>;
+    clock-frequency = <60000000>;
+    interrupts = <3 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  serial0: serial@f0300000 {
+    compatible = "andestech,uart16550", "ns16550a";
+    reg = <0xf0300000 0x1000>;
+    interrupts = <9 4>;
+    clock-frequency = <19660800>;
+    reg-shift = <2>;
+    reg-offset = <32>;
+    no-loopback-test = <1>;
+    interrupt-parent = <&plic0>;
+  };
+
+   gpio0: gpio@f0700000 {
+    compatible = "andestech,atcgpio100";
+    reg = <0x0 0xf0700000 0x0 0x00001000>;
+    interrupts = <7 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  rtc0: rtc@f0600000 {
+    compatible = "andestech,atcrtc100";
+    reg = <0xf0600000 0x1000>;
+    interrupts = <1 4>, <2 4>;
+    interrupt-parent = <&plic0>;
+    wakeup-source;
+  };
+  mac0: mac@e0100000 {
+    compatible = "andestech,atmac100";
+    reg = <0xe0100000 0x1000>;
+    interrupts = <19 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  mmc0: mmc@f0e00000 {
+    compatible = "andestech,atfsdc010";
+    max-frequency = <100000000>;
+    clock-freq-min-max = <400000 100000000>;
+    fifo-depth = <0x10>;
+    reg = <0xf0e00000 0x1000>;
+    interrupts = <18 4>;
+    cap-sd-highspeed;
+    interrupt-parent = <&plic0>;
+  };
+
+  dma0: dma@f0c00000 {
+    compatible = "andestech,atcdmac300";
+    reg = <0xf0c00000 0x1000>;
+    interrupts = <10 4 64 4 65 4 66 4 67 4 68 4 69 4 70 4 71 4>;
+    dma-channels = <8>;
+    interrupt-parent = <&plic0>;
+  };
+
+  lcd0: lcd@e0200000 {
+    compatible = "andestech,atflcdc100";
+    reg = <0xe0200000 0x1000>;
+    interrupts = <20 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  smc0: smc@e0400000 {
+    compatible = "andestech,atfsmc020";
+    reg = <0xe0400000 0x1000>;
+  };
+
+  snd0: snd@f0d00000 {
+    compatible = "andestech,atfac97";
+    reg = <0xf0d00000 0x1000>;
+    interrupts = <17 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  pmu {
+    device_type = "pmu";
+    compatible = "riscv,andes-pmu";
+  };
+
+  virtio_mmio@fe007000 {
+    interrupts = <0x17 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe007000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe006000 {
+    interrupts = <0x16 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe006000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe005000 {
+    interrupts = <0x15 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe005000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe004000 {
+    interrupts = <0x14 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe004000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe003000 {
+    interrupts = <0x13 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe003000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe002000 {
+    interrupts = <0x12 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe002000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe001000 {
+    interrupts = <0x11 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe001000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe000000 {
+    interrupts = <0x10 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe000000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+
+  nor@0,0 {
+    compatible = "cfi-flash";
+    reg = <0x88000000 0x1000>;
+    bank-width = <2>;
+    device-width = <1>;
+  };
+
+  spi: spi@f0b00000 {
+    compatible = "andestech,atcspi200";
+    reg = <0xf0b00000 0x1000>;
+    #address-cells = <1>;
+    #size-cells = <0>;
+    num-cs = <1>;
+    clocks = <&spiclk>;
+    interrupts = <4 4>;
+    interrupt-parent = <&plic0>;
+    flash@0 {
+      compatible = "mx25u1635e", "jedec,spi-nor";
+      spi-max-frequency = <50000000>;
+      reg = <0>;
+      spi-cpol;
+      spi-cpha;
+    };
+  };
+
+  i2c: i2c@f0a00000 {
+    compatible = "andestech,atciic100";
+    reg = <0xf0a00000 0x1000>;
+    interrupts = <0x6 0x4>;
+    interrupt-parent = <&plic0>;
+  };
+};
diff --git a/arch/riscv/boot/dts/ae350_rv32_noncoherent.dts b/arch/riscv/boot/dts/ae350_rv32_noncoherent.dts
new file mode 100644
index 00000000..58af511a
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_rv32_noncoherent.dts
@@ -0,0 +1,272 @@
+/dts-v1/;
+
+/ {
+  #address-cells = <1>;
+  #size-cells = <1>;
+  compatible = "andestech,a25";
+  model = "andestech,a25";
+
+  aliases {
+    uart0 = &serial0;
+    spi0 = &spi;
+  } ;
+
+  chosen {
+    bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+    stdout-path = "uart0:38400n8";
+  };
+
+  cpus {
+    #address-cells = <1>;
+    #size-cells = <0>;
+    timebase-frequency = <60000000>;
+    CPU0: cpu@0 {
+      device_type = "cpu";
+      reg = <0>;
+      status = "okay";
+      compatible = "riscv";
+      riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+      riscv,priv-major = <1>;
+      riscv,priv-minor = <10>;
+      mmu-type = "riscv,sv32";
+      clock-frequency = <60000000>;
+      i-cache-size = <0x8000>;
+      i-cache-line-size = <32>;
+      d-cache-size = <0x8000>;
+      d-cache-line-size = <32>;
+      CPU0_intc: interrupt-controller {
+        #interrupt-cells = <1>;
+        interrupt-controller;
+        compatible = "riscv,cpu-intc";
+      };
+    };
+  };
+
+  memory@0 {
+    device_type = "memory";
+    reg = <0x00000000 0x40000000>;
+  };
+
+  soc {
+    #address-cells = <1>;
+    #size-cells = <1>;
+    compatible = "simple-bus";
+    ranges;
+
+    plic0: interrupt-controller@e4000000 {
+      compatible = "riscv,plic0";
+      #address-cells = <1>;
+      #interrupt-cells = <2>;
+      interrupt-controller;
+      reg = <0xe4000000 0x2000000>;
+      riscv,ndev=<71>;
+      interrupts-extended = <&CPU0_intc 11 &CPU0_intc 9>;
+    };
+
+    plic1: interrupt-controller@e6400000 {
+      compatible = "riscv,plic1";
+      #address-cells = <1>;
+      #interrupt-cells = <1>;
+      interrupt-controller;
+      reg = <0xe6400000 0x400000>;
+      riscv,ndev=<1>;
+      interrupts-extended = <&CPU0_intc 3>;
+    };
+
+    plmt0@e6000000 {
+      compatible = "riscv,plmt0";
+      interrupts-extended = <&CPU0_intc 7>;
+      reg = <0xe6000000 0x100000>;
+    };
+  };
+
+  spiclk: virt_100mhz {
+    #clock-cells = <0>;
+    compatible = "fixed-clock";
+    clock-frequency = <100000000>;
+  };
+
+  smu: smu@f0100000 {
+    compatible = "andestech,atcsmu";
+    reg = <0xf0100000 0x1000>;
+  };
+
+  wdt0: wdt@f0500000 {
+    compatible = "andestech,atcwdt200";
+    reg = <0xf0500000 0x1000>;
+    clock-frequency = <15000000>;
+    interrupt-parent = <&plic0>;
+  };
+
+  timer0: timer@f0400000 {
+    compatible = "andestech,atcpit100";
+    reg = <0xf0400000 0x1000>;
+    clock-frequency = <60000000>;
+    interrupts = <3 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  serial0: serial@f0300000 {
+    compatible = "andestech,uart16550", "ns16550a";
+    reg = <0xf0300000 0x1000>;
+    interrupts = <9 4>;
+    clock-frequency = <19660800>;
+    reg-shift = <2>;
+    reg-offset = <32>;
+    no-loopback-test = <1>;
+    interrupt-parent = <&plic0>;
+  };
+
+  gpio0: gpio@f0700000 {
+    compatible = "andestech,atcgpio100";
+    reg = <0x0 0xf0700000 0x0 0x00001000>;
+    interrupts = <7 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  rtc0: rtc@f0600000 {
+    compatible = "andestech,atcrtc100";
+    reg = <0xf0600000 0x1000>;
+    interrupts = <1 4>, <2 4>;
+    interrupt-parent = <&plic0>;
+    wakeup-source;
+  };
+  mac0: mac@e0100000 {
+    compatible = "andestech,atmac100";
+    reg = <0xe0100000 0x1000>;
+    interrupts = <19 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  mmc0: mmc@f0e00000 {
+    compatible = "andestech,atfsdc010";
+    max-frequency = <100000000>;
+    clock-freq-min-max = <400000 100000000>;
+    fifo-depth = <0x10>;
+    reg = <0xf0e00000 0x1000>;
+    interrupts = <18 4>;
+    cap-sd-highspeed;
+    interrupt-parent = <&plic0>;
+  };
+
+  dma0: dma@f0c00000 {
+    compatible = "andestech,atcdmac300";
+    reg = <0xf0c00000 0x1000>;
+    interrupts = <10 4 64 4 65 4 66 4 67 4 68 4 69 4 70 4 71 4>;
+    dma-channels = <8>;
+    interrupt-parent = <&plic0>;
+  };
+
+  lcd0: lcd@e0200000 {
+    compatible = "andestech,atflcdc100";
+    reg = <0xe0200000 0x1000>;
+    interrupts = <20 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  smc0: smc@e0400000 {
+    compatible = "andestech,atfsmc020";
+    reg = <0xe0400000 0x1000>;
+  };
+
+  snd0: snd@f0d00000 {
+    compatible = "andestech,atfac97";
+    reg = <0xf0d00000 0x1000>;
+    interrupts = <17 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  pmu {
+    device_type = "pmu";
+    compatible = "riscv,andes-pmu";
+  };
+
+  virtio_mmio@fe007000 {
+    interrupts = <0x17 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe007000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe006000 {
+    interrupts = <0x16 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe006000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe005000 {
+    interrupts = <0x15 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe005000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe004000 {
+    interrupts = <0x14 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe004000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe003000 {
+    interrupts = <0x13 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe003000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe002000 {
+    interrupts = <0x12 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe002000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe001000 {
+    interrupts = <0x11 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe001000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe000000 {
+    interrupts = <0x10 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe000000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+
+  nor@0,0 {
+    compatible = "cfi-flash";
+    reg = <0x88000000 0x1000>;
+    bank-width = <2>;
+    device-width = <1>;
+  };
+
+  spi: spi@f0b00000 {
+    compatible = "andestech,atcspi200";
+    reg = <0xf0b00000 0x1000>;
+    #address-cells = <1>;
+    #size-cells = <0>;
+    num-cs = <1>;
+    clocks = <&spiclk>;
+    interrupts = <4 4>;
+    interrupt-parent = <&plic0>;
+    flash@0 {
+      compatible = "mx25u1635e", "jedec,spi-nor";
+      spi-max-frequency = <50000000>;
+      reg = <0>;
+      spi-cpol;
+      spi-cpha;
+    };
+  };
+
+  i2c: i2c@f0a00000 {
+    compatible = "andestech,atciic100";
+    reg = <0xf0a00000 0x1000>;
+    interrupts = <0x6 0x4>;
+    interrupt-parent = <&plic0>;
+  };
+};
diff --git a/arch/riscv/boot/dts/ae350_rv32_smp_coherent.dts b/arch/riscv/boot/dts/ae350_rv32_smp_coherent.dts
new file mode 100644
index 00000000..9f907ff8
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_rv32_smp_coherent.dts
@@ -0,0 +1,309 @@
+/dts-v1/;
+
+/ {
+  #address-cells = <1>;
+  #size-cells = <1>;
+  compatible = "andestech,a25";
+  model = "andestech,a25";
+  dma-coherent;
+
+  aliases {
+    uart0 = &serial0;
+    spi0 = &spi;
+  } ;
+
+  chosen {
+    bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+    stdout-path = "uart0:38400n8";
+  };
+
+  cpus {
+    #address-cells = <1>;
+    #size-cells = <0>;
+    timebase-frequency = <60000000>;
+    CPU0: cpu@0 {
+      device_type = "cpu";
+      reg = <0>;
+      status = "okay";
+      compatible = "riscv";
+      riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+      riscv,priv-major = <1>;
+      riscv,priv-minor = <10>;
+      mmu-type = "riscv,sv32";
+      clock-frequency = <60000000>;
+      i-cache-size = <0x8000>;
+      i-cache-line-size = <32>;
+      d-cache-size = <0x8000>;
+      d-cache-line-size = <32>;
+      next-level-cache = <&L2>;
+      CPU0_intc: interrupt-controller {
+        #interrupt-cells = <1>;
+        interrupt-controller;
+        compatible = "riscv,cpu-intc";
+      };
+    };
+    CPU1: cpu@1 {
+      device_type = "cpu";
+      reg = <1>;
+      status = "okay";
+      compatible = "riscv";
+      riscv,isa = "rv32i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+      riscv,priv-major = <1>;
+      riscv,priv-minor = <10>;
+      mmu-type = "riscv,sv32";
+      clock-frequency = <60000000>;
+      i-cache-size = <0x8000>;
+      i-cache-line-size = <32>;
+      d-cache-size = <0x8000>;
+      d-cache-line-size = <32>;
+      next-level-cache = <&L2>;
+      CPU1_intc: interrupt-controller {
+        #interrupt-cells = <1>;
+        interrupt-controller;
+        compatible = "riscv,cpu-intc";
+      };
+    };
+  };
+
+  L2: l2-cache@e0500000 {
+    compatible = "cache";
+    cache-level = <2>;
+    cache-size = <0x40000>;
+    reg = <0xe0500000 0x40000>;
+    andes,inst-prefetch = <3>;
+    andes,data-prefetch = <3>;
+    // The value format is <XRAMOCTL XRAMICTL>
+    andes,tag-ram-ctl = <0 0>;
+    andes,data-ram-ctl = <0 0>;
+  };
+
+  memory@0 {
+    device_type = "memory";
+    reg = <0x00000000 0x40000000>;
+  };
+
+  soc {
+    #address-cells = <1>;
+    #size-cells = <1>;
+    compatible = "simple-bus";
+    ranges;
+
+    plic0: interrupt-controller@e4000000 {
+      compatible = "riscv,plic0";
+      #address-cells = <1>;
+      #interrupt-cells = <2>;
+      interrupt-controller;
+      reg = <0xe4000000 0x2000000>;
+      riscv,ndev=<71>;
+      interrupts-extended = <&CPU0_intc 11 &CPU0_intc 9
+                             &CPU1_intc 11 &CPU1_intc 9>;
+    };
+
+    plic1: interrupt-controller@e6400000 {
+      compatible = "riscv,plic1";
+      #address-cells = <1>;
+      #interrupt-cells = <1>;
+      interrupt-controller;
+      reg = <0xe6400000 0x400000>;
+      riscv,ndev=<2>;
+      interrupts-extended = <&CPU0_intc 3 &CPU1_intc 3>;
+    };
+
+    plmt0@e6000000 {
+      compatible = "riscv,plmt0";
+      interrupts-extended = <&CPU0_intc 7 &CPU1_intc 7>;
+      reg = <0xe6000000 0x100000>;
+    };
+  };
+
+  spiclk: virt_100mhz {
+    #clock-cells = <0>;
+    compatible = "fixed-clock";
+    clock-frequency = <100000000>;
+  };
+
+  smu: smu@f0100000 {
+    compatible = "andestech,atcsmu";
+    reg = <0xf0100000 0x1000>;
+  };
+
+  wdt0: wdt@f0500000 {
+    compatible = "andestech,atcwdt200";
+    reg = <0xf0500000 0x1000>;
+    clock-frequency = <15000000>;
+    interrupt-parent = <&plic0>;
+  };
+
+  timer0: timer@f0400000 {
+    compatible = "andestech,atcpit100";
+    reg = <0xf0400000 0x1000>;
+    clock-frequency = <60000000>;
+    interrupts = <3 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  serial0: serial@f0300000 {
+    compatible = "andestech,uart16550", "ns16550a";
+    reg = <0xf0300000 0x1000>;
+    interrupts = <9 4>;
+    clock-frequency = <19660800>;
+    reg-shift = <2>;
+    reg-offset = <32>;
+    no-loopback-test = <1>;
+    interrupt-parent = <&plic0>;
+  };
+
+  gpio0: gpio@f0700000 {
+    compatible = "andestech,atcgpio100";
+    reg = <0x0 0xf0700000 0x0 0x00001000>;
+    interrupts = <7 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  rtc0: rtc@f0600000 {
+    compatible = "andestech,atcrtc100";
+    reg = <0xf0600000 0x1000>;
+    interrupts = <1 4>, <2 4>;
+    interrupt-parent = <&plic0>;
+    wakeup-source;
+  };
+
+  mac0: mac@e0100000 {
+    compatible = "andestech,atmac100";
+    reg = <0xe0100000 0x1000>;
+    interrupts = <19 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  mmc0: mmc@f0e00000 {
+    compatible = "andestech,atfsdc010";
+    max-frequency = <100000000>;
+    clock-freq-min-max = <400000 100000000>;
+    fifo-depth = <0x10>;
+    reg = <0xf0e00000 0x1000>;
+    interrupts = <18 4>;
+    cap-sd-highspeed;
+    interrupt-parent = <&plic0>;
+  };
+
+  dma0: dma@f0c00000 {
+    compatible = "andestech,atcdmac300";
+    reg = <0xf0c00000 0x1000>;
+    interrupts = <10 4 64 4 65 4 66 4 67 4 68 4 69 4 70 4 71 4>;
+    dma-channels = <8>;
+    interrupt-parent = <&plic0>;
+  };
+
+  lcd0: lcd@e0200000 {
+    compatible = "andestech,atflcdc100";
+    reg = <0xe0200000 0x1000>;
+    interrupts = <20 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  smc0: smc@e0400000 {
+    compatible = "andestech,atfsmc020";
+    reg = <0xe0400000 0x1000>;
+  };
+
+  snd0: snd@f0d00000 {
+    compatible = "andestech,atfac97";
+    reg = <0xf0d00000 0x1000>;
+    interrupts = <17 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  pmu {
+    device_type = "pmu";
+    compatible = "riscv,andes-pmu";
+  };
+
+  virtio_mmio@fe007000 {
+    interrupts = <0x17 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe007000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe006000 {
+    interrupts = <0x16 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe006000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe005000 {
+    interrupts = <0x15 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe005000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe004000 {
+    interrupts = <0x14 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe004000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe003000 {
+    interrupts = <0x13 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe003000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe002000 {
+    interrupts = <0x12 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe002000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe001000 {
+    interrupts = <0x11 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe001000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe000000 {
+    interrupts = <0x10 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0xfe000000 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+
+  nor@0,0 {
+    compatible = "cfi-flash";
+    reg = <0x88000000 0x1000>;
+    bank-width = <2>;
+    device-width = <1>;
+  };
+
+  spi: spi@f0b00000 {
+    compatible = "andestech,atcspi200";
+    reg = <0xf0b00000 0x1000>;
+    #address-cells = <1>;
+    #size-cells = <0>;
+    num-cs = <1>;
+    clocks = <&spiclk>;
+    interrupts = <4 4>;
+    interrupt-parent = <&plic0>;
+    flash@0 {
+      compatible = "mx25u1635e", "jedec,spi-nor";
+      spi-max-frequency = <50000000>;
+      reg = <0>;
+      spi-cpol;
+      spi-cpha;
+    };
+  };
+
+  i2c: i2c@f0a00000 {
+    compatible = "andestech,atciic100";
+    reg = <0xf0a00000 0x1000>;
+    interrupts = <0x6 0x4>;
+    interrupt-parent = <&plic0>;
+  };
+};
diff --git a/arch/riscv/boot/dts/ae350_rv64_coherent.dts b/arch/riscv/boot/dts/ae350_rv64_coherent.dts
new file mode 100644
index 00000000..787d775d
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_rv64_coherent.dts
@@ -0,0 +1,287 @@
+/dts-v1/;
+
+/ {
+  #address-cells = <2>;
+  #size-cells = <2>;
+  compatible = "andestech,ax25";
+  model = "andestech,ax25";
+  dma-coherent;
+
+  aliases {
+    uart0 = &serial0;
+    spi0 = &spi;
+  } ;
+
+  chosen {
+    bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+    stdout-path = "uart0:38400n8";
+  };
+
+  cpus {
+    #address-cells = <1>;
+    #size-cells = <0>;
+    timebase-frequency = <60000000>;
+    CPU0: cpu@0 {
+      device_type = "cpu";
+      reg = <0>;
+      status = "okay";
+      compatible = "riscv";
+      riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+      riscv,priv-major = <1>;
+      riscv,priv-minor = <10>;
+      mmu-type = "riscv,sv39";
+      clock-frequency = <60000000>;
+      i-cache-size = <0x8000>;
+      i-cache-line-size = <32>;
+      d-cache-size = <0x8000>;
+      d-cache-line-size = <32>;
+      next-level-cache = <&L2>;
+      CPU0_intc: interrupt-controller {
+        #interrupt-cells = <1>;
+        interrupt-controller;
+        compatible = "riscv,cpu-intc";
+      };
+    };
+  };
+
+  L2: l2-cache@e0500000 {
+    compatible = "cache";
+    cache-level = <2>;
+    cache-size = <0x40000>;
+    reg = <0x0 0xe0500000 0x0 0x40000>;
+    andes,inst-prefetch = <3>;
+    andes,data-prefetch = <3>;
+    // The value format is <XRAMOCTL XRAMICTL>
+    andes,tag-ram-ctl = <0 0>;
+    andes,data-ram-ctl = <0 0>;
+  };
+
+  memory@0 {
+    device_type = "memory";
+    reg = <0x0 0x00000000 0x0 0x40000000>;
+  };
+
+  soc {
+    #address-cells = <2>;
+    #size-cells = <2>;
+    compatible = "simple-bus";
+    ranges;
+
+    plic0: interrupt-controller@e4000000 {
+      compatible = "riscv,plic0";
+      #address-cells = <2>;
+      #interrupt-cells = <2>;
+      interrupt-controller;
+      reg = <0x0 0xe4000000 0x0 0x2000000>;
+      riscv,ndev=<71>;
+      interrupts-extended = <&CPU0_intc 11 &CPU0_intc 9>;
+    };
+
+    plic1: interrupt-controller@e6400000 {
+      compatible = "riscv,plic1";
+      #address-cells = <2>;
+      #interrupt-cells = <2>;
+      interrupt-controller;
+      reg = <0x0 0xe6400000 0x0 0x400000>;
+      riscv,ndev=<1>;
+      interrupts-extended = <&CPU0_intc 3>;
+    };
+
+    plmt0@e6000000 {
+      compatible = "riscv,plmt0";
+      interrupts-extended = <&CPU0_intc 7>;
+      reg = <0x0 0xe6000000 0x0 0x100000>;
+    };
+  };
+
+  spiclk: virt_100mhz {
+    #clock-cells = <0>;
+    compatible = "fixed-clock";
+    clock-frequency = <100000000>;
+  };
+
+  smu: smu@f0100000 {
+    compatible = "andestech,atcsmu";
+    reg = <0x0 0xf0100000 0x0 0x1000>;
+  };
+
+  wdt0: wdt@f0500000 {
+    compatible = "andestech,atcwdt200";
+    reg = <0x0 0xf0500000 0x0 0x1000>;
+    clock-frequency = <15000000>;
+    interrupt-parent = <&plic0>;
+  };
+
+  timer0: timer@f0400000 {
+    compatible = "andestech,atcpit100";
+    reg = <0x0 0xf0400000 0x0 0x1000>;
+    clock-frequency = <60000000>;
+    interrupts = <3 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  serial0: serial@f0300000 {
+    compatible = "andestech,uart16550", "ns16550a";
+    reg = <0x0 0xf0300000 0x0 0x1000>;
+    interrupts = <9 4>;
+    clock-frequency = <19660800>;
+    reg-shift = <2>;
+    reg-offset = <32>;
+    no-loopback-test = <1>;
+    interrupt-parent = <&plic0>;
+  };
+
+  gpio0: gpio@f0700000 {
+    compatible = "andestech,atcgpio100";
+    reg = <0x0 0xf0700000 0x0 0x00001000>;
+    interrupts = <7 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  rtc0: rtc@f0600000 {
+    compatible = "andestech,atcrtc100";
+    reg = <0x0 0xf0600000 0x0 0x1000>;
+    interrupts = <1 4>, <2 4>;
+    interrupt-parent = <&plic0>;
+    wakeup-source;
+  };
+
+  mac0: mac@e0100000 {
+    compatible = "andestech,atmac100";
+    reg = <0x0 0xe0100000 0x0 0x1000>;
+    interrupts = <19 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  mmc0: mmc@f0e00000 {
+    compatible = "andestech,atfsdc010";
+    max-frequency = <100000000>;
+    clock-freq-min-max = <400000 100000000>;
+    fifo-depth = <0x10>;
+    reg = <0x0 0xf0e00000 0x0 0x1000>;
+    interrupts = <18 4>;
+    cap-sd-highspeed;
+    interrupt-parent = <&plic0>;
+  };
+
+  dma0: dma@f0c00000 {
+    compatible = "andestech,atcdmac300";
+    reg = <0x0 0xf0c00000 0x0 0x1000>;
+    interrupts = <10 4 64 4 65 4 66 4 67 4 68 4 69 4 70 4 71 4>;
+    dma-channels = <8>;
+    interrupt-parent = <&plic0>;
+  };
+
+  lcd0: lcd@e0200000 {
+    compatible = "andestech,atflcdc100";
+    reg = <0x0 0xe0200000 0x0 0x1000>;
+    interrupts = <20 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  smc0: smc@e0400000 {
+    compatible = "andestech,atfsmc020";
+    reg = <0x0 0xe0400000 0x0 0x1000>;
+  };
+
+  snd0: snd@f0d00000 {
+    compatible = "andestech,atfac97";
+    reg = <0x0 0xf0d00000 0x0 0x1000>;
+    interrupts = <17 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  pmu {
+    device_type = "pmu";
+    compatible = "riscv,andes-pmu";
+  };
+
+  virtio_mmio@fe007000 {
+    interrupts = <0x17 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe007000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe006000 {
+    interrupts = <0x16 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe006000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe005000 {
+    interrupts = <0x15 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe005000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe004000 {
+    interrupts = <0x14 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe004000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe003000 {
+    interrupts = <0x13 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe003000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe002000 {
+    interrupts = <0x12 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe002000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe001000 {
+    interrupts = <0x11 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe001000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe000000 {
+    interrupts = <0x10 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe000000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+
+  nor@0,0 {
+    compatible = "cfi-flash";
+    reg = <0x0 0x88000000 0x0 0x1000>;
+    bank-width = <2>;
+    device-width = <1>;
+  };
+
+  spi: spi@f0b00000 {
+    compatible = "andestech,atcspi200";
+    reg = <0x0 0xf0b00000 0x0 0x1000>;
+    #address-cells = <1>;
+    #size-cells = <0>;
+    num-cs = <1>;
+    clocks = <&spiclk>;
+    interrupts = <4 4>;
+    interrupt-parent = <&plic0>;
+    flash@0 {
+      compatible = "mx25u1635e", "jedec,spi-nor";
+      spi-max-frequency = <50000000>;
+      reg = <0>;
+      spi-cpol;
+      spi-cpha;
+    };
+  };
+
+  i2c: i2c@f0a00000 {
+    compatible = "andestech,atciic100";
+    reg = <0x0 0xf0a00000 0x0 0x1000>;
+    interrupts = <6 4>;
+    interrupt-parent = <&plic0>;
+  };
+};
diff --git a/arch/riscv/boot/dts/ae350_rv64_noncoherent.dts b/arch/riscv/boot/dts/ae350_rv64_noncoherent.dts
new file mode 100644
index 00000000..e78731d4
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_rv64_noncoherent.dts
@@ -0,0 +1,273 @@
+/dts-v1/;
+
+/ {
+  #address-cells = <2>;
+  #size-cells = <2>;
+  compatible = "andestech,ax25";
+  model = "andestech,ax25";
+
+  aliases {
+    uart0 = &serial0;
+    spi0 = &spi;
+  } ;
+
+  chosen {
+    bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+    stdout-path = "uart0:38400n8";
+  };
+
+  cpus {
+    #address-cells = <1>;
+    #size-cells = <0>;
+    timebase-frequency = <60000000>;
+    CPU0: cpu@0 {
+      device_type = "cpu";
+      reg = <0>;
+      status = "okay";
+      compatible = "riscv";
+      riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+      riscv,priv-major = <1>;
+      riscv,priv-minor = <10>;
+      mmu-type = "riscv,sv39";
+      clock-frequency = <60000000>;
+      i-cache-size = <0x8000>;
+      i-cache-line-size = <32>;
+      d-cache-size = <0x8000>;
+      d-cache-line-size = <32>;
+      CPU0_intc: interrupt-controller {
+        #interrupt-cells = <1>;
+        interrupt-controller;
+        compatible = "riscv,cpu-intc";
+      };
+    };
+  };
+
+  memory@0 {
+    device_type = "memory";
+    reg = <0x0 0x00000000 0x0 0x40000000>;
+  };
+
+  soc {
+    #address-cells = <2>;
+    #size-cells = <2>;
+    compatible = "simple-bus";
+    ranges;
+
+    plic0: interrupt-controller@e4000000 {
+      compatible = "riscv,plic0";
+      #address-cells = <2>;
+      #interrupt-cells = <2>;
+      interrupt-controller;
+      reg = <0x0 0xe4000000 0x0 0x2000000>;
+      riscv,ndev=<71>;
+      interrupts-extended = <&CPU0_intc 11 &CPU0_intc 9>;
+    };
+
+    plic1: interrupt-controller@e6400000 {
+      compatible = "riscv,plic1";
+      #address-cells = <2>;
+      #interrupt-cells = <2>;
+      interrupt-controller;
+      reg = <0x0 0xe6400000 0x0 0x400000>;
+      riscv,ndev=<1>;
+      interrupts-extended = <&CPU0_intc 3>;
+    };
+
+    plmt0@e6000000 {
+      compatible = "riscv,plmt0";
+      interrupts-extended = <&CPU0_intc 7>;
+      reg = <0x0 0xe6000000 0x0 0x100000>;
+    };
+  };
+
+  spiclk: virt_100mhz {
+    #clock-cells = <0>;
+    compatible = "fixed-clock";
+    clock-frequency = <100000000>;
+  };
+
+  timer0: timer@f0400000 {
+    compatible = "andestech,atcpit100";
+    reg = <0x0 0xf0400000 0x0 0x1000>;
+    clock-frequency = <60000000>;
+    interrupts = <3 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  serial0: serial@f0300000 {
+    compatible = "andestech,uart16550", "ns16550a";
+    reg = <0x0 0xf0300000 0x0 0x1000>;
+    interrupts = <9 4>;
+    clock-frequency = <19660800>;
+    reg-shift = <2>;
+    reg-offset = <32>;
+    no-loopback-test = <1>;
+    interrupt-parent = <&plic0>;
+  };
+
+  gpio0: gpio@f0700000 {
+    compatible = "andestech,atcgpio100";
+    reg = <0x0 0xf0700000 0x0 0x00001000>;
+    interrupts = <7 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  rtc0: rtc@f0600000 {
+    compatible = "andestech,atcrtc100";
+    reg = <0x0 0xf0600000 0x0 0x1000>;
+    interrupts = <1 4>, <2 4>;
+    interrupt-parent = <&plic0>;
+    wakeup-source;
+  };
+
+  mac0: mac@e0100000 {
+    compatible = "andestech,atmac100";
+    reg = <0x0 0xe0100000 0x0 0x1000>;
+    interrupts = <19 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  mmc0: mmc@f0e00000 {
+    compatible = "andestech,atfsdc010";
+    max-frequency = <100000000>;
+    clock-freq-min-max = <400000 100000000>;
+    fifo-depth = <0x10>;
+    reg = <0x0 0xf0e00000 0x0 0x1000>;
+    interrupts = <18 4>;
+    cap-sd-highspeed;
+    interrupt-parent = <&plic0>;
+  };
+
+  dma0: dma@f0c00000 {
+    compatible = "andestech,atcdmac300";
+    reg = <0x0 0xf0c00000 0x0 0x1000>;
+    interrupts = <10 4 64 4 65 4 66 4 67 4 68 4 69 4 70 4 71 4>;
+    dma-channels = <8>;
+    interrupt-parent = <&plic0>;
+  };
+
+  smu: smu@f0100000 {
+    compatible = "andestech,atcsmu";
+    reg = <0x0 0xf0100000 0x0 0x1000>;
+  };
+
+  wdt0: wdt@f0500000 {
+    compatible = "andestech,atcwdt200";
+    reg = <0x0 0xf0500000 0x0 0x1000>;
+    clock-frequency = <15000000>;
+    interrupt-parent = <&plic0>;
+  };
+
+  lcd0: lcd@e0200000 {
+    compatible = "andestech,atflcdc100";
+    reg = <0x0 0xe0200000 0x0 0x1000>;
+    interrupts = <20 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  smc0: smc@e0400000 {
+    compatible = "andestech,atfsmc020";
+    reg = <0x0 0xe0400000 0x0 0x1000>;
+  };
+
+  snd0: snd@f0d00000 {
+    compatible = "andestech,atfac97";
+    reg = <0x0 0xf0d00000 0x0 0x1000>;
+    interrupts = <17 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  pmu {
+    device_type = "pmu";
+    compatible = "riscv,andes-pmu";
+  };
+
+  virtio_mmio@fe007000 {
+    interrupts = <0x17 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe007000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe006000 {
+    interrupts = <0x16 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe006000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe005000 {
+    interrupts = <0x15 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe005000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe004000 {
+    interrupts = <0x14 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe004000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe003000 {
+    interrupts = <0x13 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe003000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe002000 {
+    interrupts = <0x12 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe002000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe001000 {
+    interrupts = <0x11 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe001000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe000000 {
+    interrupts = <0x10 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe000000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+
+  nor@0,0 {
+    compatible = "cfi-flash";
+    reg = <0x0 0x88000000 0x0 0x1000>;
+    bank-width = <2>;
+    device-width = <1>;
+  };
+
+  spi: spi@f0b00000 {
+    compatible = "andestech,atcspi200";
+    reg = <0x0 0xf0b00000 0x0 0x1000>;
+    #address-cells = <1>;
+    #size-cells = <0>;
+    num-cs = <1>;
+    clocks = <&spiclk>;
+    interrupts = <4 4>;
+    interrupt-parent = <&plic0>;
+    flash@0 {
+      compatible = "mx25u1635e", "jedec,spi-nor";
+      spi-max-frequency = <50000000>;
+      reg = <0>;
+      spi-cpol;
+      spi-cpha;
+    };
+  };
+
+  i2c: i2c@f0a00000 {
+    compatible = "andestech,atciic100";
+    reg = <0x0 0xf0a00000 0x0 0x1000>;
+    interrupts = <6 4>;
+    interrupt-parent = <&plic0>;
+  };
+};
diff --git a/arch/riscv/boot/dts/ae350_rv64_smp_coherent.dts b/arch/riscv/boot/dts/ae350_rv64_smp_coherent.dts
new file mode 100644
index 00000000..12003c8f
--- /dev/null
+++ b/arch/riscv/boot/dts/ae350_rv64_smp_coherent.dts
@@ -0,0 +1,309 @@
+/dts-v1/;
+
+/ {
+  #address-cells = <2>;
+  #size-cells = <2>;
+  compatible = "andestech,ax25";
+  model = "andestech,ax25";
+  dma-coherent;
+
+  aliases {
+    uart0 = &serial0;
+    spi0 = &spi;
+  } ;
+
+  chosen {
+    bootargs = "console=ttyS0,38400n8 debug loglevel=7";
+    stdout-path = "uart0:38400n8";
+  };
+
+  cpus {
+    #address-cells = <1>;
+    #size-cells = <0>;
+    timebase-frequency = <60000000>;
+    CPU0: cpu@0 {
+      device_type = "cpu";
+      reg = <0>;
+      status = "okay";
+      compatible = "riscv";
+      riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+      riscv,priv-major = <1>;
+      riscv,priv-minor = <10>;
+      mmu-type = "riscv,sv39";
+      clock-frequency = <60000000>;
+      i-cache-size = <0x8000>;
+      i-cache-line-size = <32>;
+      d-cache-size = <0x8000>;
+      d-cache-line-size = <32>;
+      next-level-cache = <&L2>;
+      CPU0_intc: interrupt-controller {
+        #interrupt-cells = <1>;
+        interrupt-controller;
+        compatible = "riscv,cpu-intc";
+      };
+    };
+    CPU1: cpu@1 {
+      device_type = "cpu";
+      reg = <1>;
+      status = "okay";
+      compatible = "riscv";
+      riscv,isa = "rv64i2p0m2p0a2p0f2p0d2p0c2p0xv5-0p0";
+      riscv,priv-major = <1>;
+      riscv,priv-minor = <10>;
+      mmu-type = "riscv,sv39";
+      clock-frequency = <60000000>;
+      i-cache-size = <0x8000>;
+      i-cache-line-size = <32>;
+      d-cache-size = <0x8000>;
+      d-cache-line-size = <32>;
+      next-level-cache = <&L2>;
+      CPU1_intc: interrupt-controller {
+        #interrupt-cells = <1>;
+        interrupt-controller;
+        compatible = "riscv,cpu-intc";
+      };
+    };
+  };
+
+  L2: l2-cache@e0500000 {
+    compatible = "cache";
+    cache-level = <2>;
+    cache-size = <0x40000>;
+    reg = <0x0 0xe0500000 0x0 0x40000>;
+    andes,inst-prefetch = <3>;
+    andes,data-prefetch = <3>;
+    // The value format is <XRAMOCTL XRAMICTL>
+    andes,tag-ram-ctl = <0 0>;
+    andes,data-ram-ctl = <0 0>;
+  };
+
+  memory@0 {
+    device_type = "memory";
+    reg = <0x0 0x00000000 0x0 0x40000000>;
+  };
+
+  soc {
+    #address-cells = <2>;
+    #size-cells = <2>;
+    compatible = "simple-bus";
+    ranges;
+
+    plic0: interrupt-controller@e4000000 {
+      compatible = "riscv,plic0";
+      #address-cells = <2>;
+      #interrupt-cells = <2>;
+      interrupt-controller;
+      reg = <0x0 0xe4000000 0x0 0x2000000>;
+      riscv,ndev=<71>;
+      interrupts-extended = <&CPU0_intc 11 &CPU0_intc 9
+                             &CPU1_intc 11 &CPU1_intc 9>;
+    };
+
+    plic1: interrupt-controller@e6400000 {
+      compatible = "riscv,plic1";
+      #address-cells = <2>;
+      #interrupt-cells = <2>;
+      interrupt-controller;
+      reg = <0x0 0xe6400000 0x0 0x400000>;
+      riscv,ndev=<2>;
+      interrupts-extended = <&CPU0_intc 3 &CPU1_intc 3>;
+    };
+
+    plmt0@e6000000 {
+      compatible = "riscv,plmt0";
+      interrupts-extended = <&CPU0_intc 7 &CPU1_intc 7>;
+      reg = <0x0 0xe6000000 0x0 0x100000>;
+    };
+  };
+
+  spiclk: virt_100mhz {
+    #clock-cells = <0>;
+    compatible = "fixed-clock";
+    clock-frequency = <100000000>;
+  };
+
+  smu: smu@f0100000 {
+    compatible = "andestech,atcsmu";
+    reg = <0x0 0xf0100000 0x0 0x1000>;
+  };
+
+  wdt0: wdt@f0500000 {
+    compatible = "andestech,atcwdt200";
+    reg = <0x0 0xf0500000 0x0 0x1000>;
+    clock-frequency = <15000000>;
+    interrupt-parent = <&plic0>;
+  };
+
+  timer0: timer@f0400000 {
+    compatible = "andestech,atcpit100";
+    reg = <0x0 0xf0400000 0x0 0x1000>;
+    clock-frequency = <60000000>;
+    interrupts = <3 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  serial0: serial@f0300000 {
+    compatible = "andestech,uart16550", "ns16550a";
+    reg = <0x0 0xf0300000 0x0 0x1000>;
+    interrupts = <9 4>;
+    clock-frequency = <19660800>;
+    reg-shift = <2>;
+    reg-offset = <32>;
+    no-loopback-test = <1>;
+    interrupt-parent = <&plic0>;
+  };
+
+  gpio0: gpio@f0700000 {
+    compatible = "andestech,atcgpio100";
+    reg = <0x0 0xf0700000 0x0 0x00001000>;
+    interrupts = <7 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  rtc0: rtc@f0600000 {
+    compatible = "andestech,atcrtc100";
+    reg = <0x0 0xf0600000 0x0 0x1000>;
+    interrupts = <1 4>, <2 4>;
+    interrupt-parent = <&plic0>;
+    wakeup-source;
+  };
+
+  mac0: mac@e0100000 {
+    compatible = "andestech,atmac100";
+    reg = <0x0 0xe0100000 0x0 0x1000>;
+    interrupts = <19 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  mmc0: mmc@f0e00000 {
+    compatible = "andestech,atfsdc010";
+    max-frequency = <100000000>;
+    clock-freq-min-max = <400000 100000000>;
+    fifo-depth = <0x10>;
+    reg = <0x0 0xf0e00000 0x0 0x1000>;
+    interrupts = <18 4>;
+    cap-sd-highspeed;
+    interrupt-parent = <&plic0>;
+  };
+
+  dma0: dma@f0c00000 {
+    compatible = "andestech,atcdmac300";
+    reg = <0x0 0xf0c00000 0x0 0x1000>;
+    interrupts = <10 4 64 4 65 4 66 4 67 4 68 4 69 4 70 4 71 4>;
+    dma-channels = <8>;
+    interrupt-parent = <&plic0>;
+  };
+
+  lcd0: lcd@e0200000 {
+    compatible = "andestech,atflcdc100";
+    reg = <0x0 0xe0200000 0x0 0x1000>;
+    interrupts = <20 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  smc0: smc@e0400000 {
+    compatible = "andestech,atfsmc020";
+    reg = <0x0 0xe0400000 0x0 0x1000>;
+  };
+
+  snd0: snd@f0d00000 {
+    compatible = "andestech,atfac97";
+    reg = <0x0 0xf0d00000 0x0 0x1000>;
+    interrupts = <17 4>;
+    interrupt-parent = <&plic0>;
+  };
+
+  pmu {
+    device_type = "pmu";
+    compatible = "riscv,andes-pmu";
+  };
+
+  virtio_mmio@fe007000 {
+    interrupts = <0x17 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe007000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe006000 {
+    interrupts = <0x16 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe006000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe005000 {
+    interrupts = <0x15 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe005000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe004000 {
+    interrupts = <0x14 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe004000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe003000 {
+    interrupts = <0x13 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe003000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe002000 {
+    interrupts = <0x12 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe002000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe001000 {
+    interrupts = <0x11 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe001000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+  virtio_mmio@fe000000 {
+    interrupts = <0x10 0x4>;
+    interrupt-parent = <0x2>;
+    reg = <0x0 0xfe000000 0x0 0x1000>;
+    compatible = "virtio,mmio";
+  };
+
+
+  nor@0,0 {
+    compatible = "cfi-flash";
+    reg = <0x0 0x88000000 0x0 0x1000>;
+    bank-width = <2>;
+    device-width = <1>;
+  };
+
+  spi: spi@f0b00000 {
+    compatible = "andestech,atcspi200";
+    reg = <0x0 0xf0b00000 0x0 0x1000>;
+    #address-cells = <1>;
+    #size-cells = <0>;
+    num-cs = <1>;
+    clocks = <&spiclk>;
+    interrupts = <4 4>;
+    interrupt-parent = <&plic0>;
+    flash@0 {
+      compatible = "mx25u1635e", "jedec,spi-nor";
+      spi-max-frequency = <50000000>;
+      reg = <0>;
+      spi-cpol;
+      spi-cpha;
+    };
+  };
+
+  i2c: i2c@f0a00000 {
+    compatible = "andestech,atciic100";
+    reg = <0x0 0xf0a00000 0x0 0x1000>;
+    interrupts = <6 4>;
+    interrupt-parent = <&plic0>;
+  };
+};
diff --git a/arch/riscv/configs/ae350_rv32_smp_defconfig b/arch/riscv/configs/ae350_rv32_smp_defconfig
new file mode 100755
index 00000000..c2ec1f73
--- /dev/null
+++ b/arch/riscv/configs/ae350_rv32_smp_defconfig
@@ -0,0 +1,131 @@
+CONFIG_ARCH_RV32I=y
+CONFIG_CMODEL_MEDANY=y
+CONFIG_SMP=y
+CONFIG_NR_CPUS=4
+CONFIG_ANDES_PMU=y
+CONFIG_PREEMPT=y
+CONFIG_HZ_100=y
+CONFIG_CROSS_COMPILE="riscv32-linux-"
+CONFIG_DEFAULT_HOSTNAME="andes-test"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="rootfs-lite initramfs.txt.lite"
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_WIRELESS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_NETDEVICES=y
+CONFIG_TUN=y
+CONFIG_FTMAC100=y
+# CONFIG_WLAN is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_OF_PLATFORM=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_GPIOLIB=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_ATCGPIO100=y
+# CONFIG_HWMON is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_ATCIIC100=y
+CONFIG_FB=y
+CONFIG_FB_FTLCDC100=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=40
+CONFIG_DUMMY_CONSOLE_ROWS=30
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_FTSSP010=y
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+CONFIG_MMC_FTSDC=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_PWM=y
+CONFIG_PWM_ATCPIT100=y
+CONFIG_GENERIC_PHY=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_EXT4_ENCRYPTION=y
+CONFIG_FANOTIFY=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_NFS_USE_LEGACY_DNS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_DWARF4=y
+CONFIG_GDB_SCRIPTS=y
+CONFIG_FRAME_WARN=2048
+CONFIG_READABLE_ASM=y
+CONFIG_DEBUG_FS=y
+CONFIG_HEADERS_CHECK=y
+CONFIG_DEBUG_SECTION_MISMATCH=y
+CONFIG_PANIC_ON_OOPS=y
+# CONFIG_DEBUG_PREEMPT is not set
+CONFIG_STACKTRACE=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=300
+# CONFIG_FTRACE is not set
+CONFIG_CRYPTO_ECHAINIV=y
+# CONFIG_CRYPTO_HW is not set
diff --git a/arch/riscv/configs/ae350_rv32_up_defconfig b/arch/riscv/configs/ae350_rv32_up_defconfig
new file mode 100755
index 00000000..82d5f201
--- /dev/null
+++ b/arch/riscv/configs/ae350_rv32_up_defconfig
@@ -0,0 +1,129 @@
+CONFIG_ARCH_RV32I=y
+CONFIG_CMODEL_MEDANY=y
+CONFIG_ANDES_PMU=y
+CONFIG_PREEMPT=y
+CONFIG_HZ_100=y
+CONFIG_CROSS_COMPILE="riscv32-linux-"
+CONFIG_DEFAULT_HOSTNAME="andes-test"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="rootfs-lite initramfs.txt.lite"
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_WIRELESS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_NETDEVICES=y
+CONFIG_TUN=y
+CONFIG_FTMAC100=y
+# CONFIG_WLAN is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_OF_PLATFORM=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_GPIOLIB=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_ATCGPIO100=y
+# CONFIG_HWMON is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_ATCIIC100=y
+CONFIG_FB=y
+CONFIG_FB_FTLCDC100=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=40
+CONFIG_DUMMY_CONSOLE_ROWS=30
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_FTSSP010=y
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+CONFIG_MMC_FTSDC=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_PWM=y
+CONFIG_PWM_ATCPIT100=y
+CONFIG_GENERIC_PHY=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_EXT4_ENCRYPTION=y
+CONFIG_FANOTIFY=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_NFS_USE_LEGACY_DNS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_DWARF4=y
+CONFIG_GDB_SCRIPTS=y
+CONFIG_FRAME_WARN=2048
+CONFIG_READABLE_ASM=y
+CONFIG_DEBUG_FS=y
+CONFIG_HEADERS_CHECK=y
+CONFIG_DEBUG_SECTION_MISMATCH=y
+CONFIG_PANIC_ON_OOPS=y
+# CONFIG_DEBUG_PREEMPT is not set
+CONFIG_STACKTRACE=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=300
+# CONFIG_FTRACE is not set
+CONFIG_CRYPTO_ECHAINIV=y
+# CONFIG_CRYPTO_HW is not set
diff --git a/arch/riscv/configs/ae350_rv64_smp_defconfig b/arch/riscv/configs/ae350_rv64_smp_defconfig
new file mode 100755
index 00000000..148c16b3
--- /dev/null
+++ b/arch/riscv/configs/ae350_rv64_smp_defconfig
@@ -0,0 +1,128 @@
+CONFIG_SMP=y
+CONFIG_NR_CPUS=4
+CONFIG_ANDES_PMU=y
+CONFIG_PREEMPT=y
+CONFIG_HZ_100=y
+CONFIG_CROSS_COMPILE="riscv64-linux-"
+CONFIG_DEFAULT_HOSTNAME="andes-test"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="rootfs-lite initramfs.txt.lite"
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_WIRELESS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_NETDEVICES=y
+CONFIG_TUN=y
+CONFIG_FTMAC100=y
+# CONFIG_WLAN is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_OF_PLATFORM=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_GPIOLIB=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_ATCGPIO100=y
+# CONFIG_HWMON is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_ATCIIC100=y
+CONFIG_FB=y
+CONFIG_FB_FTLCDC100=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=40
+CONFIG_DUMMY_CONSOLE_ROWS=30
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_FTSSP010=y
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+CONFIG_MMC_FTSDC=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_PWM=y
+CONFIG_PWM_ATCPIT100=y
+CONFIG_GENERIC_PHY=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_EXT4_ENCRYPTION=y
+CONFIG_FANOTIFY=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_NFS_USE_LEGACY_DNS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_DWARF4=y
+CONFIG_GDB_SCRIPTS=y
+CONFIG_READABLE_ASM=y
+CONFIG_DEBUG_FS=y
+CONFIG_HEADERS_CHECK=y
+CONFIG_DEBUG_SECTION_MISMATCH=y
+CONFIG_PANIC_ON_OOPS=y
+# CONFIG_DEBUG_PREEMPT is not set
+CONFIG_STACKTRACE=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=300
+# CONFIG_FTRACE is not set
+CONFIG_CRYPTO_ECHAINIV=y
+# CONFIG_CRYPTO_HW is not set
diff --git a/arch/riscv/configs/ae350_rv64_up_defconfig b/arch/riscv/configs/ae350_rv64_up_defconfig
new file mode 100755
index 00000000..2529b2ba
--- /dev/null
+++ b/arch/riscv/configs/ae350_rv64_up_defconfig
@@ -0,0 +1,126 @@
+CONFIG_ANDES_PMU=y
+CONFIG_PREEMPT=y
+CONFIG_HZ_100=y
+CONFIG_CROSS_COMPILE="riscv64-linux-"
+CONFIG_DEFAULT_HOSTNAME="andes-test"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="rootfs-lite initramfs.txt.lite"
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PROFILING=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_WIRELESS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_NETDEVICES=y
+CONFIG_TUN=y
+CONFIG_FTMAC100=y
+# CONFIG_WLAN is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_OF_PLATFORM=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_GPIOLIB=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_ATCGPIO100=y
+# CONFIG_HWMON is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_ATCIIC100=y
+CONFIG_FB=y
+CONFIG_FB_FTLCDC100=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=40
+CONFIG_DUMMY_CONSOLE_ROWS=30
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_FTSSP010=y
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+CONFIG_MMC_FTSDC=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_PWM=y
+CONFIG_PWM_ATCPIT100=y
+CONFIG_GENERIC_PHY=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_EXT4_ENCRYPTION=y
+CONFIG_FANOTIFY=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_NFS_USE_LEGACY_DNS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_DWARF4=y
+CONFIG_GDB_SCRIPTS=y
+CONFIG_READABLE_ASM=y
+CONFIG_DEBUG_FS=y
+CONFIG_HEADERS_CHECK=y
+CONFIG_DEBUG_SECTION_MISMATCH=y
+CONFIG_PANIC_ON_OOPS=y
+# CONFIG_DEBUG_PREEMPT is not set
+CONFIG_STACKTRACE=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=300
+# CONFIG_FTRACE is not set
+CONFIG_CRYPTO_ECHAINIV=y
+# CONFIG_CRYPTO_HW is not set
diff --git a/arch/riscv/configs/defconfig b/arch/riscv/configs/defconfig
index bca0eee7..07326466 100644
--- a/arch/riscv/configs/defconfig
+++ b/arch/riscv/configs/defconfig
@@ -44,6 +44,7 @@ CONFIG_INPUT_MOUSEDEV=y
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
 CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_HVC_RISCV_SBI=y
 # CONFIG_PTP_1588_CLOCK is not set
 CONFIG_DRM=y
 CONFIG_DRM_RADEON=y
diff --git a/arch/riscv/include/asm/Kbuild b/arch/riscv/include/asm/Kbuild
index 4286a5f8..576ffdca 100644
--- a/arch/riscv/include/asm/Kbuild
+++ b/arch/riscv/include/asm/Kbuild
@@ -25,6 +25,7 @@ generic-y += kdebug.h
 generic-y += kmap_types.h
 generic-y += kvm_para.h
 generic-y += local.h
+generic-y += local64.h
 generic-y += mm-arch-hooks.h
 generic-y += mman.h
 generic-y += module.h
diff --git a/arch/riscv/include/asm/andesv5/csr.h b/arch/riscv/include/asm/andesv5/csr.h
new file mode 100644
index 00000000..a9c57a32
--- /dev/null
+++ b/arch/riscv/include/asm/andesv5/csr.h
@@ -0,0 +1,89 @@
+/* mdcm_cfg: Data Cache/Memory Configuration Register */
+#define MDCM_CFG_DEST_OFFSET		0
+#define MDCM_CFG_DWAY_OFFSET		3
+#define MDCM_CFG_DSZ_OFFSET		6
+#define MDCM_CFG_DLCK_OFFSET		9
+#define MDCM_CFG_DC_ECC_OFFSET		10
+#define MDCM_CFG_DLMB_OFFSET		12
+#define MDCM_CFG_DLMSZ_OFFSET		15
+#define MDCM_CFG_ULM_2BANK_OFFSET	20
+#define MDCM_CFG_DLM_ECC_OFFSET		21
+
+
+#define MDCM_CFG_DEST_MASK	(0x7  << MDCM_CFG_DEST_OFFSET)
+#define MDCM_CFG_DWAY_MASK	(0x7  << MDCM_CFG_DWAY_OFFSET)
+#define MDCM_CFG_DSZ_MASK	(0x7  << MDCM_CFG_DSZ_OFFSET)
+#define MDCM_CFG_DLCK_MASK	(0x1  << MDCM_CFG_DLCK_OFFSET)
+#define MDCM_CFG_DC_ECC_MASK	(0x3  << MDCM_CFG_DC_ECC_OFFSET)
+#define MDCM_CFG_DLMB_MASK	(0x7  << MDCM_CFG_DLMB_OFFSET)
+#define MDCM_CFG_DLMSZ_MASK	(0x1f << MDCM_CFG_DLMSZ_OFFSET)
+#define MDCM_CFG_ULM_2BANK_MASK	(0x1  << MDCM_CFG_ULM_2BANK_OFFSET)
+#define MDCM_CFG_DLM_ECC_MASK	(0x3  << MDCM_CFG_DLM_ECC_OFFSET)
+
+#define CCTL_REG_UCCTLBEGINADDR_NUM    0x80b
+#define CCTL_REG_UCCTLCOMMAND_NUM      0x80c
+
+
+#define custom_csr_write(csr_num,val) csr_write(csr_num,val)
+/* ucctlcommand */
+/* D-cache operation */
+#define CCTL_L1D_VA_INVAL	0
+#define CCTL_L1D_VA_WB		1
+#define CCTL_L1D_VA_WBINVAL	2
+
+/* L1 I-cache , D-cache */
+#define CACHE_CTL_offIC_EN  0   /* Enable I-cache */
+#define CACHE_CTL_offDC_EN  1   /* Enable D-cache */
+#define CACHE_CTL_mskIC_EN  ( 0x1  << CACHE_CTL_offIC_EN )
+#define CACHE_CTL_mskDC_EN  ( 0x1  << CACHE_CTL_offDC_EN )
+
+
+/* L2 cache */
+#define L2_CACHE_CTL_mskCEN 1
+/* L2 cache registers */
+#define L2C_REG_CFG_OFFSET	0
+#define L2C_REG_CTL_OFFSET	0x8
+#define L2C_HPM_C0_CTL_OFFSET	0x10
+#define L2C_HPM_C1_CTL_OFFSET	0x18
+#define L2C_HPM_C2_CTL_OFFSET	0x20
+#define L2C_HPM_C3_CTL_OFFSET	0x28
+#define L2C_REG_C0_CMD_OFFSET	0x40
+#define L2C_REG_C0_ACC_OFFSET	0x48
+#define L2C_REG_C1_CMD_OFFSET	0x50
+#define L2C_REG_C1_ACC_OFFSET	0x58
+#define L2C_REG_C2_CMD_OFFSET	0x60
+#define L2C_REG_C2_ACC_OFFSET	0x68
+#define L2C_REG_C3_CMD_OFFSET	0x70
+#define L2C_REG_C3_ACC_OFFSET	0x78
+#define L2C_REG_STATUS_OFFSET	0x80
+#define L2C_REG_C0_HPM_OFFSET	0x200
+
+/* L2 CCTL status */
+#define CCTL_L2_STATUS_IDLE	0
+#define CCTL_L2_STATUS_PROCESS	1
+#define CCTL_L2_STATUS_ILLEGAL	2
+/* L2 CCTL status cores mask */
+#define CCTL_L2_STATUS_C0_MASK	0xF
+#define CCTL_L2_STATUS_C1_MASK	0xF0
+#define CCTL_L2_STATUS_C2_MASK	0xF00
+#define CCTL_L2_STATUS_C3_MASK	0xF000
+
+/* L2 cache operation */
+#define CCTL_L2_PA_INVAL	0x8
+#define CCTL_L2_PA_WB		0x9
+#define CCTL_L2_PA_WBINVAL	0xA
+#define CCTL_L2_WBINVAL_ALL	0x12
+
+#define L2C_HPM_PER_CORE_OFFSET		0x8
+#define L2C_REG_PER_CORE_OFFSET		0x10
+#define CCTL_L2_STATUS_PER_CORE_OFFSET	4
+#define L2C_REG_CN_CMD_OFFSET(n)	\
+	L2C_REG_C0_CMD_OFFSET + (n * L2C_REG_PER_CORE_OFFSET)
+#define L2C_REG_CN_ACC_OFFSET(n)	\
+	L2C_REG_C0_ACC_OFFSET + (n * L2C_REG_PER_CORE_OFFSET)
+#define CCTL_L2_STATUS_CN_MASK(n)	\
+	CCTL_L2_STATUS_C0_MASK << (n * CCTL_L2_STATUS_PER_CORE_OFFSET)
+#define L2C_HPM_CN_CTL_OFFSET(n)	\
+	L2C_HPM_C0_CTL_OFFSET + (n * L2C_HPM_PER_CORE_OFFSET)
+#define L2C_REG_CN_HPM_OFFSET(n)	\
+	L2C_REG_C0_HPM_OFFSET + (n * L2C_HPM_PER_CORE_OFFSET)
diff --git a/arch/riscv/include/asm/andesv5/proc.h b/arch/riscv/include/asm/andesv5/proc.h
new file mode 100644
index 00000000..411665ea
--- /dev/null
+++ b/arch/riscv/include/asm/andesv5/proc.h
@@ -0,0 +1,28 @@
+#include <asm/io.h>
+#include <asm/page.h>
+
+int cpu_l1c_status(void);
+void cpu_icache_enable(void *info);
+void cpu_icache_disable(void *info);
+void cpu_dcache_enable(void *info);
+void cpu_dcache_disable(void *info);
+uint32_t cpu_l2c_ctl_status(void);
+void cpu_l2c_disable(void);
+
+void cpu_dma_inval_range(unsigned long start, unsigned long end);
+void cpu_dma_wb_range(unsigned long start, unsigned long end);
+void cpu_l2c_inval_range(unsigned long pa, unsigned long size);
+void cpu_l2c_wb_range(unsigned long pa, unsigned long size);
+
+/*
+ * struct andesv5_cache_info
+ * The member of this struct is dupilcated to some content of struct cacheinfo
+ * to reduce the latence of searching dcache inforamtion in andesv5/cache.c.
+ * At current only dcache-line-size is needed. when the content of
+ * andesv5_cache_info has been initilized by function fill_cpu_cache_info(),
+ * member init_done is set as true
+ */
+struct andesv5_cache_info {
+	bool init_done;
+	int dcache_line_size;
+};
diff --git a/arch/riscv/include/asm/andesv5/smu.h b/arch/riscv/include/asm/andesv5/smu.h
new file mode 100644
index 00000000..12161b99
--- /dev/null
+++ b/arch/riscv/include/asm/andesv5/smu.h
@@ -0,0 +1,86 @@
+#ifndef _ASM_RISCV_SMU_H
+#define _ASM_RISCV_SMU_H
+
+#include <asm/sbi.h>
+#define MAX_PCS_SLOT    7
+
+#define PCS0_WE_OFF     0x90
+#define PCS0_CTL_OFF    0x94
+#define PCS0_STATUS_OFF 0x98
+
+/*
+ * PCS0 --> Always on power domain, includes the JTAG tap and DMI_AHB bus in
+ *  ncejdtm200.
+ * PCS1 --> Power domain for debug subsystem
+ * PCS2 --> Main power domain, includes the system bus and AHB, APB peripheral
+ *  IPs.
+ * PCS3 --> Power domain for Core0 and L2C.
+ * PCSN --> Power domain for Core (N-3)
+ */
+
+#define PCSN_WE_OFF(n)          n * 0x20 + PCS0_WE_OFF
+#define CN_PCS_WE_OFF(n)        (n + 3) * 0x20 + PCS0_WE_OFF
+#define CN_PCS_STATUS_OFF(n)    (n + 3) * 0x20 + PCS0_STATUS_OFF
+#define CN_PCS_CTL_OFF(n)       (n + 3) * 0x20 + PCS0_CTL_OFF
+
+
+#define PD_TYPE_MASK    0x7
+#define PD_STATUS_MASK  0xf8
+#define GET_PD_TYPE(val)        val & PD_TYPE_MASK
+#define GET_PD_STATUS(val)      (val & PD_STATUS_MASK) >> 3
+
+#define RESET_VEC_OFF           0x50
+#define RESET_VEC_PER_CORE      0x4
+#define FLASH_BASE              0x80000000
+
+// PD_type
+#define ACTIVE  0
+#define RESET   1
+#define SLEEP   2
+#define TIMEOUT 7
+
+// PD_status for sleep type
+#define LightSleep_STATUS       0
+#define DeepSleep_STATUS        16
+
+// param of PCS_CTL for sleep cmd
+#define LightSleep_CTL          0
+#define DeepSleep_CTL           1
+
+// PCS_CTL
+#define PCS_CTL_PARAM_OFF       3
+#define SLEEP_CMD       3
+
+// wakeup events source offset
+#define PCS_WAKE_DBG_OFF	28
+#define PCS_WAKE_MSIP_OFF	29
+
+#define L2_CTL_OFF              0x8
+#define L2_COMMAND_OFF(cpu)     0x40 + 0x10 * cpu
+#define L2_STATUS_REG           0x80
+#define L2_WBINVAL_COMMAND      0x12
+
+struct atc_smu {
+        void __iomem *base;
+        struct resource *res;
+        spinlock_t lock;
+};
+
+extern unsigned int *wake_mask;
+extern void __iomem *l2c_base;
+
+void set_wakeup_enable(int cpu, unsigned int events);
+void set_sleep(int cpu, unsigned char sleep);
+void andes_suspend2standby(void);
+void andes_suspend2ram(void);
+
+static inline void sbi_suspend_prepare(char main_core, char enable)
+{
+	SBI_CALL_2(SBI_SUSPEND_PREPARE, main_core, enable);
+}
+
+static inline void sbi_suspend_mem(void)
+{
+	SBI_CALL_0(SBI_SUSPEND_MEM);
+}
+#endif
diff --git a/arch/riscv/include/asm/atcdmac300.h b/arch/riscv/include/asm/atcdmac300.h
new file mode 100644
index 00000000..456e5824
--- /dev/null
+++ b/arch/riscv/include/asm/atcdmac300.h
@@ -0,0 +1,544 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 Andes Technology Corporation
+ *
+ */
+
+#ifndef __NDS_DMAD_ATF_INC__
+#define __NDS_DMAD_ATF_INC__
+
+/*****************************************************************************
+ * Configuration section
+*****************************************************************************/
+/* Debug trace enable switch */
+#define DMAD_ERROR_TRACE            1       /* message for fatal errors */
+#define DMAD_DEBUG_TRACE            0       /* message for debug trace */
+typedef u32 addr_t;
+
+/* Device base address */
+
+extern resource_size_t	dmac_base;
+#define DMAC_BASE			(dmac_base)
+
+/* ID and Revision Register */
+#define ID_REV				(DMAC_BASE + 0x00)
+/* DMAC Configuration Register*/
+#define CFG				(DMAC_BASE + 0x10)
+#define REQSYNC				30
+#define CTL				(DMAC_BASE + 0x20)
+#define CH_ABT				(DMAC_BASE + 0x24)
+/* Interrupt Status Register */
+#define INT_STA				(DMAC_BASE + 0x30)
+#define TC_OFFSET			16
+#define ABT_OFFSET			8
+#define ERR_OFFSET			0
+
+
+#define CH_EN				(DMAC_BASE + 0x34)
+
+
+
+#define DMAC_CH_OFFSET			0x40
+#define CH_CTL_OFF			0x0
+#define CH_SIZE_OFF			0x4
+#define CH_SRC_LOW_OFF			0x8
+#define CH_SRC_HIGH_OFF			0xc
+#define CH_DST_LOW_OFF			0x10
+#define CH_DST_HIGH_OFF			0x14
+#define CH_LLP_LOW_OFF			0x18
+#define CH_LLP_HIGH_OFF			0x1c
+
+
+#define DMAC_C0_BASE			(DMAC_BASE + DMAC_CH_OFFSET)
+#define DMAC_MAX_CHANNELS		8
+#define DMAC_BASE_CH(n)			(DMAC_C0_BASE + n*0x20)
+
+/***** Channel n Control Register ******/
+#define CH_CTL(n)			DMAC_BASE_CH(n)+CH_CTL_OFF
+#define PRIORITY_SHIFT			29
+#define PRIORITY_LOW			0
+#define PRIORITY_HIGH			1
+#define DMAC_CSR_CHPRI_0		PRIORITY_LOW
+#define DMAC_CSR_CHPRI_1		PRIORITY_LOW
+#define DMAC_CSR_CHPRI_2		PRIORITY_HIGH
+#define DMAC_CSR_CHPRI_3		PRIORITY_HIGH
+
+
+#define SBURST_SIZE_SHIFT		24
+#define SBURST_SIZE_MASK		(0xf<<24)
+#define DMAC_CSR_SIZE_1			0x0
+#define DMAC_CSR_SIZE_2			0x1
+#define DMAC_CSR_SIZE_4			0x2
+#define DMAC_CSR_SIZE_8			0x3
+#define DMAC_CSR_SIZE_16		0x4
+#define DMAC_CSR_SIZE_32		0x5
+#define DMAC_CSR_SIZE_64		0x6
+#define DMAC_CSR_SIZE_128		0x7
+#define DMAC_CSR_SIZE_256		0x8
+#define DMAC_CSR_SIZE_512		0x9
+#define DMAC_CSR_SIZE_1024		0xa
+/* Source transfer width */
+#define SRCWIDTH			21
+#define SRCWIDTH_MASK			(0x7<<SRCWIDTH)
+#define WIDTH_1				0x0
+#define WIDTH_2				0x1
+#define WIDTH_4				0x2
+#define WIDTH_8				0x3
+#define WIDTH_16			0x4
+#define WIDTH_32			0x5
+#define DMAC_CSR_WIDTH_8	      WIDTH_1
+#define DMAC_CSR_WIDTH_16	      WIDTH_2
+#define DMAC_CSR_WIDTH_32	      WIDTH_4
+
+
+/* Destination transfer width */
+#define DSTWIDTH			18
+#define DSTWIDTH_MASK			(0x7<<DSTWIDTH)
+/* Source DMA handshake mode */
+#define SRCMODE				17
+#define HANDSHAKE			1
+#define SRC_HS				(HANDSHAKE<<SRCMODE)
+/* Destination DMA handshake mode */
+#define DSTMODE				16
+#define DST_HS				(HANDSHAKE<<DSTMODE)
+
+/* Source address control */
+#define SRCADDRCTRL			14
+#define SRCADDRCTRL_MASK		(0x3<<SRCADDRCTRL)
+#define ADDR_INC			0x0
+#define ADDR_DEC			0x1
+#define ADDR_FIX			0x2
+#define DMAC_CSR_AD_INC			ADDR_INC
+#define DMAC_CSR_AD_DEC			ADDR_DEC
+#define DMAC_CSR_AD_FIX			ADDR_FIX
+
+/* Destination address control */
+#define DSTADDRCTRL			12
+#define DSTADDRCTRL_MASK		(0x3<<DSTADDRCTRL)
+/* Source DMA request select */
+#define SRCREQSEL			8
+#define SRCREQSEL_MASK			(0xf<<SRCREQSEL)
+/* Destination DMA request select */
+#define DSTREQSEL			4
+#define DSTREQSEL_MASK			(0xf<<DSTREQSEL)
+
+
+/* Channel abort interrupt mask */
+#define INTABTMASK			(3)
+/* Channel error interrupt mask */
+#define INTERRMASK			(2)
+/* Channel terminal count interrupt mask */
+#define INTTCMASK			(1)
+/* Channel Enable */
+#define CHEN				(0)
+
+/***** Channel n Transfer Size Register ******/
+#define CH_SIZE(n)			DMAC_BASE_CH(n)+CH_SIZE_OFF
+/* total transfer size from source */
+#define DMAC_TOT_SIZE_MASK          0xffffffff
+
+
+
+
+#define CH_SRC_L(n)			DMAC_BASE_CH(n)+CH_SRC_LOW_OFF
+#define CH_SRC_H(n)			DMAC_BASE_CH(n)+CH_SRC_HIGH_OFF
+#define CH_DST_L(n)			DMAC_BASE_CH(n)+CH_DST_LOW_OFF
+#define CH_DST_H(n)			DMAC_BASE_CH(n)+CH_DST_HIGH_OFF
+#define CH_LLP_L(n)			DMAC_BASE_CH(n)+CH_LLP_LOW_OFF
+#define CH_LLP_H(n)			DMAC_BASE_CH(n)+CH_LLP_HIGH_OFF
+
+
+typedef struct channel_control
+{
+	u32	sWidth;
+	u32	sCtrl;
+	u32	sReqn;
+	u32	dWidth;
+	u32	dCtrl;
+	u32	dReqn;
+}channel_control;
+
+
+
+
+
+
+/* DMA channel 0 registers (32-bit width) */
+#define DMAC_C0_CSR                 (DMAC_C0_BASE + DMAC_CSR_OFFSET)
+#define DMAC_C0_CFG                 (DMAC_C0_BASE + DMAC_CFG_OFFSET)
+#define DMAC_C0_SRC_ADDR            (DMAC_C0_BASE + DMAC_SRC_ADDR_OFFSET)
+#define DMAC_C0_DST_ADDR            (DMAC_C0_BASE + DMAC_DST_ADDR_OFFSET)
+#define DMAC_C0_LLP                 (DMAC_C0_BASE + DMAC_LLP_OFFSET)
+#define DMAC_C0_SIZE                (DMAC_C0_BASE + DMAC_SIZE_OFFSET)
+
+
+#ifdef CONFIG_PLATFORM_AHBDMA
+#define DMAC_CYCLE_TO_BYTES(cycle, width) ((cycle) << (width))
+#define DMAC_BYTES_TO_CYCLE(bytes, width) ((bytes) >> (width))
+#else
+#define DMAC_CYCLE_TO_BYTES(cycle, width) 0
+#define DMAC_BYTES_TO_CYCLE(bytes, width) 0
+#endif  /* CONFIG_PLATFORM_AHBDMA */
+
+
+/* Assignment of DMA hardware handshake ID */
+#define DMAC_REQN_SPITX			0
+#define DMAC_REQN_SPIRX			1
+#ifdef CONFIG_PLAT_AE350
+#define DMAC_REQN_I2SAC97TX		14
+#define DMAC_REQN_I2SAC97RX		15
+#else
+
+#define DMAC_REQN_I2SAC97TX		2
+#define DMAC_REQN_I2SAC97RX		3
+#endif
+#define DMAC_REQN_UART1TX		4
+#define DMAC_REQN_UART1RX		5
+#define DMAC_REQN_UART2TX		6
+#define DMAC_REQN_UART2RX		7
+#define DMAC_REQN_I2C			8
+#define DMAC_REQN_SDC			9
+#define DMAC_REQN_NONE			16
+
+
+enum DMAD_DMAC_CORE {
+	DMAD_DMAC_AHB_CORE,
+	DMAD_DMAC_APB_CORE
+};
+
+enum DMAD_CHREG_FLAGS {
+	DMAD_FLAGS_NON_BLOCK    = 0x00000000,
+	DMAD_FLAGS_SLEEP_BLOCK  = 0x00000001,
+	DMAD_FLAGS_SPIN_BLOCK   = 0x00000002,
+	DMAD_FLAGS_RING_MODE    = 0x00000008,   /* ring submission mode */
+	DMAD_FLAGS_BIDIRECTION  = 0x00000010,   /* indicates both tx and rx */
+};
+
+enum DMAD_CHDIR
+{
+	DMAD_DIR_A0_TO_A1       = 0,
+	DMAD_DIR_A1_TO_A0       = 1,
+};
+
+/* AHB Channel Request
+ *
+ * Notes for developers:
+ *   These should be channel-only properties. Controller-specific properties
+ *   should be separated as other driver structure or driver buildin-hardcode.
+ *   If controller properties are embeded in this union, request for a channel
+ *   may unexpectedly override the controller setting of the request of other
+ *   channels.
+ */
+typedef struct dmad_ahb_chreq
+{
+	/* channel property */
+	u32 sync;                       /* (in)  different clock domain */
+	u32 priority;                   /* (in)  DMAC_CSR_CHPRI_xxx */
+	u32 hw_handshake;               /* (in)  hardware handshaking on/off */
+	u32 burst_size;                 /* (in)  DMAC_CSR_SIZE_xxx */
+
+	/* source property */
+	union {
+		u32 src_width;          /* (in)  DMAC_CSR_WIDTH_xxx */
+		u32 addr0_width;        /* (in)  bi-direction mode alias */
+		u32 ring_width;         /* (in)  ring-mode alias */
+	};
+	union {
+		u32 src_ctrl;           /* (in)  DMAC_CSR_AD_xxx */
+		u32 addr0_ctrl;         /* (in)  bi-direction mode alias */
+		u32 ring_ctrl;          /* (in)  ring-mode alias */
+	};
+	union {
+		u32 src_reqn;           /* (in)  DMAC_REQN_xxx */
+		u32 addr0_reqn;         /* (in)  bi-direction mode alias */
+		u32 ring_reqn;          /* (in)  ring-mode alias */
+	};
+
+	/* destination property */
+	union {
+		u32 dst_width;          /* (in)  DMAC_CSR_WIDTH_xxx */
+		u32 addr1_width;        /* (in)  bi-direction mode alias */
+		u32 dev_width;          /* (in)  ring-mode alias */
+	};
+	union {
+		u32 dst_ctrl;           /* (in)  DMAC_CSR_AD_xxx */
+		u32 addr1_ctrl;         /* (in)  bi-direction mode alias */
+		u32 dev_ctrl;           /* (in)  ring-mode alias */
+	};
+	union {
+		u32 dst_reqn;           /* (in)  DMAC_REQN_xxx */
+		u32 addr1_reqn;         /* (in)  bi-direction mode alias */
+		u32 dev_reqn;           /* (in)  ring-mode alias */
+	};
+
+	/* (in)  transfer direction, valid only if following flags were set ...
+	 *         DMAD_FLAGS_BIDIRECTION or
+	 *         DMAD_FLAGS_RING_MODE
+	 *       value:
+	 *         0 (addr0 -> addr1, or ring-buff to device)
+	 *         1 (addr0 <- addr1, or device to ring-buff)
+	 */
+	u32 tx_dir;
+
+} dmad_ahb_chreq;
+
+/* APB Channel Request
+ *
+ * Notes for developers:
+ *   These should be channel-only properties. Controller-specific properties
+ *   should be separated as other driver structure or driver buildin-hardcode.
+ *   If controller properties are embeded in this union, request for a channel
+ *   may unexpectedly override the controller setting of the request of other
+ *   channels.
+ */
+typedef struct dmad_apb_chreq
+{
+	/* controller property (removed! should not exist in this struct) */
+
+	/* channel property */
+	u32 burst_mode;                 /* (in)  Burst mode (0/1) */
+	u32 data_width;                 /* (in)  APBBR_DATAWIDTH_xxx */
+
+	/* source property */
+	union {
+		u32 src_ctrl;           /* (in)  APBBR_ADDRINC_xxx */
+		u32 addr0_ctrl;         /* (in)  bi-direction mode alias */
+		u32 ring_ctrl;          /* (in)  ring-mode alias */
+	};
+	union {
+		u32 src_reqn;           /* (in)  APBBR_REQN_xxx */
+		u32 addr0_reqn;         /* (in)  bi-direction mode alias */
+		u32 ring_reqn;          /* (in)  ring-mode alias */
+	};
+
+	/* destination property */
+	union {
+		u32 dst_ctrl;           /* (in)  APBBR_ADDRINC_xxx */
+		u32 addr1_ctrl;         /* (in)  bi-direction mode alias */
+		u32 dev_ctrl;           /* (in)  ring-mode alias */
+	};
+	union {
+		u32 dst_reqn;           /* (in)  APBBR_REQN_xxx */
+		u32 addr1_reqn;         /* (in)  bi-direction mode alias */
+		u32 dev_reqn;           /* (in)  ring-mode alias */
+	};
+
+	/* (in)  transfer direction, valid only if following flags were set ...
+	 *         DMAD_FLAGS_BIDIRECTION or
+	 *         DMAD_FLAGS_RING_MODE
+	 *       value:
+	 *         0 (addr0 -> addr1, or ring-buff to device)
+	 *         1 (addr0 <- addr1, or device to ring-buff)
+	 */
+	u32 tx_dir;
+
+} dmad_apb_chreq;
+
+/* Channel Request Descriptor */
+typedef struct dmad_chreq
+{
+	/* common fields */
+	u32     controller;                 /* (in)  enum DMAD_DMAC_CORE */
+	u32	flags;                      /* (in)  enum DMAD_CHREQ_FLAGS */
+
+	/**********************************************************************
+	 * ring mode specific fields (valid only for DMAD_FLAGS_RING_MODE)
+	 * note:
+	 *  - size fields are in unit of data width
+	 *    * for AHB, ring size is limited to 4K * data_width of data if
+	 *      hw-LLP is not used
+	 *    * for AHB, ring size is limited to 4K * data_width * LLP-count
+	 *      hw-if LLP is used
+	 *    * for APB, ring size is limited to 16M * data_width of data
+	 *  - currently sw ring mode dma supports only fixed or incremental
+	 *    src/dst addressing
+	 *  - ring_size shoule >= periods * period_size
+	 */
+	dma_addr_t ring_base;               /* (in)  ring buffer base (pa) */
+	dma_addr_t ring_size;               /* (in)  unit of data width */
+	dma_addr_t     dev_addr;                /* (in)  device data port address */
+	dma_addr_t periods;                 /* (in)  number of ints per ring */
+	dma_addr_t period_size;             /* (in)  size per int, data-width */
+
+
+	/* channel-wise completion callback - called when hw-ptr catches sw-ptr
+	 * (i.e., channel stops)
+	 *
+	 * completion_cb:   (in) client supplied callback function, executed in
+	 *                       interrupt context.
+	 * completion_data: (in) client private data to be passed to data
+	 *                       argument of completion_cb().
+	 */
+	void (*completion_cb)(int channel, u16 status, void *data);
+	void *completion_data;
+	/*********************************************************************/
+
+	/* channel allocation output */
+	u32     channel;                    /* (out) allocated channel */
+	void    *drq;                       /* (out) internal use (DMAD_DRQ *)*/
+
+	/* channel-alloc parameters (channel-wise properties) */
+	union {
+#ifdef CONFIG_PLATFORM_AHBDMA
+		dmad_ahb_chreq ahb_req;     /* (in)  for AHB DMA parameters */
+#endif
+#ifdef CONFIG_PLATFORM_APBDMA
+		dmad_apb_chreq apb_req;     /* (in)  APB Bridge DMA params */
+#endif
+	};
+
+} dmad_chreq;
+
+/* drb states are mutual exclusive */
+enum DMAD_DRB_STATE
+{
+	DMAD_DRB_STATE_FREE             = 0,
+	DMAD_DRB_STATE_READY            = 0x00000001,
+	DMAD_DRB_STATE_SUBMITTED        = 0x00000002,
+	DMAD_DRB_STATE_EXECUTED         = 0x00000004,
+	DMAD_DRB_STATE_COMPLETED        = 0x00000008,
+	//DMAD_DRB_STATE_ERROR          = 0x00000010,
+	DMAD_DRB_STATE_ABORT            = 0x00000020,
+};
+
+/* DMA request block
+ * todo: replaced link with kernel struct list_head ??
+ */
+typedef struct dmad_drb
+{
+	u32  prev;                       /* (internal) previous node */
+	u32  next;                       /* (internal) next node */
+	u32  node;                       /* (internal) this node */
+
+	u32  state;                      /* (out) DRB's current state */
+
+	union {
+		dma_addr_t src_addr;     /* (in)  source pa */
+		dma_addr_t addr0;        /* (in)  bi-direction mode alias */
+	};
+
+	union {
+		dma_addr_t dst_addr;     /* (in)  destination pa */
+		dma_addr_t addr1;        /* (in)  bi-direction mode alias */
+	};
+
+	/* (in) AHB DMA (22 bits): 0 ~ 4M-1, unit is "data width"
+	 *      APB DMA (24 bits): 0 ~ 16M-1, unit is "data width * burst size"
+	 *      => for safe without mistakes, use dmad_make_req_cycles() to
+	 *         compose this value if the addressing mode is incremental
+	 *         mode (not working yet for decremental mode).
+	 */
+	dma_addr_t req_cycle;
+
+	/* (in)  if non-null, this sync object will be signaled upon dma
+	 * completion (for blocked-waiting dma completion)
+	 */
+	struct completion *sync;
+
+} dmad_drb;
+
+
+/******************************************************************************
+ * Debug Trace Mechanism
+ */
+#if (DMAD_ERROR_TRACE)
+#define dmad_err(format, arg...)  printk(KERN_ERR format , ## arg)
+#else
+#define dmad_err(format, arg...)  (void)(0)
+#endif
+
+#if (DMAD_DEBUG_TRACE)
+#define dmad_dbg(format, arg...)  printk(KERN_INFO format , ## arg)
+#else
+#define dmad_dbg(format, arg...)  (void)(0)
+#endif
+
+#if (defined(CONFIG_PLATFORM_AHBDMA) || defined(CONFIG_PLATFORM_APBDMA))
+
+/******************************************************************************
+ * DMAD Driver Interface
+******************************************************************************/
+
+extern int dmad_channel_alloc(dmad_chreq *ch_req);
+extern int dmad_channel_free(dmad_chreq *ch_req);
+extern int dmad_channel_enable(const dmad_chreq *ch_req, u8 enable);
+extern u32 dmad_max_size_per_drb(dmad_chreq *ch_req);
+extern u32 dmad_bytes_to_cycles(dmad_chreq *ch_req, u32 byte_size);
+
+extern int dmad_kickoff_requests(dmad_chreq *ch_req);
+extern int dmad_drain_requests(dmad_chreq *ch_req, u8 shutdown);
+
+/* for performance reason, these two functions are platform-specific */
+#ifdef CONFIG_PLATFORM_AHBDMA
+extern int dmad_probe_irq_source_ahb(void);
+#endif
+#ifdef CONFIG_PLATFORM_APBDMA
+extern int dmad_probe_irq_source_apb(void);
+#endif
+
+/* note: hw_ptr here is phyical address of dma source or destination */
+extern dma_addr_t dmad_probe_hw_ptr_src(dmad_chreq *ch_req);
+extern dma_addr_t dmad_probe_hw_ptr_dst(dmad_chreq *ch_req);
+
+/*****************************************************************************
+ * routines only valid in discrete (non-ring) mode
+ */
+extern int dmad_config_channel_dir(dmad_chreq *ch_req, u8 dir);
+extern int dmad_alloc_drb(dmad_chreq *ch_req, dmad_drb **drb);
+extern int dmad_free_drb(dmad_chreq *ch_req, dmad_drb *drb);
+extern int dmad_submit_request(dmad_chreq *ch_req,
+			       dmad_drb *drb, u8 keep_fired);
+extern int dmad_withdraw_request(dmad_chreq *ch_req, dmad_drb *drb);
+/****************************************************************************/
+
+/*****************************************************************************
+ * routines only valid in ring mode
+ * note: sw_ptr and hw_ptr are values offset from the ring buffer base
+ *       unit of sw_ptr is data-width
+ *       unit of hw_ptr returned is byte
+ */
+extern int dmad_update_ring(dmad_chreq *ch_req);
+extern int dmad_update_ring_sw_ptr(dmad_chreq *ch_req,
+				   dma_addr_t sw_ptr, u8 keep_fired);
+extern dma_addr_t dmad_probe_ring_hw_ptr(dmad_chreq *ch_req);
+/****************************************************************************/
+
+#else  /* CONFIG_PLATFORM_AHBDMA || CONFIG_PLATFORM_APBDMA */
+
+static inline int dmad_channel_alloc(dmad_chreq *ch_req) { return -EFAULT; }
+static inline int dmad_channel_free(dmad_chreq *ch_req) { return -EFAULT; }
+static inline int dmad_channel_enable(const dmad_chreq *ch_req, u8 enable)
+	{ return -EFAULT; }
+static inline u32 dmad_max_size_per_drb(dmad_chreq *ch_req) { return 0; }
+static inline u32 dmad_bytes_to_cycles(dmad_chreq *ch_req, u32 byte_size)
+	{ return 0; }
+static inline int dmad_kickoff_requests(dmad_chreq *ch_req) { return -EFAULT; }
+static inline int dmad_drain_requests(dmad_chreq *ch_req, u8 shutdown)
+	{ return -EFAULT; }
+static inline int dmad_probe_irq_source_ahb(void) { return -EFAULT; }
+static inline int dmad_probe_irq_source_apb(void) { return -EFAULT; }
+static inline dma_addr_t dmad_probe_hw_ptr_src(dmad_chreq *ch_req)
+	{ return (dma_addr_t)NULL; }
+static inline dma_addr_t dmad_probe_hw_ptr_dst(dmad_chreq *ch_req)
+	{ return (dma_addr_t)NULL; }
+static inline int dmad_config_channel_dir(dmad_chreq *ch_req, u8 dir)
+	{ return -EFAULT; }
+static inline int dmad_alloc_drb(dmad_chreq *ch_req, dmad_drb **drb)
+	{ return -EFAULT; }
+static inline int dmad_free_drb(dmad_chreq *ch_req, dmad_drb *drb)
+	{ return -EFAULT; }
+static inline int dmad_submit_request(dmad_chreq *ch_req,
+       dmad_drb *drb, u8 keep_fired) { return -EFAULT; }
+static inline int dmad_withdraw_request(dmad_chreq *ch_req, dmad_drb *drb)
+	{ return -EFAULT; }
+static inline int dmad_update_ring(dmad_chreq *ch_req)
+	{ return -EFAULT; }
+static inline int dmad_update_ring_sw_ptr(dmad_chreq *ch_req,
+	dma_addr_t sw_ptr, u8 keep_fired) { return -EFAULT; }
+static inline dma_addr_t dmad_probe_ring_hw_ptr(dmad_chreq *ch_req)
+	{ return (dma_addr_t)NULL; }
+
+#endif  /* CONFIG_PLATFORM_AHBDMA || CONFIG_PLATFORM_APBDMA */
+
+#endif  /* __NDS_DMAD_ATF_INC__ */
+
diff --git a/arch/riscv/include/asm/bug.h b/arch/riscv/include/asm/bug.h
index bfc7f099..52a1fbde 100644
--- a/arch/riscv/include/asm/bug.h
+++ b/arch/riscv/include/asm/bug.h
@@ -21,7 +21,12 @@
 #include <asm/asm.h>
 
 #ifdef CONFIG_GENERIC_BUG
-#define __BUG_INSN	_AC(0x00100073, UL) /* ebreak */
+#define __INSN_LENGTH_MASK  _UL(0x3)
+#define __INSN_LENGTH_32    _UL(0x3)
+#define __COMPRESSED_INSN_MASK	_UL(0xffff)
+
+#define __BUG_INSN_32	_UL(0x00100073) /* ebreak */
+#define __BUG_INSN_16	_UL(0x9002) /* c.ebreak */
 
 #ifndef __ASSEMBLY__
 typedef u32 bug_insn_t;
@@ -38,38 +43,46 @@ typedef u32 bug_insn_t;
 #define __BUG_ENTRY			\
 	__BUG_ENTRY_ADDR "\n\t"		\
 	__BUG_ENTRY_FILE "\n\t"		\
-	RISCV_SHORT " %1"
+	RISCV_SHORT " %1\n\t"		\
+	RISCV_SHORT " %2"
 #else
 #define __BUG_ENTRY			\
-	__BUG_ENTRY_ADDR
+	__BUG_ENTRY_ADDR "\n\t"		\
+	RISCV_SHORT " %2"
 #endif
 
-#define BUG()							\
+#define __BUG_FLAGS(flags)					\
 do {								\
 	__asm__ __volatile__ (					\
 		"1:\n\t"					\
 			"ebreak\n"				\
-			".pushsection __bug_table,\"a\"\n\t"	\
+			".pushsection __bug_table,\"aw\"\n\t"	\
 		"2:\n\t"					\
 			__BUG_ENTRY "\n\t"			\
-			".org 2b + %2\n\t"			\
+			".org 2b + %3\n\t"                      \
 			".popsection"				\
 		:						\
 		: "i" (__FILE__), "i" (__LINE__),		\
-		  "i" (sizeof(struct bug_entry)));		\
-	unreachable();						\
+		  "i" (flags),					\
+		  "i" (sizeof(struct bug_entry)));              \
 } while (0)
+
 #endif /* !__ASSEMBLY__ */
 #else /* CONFIG_GENERIC_BUG */
 #ifndef __ASSEMBLY__
-#define BUG()							\
-do {								\
+#define __BUG_FLAGS(flags) do {					\
 	__asm__ __volatile__ ("ebreak\n");			\
-	unreachable();						\
 } while (0)
 #endif /* !__ASSEMBLY__ */
 #endif /* CONFIG_GENERIC_BUG */
 
+#define BUG() do {						\
+	__BUG_FLAGS(0);						\
+	unreachable();						\
+} while (0)
+
+#define __WARN_FLAGS(flags) __BUG_FLAGS(BUGFLAG_WARNING|(flags))
+
 #define HAVE_ARCH_BUG
 
 #include <asm-generic/bug.h>
diff --git a/arch/riscv/include/asm/cacheflush.h b/arch/riscv/include/asm/cacheflush.h
index efd89a88..e874d9fd 100644
--- a/arch/riscv/include/asm/cacheflush.h
+++ b/arch/riscv/include/asm/cacheflush.h
@@ -19,6 +19,8 @@
 #undef flush_icache_range
 #undef flush_icache_user_range
 #undef flush_dcache_page
+#undef flush_cache_vmap
+#undef flush_cache_vunmap
 
 static inline void local_flush_icache_all(void)
 {
@@ -33,12 +35,15 @@ static inline void flush_dcache_page(struct page *page)
 		clear_bit(PG_dcache_clean, &page->flags);
 }
 
-/*
- * RISC-V doesn't have an instruction to flush parts of the instruction cache,
- * so instead we just flush the whole thing.
- */
-#define flush_icache_range(start, end) flush_icache_all()
-#define flush_icache_user_range(vma, pg, addr, len) flush_icache_all()
+static inline void flush_cache_vmap(unsigned long start, unsigned long end)
+{
+	local_flush_tlb_all();
+}
+
+static inline void flush_cache_vunmap(unsigned long start, unsigned long end)
+{
+	local_flush_tlb_all();
+}
 
 #ifndef CONFIG_SMP
 
@@ -52,6 +57,13 @@ void flush_icache_mm(struct mm_struct *mm, bool local);
 
 #endif /* CONFIG_SMP */
 
+/*
+ * RISC-V doesn't have an instruction to flush parts of the instruction cache,
+ * so instead we just flush the whole thing.
+ */
+#define flush_icache_range(start, end) flush_icache_all()
+#define flush_icache_user_range(vma, pg, addr, len) flush_icache_all()
+
 /*
  * Bits in sys_riscv_flush_icache()'s flags argument.
  */
diff --git a/arch/riscv/include/asm/csr.h b/arch/riscv/include/asm/csr.h
index 421fa358..1baf8e04 100644
--- a/arch/riscv/include/asm/csr.h
+++ b/arch/riscv/include/asm/csr.h
@@ -54,6 +54,7 @@
 /* Interrupt Enable and Interrupt Pending flags */
 #define SIE_SSIE _AC(0x00000002, UL) /* Software Interrupt Enable */
 #define SIE_STIE _AC(0x00000020, UL) /* Timer Interrupt Enable */
+#define SIE_SEIE _AC(0x000000200, UL) /* External Interrupt Enable */
 
 #define EXC_INST_MISALIGNED     0
 #define EXC_INST_ACCESS         1
diff --git a/arch/riscv/include/asm/device.h b/arch/riscv/include/asm/device.h
new file mode 100644
index 00000000..b60e1408
--- /dev/null
+++ b/arch/riscv/include/asm/device.h
@@ -0,0 +1,11 @@
+#ifndef __ASM_DEVICE_H
+#define __ASM_DEVICE_H
+
+struct dev_archdata {
+	bool dma_coherent;
+};
+
+struct pdev_archdata {
+};
+
+#endif
diff --git a/arch/riscv/include/asm/dma-mapping.h b/arch/riscv/include/asm/dma-mapping.h
new file mode 100644
index 00000000..0d2c9f75
--- /dev/null
+++ b/arch/riscv/include/asm/dma-mapping.h
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: GPL-2.0
+#ifndef _RISCV_ASM_DMA_MAPPING_H
+#define _RISCV_ASM_DMA_MAPPING_H 1
+
+
+
+extern const struct dma_map_ops dummy_dma_ops;
+
+static inline const struct dma_map_ops *get_arch_dma_ops(struct bus_type *bus)
+{
+	/*
+	 * We expect no ISA devices, and all other DMA masters are expected to
+	 * have someone call arch_setup_dma_ops at device creation time.
+	 */
+	return &dummy_dma_ops;
+}
+
+extern void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
+			const struct iommu_ops *iommu, bool coherent);
+#define arch_setup_dma_ops arch_setup_dma_ops
+#endif /* _RISCV_ASM_DMA_MAPPING_H */
diff --git a/arch/riscv/include/asm/dmad.h b/arch/riscv/include/asm/dmad.h
new file mode 100644
index 00000000..44c87b49
--- /dev/null
+++ b/arch/riscv/include/asm/dmad.h
@@ -0,0 +1,71 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 Andes Technology Corporation
+ *
+ */
+
+#ifndef __NDS_DMAD_INC__
+#define __NDS_DMAD_INC__
+
+#include <asm/atcdmac300.h>
+
+#ifdef CONFIG_PLATFORM_AHBDMA
+int intc_ftdmac020_init_irq(int irq);
+#endif
+
+extern resource_size_t		ahb_base;
+extern resource_size_t		pmu_base;
+
+#define AMERALD_PRODUCT_ID	0x41471000
+#define AMERALD_MASK		0xFFFFF000
+
+/* DMAC */
+#define DMAC_FTDMAC020_IRQ_COUNT	8
+#define DMAC_FTDMAC020_IRQ0		64
+#define DMAC_FTDMAC020_IRQ1		65
+#define DMAC_FTDMAC020_IRQ2		66
+#define DMAC_FTDMAC020_IRQ3		67
+#define DMAC_FTDMAC020_IRQ4		68
+#define DMAC_FTDMAC020_IRQ5		69
+#define DMAC_FTDMAC020_IRQ6		70
+#define DMAC_FTDMAC020_IRQ7		71
+
+/* APBBRG */
+#define APBBRG_FTAPBBRG020S_IRQ_COUNT	4
+#define APBBRG_FTAPBBRG020S_IRQ0	72
+#define APBBRG_FTAPBBRG020S_IRQ1	73
+#define APBBRG_FTAPBBRG020S_IRQ2	74
+#define APBBRG_FTAPBBRG020S_IRQ3	75
+
+
+/* Dma irq */
+#define DMA_IRQ_COUNT	DMAC_FTDMAC020_IRQ_COUNT
+#define DMA_IRQ0	DMAC_FTDMAC020_IRQ0
+#define DMA_IRQ1	DMAC_FTDMAC020_IRQ1
+#define DMA_IRQ2	DMAC_FTDMAC020_IRQ2
+#define DMA_IRQ3	DMAC_FTDMAC020_IRQ3
+#define DMA_IRQ4	DMAC_FTDMAC020_IRQ4
+#define DMA_IRQ5	DMAC_FTDMAC020_IRQ5
+#define DMA_IRQ6	DMAC_FTDMAC020_IRQ6
+#define DMA_IRQ7	DMAC_FTDMAC020_IRQ7
+
+
+struct at_dma_platform_data {
+	unsigned int	nr_channels;
+	bool		is_private;
+#define CHAN_ALLOCATION_ASCENDING	0	/* zero to seven */
+#define CHAN_ALLOCATION_DESCENDING	1	/* seven to zero */
+	unsigned char	chan_allocation_order;
+#define CHAN_PRIORITY_ASCENDING		0	/* chan0 highest */
+#define CHAN_PRIORITY_DESCENDING	1	/* chan7 highest */
+	unsigned char	chan_priority;
+	unsigned short	block_size;
+	unsigned char	nr_masters;
+	unsigned char	data_width[4];
+	struct resource	*io;
+	void __iomem	*dmac_regs;
+	void __iomem	*pmu_regs;
+	void __iomem	*apb_regs;
+};
+
+#endif  /* __NDS_DMAD_INC__ */
diff --git a/arch/riscv/include/asm/elf.h b/arch/riscv/include/asm/elf.h
index a1ef503d..8bb57cf9 100644
--- a/arch/riscv/include/asm/elf.h
+++ b/arch/riscv/include/asm/elf.h
@@ -16,9 +16,6 @@
 #include <asm/auxvec.h>
 #include <asm/byteorder.h>
 
-/* TODO: Move definition into include/uapi/linux/elf-em.h */
-#define EM_RISCV	0xF3
-
 /*
  * These are used to set parameters in the core dumps.
  */
@@ -60,14 +57,12 @@
  * but it's not easy, and we've already done it here.
  */
 #define ELF_HWCAP	(elf_hwcap)
-extern unsigned long elf_hwcap;
+extern unsigned int elf_hwcap;
+#define ELF_HWCAP2	(elf_hwcap2)
+extern unsigned int elf_hwcap2;
 
-/*
- * This yields a string that ld.so will use to load implementation
- * specific libraries for optimization.  This is more specific in
- * intent than poking at uname or /proc/cpuinfo.
- */
-#define ELF_PLATFORM	(NULL)
+#define ELF_PLATFORM	(elf_platform)
+extern const char *elf_platform;
 
 #define ARCH_DLINFO						\
 do {								\
@@ -81,4 +76,20 @@ struct linux_binprm;
 extern int arch_setup_additional_pages(struct linux_binprm *bprm,
 	int uses_interp);
 
+#ifdef CONFIG_ARCH_BINFMT_ELF_STATE
+struct file;
+#ifdef CONFIG_64BIT
+struct elf64_phdr;
+extern int arch_elf_pt_proc(void *ehdr, struct elf64_phdr *phdr, struct file *elf,
+	bool is_interp, void *state);
+#else
+struct elf32_phdr;
+extern int arch_elf_pt_proc(void *ehdr, struct elf32_phdr *phdr, struct file *elf,
+	bool is_interp, void *state);
+#endif
+struct arch_elf_state {
+};
+#define INIT_ARCH_ELF_STATE { }
+#define arch_check_elf(ehdr, interp, interp_ehdr, state) (0)
+#endif
 #endif /* _ASM_RISCV_ELF_H */
diff --git a/arch/riscv/include/asm/fixmap.h b/arch/riscv/include/asm/fixmap.h
new file mode 100644
index 00000000..ba26b61e
--- /dev/null
+++ b/arch/riscv/include/asm/fixmap.h
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2005-2017 Andes Technology Corporation
+
+#ifndef __ASM_RISCV_FIXMAP_H
+#define __ASM_RISCV_FIXMAP_H
+
+#ifdef CONFIG_HIGHMEM
+#include <linux/threads.h>
+#include <asm/kmap_types.h>
+#include <asm/highmem.h>
+#endif
+
+enum fixed_addresses {
+	FIX_HOLE,
+	FIX_KMAP_RESERVED,
+	FIX_KMAP_BEGIN,
+#ifdef CONFIG_HIGHMEM
+	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_TYPE_NR * NR_CPUS),
+#endif
+	FIX_EARLYCON_MEM_BASE,
+	__end_of_fixed_addresses
+};
+#define FIXADDR_TOP         (PKMAP_BASE)
+#define FIXADDR_SIZE		((__end_of_fixed_addresses) << PAGE_SHIFT)
+#define FIXADDR_START		(FIXADDR_TOP - FIXADDR_SIZE)
+#define FIXMAP_PAGE_IO		__pgprot(PAGE_DEVICE)
+void __set_fixmap(enum fixed_addresses idx, phys_addr_t phys, pgprot_t prot);
+
+#include <asm-generic/fixmap.h>
+#endif /* __ASM_RISCV_FIXMAP_H */
diff --git a/arch/riscv/include/asm/highmem.h b/arch/riscv/include/asm/highmem.h
new file mode 100644
index 00000000..1a2a602f
--- /dev/null
+++ b/arch/riscv/include/asm/highmem.h
@@ -0,0 +1,52 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2005-2017 Andes Technology Corporation
+
+#ifndef _ASM_HIGHMEM_H
+#define _ASM_HIGHMEM_H
+
+#include <asm/kmap_types.h>
+#include <asm/cacheflush.h>
+#include <asm/pgtable.h>
+
+/*
+ * Right now we initialize only a single pte table. It can be extended
+ * easily, subsequent pte tables have to be allocated in one physical
+ * chunk of RAM.
+ */
+#define PKMAP_BASE		(VMALLOC_START - SZ_2M)
+#define LAST_PKMAP		(SZ_2M >> PAGE_SHIFT)
+#define LAST_PKMAP_MASK		(LAST_PKMAP - 1)
+#define PKMAP_NR(virt)		(((virt) - (PKMAP_BASE)) >> PAGE_SHIFT)
+#define PKMAP_ADDR(nr)		(PKMAP_BASE + ((nr) << PAGE_SHIFT))
+#define kmap_prot		PAGE_KERNEL
+
+static inline void flush_cache_kmaps(void)
+{
+	/* Do fence.i I-cache inval and D-cache wb_all */
+	local_flush_tlb_all();
+}
+
+/* declarations for highmem.c */
+extern unsigned long highstart_pfn, highend_pfn;
+
+extern pte_t *pkmap_page_table;
+
+extern void *kmap_high(struct page *page);
+extern void kunmap_high(struct page *page);
+
+extern void kmap_init(void);
+
+/*
+ * The following functions are already defined by <linux/highmem.h>
+ * when CONFIG_HIGHMEM is not set.
+ */
+#ifdef CONFIG_HIGHMEM
+extern void *kmap(struct page *page);
+extern void kunmap(struct page *page);
+extern void *kmap_atomic(struct page *page);
+extern void __kunmap_atomic(void *kvaddr);
+extern void *kmap_atomic_pfn(unsigned long pfn);
+extern struct page *kmap_atomic_to_page(void *ptr);
+#endif
+
+#endif
diff --git a/arch/riscv/include/asm/hwcap.h b/arch/riscv/include/asm/hwcap.h
index 8a4ed7bb..ef65cb7e 100644
--- a/arch/riscv/include/asm/hwcap.h
+++ b/arch/riscv/include/asm/hwcap.h
@@ -20,18 +20,13 @@
 #define __ASM_HWCAP_H
 
 #include <uapi/asm/hwcap.h>
+#include <asm/elf.h>
 
 #ifndef __ASSEMBLY__
-/*
- * This yields a mask that user programs can use to figure out what
- * instruction set this cpu supports.
- */
-#define ELF_HWCAP		(elf_hwcap)
 
 enum {
 	CAP_HWCAP = 1,
 };
 
-extern unsigned long elf_hwcap;
 #endif
 #endif
diff --git a/arch/riscv/include/asm/io.h b/arch/riscv/include/asm/io.h
index b269451e..d6196382 100644
--- a/arch/riscv/include/asm/io.h
+++ b/arch/riscv/include/asm/io.h
@@ -21,16 +21,21 @@
 
 #include <linux/types.h>
 
-extern void __iomem *ioremap(phys_addr_t offset, unsigned long size);
+extern void __iomem *ioremap(phys_addr_t offset, size_t size);
 
 /*
  * The RISC-V ISA doesn't yet specify how to query or modify PMAs, so we can't
  * change the properties of memory regions.  This should be fixed by the
  * upcoming platform spec.
  */
-#define ioremap_nocache(addr, size) ioremap((addr), (size))
-#define ioremap_wc(addr, size) ioremap((addr), (size))
-#define ioremap_wt(addr, size) ioremap((addr), (size))
+/*
+ * That being said, before PMA is ready, Andes augmented PA with an MSB bit
+ * to indicate the non-cacheability.
+ */
+#define ioremap_nocache ioremap_nocache
+extern void __iomem *ioremap_nocache(phys_addr_t offset, size_t size);
+#define ioremap_wc(addr, size) ioremap_nocache((addr), (size))
+#define ioremap_wt(addr, size) ioremap_nocache((addr), (size))
 
 extern void iounmap(volatile void __iomem *addr);
 
diff --git a/arch/riscv/include/asm/irq.h b/arch/riscv/include/asm/irq.h
index 4dee9d4c..0342d3f7 100644
--- a/arch/riscv/include/asm/irq.h
+++ b/arch/riscv/include/asm/irq.h
@@ -15,11 +15,21 @@
 #ifndef _ASM_RISCV_IRQ_H
 #define _ASM_RISCV_IRQ_H
 
-#define NR_IRQS         0
+#define NR_IRQS	72
+
+/*
+ *  * Use this value to indicate lack of interrupt
+ *   * capability
+ *    */
+#ifndef NO_IRQ
+#define NO_IRQ  ((unsigned int)(-1))
+#endif
+
 
 #define INTERRUPT_CAUSE_SOFTWARE    1
 #define INTERRUPT_CAUSE_TIMER       5
 #define INTERRUPT_CAUSE_EXTERNAL    9
+#define INTERRUPT_CAUSE_PMU        274
 
 void riscv_timer_interrupt(void);
 
diff --git a/arch/riscv/include/asm/kasan.h b/arch/riscv/include/asm/kasan.h
new file mode 100644
index 00000000..e0c1f27d
--- /dev/null
+++ b/arch/riscv/include/asm/kasan.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __ASM_KASAN_H
+#define __ASM_KASAN_H
+
+#ifndef __ASSEMBLY__
+
+#ifdef CONFIG_KASAN
+
+#include <asm/pgtable.h>
+
+#define KASAN_SHADOW_SCALE_SHIFT	3
+
+#define KASAN_SHADOW_SIZE	(UL(1) << (38 - KASAN_SHADOW_SCALE_SHIFT))
+#define KASAN_SHADOW_START	0xffffffc000000000 // 2^64 - 2^38
+#define KASAN_SHADOW_END	(KASAN_SHADOW_START + KASAN_SHADOW_SIZE)
+
+#define KASAN_SHADOW_OFFSET	(KASAN_SHADOW_END - (1ULL << \
+					(64 - KASAN_SHADOW_SCALE_SHIFT)))
+
+void kasan_init(void);
+asmlinkage void kasan_early_init(void);
+
+#endif
+#endif
+#endif
diff --git a/arch/riscv/include/asm/module.h b/arch/riscv/include/asm/module.h
index 349df338..27328fe0 100644
--- a/arch/riscv/include/asm/module.h
+++ b/arch/riscv/include/asm/module.h
@@ -8,12 +8,12 @@
 
 #define MODULE_ARCH_VERMAGIC    "riscv"
 
-u64 module_emit_got_entry(struct module *mod, u64 val);
-u64 module_emit_plt_entry(struct module *mod, u64 val);
+unsigned long module_emit_got_entry(struct module *mod, unsigned long val);
+unsigned long module_emit_plt_entry(struct module *mod, unsigned long val);
 
 #ifdef CONFIG_MODULE_SECTIONS
 struct mod_section {
-	struct elf64_shdr *shdr;
+	Elf_Shdr *shdr;
 	int num_entries;
 	int max_entries;
 };
@@ -25,18 +25,18 @@ struct mod_arch_specific {
 };
 
 struct got_entry {
-	u64 symbol_addr;	/* the real variable address */
+	unsigned long symbol_addr;	/* the real variable address */
 };
 
-static inline struct got_entry emit_got_entry(u64 val)
+static inline struct got_entry emit_got_entry(unsigned long val)
 {
 	return (struct got_entry) {val};
 }
 
-static inline struct got_entry *get_got_entry(u64 val,
+static inline struct got_entry *get_got_entry(unsigned long val,
 					      const struct mod_section *sec)
 {
-	struct got_entry *got = (struct got_entry *)sec->shdr->sh_addr;
+	struct got_entry *got = (struct got_entry *)(sec->shdr->sh_addr);
 	int i;
 	for (i = 0; i < sec->num_entries; i++) {
 		if (got[i].symbol_addr == val)
@@ -61,7 +61,9 @@ struct plt_entry {
 #define REG_T0     0x5
 #define REG_T1     0x6
 
-static inline struct plt_entry emit_plt_entry(u64 val, u64 plt, u64 got_plt)
+static inline struct plt_entry emit_plt_entry(unsigned long val,
+					      unsigned long plt,
+					      unsigned long got_plt)
 {
 	/*
 	 * U-Type encoding:
@@ -75,7 +77,7 @@ static inline struct plt_entry emit_plt_entry(u64 val, u64 plt, u64 got_plt)
 	 * +------------+------------+--------+----------+----------+
 	 *
 	 */
-	u64 offset = got_plt - plt;
+	unsigned long offset = got_plt - plt;
 	u32 hi20 = (offset + 0x800) & 0xfffff000;
 	u32 lo12 = (offset - hi20);
 	return (struct plt_entry) {
@@ -85,7 +87,7 @@ static inline struct plt_entry emit_plt_entry(u64 val, u64 plt, u64 got_plt)
 	};
 }
 
-static inline int get_got_plt_idx(u64 val, const struct mod_section *sec)
+static inline int get_got_plt_idx(unsigned long val, const struct mod_section *sec)
 {
 	struct got_entry *got_plt = (struct got_entry *)sec->shdr->sh_addr;
 	int i;
@@ -96,9 +98,9 @@ static inline int get_got_plt_idx(u64 val, const struct mod_section *sec)
 	return -1;
 }
 
-static inline struct plt_entry *get_plt_entry(u64 val,
-				      const struct mod_section *sec_plt,
-				      const struct mod_section *sec_got_plt)
+static inline struct plt_entry *get_plt_entry(unsigned long val,
+					      const struct mod_section *sec_plt,
+					      const struct mod_section *sec_got_plt)
 {
 	struct plt_entry *plt = (struct plt_entry *)sec_plt->shdr->sh_addr;
 	int got_plt_idx = get_got_plt_idx(val, sec_got_plt);
diff --git a/arch/riscv/include/asm/perf_event.h b/arch/riscv/include/asm/perf_event.h
new file mode 100644
index 00000000..30bd3a99
--- /dev/null
+++ b/arch/riscv/include/asm/perf_event.h
@@ -0,0 +1,198 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 SiFive
+ * Copyright (C) 2018 Andes Technology Corporation
+ *
+ */
+
+#ifndef _ASM_RISCV_PERF_EVENT_H
+#define _ASM_RISCV_PERF_EVENT_H
+
+#include <linux/perf_event.h>
+#include <linux/ptrace.h>
+#include <linux/irqreturn.h>
+
+/*
+ * There only have 2 base counters,
+ * but there is a *time* register at counteren[1]
+ */
+#ifdef CONFIG_RISCV_BASE_PMU
+#define RISCV_MAX_COUNTERS	3
+#elif defined CONFIG_ANDES_PMU
+#define RISCV_MAX_COUNTERS      7
+#endif
+
+#define L2C_MAX_COUNTERS	32
+#define BASE_COUNTERS	3
+
+#ifndef RISCV_MAX_COUNTERS
+#error "Please provide a valid RISCV_MAX_COUNTERS for the PMU."
+#endif
+
+/*
+ * These are the indexes of bits in counteren register *minus* 1,
+ * except for cycle.  It would be coherent if it can directly mapped
+ * to counteren bit definition, but there is a *time* register at
+ * counteren[1].  Per-cpu structure is scarce resource here.
+ *
+ * According to the spec, an implementation can support counter up to
+ * mhpmcounter31, but many high-end processors has at most 6 general
+ * PMCs, we give the definition to MHPMCOUNTER8 here.
+ */
+#define RISCV_CYCLE_COUNTER	0
+#define RISCV_INSTRET_COUNTER	2
+#define RISCV_PMU_MHPMCOUNTER3	3
+#define RISCV_PMU_MHPMCOUNTER4	4
+#define RISCV_PMU_MHPMCOUNTER5	5
+#define RISCV_PMU_MHPMCOUNTER6	6
+#define RISCV_PMU_MHPMCOUNTER7	7
+#define RISCV_PMU_MHPMCOUNTER8	8
+
+#define RISCV_OP_UNSUPP		(-EOPNOTSUPP)
+
+/* Event code for instruction commit events */
+#define RISCV_CYCLE_COUNT               0x10
+#define RISCV_INSTRET                   0x20
+#define INT_LOAD_INST                   0x30
+#define INT_STORE_INST                  0x40
+#define ATOMIC_MEM_OP                   0x50
+#define SYS_INST                        0x60
+#define INT_COMPUTE_INST                0x70
+#define CONDITION_BR                    0x80
+#define TAKEN_CONDITION_BR              0x90
+#define JAL_INST                        0xA0
+#define JALR_INST                       0xB0
+#define RET_INST                        0xC0
+#define CONTROL_TRANS_INST              0xD0
+#define EX9_INST                        0xE0
+#define INT_MUL_INST                    0xF0
+#define INT_DIV_REMAINDER_INST          0x100
+#define FLOAT_LOAD_INST                 0x110
+#define FLOAT_STORE_INST                0x120
+#define FLOAT_ADD_SUB_INST              0x130
+#define FLOAT_MUL_INST                  0x140
+#define FLOAT_FUSED_MULADD_INST         0x150
+#define FLOAT_DIV_SQUARE_ROOT_INST      0x160
+#define OTHER_FLOAT_INST                0x170
+
+/* Event code for memory system events */
+#define ILM_ACCESS                      0x01
+#define DLM_ACCESS                      0x11
+#define ICACHE_ACCESS                   0x21
+#define ICACHE_MISS                     0x31
+#define DCACHE_ACCESS                   0x41
+#define DCACHE_MISS                     0x51
+#define DCACHE_LOAD_ACCESS              0x61
+#define DCACHE_LOAD_MISS                0x71
+#define DCACHE_STORE_ACCESS             0x81
+#define DCACHE_STORE_MISS               0x91
+#define DCACHE_WB                       0xA1
+#define CYCLE_WAIT_ICACHE_FILL          0xB1
+#define CYCLE_WAIT_DCACHE_FILL          0xC1
+#define UNCACHED_IFETCH_FROM_BUS        0xD1
+#define UNCACHED_LOAD_FROM_BUS          0xE1
+#define CYCLE_WAIT_UNCACHED_IFETCH      0xF1
+#define CYCLE_WAIT_UNCACHED_LOAD        0x101
+#define MAIN_ITLB_ACCESS                0x111
+#define MAIN_ITLB_MISS                  0x121
+#define MAIN_DTLB_ACCESS                0x131
+#define MAIN_DTLB_MISS                  0x141
+#define CYCLE_WAIT_ITLB_FILL            0x151
+#define PIPE_STALL_CYCLE_DTLB_MISS      0x161
+
+/* Event code for microarchitecture events */
+#define MISPREDICT_CONDITION_BR         0x02
+#define MISPREDICT_TAKE_CONDITION_BR    0x12
+#define MISPREDICT_TARGET_RET_INST      0x22
+/* LAS: load after store, SAS: store after store */
+#define REPLAY_LAS_SAS                  0x32
+
+/* Event code for L2c */
+#define L2C_CORE_OFF			0x10
+#define TOTAL_C0_ACCESS			0xff00
+#define L2C_C0_ACCESS			0xff01
+#define L2C_C0_MISS			0xff02
+#define TRANS_SNOOP_DATA		0xff03
+#define RECV_SNOOP_DATA			0xff04
+#define TOTAL_M4_ACCESS			0xff40
+#define L2C_M4_ACCESS			0xff41
+#define L2C_M4_MISS			0xff42
+#define M4_RECV_SNOOP			0xff44
+#define SYS_BUS_ACCESS			0xff50
+#define L2_WAY_0_EVICTION_COUNT		0xff70
+#define L2_WAY_1_EVICTION_COUNT		0xff71
+#define L2_WAY_2_EVICTION_COUNT		0xff72
+#define L2_WAY_3_EVICTION_COUNT		0xff73
+#define L2_WAY_4_EVICTION_COUNT		0xff74
+#define L2_WAY_5_EVICTION_COUNT		0xff75
+#define L2_WAY_6_EVICTION_COUNT		0xff76
+#define L2_WAY_7_EVICTION_COUNT		0xff77
+#define L2_WAY_8_EVICTION_COUNT		0xff78
+#define L2_WAY_9_EVICTION_COUNT		0xff79
+#define L2_WAY_10_EVICTION_COUNT	0xff7a
+#define L2_WAY_11_EVICTION_COUNT	0xff7b
+#define L2_WAY_12_EVICTION_COUNT	0xff7c
+#define L2_WAY_13_EVICTION_COUNT	0xff7d
+#define L2_WAY_14_EVICTION_COUNT	0xff7e
+#define L2_WAY_15_EVICTION_COUNT	0xff7f
+
+#define CN_RECV_SNOOP_DATA(x)	\
+	(RECV_SNOOP_DATA + (x * L2C_CORE_OFF))
+
+struct cpu_hw_events {
+	/* # currently enabled events*/
+	int			n_events;
+	/* currently enabled events */
+	struct perf_event	*events[RISCV_MAX_COUNTERS];
+
+	unsigned long           active_mask[BITS_TO_LONGS(RISCV_MAX_COUNTERS)];
+	unsigned long           used_mask[BITS_TO_LONGS(RISCV_MAX_COUNTERS)];
+	/* vendor-defined PMU data */
+	void			*platform;
+};
+
+struct l2c_hw_events {
+	int n_events;
+	struct perf_event	*events[32];
+
+	unsigned long		active_mask[BITS_TO_LONGS(32)];
+	unsigned long		used_mask[BITS_TO_LONGS(32)];
+
+	raw_spinlock_t          pmu_lock;
+};
+
+struct riscv_pmu {
+	struct pmu	*pmu;
+
+	/* generic hw/cache events table */
+	const int	*hw_events;
+	const int	(*cache_events)[PERF_COUNT_HW_CACHE_MAX]
+				       [PERF_COUNT_HW_CACHE_OP_MAX]
+				       [PERF_COUNT_HW_CACHE_RESULT_MAX];
+	/* method used to map hw/cache events */
+	int		(*map_hw_event)(u64 config);
+	int		(*map_cache_event)(u64 config);
+	int             (*map_raw_event)(u64 config);
+
+	/* max generic hw events in map */
+	int		max_events;
+	/* number total counters, 2(base) + x(general) */
+	int		num_counters;
+	/* the width of the counter */
+	int		counter_width;
+
+	/* vendor-defined PMU features */
+	void		*platform;
+
+	void		(*handle_irq)(struct pt_regs *regs);
+	int		irq;
+	u64		max_period;
+};
+
+void riscv_perf_interrupt(struct pt_regs *regs);
+int cpu_l2c_get_counter_idx(struct l2c_hw_events *l2c);
+void l2c_write_counter(int idx, u64 value);
+u64 l2c_read_counter(int idx);
+void l2c_pmu_disable_counter(int idx);
+void l2c_pmu_event_enable(u64 config, int idx);
+#endif /* _ASM_RISCV_PERF_EVENT_H */
diff --git a/arch/riscv/include/asm/pgalloc.h b/arch/riscv/include/asm/pgalloc.h
index a79ed5fa..08863499 100644
--- a/arch/riscv/include/asm/pgalloc.h
+++ b/arch/riscv/include/asm/pgalloc.h
@@ -26,6 +26,8 @@ static inline void pmd_populate_kernel(struct mm_struct *mm,
 	set_pmd(pmd, __pmd((pfn << _PAGE_PFN_SHIFT) | _PAGE_TABLE));
 }
 
+int get_cache_line_size(void);
+void cpu_dma_wb_range(unsigned long start, unsigned long end);
 static inline void pmd_populate(struct mm_struct *mm,
 	pmd_t *pmd, pgtable_t pte)
 {
@@ -56,6 +58,7 @@ static inline pgd_t *pgd_alloc(struct mm_struct *mm)
 		memcpy(pgd + USER_PTRS_PER_PGD,
 			init_mm.pgd + USER_PTRS_PER_PGD,
 			(PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
+		flush_tlb_all();
 	}
 	return pgd;
 }
diff --git a/arch/riscv/include/asm/pgtable-bits.h b/arch/riscv/include/asm/pgtable-bits.h
index 997ddbb1..2f75c242 100644
--- a/arch/riscv/include/asm/pgtable-bits.h
+++ b/arch/riscv/include/asm/pgtable-bits.h
@@ -31,6 +31,8 @@
 #define _PAGE_ACCESSED  (1 << 6)    /* Set by hardware on any access */
 #define _PAGE_DIRTY     (1 << 7)    /* Set by hardware on any write */
 #define _PAGE_SOFT      (1 << 8)    /* Reserved for software */
+extern phys_addr_t pa_msb;
+#define _PAGE_NONCACHEABLE      ((!!pa_msb) << 31)
 
 #define _PAGE_SPECIAL   _PAGE_SOFT
 #define _PAGE_TABLE     _PAGE_PRESENT
diff --git a/arch/riscv/include/asm/pgtable.h b/arch/riscv/include/asm/pgtable.h
index 16301966..eec379f5 100644
--- a/arch/riscv/include/asm/pgtable.h
+++ b/arch/riscv/include/asm/pgtable.h
@@ -25,6 +25,7 @@
 #include <asm/page.h>
 #include <asm/tlbflush.h>
 #include <linux/mm_types.h>
+#include <linux/sizes.h>
 
 #ifdef CONFIG_64BIT
 #include <asm/pgtable-64.h>
@@ -44,7 +45,7 @@
 /* Page protection bits */
 #define _PAGE_BASE	(_PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_USER)
 
-#define PAGE_NONE		__pgprot(0)
+#define PAGE_NONE		__pgprot(_PAGE_BASE)
 #define PAGE_READ		__pgprot(_PAGE_BASE | _PAGE_READ)
 #define PAGE_WRITE		__pgprot(_PAGE_BASE | _PAGE_READ | _PAGE_WRITE)
 #define PAGE_EXEC		__pgprot(_PAGE_BASE | _PAGE_EXEC)
@@ -89,6 +90,12 @@ extern pgd_t swapper_pg_dir[];
 #define __S110	PAGE_SHARED_EXEC
 #define __S111	PAGE_SHARED_EXEC
 
+#define pgprot_noncached pgprot_noncached
+static inline pgprot_t pgprot_noncached(pgprot_t _prot)
+{
+       return __pgprot(pgprot_val(_prot) | _PAGE_NONCACHEABLE);
+}
+
 /*
  * ZERO_PAGE is a global shared page that is always zero,
  * used for zero-mapped memory areas, etc.
@@ -137,6 +144,11 @@ static inline pgd_t *pgd_offset(const struct mm_struct *mm, unsigned long addr)
 /* Locate an entry in the kernel page global directory */
 #define pgd_offset_k(addr)      pgd_offset(&init_mm, (addr))
 
+#ifdef CONFIG_HIGHMEM
+/* Locate an entry in the second-level page table */
+#define pmd_off_k(address)  pmd_offset((pud_t *)pgd_offset_k(address), address)
+#endif
+
 static inline struct page *pmd_page(pmd_t pmd)
 {
 	return pfn_to_page(pmd_val(pmd) >> _PAGE_PFN_SHIFT);
@@ -156,9 +168,16 @@ static inline unsigned long pte_pfn(pte_t pte)
 #define pte_page(x)     pfn_to_page(pte_pfn(x))
 
 /* Constructs a page table entry */
+extern phys_addr_t pa_msb;
 static inline pte_t pfn_pte(unsigned long pfn, pgprot_t prot)
 {
-	return __pte((pfn << _PAGE_PFN_SHIFT) | pgprot_val(prot));
+	/*
+	 * When PMA is on and activated: pa_msb == 0;
+	 * 		      Otherwise: pa_msb != 0;
+	 */
+	return (pa_msb && (pgprot_val(prot) & _PAGE_NONCACHEABLE)) ? \
+		__pte(((pfn|pa_msb) << _PAGE_PFN_SHIFT) | (pgprot_val(prot) & ~_PAGE_NONCACHEABLE)) : \
+		__pte((pfn << _PAGE_PFN_SHIFT) | pgprot_val(prot));
 }
 
 static inline pte_t mk_pte(struct page *page, pgprot_t prot)
@@ -411,9 +430,20 @@ static inline void pgtable_cache_init(void)
 	/* No page table caches to initialize */
 }
 
+#ifdef CONFIG_HIGHMEM
+#define VMALLOC_SIZE     (SZ_128M)
+#define VMALLOC_END      (0xfff00000UL) /*Reserved 1023K from FFFF_FFFFF*/
+#define VMALLOC_START    (VMALLOC_END - VMALLOC_SIZE)
+
+#include <asm/fixmap.h>
+#define LOWMEM_END			(ALIGN_DOWN(FIXADDR_START, SZ_4M))
+#define LOWMEM_SIZE			(LOWMEM_END - PAGE_OFFSET)
+#define LOWMEM_END_PFN		(PFN_DOWN(__pa(LOWMEM_END)))
+#else
 #define VMALLOC_SIZE     (KERN_VIRT_SIZE >> 1)
 #define VMALLOC_END      (PAGE_OFFSET - 1)
 #define VMALLOC_START    (PAGE_OFFSET - VMALLOC_SIZE)
+#endif
 
 /*
  * Task size is 0x40000000000 for RV64 or 0xb800000 for RV32.
@@ -422,8 +452,12 @@ static inline void pgtable_cache_init(void)
 #ifdef CONFIG_64BIT
 #define TASK_SIZE (PGDIR_SIZE * PTRS_PER_PGD / 2)
 #else
+#ifdef CONFIG_HIGHMEM
+#define TASK_SIZE UL(CONFIG_PAGE_OFFSET)
+#else
 #define TASK_SIZE VMALLOC_START
 #endif
+#endif
 
 #include <asm-generic/pgtable.h>
 
diff --git a/arch/riscv/include/asm/processor.h b/arch/riscv/include/asm/processor.h
index 3fe4af81..2d313d71 100644
--- a/arch/riscv/include/asm/processor.h
+++ b/arch/riscv/include/asm/processor.h
@@ -22,7 +22,7 @@
  * This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
-#define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE >> 1)
+#define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE / 3)
 
 #define STACK_TOP		TASK_SIZE
 #define STACK_TOP_MAX		STACK_TOP
@@ -46,6 +46,9 @@ struct thread_struct {
 	unsigned long sp;	/* Kernel mode stack */
 	unsigned long s[12];	/* s[0]: frame pointer */
 	struct __riscv_d_ext_state fstate;
+#ifdef CONFIG_DSP
+	struct __riscv_dsp_state dspstate;
+#endif
 };
 
 #define INIT_THREAD {					\
@@ -91,6 +94,9 @@ struct device_node;
 extern int riscv_of_processor_hart(struct device_node *node);
 
 extern void riscv_fill_hwcap(void);
+#ifdef CONFIG_ARCH_BINFMT_ELF_STATE
+extern unsigned int elf_attribute_checking;
+#endif
 
 #endif /* __ASSEMBLY__ */
 
diff --git a/arch/riscv/include/asm/ptrace.h b/arch/riscv/include/asm/ptrace.h
index 2c5df945..07713bc2 100644
--- a/arch/riscv/include/asm/ptrace.h
+++ b/arch/riscv/include/asm/ptrace.h
@@ -66,6 +66,7 @@ struct pt_regs {
 #define REG_FMT "%08lx"
 #endif
 
+#define arch_has_single_step()	(1)
 #define user_mode(regs) (((regs)->sstatus & SR_SPP) == 0)
 
 
diff --git a/arch/riscv/include/asm/sbi.h b/arch/riscv/include/asm/sbi.h
index b6bb10b9..b56bc866 100644
--- a/arch/riscv/include/asm/sbi.h
+++ b/arch/riscv/include/asm/sbi.h
@@ -25,6 +25,20 @@
 #define SBI_REMOTE_SFENCE_VMA 6
 #define SBI_REMOTE_SFENCE_VMA_ASID 7
 #define SBI_SHUTDOWN 8
+#define SBI_TRIGGER 9
+#define SBI_SET_PFM 10
+#define SBI_READ_POWERBRAKE 11
+#define SBI_WRITE_POWERBRAKE 12
+#define SBI_SUSPEND_PREPARE 13
+#define SBI_SUSPEND_MEM 14
+#define SBI_DCACHE_OP 15
+#define SBI_ICACHE_OP 16
+#define SBI_L1CACHE_STATUS 17
+#define SBI_RESTART 18
+#define SBI_SET_RESET_VEC 19
+#define SBI_SET_PMA 20
+#define SBI_FREE_PMA 21
+#define SBI_PROBE_PMA 22
 
 #define SBI_CALL(which, arg0, arg1, arg2) ({			\
 	register uintptr_t a0 asm ("a0") = (uintptr_t)(arg0);	\
@@ -42,6 +56,48 @@
 #define SBI_CALL_0(which) SBI_CALL(which, 0, 0, 0)
 #define SBI_CALL_1(which, arg0) SBI_CALL(which, arg0, 0, 0)
 #define SBI_CALL_2(which, arg0, arg1) SBI_CALL(which, arg0, arg1, 0)
+#define SBI_CALL_3(which, arg0, arg1, arg2) SBI_CALL(which, arg0, arg1, arg2)
+
+static inline bool sbi_probe_pma(void)
+{
+	return SBI_CALL_0(SBI_PROBE_PMA);
+}
+
+static inline void sbi_set_pma(phys_addr_t offset, unsigned long vaddr,
+			       size_t size)
+{
+	SBI_CALL_3(SBI_SET_PMA, offset, vaddr, size);
+}
+
+static inline void sbi_free_pma(unsigned long vaddr)
+{
+	SBI_CALL_1(SBI_FREE_PMA, vaddr);
+}
+
+static inline void sbi_set_reset_vec(int val)
+{
+	SBI_CALL_1(SBI_SET_RESET_VEC, val);
+}
+
+static inline void sbi_restart(int val)
+{
+	SBI_CALL_1(SBI_RESTART, val);
+}
+
+static inline void sbi_write_powerbrake(int val)
+{
+	SBI_CALL_1(SBI_WRITE_POWERBRAKE, val);
+}
+
+static inline int sbi_read_powerbrake(void)
+{
+	return SBI_CALL_0(SBI_READ_POWERBRAKE);
+}
+
+static inline void sbi_set_trigger(unsigned int type, uintptr_t data, int enable)
+{
+	SBI_CALL_3(SBI_TRIGGER, type, data, enable);
+}
 
 static inline void sbi_console_putchar(int ch)
 {
diff --git a/arch/riscv/include/asm/seccomp.h b/arch/riscv/include/asm/seccomp.h
new file mode 100644
index 00000000..149e1a11
--- /dev/null
+++ b/arch/riscv/include/asm/seccomp.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _ASM_RISCV_SECCOMP_H
+#define _ASM_RISCV_SECCOMP_H
+
+#include <asm/unistd.h>
+
+#ifdef CONFIG_COMPAT
+#include <asm/ia32_unistd.h>
+#define __NR_seccomp_read_32		__NR_ia32_read
+#define __NR_seccomp_write_32		__NR_ia32_write
+#define __NR_seccomp_exit_32		__NR_ia32_exit
+#define __NR_seccomp_sigreturn_32	__NR_ia32_sigreturn
+#endif
+
+#include <asm-generic/seccomp.h>
+
+#endif /* _ASM_RISCV_SECCOMP_H */
diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index 85e42208..2dfd41a6 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -14,19 +14,12 @@
 #ifndef _ASM_RISCV_SMP_H
 #define _ASM_RISCV_SMP_H
 
-/* This both needs asm-offsets.h and is used when generating it. */
-#ifndef GENERATING_ASM_OFFSETS
-#include <asm/asm-offsets.h>
-#endif
-
 #include <linux/cpumask.h>
 #include <linux/irqreturn.h>
+#include <linux/thread_info.h>
 
 #ifdef CONFIG_SMP
 
-/* SMP initialization hook for setup_arch */
-void __init init_clockevent(void);
-
 /* SMP initialization hook for setup_arch */
 void __init setup_smp(void);
 
@@ -37,16 +30,20 @@ void arch_send_call_function_ipi_mask(struct cpumask *mask);
 void arch_send_call_function_single_ipi(int cpu);
 
 /*
- * This is particularly ugly: it appears we can't actually get the definition
- * of task_struct here, but we need access to the CPU this task is running on.
- * Instead of using C we're using asm-offsets.h to get the current processor
- * ID.
+ * Obtains the hart ID of the currently executing task.  This relies on
+ * THREAD_INFO_IN_TASK, but we define that unconditionally.
  */
-#define raw_smp_processor_id() (*((int*)((char*)get_current() + TASK_TI_CPU)))
+#define raw_smp_processor_id() (current_thread_info()->cpu)
 
 /* Interprocessor interrupt handler */
 irqreturn_t handle_ipi(void);
 
+#ifdef CONFIG_HOTPLUG_CPU
+extern int __cpu_disable(void);
+extern void __cpu_die(unsigned int cpu);
+extern void cpu_play_dead(void);
+extern void boot_sec_cpu(void);
+#endif
 #endif /* CONFIG_SMP */
 
 #endif /* _ASM_RISCV_SMP_H */
diff --git a/arch/riscv/include/asm/string.h b/arch/riscv/include/asm/string.h
index 9210fcf4..a3150b54 100644
--- a/arch/riscv/include/asm/string.h
+++ b/arch/riscv/include/asm/string.h
@@ -19,8 +19,18 @@
 
 #define __HAVE_ARCH_MEMSET
 extern asmlinkage void *memset(void *, int, size_t);
+extern asmlinkage void *__memset(void *, int, size_t);
 
 #define __HAVE_ARCH_MEMCPY
 extern asmlinkage void *memcpy(void *, const void *, size_t);
+extern asmlinkage void *__memcpy(void *, const void *, size_t);
+
+#define __HAVE_ARCH_MEMMOVE
+extern asmlinkage void *memmove(void *, const void *, size_t);
+extern asmlinkage void *__memmove(void *, const void *, size_t);
+
+#define memcpy(dst, src, len) __memcpy(dst, src, len)
+#define memmove(dst, src, len) __memmove(dst, src, len)
+#define memset(s, c, n) __memset(s, c, n)
 
 #endif /* _ASM_RISCV_STRING_H */
diff --git a/arch/riscv/include/asm/switch_to.h b/arch/riscv/include/asm/switch_to.h
index dd6b05bf..cae56a08 100644
--- a/arch/riscv/include/asm/switch_to.h
+++ b/arch/riscv/include/asm/switch_to.h
@@ -18,6 +18,7 @@
 #include <asm/ptrace.h>
 #include <asm/csr.h>
 
+#ifdef CONFIG_FPU
 extern void __fstate_save(struct task_struct *save_to);
 extern void __fstate_restore(struct task_struct *restore_from);
 
@@ -44,25 +45,56 @@ static inline void fstate_restore(struct task_struct *task,
 	}
 }
 
+extern bool has_fpu;
+#else
+#define has_fpu false
+#define fstate_save(task, regs) do { } while (0)
+#define fstate_restore(task, regs) do { } while (0)
+#endif
+
+#ifdef CONFIG_DSP
+static inline void dspstate_save(struct task_struct *task)
+{
+	task->thread.dspstate.ucode = csr_read(ucode);
+}
+static inline void dspstate_restore(struct task_struct *task)
+{
+	csr_write(ucode, task->thread.dspstate.ucode);
+}
+extern bool has_dsp;
+#else
+#define has_dsp false
+#define dspstate_save(task, regs) do { } while (0)
+#define dspstate_restore(task, regs) do { } while (0)
+#endif
+
+extern struct task_struct *__switch_to(struct task_struct *,
+				       struct task_struct *);
+
 static inline void __switch_to_aux(struct task_struct *prev,
 				   struct task_struct *next)
 {
+#ifdef CONFIG_FPU
 	struct pt_regs *regs;
-
 	regs = task_pt_regs(prev);
 	if (unlikely(regs->sstatus & SR_SD))
 		fstate_save(prev, regs);
 	fstate_restore(next, task_pt_regs(next));
+#endif
+#ifdef CONFIG_DSP
+	if (likely(has_dsp)) {
+		dspstate_save(prev);
+		dspstate_restore(next);
+	}
+#endif
 }
 
-extern struct task_struct *__switch_to(struct task_struct *,
-				       struct task_struct *);
-
 #define switch_to(prev, next, last)			\
 do {							\
 	struct task_struct *__prev = (prev);		\
 	struct task_struct *__next = (next);		\
-	__switch_to_aux(__prev, __next);		\
+	if (has_fpu || has_dsp)				\
+		__switch_to_aux(__prev, __next);	\
 	((last) = __switch_to(__prev, __next));		\
 } while (0)
 
diff --git a/arch/riscv/include/asm/syscall.h b/arch/riscv/include/asm/syscall.h
index 8d25f890..d24f774f 100644
--- a/arch/riscv/include/asm/syscall.h
+++ b/arch/riscv/include/asm/syscall.h
@@ -19,6 +19,7 @@
 #define _ASM_RISCV_SYSCALL_H
 
 #include <linux/sched.h>
+#include <uapi/linux/audit.h>
 #include <linux/err.h>
 
 /* The array of function pointers for syscalls. */
@@ -99,4 +100,9 @@ static inline void syscall_set_arguments(struct task_struct *task,
 	memcpy(&regs->a1 + i * sizeof(regs->a1), args, n * sizeof(regs->a0));
 }
 
+static inline int syscall_get_arch(void)
+{
+	return AUDIT_ARCH_RISCV;
+}
+
 #endif	/* _ASM_RISCV_SYSCALL_H */
diff --git a/arch/riscv/include/asm/thread_info.h b/arch/riscv/include/asm/thread_info.h
index f8fa1cd2..c0a3f5e0 100644
--- a/arch/riscv/include/asm/thread_info.h
+++ b/arch/riscv/include/asm/thread_info.h
@@ -80,13 +80,19 @@ struct thread_info {
 #define TIF_RESTORE_SIGMASK	4	/* restore signal mask in do_signal() */
 #define TIF_MEMDIE		5	/* is terminating due to OOM killer */
 #define TIF_SYSCALL_TRACEPOINT  6       /* syscall tracepoint instrumentation */
+#define TIF_SECCOMP		7	/* seccomp syscall filtering active */
+#define TIF_SINGLESTEP		8	/* trigger module single step */
 
 #define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
 #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
 #define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
+#define _TIF_SINGLESTEP		(1 << TIF_SINGLESTEP)
 
 #define _TIF_WORK_MASK \
 	(_TIF_NOTIFY_RESUME | _TIF_SIGPENDING | _TIF_NEED_RESCHED)
 
+#define _TIF_WORK_SYSCALL_MASK \
+	(_TIF_SYSCALL_TRACE | _TIF_SINGLESTEP)
+
 #endif /* _ASM_RISCV_THREAD_INFO_H */
diff --git a/arch/riscv/include/asm/timex.h b/arch/riscv/include/asm/timex.h
index 2f26989c..12efecfd 100644
--- a/arch/riscv/include/asm/timex.h
+++ b/arch/riscv/include/asm/timex.h
@@ -18,7 +18,7 @@
 
 typedef unsigned long cycles_t;
 
-static inline cycles_t get_cycles_inline(void)
+static inline notrace cycles_t get_cycles_inline(void)
 {
 	cycles_t n;
 
@@ -30,12 +30,12 @@ static inline cycles_t get_cycles_inline(void)
 #define get_cycles get_cycles_inline
 
 #ifdef CONFIG_64BIT
-static inline uint64_t get_cycles64(void)
+static inline notrace uint64_t get_cycles64(void)
 {
         return get_cycles();
 }
 #else
-static inline uint64_t get_cycles64(void)
+static inline notrace uint64_t get_cycles64(void)
 {
 	u32 lo, hi, tmp;
 	__asm__ __volatile__ (
diff --git a/arch/riscv/include/asm/tlbflush.h b/arch/riscv/include/asm/tlbflush.h
index 7b209aec..011c0b81 100644
--- a/arch/riscv/include/asm/tlbflush.h
+++ b/arch/riscv/include/asm/tlbflush.h
@@ -24,12 +24,14 @@
 static inline void local_flush_tlb_all(void)
 {
 	__asm__ __volatile__ ("sfence.vma" : : : "memory");
+	__asm__ __volatile__ ("fence.i" : : : "memory");
 }
 
 /* Flush one page from local TLB */
 static inline void local_flush_tlb_page(unsigned long addr)
 {
 	__asm__ __volatile__ ("sfence.vma %0" : : "r" (addr) : "memory");
+	__asm__ __volatile__ ("fence.i" : : : "memory");
 }
 
 #ifndef CONFIG_SMP
diff --git a/arch/riscv/include/asm/uaccess.h b/arch/riscv/include/asm/uaccess.h
index 14b0b22f..e15f7c7d 100644
--- a/arch/riscv/include/asm/uaccess.h
+++ b/arch/riscv/include/asm/uaccess.h
@@ -307,7 +307,7 @@ do {								\
 		"	.balign 4\n"				\
 		"4:\n"						\
 		"	li %0, %6\n"				\
-		"	jump 2b, %1\n"				\
+		"	jump 3b, %1\n"				\
 		"	.previous\n"				\
 		"	.section __ex_table,\"a\"\n"		\
 		"	.balign " RISCV_SZPTR "\n"			\
diff --git a/arch/riscv/include/uapi/asm/elf.h b/arch/riscv/include/uapi/asm/elf.h
index 5cae4c30..bef95246 100644
--- a/arch/riscv/include/uapi/asm/elf.h
+++ b/arch/riscv/include/uapi/asm/elf.h
@@ -19,10 +19,21 @@ typedef unsigned long elf_greg_t;
 typedef struct user_regs_struct elf_gregset_t;
 #define ELF_NGREG (sizeof(elf_gregset_t) / sizeof(elf_greg_t))
 
+/*
+ * Use 32-bits wide as fpr register size. Because there is a 32-bits wide
+ * register 'fcsr' at the end of fp state structure.
+ */
+typedef u32 elf_fpreg_t;
 typedef union __riscv_fp_state elf_fpregset_t;
+#define ELF_NFPREG (sizeof(elf_fpregset_t) / sizeof(elf_fpreg_t))
 
-#define ELF_RISCV_R_SYM(r_info) ((r_info) >> 32)
-#define ELF_RISCV_R_TYPE(r_info) ((r_info) & 0xffffffff)
+#if __riscv_xlen == 64
+#define ELF_RISCV_R_SYM(r_info)		ELF64_R_SYM(r_info)
+#define ELF_RISCV_R_TYPE(r_info)	ELF64_R_TYPE(r_info)
+#else
+#define ELF_RISCV_R_SYM(r_info)		ELF32_R_SYM(r_info)
+#define ELF_RISCV_R_TYPE(r_info)	ELF32_R_TYPE(r_info)
+#endif
 
 /*
  * RISC-V relocation types
@@ -86,5 +97,22 @@ typedef union __riscv_fp_state elf_fpregset_t;
 #define R_RISCV_SET32		56
 #define R_RISCV_32_PCREL	57
 
+/* NDS V5*/
+#define R_RISCV_ALIGN_BTB		240
+#define R_RISCV_10_PCREL		241
+#define R_RISCV_DATA			242
+#define R_RISCV_LALO_HI20		243
+#define R_RISCV_LALO_LO12_I		244
+#define R_RISCV_RELAX_ENTRY		245
+#define R_RISCV_LGP18S0			246
+#define R_RISCV_LGP17S1			247
+#define R_RISCV_LGP17S2			248
+#define R_RISCV_LGP17S3			249
+#define R_RISCV_SGP18S0			250
+#define R_RISCV_SGP17S1			251
+#define R_RISCV_SGP17S2			252
+#define R_RISCV_SGP17S3			253
+#define R_RISCV_RELAX_REGION_BEGIN	254
+#define R_RISCV_RELAX_REGION_END	255
 
 #endif /* _UAPI_ASM_ELF_H */
diff --git a/arch/riscv/include/uapi/asm/ptrace.h b/arch/riscv/include/uapi/asm/ptrace.h
index 1a9e4cdd..0bd9c8a4 100644
--- a/arch/riscv/include/uapi/asm/ptrace.h
+++ b/arch/riscv/include/uapi/asm/ptrace.h
@@ -59,6 +59,12 @@ struct user_regs_struct {
 	unsigned long t6;
 };
 
+#ifdef CONFIG_DSP
+struct __riscv_dsp_state {
+	unsigned long ucode;
+};
+#endif
+
 struct __riscv_f_ext_state {
 	__u32 f[32];
 	__u32 fcsr;
diff --git a/arch/riscv/include/uapi/asm/sigcontext.h b/arch/riscv/include/uapi/asm/sigcontext.h
index ed7372b2..80748908 100644
--- a/arch/riscv/include/uapi/asm/sigcontext.h
+++ b/arch/riscv/include/uapi/asm/sigcontext.h
@@ -25,6 +25,9 @@
 struct sigcontext {
 	struct user_regs_struct sc_regs;
 	union __riscv_fp_state sc_fpregs;
+#ifdef CONFIG_DSP
+	struct __riscv_dsp_state sc_dspregs;
+#endif
 };
 
 #endif /* _UAPI_ASM_RISCV_SIGCONTEXT_H */
diff --git a/arch/riscv/kernel/.gitignore b/arch/riscv/kernel/.gitignore
deleted file mode 100644
index b51634f6..00000000
--- a/arch/riscv/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/vmlinux.lds
diff --git a/arch/riscv/kernel/Makefile b/arch/riscv/kernel/Makefile
index 8586dd96..82a35fbf 100644
--- a/arch/riscv/kernel/Makefile
+++ b/arch/riscv/kernel/Makefile
@@ -13,6 +13,9 @@ extra-y += vmlinux.lds
 obj-y	+= cpu.o
 obj-y	+= cpufeature.o
 obj-y	+= entry.o
+ifdef CONFIG_ARCH_BINFMT_ELF_STATE
+obj-y	+= elf.o
+endif
 obj-y	+= irq.o
 obj-y	+= process.o
 obj-y	+= ptrace.o
@@ -29,8 +32,10 @@ obj-y	+= vdso.o
 obj-y	+= cacheinfo.o
 obj-y	+= vdso/
 
+KASAN_SANITIZE_setup.o := n
 CFLAGS_setup.o := -mcmodel=medany
 
+obj-$(CONFIG_FPU)		+= fpu.o
 obj-$(CONFIG_SMP)		+= smpboot.o
 obj-$(CONFIG_SMP)		+= smp.o
 obj-$(CONFIG_MODULES)		+= module.o
@@ -39,4 +44,8 @@ obj-$(CONFIG_MODULE_SECTIONS)	+= module-sections.o
 obj-$(CONFIG_FUNCTION_TRACER)	+= mcount.o ftrace.o
 obj-$(CONFIG_DYNAMIC_FTRACE)	+= mcount-dyn.o
 
+obj-$(CONFIG_PERF_EVENTS)      += perf_event.o
+
+obj-$(CONFIG_PM)		+= pm.o sleep.o
+
 clean:
diff --git a/arch/riscv/kernel/asm-offsets.c b/arch/riscv/kernel/asm-offsets.c
index 6a92a2fe..dac98348 100644
--- a/arch/riscv/kernel/asm-offsets.c
+++ b/arch/riscv/kernel/asm-offsets.c
@@ -39,6 +39,7 @@ void asm_offsets(void)
 	OFFSET(TASK_STACK, task_struct, stack);
 	OFFSET(TASK_TI, task_struct, thread_info);
 	OFFSET(TASK_TI_FLAGS, task_struct, thread_info.flags);
+	OFFSET(TASK_TI_PREEMPT_COUNT, task_struct, thread_info.preempt_count);
 	OFFSET(TASK_TI_KERNEL_SP, task_struct, thread_info.kernel_sp);
 	OFFSET(TASK_TI_USER_SP, task_struct, thread_info.user_sp);
 	OFFSET(TASK_TI_CPU, task_struct, thread_info.cpu);
diff --git a/arch/riscv/kernel/cpufeature.c b/arch/riscv/kernel/cpufeature.c
index 17011a87..ebf367fb 100644
--- a/arch/riscv/kernel/cpufeature.c
+++ b/arch/riscv/kernel/cpufeature.c
@@ -21,23 +21,21 @@
 #include <asm/processor.h>
 #include <asm/hwcap.h>
 
-unsigned long elf_hwcap __read_mostly;
+unsigned int elf_hwcap __read_mostly;
+unsigned int elf_hwcap2 __read_mostly;
+const char *elf_platform;
+EXPORT_SYMBOL(elf_platform);
+#ifdef CONFIG_FPU
+bool has_fpu __read_mostly;
+#endif
+#ifdef CONFIG_DSP
+bool has_dsp __read_mostly;
+#endif
 
 void riscv_fill_hwcap(void)
 {
 	struct device_node *node;
-	const char *isa;
-	size_t i;
-	static unsigned long isa2hwcap[256] = {0};
-
-	isa2hwcap['i'] = isa2hwcap['I'] = COMPAT_HWCAP_ISA_I;
-	isa2hwcap['m'] = isa2hwcap['M'] = COMPAT_HWCAP_ISA_M;
-	isa2hwcap['a'] = isa2hwcap['A'] = COMPAT_HWCAP_ISA_A;
-	isa2hwcap['f'] = isa2hwcap['F'] = COMPAT_HWCAP_ISA_F;
-	isa2hwcap['d'] = isa2hwcap['D'] = COMPAT_HWCAP_ISA_D;
-	isa2hwcap['c'] = isa2hwcap['C'] = COMPAT_HWCAP_ISA_C;
-
-	elf_hwcap = 0;
+	u32 major, minor;
 
 	/*
 	 * We don't support running Linux on hertergenous ISA systems.  For
@@ -49,13 +47,30 @@ void riscv_fill_hwcap(void)
 		return;
 	}
 
-	if (of_property_read_string(node, "riscv,isa", &isa)) {
+	if (of_property_read_string(node, "riscv,isa", &elf_platform)) {
 		pr_warning("Unable to find \"riscv,isa\" devicetree entry");
 		return;
 	}
+	pr_info("elf_platform is %s", elf_platform);
+
+	if (of_property_read_u32(node, "riscv,priv-major", &major) ||
+	    of_property_read_u32(node, "riscv,priv-minor", &minor)) {
+		pr_warning("Unable to find \"riscv,priv*\" devicetree entry");
+		return;
+	}
+	pr_info("compatible privileged spec version %d.%d", major, minor);
 
-	for (i = 0; i < strlen(isa); ++i)
-		elf_hwcap |= isa2hwcap[(unsigned char)(isa[i])];
+	/* enabling ELF atrribute checking */
+	elf_hwcap = 1;
+	/* wrap up the priv spec version */
+	elf_hwcap2 = (major << 16) | minor;
 
-	pr_info("elf_hwcap is 0x%lx", elf_hwcap);
+#ifdef CONFIG_FPU
+       if (strstr(elf_platform, "f2p0") && strstr(elf_platform, "d2p0"))
+               has_fpu = true;
+#endif
+#ifdef CONFIG_DSP
+       if (strstr(elf_platform, "xdsp"))
+               has_dsp = true;
+#endif
 }
diff --git a/arch/riscv/kernel/elf.c b/arch/riscv/kernel/elf.c
new file mode 100644
index 00000000..7522b3b2
--- /dev/null
+++ b/arch/riscv/kernel/elf.c
@@ -0,0 +1,610 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 Andes Technology Corporation
+ */
+
+#include <linux/elf.h>
+#include <linux/printk.h>
+#include <linux/binfmts.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/ctype.h>
+
+unsigned int elf_attribute_checking = 1;
+EXPORT_SYMBOL(elf_attribute_checking);
+
+static const char *strcasechr(const char *str, char c)
+{
+	const char *s = str;
+	for (; tolower(*s) != tolower(c); s++)
+		if (*s == '\0')
+			return NULL;
+	return s;
+}
+
+char parse_byte(const char** buf, const char* end)
+{
+	const char ch = **buf;
+
+	if (end - *buf < sizeof(char))
+		pr_warn("Truncated ELF attribute section");
+	*buf = *buf + sizeof(char);
+	return ch;
+}
+
+unsigned int parse_uint32le(const char** buf, const char* end)
+{
+	const unsigned int i = *((const unsigned int*) *buf);
+
+	if (end - *buf < sizeof(unsigned int))
+		pr_warn("Truncated ELF attribute section");
+	*buf = *buf + sizeof(unsigned int);
+	return i;
+}
+
+const char* parse_ntbs(const char** buf, const char* end)
+{
+	const char* s = (const char*) *buf;
+	while (*buf < end && **buf != '\0')
+		(*buf)++;
+
+	if (*buf == end)
+		pr_warn("Truncated ELF attribute section");
+
+	(*buf)++; // Skip over '\0'
+	return s;
+}
+
+unsigned long parse_uleb128(const char** buf, const char* end)
+{
+	unsigned long shift = 0;
+	unsigned long value = 0;
+	while (*buf < end) {
+		value |= (**buf & 0x7f) << shift;
+		if ((**buf & 0x80) == 0)
+			break;
+		*buf += 1;
+		shift += 7;
+	}
+
+	if (*buf == end)
+		pr_warn("Truncated ELF attribute section");
+
+	*buf += 1;
+
+	return value;
+}
+
+int parse_decimal(const char** s)
+{
+	int n = 0;
+
+	if (!isdigit(**s))
+		pr_warn("Invalid decimal number `%c'", **s);
+
+	while (isdigit(**s)) {
+		n = n * 10 + (**s - '0');
+		*s += 1;
+	}
+
+	return n;
+}
+
+struct riscv_version {
+	int major;
+	int minor;
+};
+
+static bool parse_riscv_isa_version(const char** ver)
+{
+	struct riscv_version v;
+
+	v.major = parse_decimal(ver);
+
+	if (**ver != 'p') {
+		pr_warn("Major version number is not followed by `p'");
+		return false;
+	}
+	*ver += 1;
+
+	v.minor = parse_decimal(ver);
+
+	return true;
+}
+
+
+static void skip_underscores(const char **s)
+{
+	while (**s == '_')
+		(*s)++;
+}
+
+static bool riscv_isa_version_backward_compatible(struct riscv_version *elf,
+	struct riscv_version *host)
+{
+	if(elf->major > host->major)
+		return false;
+	if(elf->major == host->major || elf->minor > host->minor)
+		return false;
+	return true;
+}
+
+static bool riscv_isa_version_exact_compatible(struct riscv_version *elf,
+	struct riscv_version *host)
+{
+	if(elf->major != host->major || elf->minor != host->minor)
+		return false;
+	return true;
+}
+
+typedef bool (*compat_func_t)(struct riscv_version *elf,
+	struct riscv_version *host);
+
+static bool riscv_isa_version_compatible(const char** elf_ver,
+	const char **host_ver, compat_func_t fn)
+{
+	struct riscv_version elf;
+	struct riscv_version host;
+
+	/*
+	 * ISA version is in the format of "<major>p<minor>" where major and
+	 * minor numbers are decimal. We don't use strtol() here to avoid
+	 * accepting whitespaces or plus/minus signs.
+	 */
+	elf.major = parse_decimal(elf_ver);
+	host.major = parse_decimal(host_ver);
+
+	if (**elf_ver != 'p' || **host_ver != 'p') {
+		pr_warn("Major version number is not followed by `p'");
+		return false;
+	}
+	*elf_ver += 1;
+	*host_ver += 1;
+
+	elf.minor = parse_decimal(elf_ver);
+	host.minor = parse_decimal(host_ver);
+
+	return (*fn)(&elf, &host);
+}
+
+static bool riscv_non_standard_compatible(const char **elf_nse,
+	const char **host_nse)
+{
+	/* We need more discussion on non-standard extension processing */
+	return true;
+}
+
+const char* riscv_extensions = "MAFDQLCBJTPVN";
+
+static inline bool extension_later_than(char elf_ex, char host_ex)
+{
+	const char* elf = strcasechr(riscv_extensions, elf_ex);
+	const char* host = strcasechr(riscv_extensions, host_ex);
+
+	if (elf > host)
+		return true;
+	return false;
+}
+
+static inline bool reach_extension_end(char host_ex)
+{
+	if (host_ex == 'x' || host_ex == 'X' || host_ex == '\0')
+		return true;
+	return false;
+}
+
+static bool riscv_extension_compatible(const char** elf_isa,
+	const char **host_isa)
+{
+	char ch;
+	const char *prev_pos = NULL;
+	const char *curr_pos = NULL;
+
+	while (**elf_isa != '\0') {
+		if (**elf_isa == 'x' || **elf_isa == 'X')
+			return true;
+
+		while (extension_later_than(**elf_isa, **host_isa)) {
+			(*host_isa)++;
+			parse_riscv_isa_version(host_isa);
+
+			if (reach_extension_end(**host_isa))
+				return false;
+		}
+
+		curr_pos = strcasechr(riscv_extensions, **elf_isa);
+		if (prev_pos && prev_pos > curr_pos) {
+			pr_warn("Wrong extension order `%c' after `%c'",
+			        *curr_pos, *prev_pos);
+			return false;
+		}
+		prev_pos = curr_pos;
+
+		if (tolower(**elf_isa) < tolower(**host_isa)) {
+			/*
+			 * According to the law of trichonomy, something went
+			 * wrong here.  This ELF has an non-supported extension.
+			 * Abort the check.
+			 */
+			pr_warn("Invalid extension `%c'", **elf_isa);
+			return false;
+		}
+
+		ch = **elf_isa;
+		switch (tolower(ch)) {
+		/*
+		 * This group of extensions has been frozen, so an exact
+		 * match is assumed.
+		 */
+		case 'm':
+		case 'a':
+		case 'f':
+		case 'd':
+		case 'q':
+		case 'c':
+			(*elf_isa)++;
+			(*host_isa)++;
+			if (!riscv_isa_version_compatible(elf_isa, host_isa,
+				&riscv_isa_version_exact_compatible)) {
+				pr_warn("Extension `%c' is not compatible", ch);
+				return false;
+			}
+			break;
+		/*
+		 * Extensions in this group are development in progress.
+		 * Assuming backward compatibility here.
+		 */
+		case 'l':
+		case 'b':
+		case 'j':
+		case 't':
+		case 'p':
+		case 'v':
+		case 'n':
+			(*elf_isa)++;
+			(*host_isa)++;
+			if (!riscv_isa_version_compatible(elf_isa, host_isa,
+				&riscv_isa_version_backward_compatible)) {
+				pr_warn("Extension `%c' is not compatible", ch);
+				return false;
+			}
+			break;
+		default:
+			/* should NOT be here */
+			pr_warn("Invalid extension `%c'", ch);
+			return false;
+		}
+
+		skip_underscores(elf_isa);
+		skip_underscores(host_isa);
+	}
+	return true;
+}
+
+#define RISCV_NUM_BASE_ISA 4
+static bool riscv_base_isa_compatible(const char** elf_isa,
+	const char **host_isa)
+{
+	/* The ISA string must begin with one of these four */
+	const char* base_isas[RISCV_NUM_BASE_ISA] = { "RV32I", "RV32E", "RV64I",
+						      "RV128I" };
+	int elf_base = -1;
+	int host_base = -1;
+	int i;
+	const char* elf_orig = *elf_isa;
+
+	for (i = 0; i < RISCV_NUM_BASE_ISA; i++) {
+		size_t len = strlen(base_isas[i]);
+		if (elf_base < 0 && !strncasecmp(*elf_isa, base_isas[i], len)) {
+			elf_base = i;
+			*elf_isa += len;
+		}
+		if (host_base < 0 && !strncasecmp(*host_isa, base_isas[i], len)) {
+			host_base = i;
+			*host_isa += len;
+		}
+	}
+
+	if (elf_base < 0 || host_base < 0)
+		goto out_invalid_base;
+
+	if (elf_base != host_base)
+		goto out_invalid_base;
+
+	if (!riscv_isa_version_compatible(elf_isa, host_isa,
+					  &riscv_isa_version_exact_compatible)) {
+		pr_warn("The version of base ISA `%s' is not compatible",
+			base_isas[elf_base]);
+		return false;
+	}
+
+	skip_underscores(elf_isa);
+	skip_underscores(host_isa);
+
+	return true;
+out_invalid_base:
+	pr_warn("Invalid base ISA `%s'", elf_orig);
+	return false;
+}
+
+static bool riscv_isa_compatible(const char* elf_isa)
+{
+	const char *host_isa = elf_platform;
+
+	if (!strcmp(elf_isa, host_isa))
+		return true;
+
+	/* The ISA string starts with the base ISA */
+	if (!riscv_base_isa_compatible(&elf_isa, &host_isa))
+		return false;
+
+	/* Followed by multiple extensions */
+	if (!riscv_extension_compatible(&elf_isa, &host_isa))
+		return false;
+
+	/* Optionally followed by non-standard extensions */
+	if (!riscv_non_standard_compatible(&elf_isa, &host_isa))
+		return false;
+
+	return true;
+}
+
+static bool riscv_priv_spec_compatible(struct riscv_version *priv)
+{
+	struct riscv_version host;
+
+	host.major = elf_hwcap2 >> 16;
+	host.minor = elf_hwcap2 & 0xFFFF;
+
+	if (!riscv_isa_version_exact_compatible(priv, &host))
+		return false;
+	return true;
+}
+
+#define Tag_File                     1
+#define Tag_RISCV_stack_align        4
+#define Tag_RISCV_arch               5
+#define Tag_RISCV_unaligned_access   6
+#define Tag_RISCV_priv_spec          8
+#define Tag_RISCV_priv_spec_minor    10
+#define Tag_RISCV_priv_spec_revision 12
+#define Tag_ict_version              0x8000
+#define Tag_ict_model                0x8001
+
+#define Tag_arch_legacy               4
+#define Tag_priv_spec_legacy          5
+#define Tag_priv_spec_minor_legacy    6
+#define Tag_priv_spec_revision_legacy 7
+#define Tag_strict_align_legacy       8
+#define Tag_stack_align_legacy        9
+#define TAG_IGNORE_CASE(tag) \
+	case tag: \
+		continue;
+
+static int parse_riscv_attributes(const char* buf, const char* end)
+{
+	unsigned long tag;
+	const char* isa;
+
+	while (buf < end) {
+		/*
+		 * Each attribute is a pair of tag and value. The value can be
+		 * either a null-terminated byte string or an ULEB128 encoded
+		 * integer depending on the tag.
+		 */
+		tag = parse_uleb128(&buf, end);
+		switch (tag) {
+			case Tag_RISCV_arch:
+				/* For Tag_arch, parse the arch substring. */
+				isa = parse_ntbs(&buf, end);
+				if (riscv_isa_compatible(isa))
+					return 0;
+				break;
+			case Tag_RISCV_stack_align:
+				parse_uleb128(&buf, end);
+				break;
+			/* Simply ignore other tags */
+			TAG_IGNORE_CASE(Tag_RISCV_priv_spec_revision)
+			TAG_IGNORE_CASE(Tag_RISCV_priv_spec)
+			TAG_IGNORE_CASE(Tag_RISCV_priv_spec_minor)
+			TAG_IGNORE_CASE(Tag_RISCV_unaligned_access)
+				continue;
+			default:
+				pr_warn("Unknown RISCV attribute tag %lu", tag);
+				continue;
+		}
+	}
+	return -ENOEXEC;
+}
+
+
+static int parse_legacy_riscv_attributes(const char* buf, const char* end)
+{
+	unsigned long tag;
+	const char* isa;
+	struct riscv_version priv = {.major = 0, .minor = 0};
+	int total_check = 0;
+
+	while (buf < end) {
+		/*
+		 * Each attribute is a pair of tag and value. The value can be
+		 * either a null-terminated byte string or an ULEB128 encoded
+		 * integer depending on the tag.
+		 */
+		tag = parse_uleb128(&buf, end);
+		switch (tag) {
+			case Tag_arch_legacy:
+				/* For Tag_arch, parse the arch substring. */
+				isa = parse_ntbs(&buf, end);
+				if (!riscv_isa_compatible(isa))
+					return -ENOEXEC;
+				total_check++;
+				break;
+			case Tag_priv_spec_legacy:
+				priv.major = parse_uleb128(&buf, end);
+				total_check++;
+				break;
+			case Tag_priv_spec_minor_legacy:
+				priv.minor = parse_uleb128(&buf, end);
+				total_check++;
+				break;
+			/* Simply ignore other tags */
+			TAG_IGNORE_CASE(Tag_priv_spec_revision_legacy)
+			TAG_IGNORE_CASE(Tag_strict_align_legacy)
+			TAG_IGNORE_CASE(Tag_stack_align_legacy)
+				continue;
+			default:
+				pr_warn("Unknown RISCV attribute tag %lu", tag);
+				continue;
+		}
+
+		if (total_check == 3) {
+			if (riscv_priv_spec_compatible(&priv))
+				return 0;
+			break;
+		}
+	}
+	return -ENOEXEC;
+}
+
+/*
+ * Our toolchain previously used incompatible values for tags and there is no
+ * good way to disambiguate them as there is no version information for the
+ * attribute per se.
+
+ * We "guess" the format by checking if the value for tag 4 is a string
+ * that starts with "rv", in this case it must be the old Tag_arch. Otherwise,
+ * we treat the whole attribute section as new.
+ */
+static bool is_legacy_riscv_attributes(const char* buf, const char* end)
+{
+	unsigned long tag = parse_uleb128(&buf, end);
+
+	if (tag == 4 && end - buf >= 2 && \
+	    strncasecmp((const char*) buf, "rv", 2) == 0)
+		return true;
+	return false;
+}
+
+/*
+ * We assume that the subsection started with "riscv", the only subsection we
+ * support now, has one attribute entry only.  We don't support finer
+ * grainularity (attributes for multiple files, sections or symbols), but
+ * recongnize the ELF file as a whole.
+ */
+static int parse_riscv_subsection(const char* buf, const char* end)
+{
+	const char* sub_begin = buf;
+	const char* sub_end;
+	unsigned int len;
+
+	/* The "riscv" subsection must begin with a Tag_File */
+	if (parse_uleb128(&buf, end) != Tag_File) {
+		pr_warn("No Tag_File in \"riscv\" subsection");
+		goto out_noexec;
+	}
+
+	/* Followed by a length field including the tag byte */
+	len = parse_uint32le(&buf, end);
+	if (end - sub_begin < len) {
+		pr_warn("Truncated \"riscv\" attribute subsection");
+		goto out_noexec;
+	}
+	sub_end = sub_begin + len;
+
+	/* Followed by the actual RISC-V attributes */
+	//if (parse_riscv_attributes(buf, sub_end))
+	//	goto out_noexec;
+	if (is_legacy_riscv_attributes(buf, sub_end)) {
+		if(parse_legacy_riscv_attributes(buf, sub_end))
+			goto out_noexec;
+	} else if(parse_riscv_attributes(buf, sub_end))
+		goto out_noexec;
+
+	return 0;
+out_noexec:
+	return -ENOEXEC;
+}
+
+/*
+ * We implement this ELF attribute section with reference to Sec 2.2, ARM IHI
+ * 0045E specification, but a slightly restricted form.  For detail please
+ * check parse_elf_attribute_subsection.
+ */
+static int parse_elf_attribute_section(const char* buf, const char* end)
+{
+	const char version = parse_byte(&buf, end);
+	char* sub_begin;
+	char* sub_end;
+	size_t len;
+
+	/* The first byte must be the ASCII character 'A' */
+	if (version != 'A') {
+		pr_warn("Unsupported ELF attribute version");
+		goto out_noexec;
+	}
+
+	/* The section is divided into multiple subsections. */
+	while (buf < end) {
+		/*
+		 * Each subsection begins with a 32-bit unsigned integer
+		 * indicating its length (including the length field itself).
+		 */
+		sub_begin = (char *)buf;
+		len = parse_uint32le(&buf, end);
+		if (end - sub_begin < len) {
+			pr_warn("Truncated ELF attribute subsection");
+			goto out_noexec;
+		}
+		sub_end = sub_begin + len;
+
+		/*
+		 * It is followed by the a null-terminated name which determines
+		 * how to parse the content.  For now we only support one
+		 * subsection named "riscv" here.
+		 */
+		if (strcmp(buf, "riscv")) {
+			pr_warn("Ignore not supported subsection %s", buf);
+			buf = sub_end;
+			continue;
+		}
+
+		buf += strlen("riscv") + 1;
+		if(parse_riscv_subsection(buf, sub_end))
+			goto out_noexec;
+
+		buf = sub_end;
+	}
+
+	return 0;
+out_noexec:
+	return -ENOEXEC;
+}
+
+int arch_elf_pt_proc(void *ehdr, struct elf_phdr *phdr, struct file *elf,
+	bool is_interp, void *state)
+{
+	int retval = 0;
+	char *rvattr = NULL;
+	loff_t pos;
+
+	if (elf_platform == NULL || elf_hwcap == 0)
+		return 0;
+
+	rvattr = kmalloc(phdr->p_filesz, GFP_KERNEL);
+	if (!rvattr)
+		goto out_oom;
+
+	pos = phdr->p_offset;
+	retval = kernel_read(elf, rvattr, phdr->p_filesz, &pos);
+	if (retval <= 0)
+		goto out_free;
+
+	retval = parse_elf_attribute_section(rvattr, rvattr + phdr->p_filesz);
+
+out_free:
+	kfree(rvattr);
+out_oom:
+	return retval;
+}
diff --git a/arch/riscv/kernel/entry.S b/arch/riscv/kernel/entry.S
index 9aaf6c98..cf92f8d4 100644
--- a/arch/riscv/kernel/entry.S
+++ b/arch/riscv/kernel/entry.S
@@ -144,6 +144,10 @@ _save_context:
 	REG_L x2,  PT_SP(sp)
 	.endm
 
+#if !IS_ENABLED(CONFIG_PREEMPT)
+#define resume_kernel restore_all
+#endif
+
 ENTRY(handle_exception)
 	SAVE_ALL
 
@@ -202,7 +206,7 @@ handle_syscall:
 	REG_S s2, PT_SEPC(sp)
 	/* Trace syscalls, but only if requested by the user. */
 	REG_L t0, TASK_TI_FLAGS(tp)
-	andi t0, t0, _TIF_SYSCALL_TRACE
+	andi t0, t0, _TIF_WORK_SYSCALL_MASK
 	bnez t0, handle_syscall_trace_enter
 check_syscall_nr:
 	/* Check to make sure we don't jump to a bogus syscall number. */
@@ -222,14 +226,14 @@ ret_from_syscall:
 	REG_S a0, PT_A0(sp)
 	/* Trace syscalls, but only if requested by the user. */
 	REG_L t0, TASK_TI_FLAGS(tp)
-	andi t0, t0, _TIF_SYSCALL_TRACE
+	andi t0, t0, _TIF_WORK_SYSCALL_MASK
 	bnez t0, handle_syscall_trace_exit
 
 ret_from_exception:
 	REG_L s0, PT_SSTATUS(sp)
 	csrc sstatus, SR_SIE
 	andi s0, s0, SR_SPP
-	bnez s0, restore_all
+	bnez s0, resume_kernel
 
 resume_userspace:
 	/* Interrupts must be disabled here so flags are checked atomically */
@@ -237,6 +241,13 @@ resume_userspace:
 	andi s1, s0, _TIF_WORK_MASK
 	bnez s1, work_pending
 
+.global bypass_singlestep
+bypass_singlestep:
+	j 1f
+	/* Set trigger module for single step */
+	call do_singlestep
+
+1:
 	/* Save unwound kernel stack pointer in thread_info */
 	addi s0, sp, PT_SIZE_ON_STACK
 	REG_S s0, TASK_TI_KERNEL_SP(tp)
@@ -251,6 +262,18 @@ restore_all:
 	RESTORE_ALL
 	sret
 
+#if IS_ENABLED(CONFIG_PREEMPT)
+resume_kernel:
+	REG_L s0, TASK_TI_PREEMPT_COUNT(tp)
+	bnez s0, restore_all
+need_resched:
+	REG_L s0, TASK_TI_FLAGS(tp)
+	andi s0, s0, _TIF_NEED_RESCHED
+	beqz s0, restore_all
+	call preempt_schedule_irq
+	j need_resched
+#endif
+
 work_pending:
 	/* Enter slow path for supplementary processing */
 	la ra, ret_from_exception
@@ -357,93 +380,6 @@ ENTRY(__switch_to)
 	ret
 ENDPROC(__switch_to)
 
-ENTRY(__fstate_save)
-	li  a2,  TASK_THREAD_F0
-	add a0, a0, a2
-	li t1, SR_FS
-	csrs sstatus, t1
-	frcsr t0
-	fsd f0,  TASK_THREAD_F0_F0(a0)
-	fsd f1,  TASK_THREAD_F1_F0(a0)
-	fsd f2,  TASK_THREAD_F2_F0(a0)
-	fsd f3,  TASK_THREAD_F3_F0(a0)
-	fsd f4,  TASK_THREAD_F4_F0(a0)
-	fsd f5,  TASK_THREAD_F5_F0(a0)
-	fsd f6,  TASK_THREAD_F6_F0(a0)
-	fsd f7,  TASK_THREAD_F7_F0(a0)
-	fsd f8,  TASK_THREAD_F8_F0(a0)
-	fsd f9,  TASK_THREAD_F9_F0(a0)
-	fsd f10, TASK_THREAD_F10_F0(a0)
-	fsd f11, TASK_THREAD_F11_F0(a0)
-	fsd f12, TASK_THREAD_F12_F0(a0)
-	fsd f13, TASK_THREAD_F13_F0(a0)
-	fsd f14, TASK_THREAD_F14_F0(a0)
-	fsd f15, TASK_THREAD_F15_F0(a0)
-	fsd f16, TASK_THREAD_F16_F0(a0)
-	fsd f17, TASK_THREAD_F17_F0(a0)
-	fsd f18, TASK_THREAD_F18_F0(a0)
-	fsd f19, TASK_THREAD_F19_F0(a0)
-	fsd f20, TASK_THREAD_F20_F0(a0)
-	fsd f21, TASK_THREAD_F21_F0(a0)
-	fsd f22, TASK_THREAD_F22_F0(a0)
-	fsd f23, TASK_THREAD_F23_F0(a0)
-	fsd f24, TASK_THREAD_F24_F0(a0)
-	fsd f25, TASK_THREAD_F25_F0(a0)
-	fsd f26, TASK_THREAD_F26_F0(a0)
-	fsd f27, TASK_THREAD_F27_F0(a0)
-	fsd f28, TASK_THREAD_F28_F0(a0)
-	fsd f29, TASK_THREAD_F29_F0(a0)
-	fsd f30, TASK_THREAD_F30_F0(a0)
-	fsd f31, TASK_THREAD_F31_F0(a0)
-	sw t0, TASK_THREAD_FCSR_F0(a0)
-	csrc sstatus, t1
-	ret
-ENDPROC(__fstate_save)
-
-ENTRY(__fstate_restore)
-	li  a2,  TASK_THREAD_F0
-	add a0, a0, a2
-	li t1, SR_FS
-	lw t0, TASK_THREAD_FCSR_F0(a0)
-	csrs sstatus, t1
-	fld f0,  TASK_THREAD_F0_F0(a0)
-	fld f1,  TASK_THREAD_F1_F0(a0)
-	fld f2,  TASK_THREAD_F2_F0(a0)
-	fld f3,  TASK_THREAD_F3_F0(a0)
-	fld f4,  TASK_THREAD_F4_F0(a0)
-	fld f5,  TASK_THREAD_F5_F0(a0)
-	fld f6,  TASK_THREAD_F6_F0(a0)
-	fld f7,  TASK_THREAD_F7_F0(a0)
-	fld f8,  TASK_THREAD_F8_F0(a0)
-	fld f9,  TASK_THREAD_F9_F0(a0)
-	fld f10, TASK_THREAD_F10_F0(a0)
-	fld f11, TASK_THREAD_F11_F0(a0)
-	fld f12, TASK_THREAD_F12_F0(a0)
-	fld f13, TASK_THREAD_F13_F0(a0)
-	fld f14, TASK_THREAD_F14_F0(a0)
-	fld f15, TASK_THREAD_F15_F0(a0)
-	fld f16, TASK_THREAD_F16_F0(a0)
-	fld f17, TASK_THREAD_F17_F0(a0)
-	fld f18, TASK_THREAD_F18_F0(a0)
-	fld f19, TASK_THREAD_F19_F0(a0)
-	fld f20, TASK_THREAD_F20_F0(a0)
-	fld f21, TASK_THREAD_F21_F0(a0)
-	fld f22, TASK_THREAD_F22_F0(a0)
-	fld f23, TASK_THREAD_F23_F0(a0)
-	fld f24, TASK_THREAD_F24_F0(a0)
-	fld f25, TASK_THREAD_F25_F0(a0)
-	fld f26, TASK_THREAD_F26_F0(a0)
-	fld f27, TASK_THREAD_F27_F0(a0)
-	fld f28, TASK_THREAD_F28_F0(a0)
-	fld f29, TASK_THREAD_F29_F0(a0)
-	fld f30, TASK_THREAD_F30_F0(a0)
-	fld f31, TASK_THREAD_F31_F0(a0)
-	fscsr t0
-	csrc sstatus, t1
-	ret
-ENDPROC(__fstate_restore)
-
-
 	.section ".rodata"
 	/* Exception vector table */
 ENTRY(excp_vect_table)
diff --git a/arch/riscv/kernel/fpu.S b/arch/riscv/kernel/fpu.S
new file mode 100644
index 00000000..1defb061
--- /dev/null
+++ b/arch/riscv/kernel/fpu.S
@@ -0,0 +1,106 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2012 Regents of the University of California
+ * Copyright (C) 2017 SiFive
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+
+#include <asm/asm.h>
+#include <asm/csr.h>
+#include <asm/asm-offsets.h>
+
+ENTRY(__fstate_save)
+	li  a2,  TASK_THREAD_F0
+	add a0, a0, a2
+	li t1, SR_FS
+	csrs sstatus, t1
+	frcsr t0
+	fsd f0,  TASK_THREAD_F0_F0(a0)
+	fsd f1,  TASK_THREAD_F1_F0(a0)
+	fsd f2,  TASK_THREAD_F2_F0(a0)
+	fsd f3,  TASK_THREAD_F3_F0(a0)
+	fsd f4,  TASK_THREAD_F4_F0(a0)
+	fsd f5,  TASK_THREAD_F5_F0(a0)
+	fsd f6,  TASK_THREAD_F6_F0(a0)
+	fsd f7,  TASK_THREAD_F7_F0(a0)
+	fsd f8,  TASK_THREAD_F8_F0(a0)
+	fsd f9,  TASK_THREAD_F9_F0(a0)
+	fsd f10, TASK_THREAD_F10_F0(a0)
+	fsd f11, TASK_THREAD_F11_F0(a0)
+	fsd f12, TASK_THREAD_F12_F0(a0)
+	fsd f13, TASK_THREAD_F13_F0(a0)
+	fsd f14, TASK_THREAD_F14_F0(a0)
+	fsd f15, TASK_THREAD_F15_F0(a0)
+	fsd f16, TASK_THREAD_F16_F0(a0)
+	fsd f17, TASK_THREAD_F17_F0(a0)
+	fsd f18, TASK_THREAD_F18_F0(a0)
+	fsd f19, TASK_THREAD_F19_F0(a0)
+	fsd f20, TASK_THREAD_F20_F0(a0)
+	fsd f21, TASK_THREAD_F21_F0(a0)
+	fsd f22, TASK_THREAD_F22_F0(a0)
+	fsd f23, TASK_THREAD_F23_F0(a0)
+	fsd f24, TASK_THREAD_F24_F0(a0)
+	fsd f25, TASK_THREAD_F25_F0(a0)
+	fsd f26, TASK_THREAD_F26_F0(a0)
+	fsd f27, TASK_THREAD_F27_F0(a0)
+	fsd f28, TASK_THREAD_F28_F0(a0)
+	fsd f29, TASK_THREAD_F29_F0(a0)
+	fsd f30, TASK_THREAD_F30_F0(a0)
+	fsd f31, TASK_THREAD_F31_F0(a0)
+	sw t0, TASK_THREAD_FCSR_F0(a0)
+	csrc sstatus, t1
+	ret
+ENDPROC(__fstate_save)
+
+ENTRY(__fstate_restore)
+	li  a2,  TASK_THREAD_F0
+	add a0, a0, a2
+	li t1, SR_FS
+	lw t0, TASK_THREAD_FCSR_F0(a0)
+	csrs sstatus, t1
+	fld f0,  TASK_THREAD_F0_F0(a0)
+	fld f1,  TASK_THREAD_F1_F0(a0)
+	fld f2,  TASK_THREAD_F2_F0(a0)
+	fld f3,  TASK_THREAD_F3_F0(a0)
+	fld f4,  TASK_THREAD_F4_F0(a0)
+	fld f5,  TASK_THREAD_F5_F0(a0)
+	fld f6,  TASK_THREAD_F6_F0(a0)
+	fld f7,  TASK_THREAD_F7_F0(a0)
+	fld f8,  TASK_THREAD_F8_F0(a0)
+	fld f9,  TASK_THREAD_F9_F0(a0)
+	fld f10, TASK_THREAD_F10_F0(a0)
+	fld f11, TASK_THREAD_F11_F0(a0)
+	fld f12, TASK_THREAD_F12_F0(a0)
+	fld f13, TASK_THREAD_F13_F0(a0)
+	fld f14, TASK_THREAD_F14_F0(a0)
+	fld f15, TASK_THREAD_F15_F0(a0)
+	fld f16, TASK_THREAD_F16_F0(a0)
+	fld f17, TASK_THREAD_F17_F0(a0)
+	fld f18, TASK_THREAD_F18_F0(a0)
+	fld f19, TASK_THREAD_F19_F0(a0)
+	fld f20, TASK_THREAD_F20_F0(a0)
+	fld f21, TASK_THREAD_F21_F0(a0)
+	fld f22, TASK_THREAD_F22_F0(a0)
+	fld f23, TASK_THREAD_F23_F0(a0)
+	fld f24, TASK_THREAD_F24_F0(a0)
+	fld f25, TASK_THREAD_F25_F0(a0)
+	fld f26, TASK_THREAD_F26_F0(a0)
+	fld f27, TASK_THREAD_F27_F0(a0)
+	fld f28, TASK_THREAD_F28_F0(a0)
+	fld f29, TASK_THREAD_F29_F0(a0)
+	fld f30, TASK_THREAD_F30_F0(a0)
+	fld f31, TASK_THREAD_F31_F0(a0)
+	fscsr t0
+	csrc sstatus, t1
+	ret
+ENDPROC(__fstate_restore)
diff --git a/arch/riscv/kernel/head.S b/arch/riscv/kernel/head.S
index 6e07ed37..12436fe5 100644
--- a/arch/riscv/kernel/head.S
+++ b/arch/riscv/kernel/head.S
@@ -48,8 +48,17 @@ ENTRY(_start)
 	mv s0, a0
 	mv s1, a1
 
+clear_bss:
+	la a0, __bss_start
+	la a1, __bss_stop
+clbss_l:
+	REG_S zero, 0(a0)
+	addi a0, a0, SZREG
+	blt a0, a1, clbss_l
+
 	/* Initialize page tables and relocate to virtual addresses */
 	la sp, init_thread_union + THREAD_SIZE
+	call setup_maxpa
 	call setup_vm
 	call relocate
 
@@ -61,6 +70,10 @@ ENTRY(_start)
 	li a0, ASM_THREAD_SIZE
 	add sp, sp, a0
 
+#ifdef CONFIG_KASAN
+	call kasan_early_init
+#endif
+
 	/* Start the kernel */
 	mv a0, s0
 	mv a1, s1
@@ -94,6 +107,8 @@ relocate:
 	or a0, a0, a1
 	sfence.vma
 	csrw sptbr, a0
+
+.align 2
 1:
 	/* Set trap vector to spin forever to help debug */
 	la a0, .Lsecondary_park
@@ -143,12 +158,27 @@ relocate:
 	tail smp_callin
 #endif
 
+.align 2
 .Lsecondary_park:
 	/* We lack SMP support or have too many harts, so park this hart */
 	wfi
 	j .Lsecondary_park
 END(_start)
 
+.section .text
+.global boot_sec_cpu
+
+#ifdef CONFIG_SMP
+boot_sec_cpu:
+	/* clear all pending flags */
+	csrw sip, zero
+	/* Mask all interrupts */
+	csrw sie, zero
+	fence
+
+	tail smp_callin
+#endif
+
 __PAGE_ALIGNED_BSS
 	/* Empty zero page */
 	.balign PAGE_SIZE
diff --git a/arch/riscv/kernel/module-sections.c b/arch/riscv/kernel/module-sections.c
index bbbd26e1..e8b991ad 100644
--- a/arch/riscv/kernel/module-sections.c
+++ b/arch/riscv/kernel/module-sections.c
@@ -9,14 +9,14 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 
-u64 module_emit_got_entry(struct module *mod, u64 val)
+unsigned long module_emit_got_entry(struct module *mod, unsigned long val)
 {
 	struct mod_section *got_sec = &mod->arch.got;
 	int i = got_sec->num_entries;
 	struct got_entry *got = get_got_entry(val, got_sec);
 
 	if (got)
-		return (u64)got;
+		return (unsigned long)got;
 
 	/* There is no duplicate entry, create a new one */
 	got = (struct got_entry *)got_sec->shdr->sh_addr;
@@ -25,10 +25,10 @@ u64 module_emit_got_entry(struct module *mod, u64 val)
 	got_sec->num_entries++;
 	BUG_ON(got_sec->num_entries > got_sec->max_entries);
 
-	return (u64)&got[i];
+	return (unsigned long)&got[i];
 }
 
-u64 module_emit_plt_entry(struct module *mod, u64 val)
+unsigned long module_emit_plt_entry(struct module *mod, unsigned long val)
 {
 	struct mod_section *got_plt_sec = &mod->arch.got_plt;
 	struct got_entry *got_plt;
@@ -37,27 +37,29 @@ u64 module_emit_plt_entry(struct module *mod, u64 val)
 	int i = plt_sec->num_entries;
 
 	if (plt)
-		return (u64)plt;
+		return (unsigned long)plt;
 
 	/* There is no duplicate entry, create a new one */
 	got_plt = (struct got_entry *)got_plt_sec->shdr->sh_addr;
 	got_plt[i] = emit_got_entry(val);
 	plt = (struct plt_entry *)plt_sec->shdr->sh_addr;
-	plt[i] = emit_plt_entry(val, (u64)&plt[i], (u64)&got_plt[i]);
+	plt[i] = emit_plt_entry(val,
+                                (unsigned long)&plt[i],
+                                (unsigned long)&got_plt[i]);
 
 	plt_sec->num_entries++;
 	got_plt_sec->num_entries++;
 	BUG_ON(plt_sec->num_entries > plt_sec->max_entries);
 
-	return (u64)&plt[i];
+	return (unsigned long)&plt[i];
 }
 
-static int is_rela_equal(const Elf64_Rela *x, const Elf64_Rela *y)
+static int is_rela_equal(const Elf_Rela *x, const Elf_Rela *y)
 {
 	return x->r_info == y->r_info && x->r_addend == y->r_addend;
 }
 
-static bool duplicate_rela(const Elf64_Rela *rela, int idx)
+static bool duplicate_rela(const Elf_Rela *rela, int idx)
 {
 	int i;
 	for (i = 0; i < idx; i++) {
@@ -67,13 +69,13 @@ static bool duplicate_rela(const Elf64_Rela *rela, int idx)
 	return false;
 }
 
-static void count_max_entries(Elf64_Rela *relas, int num,
+static void count_max_entries(Elf_Rela *relas, int num,
 			      unsigned int *plts, unsigned int *gots)
 {
 	unsigned int type, i;
 
 	for (i = 0; i < num; i++) {
-		type = ELF64_R_TYPE(relas[i].r_info);
+		type = ELF_RISCV_R_TYPE(relas[i].r_info);
 		if (type == R_RISCV_CALL_PLT) {
 			if (!duplicate_rela(relas, i))
 				(*plts)++;
@@ -118,9 +120,9 @@ int module_frob_arch_sections(Elf_Ehdr *ehdr, Elf_Shdr *sechdrs,
 
 	/* Calculate the maxinum number of entries */
 	for (i = 0; i < ehdr->e_shnum; i++) {
-		Elf64_Rela *relas = (void *)ehdr + sechdrs[i].sh_offset;
-		int num_rela = sechdrs[i].sh_size / sizeof(Elf64_Rela);
-		Elf64_Shdr *dst_sec = sechdrs + sechdrs[i].sh_info;
+		Elf_Rela *relas = (void *)ehdr + sechdrs[i].sh_offset;
+		int num_rela = sechdrs[i].sh_size / sizeof(Elf_Rela);
+		Elf_Shdr *dst_sec = sechdrs + sechdrs[i].sh_info;
 
 		if (sechdrs[i].sh_type != SHT_RELA)
 			continue;
diff --git a/arch/riscv/kernel/module.c b/arch/riscv/kernel/module.c
index 5dddba30..57c3d070 100644
--- a/arch/riscv/kernel/module.c
+++ b/arch/riscv/kernel/module.c
@@ -17,6 +17,17 @@
 #include <linux/errno.h>
 #include <linux/moduleloader.h>
 
+static int apply_r_riscv_32_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	if (v != (u32)v) {
+		pr_err("%s: value %016llx out of range for 32-bit field\n",
+		       me->name, v);
+		return -EINVAL;
+	}
+	*location = v;
+	return 0;
+}
+
 static int apply_r_riscv_64_rela(struct module *me, u32 *location, Elf_Addr v)
 {
 	*(u64 *)location = v;
@@ -26,7 +37,7 @@ static int apply_r_riscv_64_rela(struct module *me, u32 *location, Elf_Addr v)
 static int apply_r_riscv_branch_rela(struct module *me, u32 *location,
 				     Elf_Addr v)
 {
-	s64 offset = (void *)v - (void *)location;
+	ptrdiff_t offset = (void *)v - (void *)location;
 	u32 imm12 = (offset & 0x1000) << (31 - 12);
 	u32 imm11 = (offset & 0x800) >> (11 - 7);
 	u32 imm10_5 = (offset & 0x7e0) << (30 - 10);
@@ -39,7 +50,7 @@ static int apply_r_riscv_branch_rela(struct module *me, u32 *location,
 static int apply_r_riscv_jal_rela(struct module *me, u32 *location,
 				  Elf_Addr v)
 {
-	s64 offset = (void *)v - (void *)location;
+	ptrdiff_t offset = (void *)v - (void *)location;
 	u32 imm20 = (offset & 0x100000) << (31 - 20);
 	u32 imm19_12 = (offset & 0xff000);
 	u32 imm11 = (offset & 0x800) << (20 - 11);
@@ -52,7 +63,7 @@ static int apply_r_riscv_jal_rela(struct module *me, u32 *location,
 static int apply_r_riscv_rcv_branch_rela(struct module *me, u32 *location,
 					 Elf_Addr v)
 {
-	s64 offset = (void *)v - (void *)location;
+	ptrdiff_t offset = (void *)v - (void *)location;
 	u16 imm8 = (offset & 0x100) << (12 - 8);
 	u16 imm7_6 = (offset & 0xc0) >> (6 - 5);
 	u16 imm5 = (offset & 0x20) >> (5 - 2);
@@ -67,7 +78,7 @@ static int apply_r_riscv_rcv_branch_rela(struct module *me, u32 *location,
 static int apply_r_riscv_rvc_jump_rela(struct module *me, u32 *location,
 				       Elf_Addr v)
 {
-	s64 offset = (void *)v - (void *)location;
+	ptrdiff_t offset = (void *)v - (void *)location;
 	u16 imm11 = (offset & 0x800) << (12 - 11);
 	u16 imm10 = (offset & 0x400) >> (10 - 8);
 	u16 imm9_8 = (offset & 0x300) << (12 - 11);
@@ -85,12 +96,12 @@ static int apply_r_riscv_rvc_jump_rela(struct module *me, u32 *location,
 static int apply_r_riscv_pcrel_hi20_rela(struct module *me, u32 *location,
 					 Elf_Addr v)
 {
-	s64 offset = (void *)v - (void *)location;
+	ptrdiff_t offset = (void *)v - (void *)location;
 	s32 hi20;
 
 	if (offset != (s32)offset) {
 		pr_err(
-		  "%s: target %016llx can not be addressed by the 32-bit offset from PC = %p\n",
+		  "%s: target %016" PRIxEA "can not be addressed by the 32-bit offset from PC = %p\n",
 		  me->name, v, location);
 		return -EINVAL;
 	}
@@ -132,7 +143,7 @@ static int apply_r_riscv_hi20_rela(struct module *me, u32 *location,
 
 	if (IS_ENABLED(CMODEL_MEDLOW)) {
 		pr_err(
-		  "%s: target %016llx can not be addressed by the 32-bit offset from PC = %p\n",
+		  "%s: target %016" PRIxEA "can not be addressed by the 32-bit offset from PC = %p\n",
 		  me->name, v, location);
 		return -EINVAL;
 	}
@@ -167,7 +178,7 @@ static int apply_r_riscv_lo12_s_rela(struct module *me, u32 *location,
 static int apply_r_riscv_got_hi20_rela(struct module *me, u32 *location,
 				       Elf_Addr v)
 {
-	s64 offset = (void *)v - (void *)location;
+	ptrdiff_t offset = (void *)v - (void *)location;
 	s32 hi20;
 
 	/* Always emit the got entry */
@@ -176,7 +187,7 @@ static int apply_r_riscv_got_hi20_rela(struct module *me, u32 *location,
 		offset = (void *)offset - (void *)location;
 	} else {
 		pr_err(
-		  "%s: can not generate the GOT entry for symbol = %016llx from PC = %p\n",
+		  "%s: can not generate the GOT entry for symbol = %016" PRIxEA "from PC = %p\n",
 		  me->name, v, location);
 		return -EINVAL;
 	}
@@ -189,7 +200,7 @@ static int apply_r_riscv_got_hi20_rela(struct module *me, u32 *location,
 static int apply_r_riscv_call_plt_rela(struct module *me, u32 *location,
 				       Elf_Addr v)
 {
-	s64 offset = (void *)v - (void *)location;
+	ptrdiff_t offset = (void *)v - (void *)location;
 	s32 fill_v = offset;
 	u32 hi20, lo12;
 
@@ -200,7 +211,7 @@ static int apply_r_riscv_call_plt_rela(struct module *me, u32 *location,
 			offset = (void *)offset - (void *)location;
 		} else {
 			pr_err(
-			  "%s: target %016llx can not be addressed by the 32-bit offset from PC = %p\n",
+			  "%s: target %016" PRIxEA "can not be addressed by the 32-bit offset from PC = %p\n",
 			  me->name, v, location);
 			return -EINVAL;
 		}
@@ -216,13 +227,13 @@ static int apply_r_riscv_call_plt_rela(struct module *me, u32 *location,
 static int apply_r_riscv_call_rela(struct module *me, u32 *location,
 				   Elf_Addr v)
 {
-	s64 offset = (void *)v - (void *)location;
+	ptrdiff_t offset = (void *)v - (void *)location;
 	s32 fill_v = offset;
 	u32 hi20, lo12;
 
 	if (offset != fill_v) {
 		pr_err(
-		  "%s: target %016llx can not be addressed by the 32-bit offset from PC = %p\n",
+		  "%s: target %016" PRIxEA "can not be addressed by the 32-bit offset from PC = %p\n",
 		  me->name, v, location);
 		return -EINVAL;
 	}
@@ -252,19 +263,39 @@ static int apply_r_riscv_align_rela(struct module *me, u32 *location,
 static int apply_r_riscv_add32_rela(struct module *me, u32 *location,
 				    Elf_Addr v)
 {
-	*(u32 *)location += (*(u32 *)v);
+	*(u32 *)location += (u32)v;
 	return 0;
 }
 
 static int apply_r_riscv_sub32_rela(struct module *me, u32 *location,
 				    Elf_Addr v)
 {
-	*(u32 *)location -= (*(u32 *)v);
+	*(u32 *)location -= (u32)v;
+	return 0;
+}
+
+static int apply_r_riscv_10_pcrel_rela(struct module *me, u32 *location,
+				       Elf_Addr v)
+{
+	s64 offset = (void *)v - (void *)location;
+	u32 imm10 = (offset & 0x400) << (31 - 10);
+	u32 imm9_5 = (offset & 0x3e0) << (25 - 5);
+	u32 imm4_1 = (offset & 0x1e) << (8 - 1);
+
+	*(u32 *) location = (*(u32 *) location & 0x41fff0ff) |
+	    imm10 | imm9_5 | imm4_1;
+	return 0;
+}
+
+static int apply_r_riscv_ignore_rela(struct module *me, u32 *location,
+				     Elf_Addr v)
+{
 	return 0;
 }
 
 static int (*reloc_handlers_rela[]) (struct module *me, u32 *location,
 				Elf_Addr v) = {
+	[R_RISCV_32]			= apply_r_riscv_32_rela,
 	[R_RISCV_64]			= apply_r_riscv_64_rela,
 	[R_RISCV_BRANCH]		= apply_r_riscv_branch_rela,
 	[R_RISCV_JAL]			= apply_r_riscv_jal_rela,
@@ -285,6 +316,18 @@ static int (*reloc_handlers_rela[]) (struct module *me, u32 *location,
 	[R_RISCV_SUB32]			= apply_r_riscv_sub32_rela,
 };
 
+static int (*reloc_handlers_rela_nds(unsigned int type)) (struct module * me,
+							  u32 * location,
+							  Elf_Addr v)
+{
+	if (type == R_RISCV_10_PCREL)
+		return apply_r_riscv_10_pcrel_rela;
+	else if (type >= R_RISCV_ALIGN_BTB && type <= R_RISCV_RELAX_REGION_END)
+		return apply_r_riscv_ignore_rela;
+	else
+		return NULL;
+}
+
 int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,
 		       unsigned int symindex, unsigned int relsec,
 		       struct module *me)
@@ -321,7 +364,7 @@ int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,
 		if (type < ARRAY_SIZE(reloc_handlers_rela))
 			handler = reloc_handlers_rela[type];
 		else
-			handler = NULL;
+			handler = reloc_handlers_rela_nds(type);
 
 		if (!handler) {
 			pr_err("%s: Unknown relocation type %u\n",
@@ -335,7 +378,7 @@ int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,
 			unsigned int j;
 
 			for (j = 0; j < sechdrs[relsec].sh_size / sizeof(*rel); j++) {
-				u64 hi20_loc =
+				unsigned long hi20_loc =
 					sechdrs[sechdrs[relsec].sh_info].sh_addr
 					+ rel[j].r_offset;
 				u32 hi20_type = ELF_RISCV_R_TYPE(rel[j].r_info);
@@ -348,12 +391,12 @@ int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,
 					Elf_Sym *hi20_sym =
 						(Elf_Sym *)sechdrs[symindex].sh_addr
 						+ ELF_RISCV_R_SYM(rel[j].r_info);
-					u64 hi20_sym_val =
+					unsigned long hi20_sym_val =
 						hi20_sym->st_value
 						+ rel[j].r_addend;
 
 					/* Calculate lo12 */
-					u64 offset = hi20_sym_val - hi20_loc;
+					size_t offset = hi20_sym_val - hi20_loc;
 					if (IS_ENABLED(CONFIG_MODULE_SECTIONS)
 					    && hi20_type == R_RISCV_GOT_HI20) {
 						offset = module_emit_got_entry(
diff --git a/arch/riscv/kernel/perf_event.c b/arch/riscv/kernel/perf_event.c
new file mode 100644
index 00000000..ce536be1
--- /dev/null
+++ b/arch/riscv/kernel/perf_event.c
@@ -0,0 +1,1044 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2008 Thomas Gleixner <tglx@linutronix.de>
+ * Copyright (C) 2008-2009 Red Hat, Inc., Ingo Molnar
+ * Copyright (C) 2009 Jaswinder Singh Rajput
+ * Copyright (C) 2009 Advanced Micro Devices, Inc., Robert Richter
+ * Copyright (C) 2008-2009 Red Hat, Inc., Peter Zijlstra
+ * Copyright (C) 2009 Intel Corporation, <markus.t.metzger@intel.com>
+ * Copyright (C) 2009 Google, Inc., Stephane Eranian
+ * Copyright 2014 Tilera Corporation. All Rights Reserved.
+ * Copyright (C) 2018 Andes Technology Corporation
+ *
+ * Perf_events support for RISC-V platforms.
+ *
+ * Since the spec. (as of now, Priv-Spec 1.10) does not provide enough
+ * functionality for perf event to fully work, this file provides
+ * the very basic framework only.
+ *
+ * For platform portings, please check Documentations/riscv/pmu.txt.
+ *
+ * The Copyright line includes x86 and tile ones.
+ */
+
+#include <linux/kprobes.h>
+#include <linux/kernel.h>
+#include <linux/kdebug.h>
+#include <linux/mutex.h>
+#include <linux/bitmap.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/perf_event.h>
+#include <linux/atomic.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <asm/perf_event.h>
+#include <asm/sbi.h>
+#include <asm/andesv5/csr.h>
+
+#define PFMOVF_MASK	0x40000
+#define L2C_EVSEL_MASK	0xff
+#define EVSEL_MASK	0xf
+#define UMODE_MASK	0x4
+#define SMODE_MASK	0x2
+#define MMODE_MASK	0x1
+
+#define MHPEVENT_OFF	4
+#define EVSEL_OFF	3
+#define L2C_MARK_OFF	8
+#define L2C_FLAG_OFF	(L2C_MARK_OFF + EVSEL_OFF)
+
+#define INST_COMMIT	0
+#define MEM_SYS		1
+#define MICROARCH	2
+
+#define INST_COMMIT_NUM	23
+#define MEM_SYS_NUM	22
+#define MICROARCH_NUM	3
+
+static const struct riscv_pmu *riscv_pmu __read_mostly;
+static DEFINE_PER_CPU(struct cpu_hw_events, cpu_hw_events);
+typedef void (*perf_irq_t)(struct pt_regs *);
+perf_irq_t perf_irq = NULL;
+static cpumask_t pmu_cpu;
+static struct l2c_hw_events l2c_hw_events;
+/*
+ * Hardware & cache maps and their methods
+ */
+
+static const int riscv_hw_event_map[] = {
+	[PERF_COUNT_HW_CPU_CYCLES]		= RISCV_CYCLE_COUNT,
+	[PERF_COUNT_HW_INSTRUCTIONS]		= RISCV_INSTRET,
+	[PERF_COUNT_HW_CACHE_REFERENCES]	= DCACHE_ACCESS,
+	[PERF_COUNT_HW_CACHE_MISSES]		= DCACHE_MISS,
+	[PERF_COUNT_HW_BRANCH_INSTRUCTIONS]	= RISCV_OP_UNSUPP,
+	[PERF_COUNT_HW_BRANCH_MISSES]		= RISCV_OP_UNSUPP,
+	[PERF_COUNT_HW_BUS_CYCLES]		= RISCV_OP_UNSUPP,
+};
+
+#define C(x) PERF_COUNT_HW_CACHE_##x
+static const int riscv_cache_event_map[PERF_COUNT_HW_CACHE_MAX]
+[PERF_COUNT_HW_CACHE_OP_MAX]
+[PERF_COUNT_HW_CACHE_RESULT_MAX] = {
+	[C(L1D)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = DCACHE_LOAD_ACCESS,
+			[C(RESULT_MISS)] = DCACHE_LOAD_MISS,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = DCACHE_STORE_ACCESS,
+			[C(RESULT_MISS)] = DCACHE_STORE_MISS,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+	[C(L1I)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = ICACHE_ACCESS,
+			[C(RESULT_MISS)] = ICACHE_MISS,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+	[C(LL)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = L2C_C0_ACCESS,
+			[C(RESULT_MISS)] = L2C_C0_MISS,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = L2C_C0_ACCESS,
+			[C(RESULT_MISS)] = L2C_C0_MISS,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+	[C(DTLB)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] =  RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] =  RISCV_OP_UNSUPP,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+	[C(ITLB)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+	[C(BPU)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+	[C(NODE)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+};
+
+static bool is_l2c_event(u64 config)
+{
+	return ((config >> L2C_FLAG_OFF) == L2C_EVSEL_MASK);
+}
+
+static int riscv_map_raw_event(u64 config)
+{
+        u32 val = config & EVSEL_MASK;
+        u32 event = config >> MHPEVENT_OFF;
+
+	if ((config >> L2C_MARK_OFF) == L2C_EVSEL_MASK)
+		return config;
+
+        switch (val) {
+                case INST_COMMIT:
+                        if (event > INST_COMMIT_NUM)
+                                return -EINVAL;
+                        break;
+                case MEM_SYS:
+                        if (event > MEM_SYS_NUM)
+                                return -EINVAL;
+                        break;
+                case MICROARCH:
+                        if (event > MICROARCH_NUM)
+                                return -EINVAL;
+                        break;
+                default:
+                        return -EINVAL;
+        }
+
+        return config;
+}
+
+static int riscv_map_hw_event(u64 config)
+{
+	if (config >= riscv_pmu->max_events)
+		return -EINVAL;
+
+	return riscv_pmu->hw_events[config];
+}
+
+static int riscv_map_cache_event(u64 config)
+{
+	unsigned int type, op, result;
+	int code;
+
+	type = (config >> 0) & 0xff;
+	op = (config >> 8) & 0xff;
+	result = (config >> 16) & 0xff;
+
+	if (!riscv_pmu->cache_events)
+		return -ENOENT;
+
+	if (type >= PERF_COUNT_HW_CACHE_MAX ||
+	    op >= PERF_COUNT_HW_CACHE_OP_MAX ||
+	    result >= PERF_COUNT_HW_CACHE_RESULT_MAX)
+		return -EINVAL;
+
+	code = (*riscv_pmu->cache_events)[type][op][result];
+	if (code == RISCV_OP_UNSUPP)
+		return -ENOENT;
+
+	return code;
+}
+
+/*
+ * Low-level functions: reading/writing counters
+ */
+
+static inline u64 read_counter(int idx)
+{
+	u64 val = 0;
+
+	switch (idx) {
+	case RISCV_CYCLE_COUNTER:
+#if __riscv_xlen == 32
+                val |= csr_read(cycle);
+                val |= ((u64)csr_read(cycleh) << 32);
+#elif __riscv_xlen == 64
+                val = csr_read(cycle);
+#endif
+		break;
+	case RISCV_INSTRET_COUNTER:
+#if __riscv_xlen == 32
+                val |= csr_read(instret);
+                val |= ((u64)csr_read(instreth) << 32);
+#elif __riscv_xlen == 64
+                val = csr_read(instret);
+#endif
+		break;
+	case RISCV_PMU_MHPMCOUNTER3:
+#if __riscv_xlen == 32
+                val |= csr_read(0xC03);
+                val |= ((u64)csr_read(0xC83) << 32);
+#elif __riscv_xlen == 64
+                val = csr_read(0xC03);
+#endif
+		break;
+	case RISCV_PMU_MHPMCOUNTER4:
+#if __riscv_xlen == 32
+                val |= csr_read(0xC04);
+                val |= ((u64)csr_read(0xC84) << 32);
+#elif __riscv_xlen == 64
+                val = csr_read(0xC04);
+#endif
+		break;
+	case RISCV_PMU_MHPMCOUNTER5:
+#if __riscv_xlen == 32
+                val |= csr_read(0xC05);
+                val |= ((u64)csr_read(0xC85) << 32);
+#elif __riscv_xlen == 64
+                val = csr_read(0xC05);
+#endif
+		break;
+	case RISCV_PMU_MHPMCOUNTER6:
+#if __riscv_xlen == 32
+                val |= csr_read(0xC06);
+                val |= ((u64)csr_read(0xC86) << 32);
+#elif __riscv_xlen == 64
+                val = csr_read(0xC06);
+#endif
+		break;
+	default:
+		WARN_ON_ONCE(idx < 0 ||	idx > RISCV_MAX_COUNTERS);
+		return -EINVAL;
+	}
+
+	return val;
+}
+
+static inline void write_counter(int idx, u64 value)
+{
+        switch (idx) {
+        case RISCV_CYCLE_COUNTER:
+#if __riscv_xlen == 32
+                csr_write(cycle, value);
+                csr_write(cycleh, value >> 32);
+#elif __riscv_xlen == 64
+                csr_write(cycle, value);
+#endif
+                break;
+        case RISCV_INSTRET_COUNTER:
+#if __riscv_xlen == 32
+                csr_write(instret, value);
+                csr_write(instreth, value >> 32);
+#elif __riscv_xlen == 64
+                csr_write(instret, value);
+#endif
+                break;
+        case RISCV_PMU_MHPMCOUNTER3:
+#if __riscv_xlen == 32
+                csr_write(0xC03, value);
+                csr_write(0xC83, value >> 32);
+#elif __riscv_xlen == 64
+                csr_write(0xC03, value);
+#endif
+                break;
+        case RISCV_PMU_MHPMCOUNTER4:
+#if __riscv_xlen == 32
+                csr_write(0xC04, value);
+                csr_write(0xC84, value >> 32);
+#elif __riscv_xlen == 64
+                csr_write(0xC04, value);
+#endif
+                break;
+        case RISCV_PMU_MHPMCOUNTER5:
+#if __riscv_xlen == 32
+                csr_write(0xC05, value);
+                csr_write(0xC85, value >> 32);
+#elif __riscv_xlen == 64
+                csr_write(0xC05, value);
+#endif
+                break;
+        case RISCV_PMU_MHPMCOUNTER6:
+#if __riscv_xlen == 32
+                csr_write(0xC06, value);
+                csr_write(0xC86, value >> 32);
+#elif __riscv_xlen == 64
+                csr_write(0xC06, value);
+#endif
+                break;
+        default:
+                WARN_ON_ONCE(idx < 0 || idx > RISCV_MAX_COUNTERS);
+        }
+}
+
+/*
+ * pmu->read: read and update the counter
+ *
+ * Other architectures' implementation often have a xxx_perf_event_update
+ * routine, which can return counter values when called in the IRQ, but
+ * return void when being called by the pmu->read method.
+ */
+static void riscv_pmu_read(struct perf_event *event)
+{
+	struct hw_perf_event *hwc = &event->hw;
+	u64 prev_raw_count, new_raw_count;
+	u64 oldval;
+	int idx = hwc->idx;
+	u64 delta;
+
+	do {
+		prev_raw_count = local64_read(&hwc->prev_count);
+		if (is_l2c_event(hwc->config))
+			new_raw_count = l2c_read_counter(idx);
+		else
+			new_raw_count = read_counter(idx);
+
+		oldval = local64_cmpxchg(&hwc->prev_count, prev_raw_count,
+					 new_raw_count);
+	} while (oldval != prev_raw_count);
+
+	/*
+	 * delta is the value to update the counter we maintain in the kernel.
+	 */
+	delta = (new_raw_count - prev_raw_count) &
+		((1ULL << riscv_pmu->counter_width) - 1);
+	local64_add(delta, &event->count);
+	/*
+	 * Something like local64_sub(delta, &hwc->period_left) here is
+	 * needed if there is an interrupt for perf.
+	 */
+	local64_sub(delta, &hwc->period_left);
+}
+
+void riscv_pmu_disable_counter(int idx)
+{
+        u32 val = 1UL << idx;
+
+        csr_set(scountinhibit, val);
+}
+
+void riscv_pmu_enable_counter(int idx)
+{
+        u32 val = 1UL << idx;
+
+        csr_clear(scountinhibit, val);
+}
+
+void riscv_pmu_disable_interrupt(int idx)
+{
+        u32 val = 1UL << idx;
+
+        csr_clear(scounterinten, val);
+}
+
+void riscv_pmu_enable_interrupt(int idx)
+{
+        u32 val = 1UL << idx;
+
+        csr_set(scounterinten, val);
+}
+
+static inline void riscv_pmu_disable_event(struct perf_event *event)
+{
+        struct hw_perf_event *hwc = &event->hw;
+        int idx = hwc->idx;
+
+        if (idx == -1)
+                return;
+
+        // disable counter
+        riscv_pmu_disable_counter(idx);
+
+        // disable interrupt
+        riscv_pmu_disable_interrupt(idx);
+}
+
+static inline void riscv_pmu_disable(void)
+{
+        // Disable all counter
+        csr_set(scountinhibit, 0xfffffffd);
+}
+
+static inline void riscv_pmu_enable(struct perf_event *event)
+{
+        // Enable all counter
+	csr_clear(scountinhibit, 0xfffffffd);
+}
+
+static int riscv_event_set_period(struct perf_event *event)
+{
+        struct hw_perf_event *hwc = &event->hw;
+        int idx = hwc->idx;
+        s64 left = local64_read(&hwc->period_left);
+        s64 period = hwc->sample_period;
+        int ret = 0;
+
+        if (unlikely(left <= -period)) {
+                left = period;
+                local64_set(&hwc->period_left, left);
+                hwc->last_period = period;
+                ret = 1;
+        }
+
+        if (unlikely(left <= 0)) {
+                left += period;
+                local64_set(&hwc->period_left, left);
+                hwc->last_period = period;
+                ret = 1;
+        }
+
+        if (left > riscv_pmu->max_period)
+                left = riscv_pmu->max_period;
+
+        local64_set(&hwc->prev_count, (u64)-left);
+
+	if (is_l2c_event(hwc->config))
+		l2c_write_counter(idx, (u64)(-left));
+	else
+		write_counter(idx, (u64)(-left));
+
+        perf_event_update_userpage(event);
+
+        return ret;
+}
+
+static inline void riscv_pmu_event_enable(struct perf_event *event)
+{
+        struct hw_perf_event *hwc = &event->hw;
+        int idx = hwc->idx;
+        u32 value = 1UL << idx;
+        u32 ev_config = hwc->config >> EVSEL_OFF;
+
+        if (WARN_ON_ONCE(idx == -1))
+                return;
+
+        if(hwc->config & MMODE_MASK)
+                csr_set(scountermask_m, value);
+        if(hwc->config & SMODE_MASK)
+                csr_set(scountermask_s, value);
+        if(hwc->config & UMODE_MASK)
+                csr_set(scountermask_u, value);
+
+        if (idx < BASE_COUNTERS)
+                return;
+
+        switch (idx) {
+                case RISCV_PMU_MHPMCOUNTER3:
+                        csr_write(0x9E3, ev_config);
+                        break;
+                case RISCV_PMU_MHPMCOUNTER4:
+                        csr_write(0x9E4, ev_config);
+                        break;
+                case RISCV_PMU_MHPMCOUNTER5:
+                        csr_write(0x9E5, ev_config);
+                        break;
+                case RISCV_PMU_MHPMCOUNTER6:
+                        csr_write(0x9E6, ev_config);
+                        break;
+                default:
+                        pr_err("The number of counters are exceedied!\n");
+                        break;
+        }
+}
+
+static inline int riscv_get_counter_idx(u64 config)
+{
+        struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
+        int idx;
+        u64 val = config >> EVSEL_OFF;
+
+        if (val == RISCV_CYCLE_COUNT) {
+                if (test_bit(RISCV_CYCLE_COUNTER, cpuc->used_mask))
+                        idx = find_next_zero_bit(cpuc->used_mask, RISCV_MAX_COUNTERS,
+						 BASE_COUNTERS);
+                else
+                        idx = RISCV_CYCLE_COUNTER;
+        } else if (val == RISCV_INSTRET) {
+                if (test_bit(RISCV_INSTRET_COUNTER, cpuc->used_mask))
+                        idx = find_next_zero_bit(cpuc->used_mask, RISCV_MAX_COUNTERS,
+						 BASE_COUNTERS);
+                else
+                        idx = RISCV_INSTRET_COUNTER;
+        } else
+                idx = find_next_zero_bit(cpuc->used_mask, RISCV_MAX_COUNTERS,
+					 BASE_COUNTERS);
+
+        return idx;
+}
+
+/*
+ * State transition functions:
+ *
+ * stop()/start() & add()/del()
+ */
+
+/*
+ * pmu->stop: stop the counter
+ */
+static void riscv_pmu_stop(struct perf_event *event, int flags)
+{
+	struct hw_perf_event *hwc = &event->hw;
+	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
+	struct l2c_hw_events *l2c = &l2c_hw_events;
+	int idx = hwc->idx;
+	unsigned long irq_flags;
+
+	if (is_l2c_event(hwc->config))
+		goto l2c_event_stop;
+
+	if (__test_and_clear_bit(idx, cpuc->active_mask)) {
+		riscv_pmu_disable_event(event);
+		WARN_ON_ONCE(hwc->state & PERF_HES_STOPPED);
+		hwc->state |= PERF_HES_STOPPED;
+	}
+
+	if ((flags & PERF_EF_UPDATE) && !(hwc->state & PERF_HES_UPTODATE)) {
+		riscv_pmu->pmu->read(event);
+		hwc->state |= PERF_HES_UPTODATE;
+	}
+
+	// disable all mask
+	if (cpuc->n_events == 0) {
+		csr_write(scountermask_m, 0);
+		csr_write(scountermask_s, 0);
+		csr_write(scountermask_u, 0);
+	}
+	return;
+l2c_event_stop:
+	if (__test_and_clear_bit(idx, l2c->active_mask)) {
+		raw_spin_lock_irqsave(&l2c->pmu_lock, irq_flags);
+                l2c_pmu_disable_counter(hwc->idx);
+		raw_spin_unlock_irqrestore(&l2c->pmu_lock, irq_flags);
+
+                WARN_ON_ONCE(hwc->state & PERF_HES_STOPPED);
+                hwc->state |= PERF_HES_STOPPED;
+        }
+
+	if ((flags & PERF_EF_UPDATE) && !(hwc->state & PERF_HES_UPTODATE)) {
+		riscv_pmu->pmu->read(event);
+		hwc->state |= PERF_HES_UPTODATE;
+	}
+}
+
+/*
+ * pmu->start: start the event.
+ */
+static void riscv_pmu_start(struct perf_event *event, int flags)
+{
+	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
+	struct l2c_hw_events *l2c = &l2c_hw_events;
+	int idx = event->hw.idx;
+	unsigned long irq_flags;
+
+	if (WARN_ON_ONCE(!(event->hw.state & PERF_HES_STOPPED)))
+		return;
+
+	if (WARN_ON_ONCE(idx == -1))
+		return;
+
+	if (is_l2c_event(event->hw.config))
+		goto l2c_event_start;
+
+	riscv_pmu_disable_counter(idx);
+	if (flags & PERF_EF_RELOAD) {
+		WARN_ON_ONCE(!(event->hw.state & PERF_HES_UPTODATE));
+
+		/*
+		 * Set the counter to the period to the next interrupt here,
+		 * if you have any.
+		 */
+		riscv_event_set_period(event);
+	}
+
+	event->hw.state = 0;
+	cpuc->events[idx] = event;
+	__set_bit(idx, cpuc->active_mask);
+
+	riscv_pmu_enable_interrupt(idx);
+	riscv_pmu_event_enable(event);
+	riscv_pmu_enable_counter(idx);
+	goto finish_start;
+l2c_event_start:
+	raw_spin_lock_irqsave(&l2c->pmu_lock, irq_flags);
+	l2c_pmu_disable_counter(idx);
+	raw_spin_unlock_irqrestore(&l2c->pmu_lock, irq_flags);
+
+	if (flags & PERF_EF_RELOAD) {
+		WARN_ON_ONCE(!(event->hw.state & PERF_HES_UPTODATE));
+
+		/*
+		 * Set the counter to the period to the next interrupt here,
+		 * if you have any.
+		 */
+		riscv_event_set_period(event);
+	}
+	event->hw.state = 0;
+	l2c->events[idx] = event;
+
+	raw_spin_lock_irqsave(&l2c->pmu_lock, irq_flags);
+	__set_bit(idx, l2c->active_mask);
+
+	l2c_pmu_event_enable((event->hw.config >> EVSEL_OFF) & L2C_EVSEL_MASK,
+				idx);
+	raw_spin_unlock_irqrestore(&l2c->pmu_lock, irq_flags);
+finish_start:
+	perf_event_update_userpage(event);
+}
+
+/*
+ * pmu->add: add the event to PMU.
+ */
+static int riscv_pmu_add(struct perf_event *event, int flags)
+{
+	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
+	struct hw_perf_event *hwc = &event->hw;
+	struct l2c_hw_events *l2c = &l2c_hw_events;
+	int idx = 0;
+	unsigned long irq_flags;
+
+	if (is_l2c_event(hwc->config))
+		goto add_l2c_event;
+
+	idx = riscv_get_counter_idx(hwc->config);
+
+	if (idx > riscv_pmu->num_counters)
+		return -ENOSPC;
+
+	cpuc->events[idx] = event;
+	cpuc->n_events++;
+
+	__set_bit(idx, cpuc->used_mask);
+
+	goto finish_add;
+
+add_l2c_event:
+	if (l2c->n_events == L2C_MAX_COUNTERS)
+		return -ENOSPC;
+
+	raw_spin_lock_irqsave(&l2c->pmu_lock, irq_flags);
+	idx = cpu_l2c_get_counter_idx(l2c);
+	if (WARN_ON_ONCE(idx == L2C_MAX_COUNTERS))
+		return -ENOSPC;
+
+	l2c->events[idx] = event;
+	l2c->n_events++;
+
+	__set_bit(idx, l2c->used_mask);
+	raw_spin_unlock_irqrestore(&l2c->pmu_lock, irq_flags);
+finish_add:
+	hwc->idx = idx;
+	hwc->state = PERF_HES_UPTODATE | PERF_HES_STOPPED;
+
+        if (flags & PERF_EF_START)
+                riscv_pmu->pmu->start(event, PERF_EF_RELOAD);
+
+	return 0;
+}
+
+/*
+ * pmu->del: delete the event from PMU.
+ */
+static void riscv_pmu_del(struct perf_event *event, int flags)
+{
+	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
+	struct l2c_hw_events *l2c = &l2c_hw_events;
+	struct hw_perf_event *hwc = &event->hw;
+	unsigned long irq_flags;
+
+	if (is_l2c_event(hwc->config))
+		goto l2c_events_del;
+
+	cpuc->events[hwc->idx] = NULL;
+	cpuc->n_events--;
+	__clear_bit(hwc->idx, cpuc->used_mask);
+	goto finish_del;
+
+l2c_events_del:
+	l2c->events[hwc->idx] = NULL;
+
+	raw_spin_lock_irqsave(&l2c->pmu_lock, irq_flags);
+	l2c->n_events--;
+	raw_spin_unlock_irqrestore(&l2c->pmu_lock, irq_flags);
+
+	__clear_bit(hwc->idx, l2c->used_mask);
+finish_del:
+	riscv_pmu->pmu->stop(event, PERF_EF_UPDATE);
+	perf_event_update_userpage(event);
+}
+
+/*
+ * Interrupt: a skeletion for reference.
+ */
+
+static DEFINE_MUTEX(pmc_reserve_mutex);
+
+unsigned long riscv_pmu_get_overflow(void)
+{
+        return csr_read(scounterovf);
+}
+
+void riscv_reset_overflow(unsigned long status)
+{
+        csr_write(scounterovf ,status);
+}
+
+static atomic_t riscv_active_events = ATOMIC_INIT(0);
+
+void riscv_base_pmu_handle_irq(struct pt_regs *regs)
+{
+        struct perf_sample_data data;
+        struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
+        struct perf_event *event;
+        unsigned long status;
+        int bit;
+
+        if (!atomic_read(&riscv_active_events))
+                return;
+
+        if (!cpuc->n_events)
+                return;
+
+        status = riscv_pmu_get_overflow();
+        riscv_reset_overflow(status);
+
+        riscv_pmu_disable();
+        for_each_set_bit(bit, &status, RISCV_MAX_COUNTERS) {
+                event = cpuc->events[bit];
+
+                if (!event)
+                        continue;
+
+                if (!test_bit(bit, cpuc->active_mask))
+                        continue;
+
+                riscv_pmu_read(event);
+
+                perf_sample_data_init(&data, 0, event->hw.last_period);
+                if (!riscv_event_set_period(event))
+                        continue;
+
+                if (perf_event_overflow(event, &data, regs))
+                        riscv_pmu_stop(event, 0);
+        }
+        riscv_pmu_enable(event);
+}
+
+void riscv_perf_interrupt(struct pt_regs *regs)
+{
+        if (!perf_irq)
+                panic("Unexpected Perf interrupt\n");
+
+        perf_irq(regs);
+        SBI_CALL_0(SBI_SET_PFM);
+}
+
+perf_irq_t reserve_pmc_hardware(perf_irq_t new_perf_irq)
+{
+        return cmpxchg(&perf_irq, NULL, new_perf_irq);
+}
+
+void release_pmc_hardware(void)
+{
+        perf_irq = NULL;
+}
+
+/*
+ * Event Initialization/Finalization
+ */
+
+static void riscv_event_destroy(struct perf_event *event)
+{
+	if (atomic_dec_return(&riscv_active_events) == 0)
+		release_pmc_hardware();
+}
+
+extern void __iomem *l2c_base;
+
+static int riscv_event_init(struct perf_event *event)
+{
+	struct perf_event_attr *attr = &event->attr;
+	struct hw_perf_event *hwc = &event->hw;
+	perf_irq_t err = NULL;
+	int code;
+
+	switch (event->attr.type) {
+	case PERF_TYPE_HARDWARE:
+		code = riscv_pmu->map_hw_event(attr->config);
+		break;
+	case PERF_TYPE_HW_CACHE:
+		code = riscv_pmu->map_cache_event(attr->config);
+		break;
+	case PERF_TYPE_RAW:
+		code = riscv_pmu->map_raw_event(attr->config);
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	if (atomic_inc_return(&riscv_active_events) == 1) {
+		err = reserve_pmc_hardware(riscv_base_pmu_handle_irq);
+
+		if (err) {
+			pr_warn("PMC hardware not available\n");
+			atomic_dec(&riscv_active_events);
+			return -EBUSY;
+		}
+	}
+
+	if ((code >> L2C_MARK_OFF) == L2C_EVSEL_MASK && !l2c_base)
+		code = -EINVAL;
+
+	event->destroy = riscv_event_destroy;
+	if (code < 0) {
+		event->destroy(event);
+		return code;
+	}
+
+        /*
+         * Design of hwc->config:
+         *      The lower 3 bits :
+         *      _ _ _
+         *      U S M
+         *
+         * Each bit present each mode for each counter.
+         * The rest of bits are for event code.
+         */
+
+        if (attr->exclude_user)
+                hwc->config |= UMODE_MASK;
+
+        if (attr->exclude_kernel)
+                hwc->config |= SMODE_MASK;
+
+        if (attr->exclude_machine)
+                hwc->config |= MMODE_MASK;
+
+
+        if (!hwc->sample_period) {
+                hwc->sample_period = riscv_pmu->max_period;
+                hwc->last_period = hwc->sample_period;
+                local64_set(&hwc->period_left, hwc->sample_period);
+        }
+
+	/*
+	 * idx is set to -1 because the index of a general event should not be
+	 * decided until binding to some counter in pmu->add().
+	 */
+	hwc->config |= (code << EVSEL_OFF);
+	hwc->idx = -1;
+
+	return 0;
+}
+
+/*
+ * Initialization
+ */
+PMU_FORMAT_ATTR(event, "config:0-63");
+
+static struct attribute *riscv_arch_formats_attr[] = {
+        &format_attr_event.attr,
+        NULL,
+};
+
+static struct attribute_group riscv_pmu_format_group = {
+        .name = "format",
+        .attrs = riscv_arch_formats_attr,
+};
+
+static ssize_t riscv_pmu_cpumask_show(struct device *dev,
+                                      struct device_attribute *attr,
+                                      char *buf)
+{
+        return cpumap_print_to_pagebuf(true, buf, &pmu_cpu);
+}
+
+static DEVICE_ATTR(cpus, 0444, riscv_pmu_cpumask_show, NULL);
+
+static struct attribute *riscv_pmu_common_attrs[] = {
+        &dev_attr_cpus.attr,
+        NULL,
+};
+
+static struct attribute_group riscv_pmu_common_group = {
+        .attrs = riscv_pmu_common_attrs,
+};
+
+static const struct attribute_group *riscv_pmu_attr_groups[] = {
+        &riscv_pmu_format_group,
+        &riscv_pmu_common_group,
+        NULL,
+};
+
+static struct pmu min_pmu = {
+#ifdef CONFIG_ANDES_PMU
+	.name		= "andes-base",
+#elif defined CONFIG_RISCV_BASE_PMU
+	.name		= "riscv-base",
+#endif
+	.attr_groups    = riscv_pmu_attr_groups,
+	.event_init	= riscv_event_init,
+	.add		= riscv_pmu_add,
+	.del		= riscv_pmu_del,
+	.start		= riscv_pmu_start,
+	.stop		= riscv_pmu_stop,
+	.read		= riscv_pmu_read,
+};
+
+static const struct riscv_pmu riscv_base_pmu = {
+	.pmu = &min_pmu,
+	.max_events = ARRAY_SIZE(riscv_hw_event_map),
+	.map_hw_event = riscv_map_hw_event,
+	.hw_events = riscv_hw_event_map,
+	.map_cache_event = riscv_map_cache_event,
+	.map_raw_event = riscv_map_raw_event,
+	.cache_events = &riscv_cache_event_map,
+	.counter_width = 63,
+	.num_counters = RISCV_MAX_COUNTERS - 1,
+	.handle_irq = &riscv_base_pmu_handle_irq,
+	.max_period = 0xFFFFFFFF,
+	/* This means this PMU has no IRQ. */
+	.irq = -1,
+};
+
+static const struct of_device_id riscv_pmu_of_ids[] = {
+	{.compatible = "riscv,base-pmu",	.data = &riscv_base_pmu},
+	{.compatible = "riscv,andes-pmu",	.data = &riscv_base_pmu},
+	{ /* sentinel value */ }
+};
+
+void init_cpu_pmu(void *arg)
+{
+	// enable S-mode local interrupt and M-mode interrupt
+	csr_write(slie, PFMOVF_MASK);
+	SBI_CALL_0(SBI_SET_PFM);
+}
+
+int __init init_hw_perf_events(void)
+{
+	struct device_node *node = of_find_node_by_type(NULL, "pmu");
+	const struct of_device_id *of_id;
+	int cpu;
+
+	raw_spin_lock_init(&l2c_hw_events.pmu_lock);
+	l2c_hw_events.n_events = 0;
+	riscv_pmu = &riscv_base_pmu;
+	cpumask_setall(&pmu_cpu);
+	/* The second bit we don't use*/
+	for_each_cpu(cpu, &pmu_cpu) {
+		struct cpu_hw_events *cpuc = per_cpu_ptr(&cpu_hw_events, cpu);
+
+		__set_bit(1, cpuc->active_mask);
+		__set_bit(1, cpuc->used_mask);
+		smp_call_function_single(cpu, init_cpu_pmu, NULL, 1);
+	}
+
+	if (node) {
+		of_id = of_match_node(riscv_pmu_of_ids, node);
+
+		if (of_id)
+			riscv_pmu = of_id->data;
+	}
+#ifdef CONFIG_ANDES_PMU
+	perf_pmu_register(riscv_pmu->pmu, "andes-base", PERF_TYPE_RAW);
+#elif defined CONFIG_RISCV_BASE_PMU
+	perf_pmu_register(riscv_pmu->pmu, "riscv-base", PERF_TYPE_RAW);
+#endif
+
+	return 0;
+}
+arch_initcall(init_hw_perf_events);
diff --git a/arch/riscv/kernel/pm.c b/arch/riscv/kernel/pm.c
new file mode 100644
index 00000000..8a02f5f2
--- /dev/null
+++ b/arch/riscv/kernel/pm.c
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2008-2017 Andes Technology Corporation
+
+#include <linux/init.h>
+#include <linux/suspend.h>
+#include <linux/device.h>
+#include <linux/printk.h>
+#include <linux/suspend.h>
+
+#include <asm/andesv5/smu.h>
+extern unsigned int *wake_mask;
+extern void __iomem *plic_base;
+#define PLIC_PEND_OFF	0x1000
+#define MAX_DEVICES	1024
+#define MAX_USE_REGS	MAX_DEVICES / 32
+
+int suspend_begin;
+
+static void riscv_suspend_cpu(void)
+{
+	int i;
+	unsigned int wake;
+	u32 __iomem *reg = plic_base + PLIC_PEND_OFF;
+
+	while (true) {
+		__asm__ volatile ("wfi\n\t");
+		for (i = 0; i < MAX_USE_REGS; i++) {
+			if (wake_mask[i]) {
+				wake = readl(reg + i);
+				if (wake_mask[i] & wake) {
+					goto wakeup;
+				}
+			}
+		}
+	}
+wakeup:
+	return;
+}
+
+extern void riscv_suspend2ram(void);
+
+static int riscv_pm_enter(suspend_state_t state)
+{
+	pr_debug("%s:state:%d\n", __func__, state);
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+#ifdef CONFIG_ATCSMU
+		andes_suspend2standby();
+#else
+		riscv_suspend_cpu();
+#endif
+		return 0;
+	case PM_SUSPEND_MEM:
+#ifdef CONFIG_ATCSMU
+		andes_suspend2ram();
+#else
+		riscv_suspend2ram();
+#endif
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int riscv_pm_valid(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_ON:
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		return 1;
+	default:
+		return -EINVAL;
+	}
+}
+
+int num_cpus;
+static int riscv_pm_begin(suspend_state_t state)
+{
+	suspend_begin = state;
+	num_cpus = num_online_cpus();
+	return 0;
+}
+
+static void riscv_pm_end(void)
+{
+	suspend_begin = 0;
+}
+
+static const struct platform_suspend_ops riscv_pm_ops = {
+	.valid = riscv_pm_valid,
+	.begin = riscv_pm_begin,
+	.enter = riscv_pm_enter,
+	.end   = riscv_pm_end,
+};
+
+static int __init riscv_pm_init(void)
+{
+	pr_debug("Enter %s\n", __func__);
+	suspend_set_ops(&riscv_pm_ops);
+	return 0;
+}
+late_initcall(riscv_pm_init);
diff --git a/arch/riscv/kernel/process.c b/arch/riscv/kernel/process.c
index d7c6ca7c..2433d1bb 100644
--- a/arch/riscv/kernel/process.c
+++ b/arch/riscv/kernel/process.c
@@ -42,6 +42,13 @@ void arch_cpu_idle(void)
 	local_irq_enable();
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+void arch_cpu_idle_dead(void)
+{
+	cpu_play_dead();
+}
+#endif
+
 void show_regs(struct pt_regs *regs)
 {
 	show_regs_print_info(KERN_DEFAULT);
@@ -76,7 +83,9 @@ void show_regs(struct pt_regs *regs)
 void start_thread(struct pt_regs *regs, unsigned long pc,
 	unsigned long sp)
 {
-	regs->sstatus = SR_SPIE /* User mode, irqs on */ | SR_FS_INITIAL;
+	regs->sstatus = SR_SPIE;
+	if (has_fpu)
+		regs->sstatus |= SR_FS_INITIAL;
 	regs->sepc = pc;
 	regs->sp = sp;
 	set_fs(USER_DS);
@@ -84,12 +93,17 @@ void start_thread(struct pt_regs *regs, unsigned long pc,
 
 void flush_thread(void)
 {
+#ifdef CONFIG_FPU
 	/*
 	 * Reset FPU context
 	 *	frm: round to nearest, ties to even (IEEE default)
 	 *	fflags: accrued exceptions cleared
 	 */
 	memset(&current->thread.fstate, 0, sizeof(current->thread.fstate));
+#endif
+#ifdef CONFIG_DSP
+	memset(&current->thread.dspstate, 0, sizeof(current->thread.dspstate));
+#endif
 }
 
 int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index ba3e8071..73020481 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -18,6 +18,8 @@
 #include <asm/ptrace.h>
 #include <asm/syscall.h>
 #include <asm/thread_info.h>
+#include <asm/sbi.h>
+#include <asm/cacheflush.h>
 #include <linux/ptrace.h>
 #include <linux/elf.h>
 #include <linux/regset.h>
@@ -27,7 +29,8 @@
 #include <trace/events/syscalls.h>
 
 enum riscv_regset {
-	REGSET_X,
+	REGSET_GPR,
+	REGSET_FPR,
 };
 
 static int riscv_gpr_get(struct task_struct *target,
@@ -50,13 +53,56 @@ static int riscv_gpr_set(struct task_struct *target,
 	struct pt_regs *regs;
 
 	regs = task_pt_regs(target);
-	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &regs, 0, -1);
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, regs, 0, -1);
 	return ret;
 }
 
+#ifdef CONFIG_FPU
+extern bool has_fpu;
+
+static int riscv_fpr_get(struct task_struct *target,
+			 const struct user_regset *regset,
+			 unsigned int pos, unsigned int count,
+			 void *kbuf, void __user *ubuf)
+{
+	int err;
+	elf_fpregset_t fstate;
+
+	if (!has_fpu)
+		return -EIO;
+
+	fstate.d = target->thread.fstate;
+
+	err = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+				  &fstate,
+				  0, sizeof(fstate));
+	return err;
+}
+
+static int riscv_fpr_set(struct task_struct *target,
+			 const struct user_regset *regset,
+			 unsigned int pos, unsigned int count,
+			 const void *kbuf, const void __user *ubuf)
+{
+	int err;
+	elf_fpregset_t newstate;
+
+	if (!has_fpu)
+		return -EIO;
+
+	err = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+				 &newstate, 0, sizeof(newstate));
+	if (err)
+		return err;
+
+	target->thread.fstate = newstate.d;
+
+	return err;
+}
+#endif
 
 static const struct user_regset riscv_user_regset[] = {
-	[REGSET_X] = {
+	[REGSET_GPR] = {
 		.core_note_type = NT_PRSTATUS,
 		.n = ELF_NGREG,
 		.size = sizeof(elf_greg_t),
@@ -64,6 +110,16 @@ static const struct user_regset riscv_user_regset[] = {
 		.get = &riscv_gpr_get,
 		.set = &riscv_gpr_set,
 	},
+#ifdef CONFIG_FPU
+	[REGSET_FPR] = {
+		.core_note_type = NT_PRFPREG,
+		.n = ELF_NFPREG,
+		.size = sizeof(elf_fpreg_t),
+		.align = sizeof(elf_fpreg_t),
+		.get = &riscv_fpr_get,
+		.set = &riscv_fpr_set,
+	},
+#endif
 };
 
 static const struct user_regset_view riscv_user_native_view = {
@@ -81,6 +137,7 @@ const struct user_regset_view *task_user_regset_view(struct task_struct *task)
 void ptrace_disable(struct task_struct *child)
 {
 	clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+	user_disable_single_step(child);
 }
 
 long arch_ptrace(struct task_struct *child, long request,
@@ -97,6 +154,42 @@ long arch_ptrace(struct task_struct *child, long request,
 	return ret;
 }
 
+#define CNOP		0x0001
+#define CNOP_SIZE	0x2
+extern void bypass_singlestep(void);
+static void modify_bypass_to_nop(void)
+{
+	unsigned int nop = CNOP;
+	probe_kernel_write(&bypass_singlestep, &nop, CNOP_SIZE);
+	smp_mb();
+	flush_icache_range(&bypass_singlestep, &bypass_singlestep + CNOP_SIZE);
+}
+
+static bool is_bypass_singlestep = true;
+void user_enable_single_step(struct task_struct *child)
+{
+	set_tsk_thread_flag(child, TIF_SINGLESTEP);
+	if (is_bypass_singlestep) {
+		modify_bypass_to_nop();
+		is_bypass_singlestep = false;
+	}
+}
+
+void user_disable_single_step(struct task_struct *child)
+{
+	clear_tsk_thread_flag(child, TIF_SINGLESTEP);
+}
+
+#define TRIGGER_TYPE_ICOUNT 3
+#define ICOUNT 1
+void do_singlestep(void)
+{
+	if (test_thread_flag(TIF_SINGLESTEP))
+		sbi_set_trigger(TRIGGER_TYPE_ICOUNT, ICOUNT, 1);
+	else
+		sbi_set_trigger(TRIGGER_TYPE_ICOUNT, ICOUNT, 0);
+}
+
 /*
  * Allows PTRACE_SYSCALL to work.  These are called from entry.S in
  * {handle,ret_from}_syscall.
@@ -115,8 +208,9 @@ void do_syscall_trace_enter(struct pt_regs *regs)
 
 void do_syscall_trace_exit(struct pt_regs *regs)
 {
+	int step = test_thread_flag(TIF_SINGLESTEP);
 	if (test_thread_flag(TIF_SYSCALL_TRACE))
-		tracehook_report_syscall_exit(regs, 0);
+		tracehook_report_syscall_exit(regs, step);
 
 #ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
 	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))
diff --git a/arch/riscv/kernel/riscv_ksyms.c b/arch/riscv/kernel/riscv_ksyms.c
index 55173424..bc053b64 100644
--- a/arch/riscv/kernel/riscv_ksyms.c
+++ b/arch/riscv/kernel/riscv_ksyms.c
@@ -16,3 +16,7 @@ EXPORT_SYMBOL(__clear_user);
 EXPORT_SYMBOL(__copy_user);
 EXPORT_SYMBOL(memset);
 EXPORT_SYMBOL(memcpy);
+EXPORT_SYMBOL(memmove);
+EXPORT_SYMBOL(__memset);
+EXPORT_SYMBOL(__memcpy);
+EXPORT_SYMBOL(__memmove);
diff --git a/arch/riscv/kernel/setup.c b/arch/riscv/kernel/setup.c
index c11f40c1..3b1d3283 100644
--- a/arch/riscv/kernel/setup.c
+++ b/arch/riscv/kernel/setup.c
@@ -22,6 +22,7 @@
 #include <linux/init.h>
 #include <linux/mm.h>
 #include <linux/memblock.h>
+#include <linux/bootmem.h>
 #include <linux/sched.h>
 #include <linux/initrd.h>
 #include <linux/console.h>
@@ -29,6 +30,7 @@
 #include <linux/of_fdt.h>
 #include <linux/of_platform.h>
 #include <linux/sched/task.h>
+#include <linux/swiotlb.h>
 
 #include <asm/setup.h>
 #include <asm/sections.h>
@@ -37,6 +39,29 @@
 #include <asm/sbi.h>
 #include <asm/tlbflush.h>
 #include <asm/thread_info.h>
+#include <asm/csr.h>
+#include <asm/kasan.h>
+
+#ifdef CONFIG_EARLY_PRINTK
+static void sbi_console_write(struct console *co, const char *buf,
+			      unsigned int n)
+{
+	int i;
+
+	for (i = 0; i < n; ++i) {
+		if (buf[i] == '\n')
+			sbi_console_putchar('\r');
+		sbi_console_putchar(buf[i]);
+	}
+}
+
+struct console riscv_sbi_early_console_dev __initdata = {
+	.name	= "early",
+	.write	= sbi_console_write,
+	.flags	= CON_PRINTBUFFER | CON_BOOT | CON_ANYTIME,
+	.index	= -1
+};
+#endif
 
 #ifdef CONFIG_DUMMY_CONSOLE
 struct screen_info screen_info = {
@@ -59,6 +84,7 @@ EXPORT_SYMBOL(empty_zero_page);
 
 /* The lucky hart to first increment this variable will boot the other cores */
 atomic_t hart_lottery;
+static DEFINE_PER_CPU(struct cpu, cpu_devices);
 
 #ifdef CONFIG_BLK_DEV_INITRD
 static void __init setup_initrd(void)
@@ -103,7 +129,18 @@ pgd_t trampoline_pg_dir[PTRS_PER_PGD] __initdata __aligned(PAGE_SIZE);
 pmd_t swapper_pmd[PTRS_PER_PMD*((-PAGE_OFFSET)/PGDIR_SIZE)] __page_aligned_bss;
 pmd_t trampoline_pmd[PTRS_PER_PGD] __initdata __aligned(PAGE_SIZE);
 #endif
-
+phys_addr_t pa_msb;
+asmlinkage void __init setup_maxpa(void)
+{
+#ifdef CONFIG_PMA
+	if (sbi_probe_pma()) {
+		pa_msb = 0;
+		return;
+	}
+#endif
+	csr_write(satp, SATP_PPN);
+	pa_msb = (csr_read(satp) + 1) >>1;
+}
 asmlinkage void __init setup_vm(void)
 {
 	extern char _start;
@@ -117,6 +154,9 @@ asmlinkage void __init setup_vm(void)
 	/* Sanity check alignment and size */
 	BUG_ON((PAGE_OFFSET % PGDIR_SIZE) != 0);
 	BUG_ON((pa % (PAGE_SIZE * PTRS_PER_PTE)) != 0);
+#ifdef CONFIG_HIGHMEM
+	BUG_ON((LOWMEM_SIZE % PGDIR_SIZE) != 0);
+#endif
 
 #ifndef __PAGETABLE_PMD_FOLDED
 	trampoline_pg_dir[(PAGE_OFFSET >> PGDIR_SHIFT) % PTRS_PER_PGD] =
@@ -124,8 +164,13 @@ asmlinkage void __init setup_vm(void)
 			__pgprot(_PAGE_TABLE));
 	trampoline_pmd[0] = pfn_pmd(PFN_DOWN(pa), prot);
 
+#ifndef CONFIG_HIGHMEM
 	for (i = 0; i < (-PAGE_OFFSET)/PGDIR_SIZE; ++i) {
+#else
+	for (i = 0; i < (LOWMEM_SIZE)/PGDIR_SIZE; ++i) {
+#endif
 		size_t o = (PAGE_OFFSET >> PGDIR_SHIFT) % PTRS_PER_PGD + i;
+
 		swapper_pg_dir[o] =
 			pfn_pgd(PFN_DOWN((uintptr_t)swapper_pmd) + i,
 				__pgprot(_PAGE_TABLE));
@@ -135,8 +180,11 @@ asmlinkage void __init setup_vm(void)
 #else
 	trampoline_pg_dir[(PAGE_OFFSET >> PGDIR_SHIFT) % PTRS_PER_PGD] =
 		pfn_pgd(PFN_DOWN(pa), prot);
-
+#ifndef CONFIG_HIGHMEM
 	for (i = 0; i < (-PAGE_OFFSET)/PGDIR_SIZE; ++i) {
+#else
+	for (i = 0; i < (LOWMEM_SIZE)/PGDIR_SIZE; ++i) {
+#endif
 		size_t o = (PAGE_OFFSET >> PGDIR_SHIFT) % PTRS_PER_PGD + i;
 		swapper_pg_dir[o] =
 			pfn_pgd(PFN_DOWN(pa + i * PGDIR_SIZE), prot);
@@ -165,14 +213,23 @@ static void __init setup_bootmem(void)
 			 * the kernel
 			 */
 			memblock_reserve(reg->base, vmlinux_end - reg->base);
+#ifdef CONFIG_HIGHMEM
+			mem_size = reg->size;
+#else
 			mem_size = min(reg->size, (phys_addr_t)-PAGE_OFFSET);
+#endif
 		}
 	}
 	BUG_ON(mem_size == 0);
 
 	set_max_mapnr(PFN_DOWN(mem_size));
-	max_low_pfn = pfn_base + PFN_DOWN(mem_size);
-
+#ifdef CONFIG_HIGHMEM
+	max_low_pfn = LOWMEM_END_PFN ;
+	 max_pfn	= PFN_DOWN(memblock_end_of_DRAM());
+	 memblock_set_current_limit(__pa(LOWMEM_END));
+#else
+	max_low_pfn = PFN_DOWN(memblock_end_of_DRAM());
+#endif
 #ifdef CONFIG_BLK_DEV_INITRD
 	setup_initrd();
 #endif /* CONFIG_BLK_DEV_INITRD */
@@ -194,6 +251,12 @@ static void __init setup_bootmem(void)
 
 void __init setup_arch(char **cmdline_p)
 {
+#if defined(CONFIG_EARLY_PRINTK)
+       if (likely(early_console == NULL)) {
+               early_console = &riscv_sbi_early_console_dev;
+               register_console(early_console);
+       }
+#endif
 	*cmdline_p = boot_command_line;
 
 	parse_early_param();
@@ -206,6 +269,13 @@ void __init setup_arch(char **cmdline_p)
 	setup_bootmem();
 	paging_init();
 	unflatten_device_tree();
+#ifdef CONFIG_SWIOTLB
+	swiotlb_init(1);
+#endif
+
+#ifdef CONFIG_KASAN
+	kasan_init();
+#endif
 
 #ifdef CONFIG_SMP
 	setup_smp();
@@ -218,6 +288,22 @@ void __init setup_arch(char **cmdline_p)
 	riscv_fill_hwcap();
 }
 
+static int __init topology_init(void)
+{
+	int i;
+
+	for_each_possible_cpu(i) {
+		struct cpu *cpu = &per_cpu(cpu_devices, i);
+#ifdef CONFIG_HOTPLUG_CPU
+		cpu->hotpluggable = 1;
+#endif
+		register_cpu(cpu, i);
+	}
+
+	return 0;
+}
+subsys_initcall(topology_init);
+
 static int __init riscv_device_init(void)
 {
 	return of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
diff --git a/arch/riscv/kernel/signal.c b/arch/riscv/kernel/signal.c
index 718d0c98..38fd36ad 100644
--- a/arch/riscv/kernel/signal.c
+++ b/arch/riscv/kernel/signal.c
@@ -37,45 +37,100 @@ struct rt_sigframe {
 	struct ucontext uc;
 };
 
-static long restore_d_state(struct pt_regs *regs,
-	struct __riscv_d_ext_state __user *state)
+#ifdef CONFIG_DSP
+static long restore_dsp_state(struct pt_regs *regs,
+			     struct __riscv_dsp_state *sc_dspregs)
 {
 	long err;
-	err = __copy_from_user(&current->thread.fstate, state, sizeof(*state));
-	if (likely(!err))
-		fstate_restore(current, regs);
-	return err;
+
+	err = __copy_from_user(&current->thread.dspstate.ucode, &sc_dspregs->ucode, sizeof(unsigned long));
+	if (unlikely(err))
+		return err;
+	dspstate_restore(current);
+	return 0;
 }
 
-static long save_d_state(struct pt_regs *regs,
-	struct __riscv_d_ext_state __user *state)
+static long save_dsp_state(struct pt_regs *regs,
+			  struct __riscv_dsp_state *sc_dspregs)
 {
-	fstate_save(current, regs);
-	return __copy_to_user(state, &current->thread.fstate, sizeof(*state));
+	long err;
+
+	dspstate_save(current);
+	err = __copy_to_user(&sc_dspregs->ucode, &current->thread.dspstate.ucode, sizeof(unsigned long));
+	if (unlikely(err))
+		return err;
+	return 0;
 }
+#else
+#define save_dsp_state(task, regs) (0)
+#define restore_dsp_state(task, regs) (0)
+#endif
 
-static long restore_sigcontext(struct pt_regs *regs,
-	struct sigcontext __user *sc)
+#ifdef CONFIG_FPU
+static long restore_fp_state(struct pt_regs *regs,
+			     union __riscv_fp_state *sc_fpregs)
 {
 	long err;
+	struct __riscv_d_ext_state __user *state = &sc_fpregs->d;
 	size_t i;
-	/* sc_regs is structured the same as the start of pt_regs */
-	err = __copy_from_user(regs, &sc->sc_regs, sizeof(sc->sc_regs));
-	if (unlikely(err))
-		return err;
-	/* Restore the floating-point state. */
-	err = restore_d_state(regs, &sc->sc_fpregs.d);
+
+	err = __copy_from_user(&current->thread.fstate, state, sizeof(*state));
 	if (unlikely(err))
 		return err;
+
+	fstate_restore(current, regs);
+
 	/* We support no other extension state at this time. */
-	for (i = 0; i < ARRAY_SIZE(sc->sc_fpregs.q.reserved); i++) {
+	for (i = 0; i < ARRAY_SIZE(sc_fpregs->q.reserved); i++) {
 		u32 value;
-		err = __get_user(value, &sc->sc_fpregs.q.reserved[i]);
+
+		err = __get_user(value, &sc_fpregs->q.reserved[i]);
 		if (unlikely(err))
 			break;
 		if (value != 0)
 			return -EINVAL;
 	}
+
+	return err;
+}
+
+static long save_fp_state(struct pt_regs *regs,
+			  union __riscv_fp_state *sc_fpregs)
+{
+	long err;
+	struct __riscv_d_ext_state __user *state = &sc_fpregs->d;
+	size_t i;
+
+	fstate_save(current, regs);
+	err = __copy_to_user(state, &current->thread.fstate, sizeof(*state));
+	if (unlikely(err))
+		return err;
+
+	/* We support no other extension state at this time. */
+	for (i = 0; i < ARRAY_SIZE(sc_fpregs->q.reserved); i++) {
+		err = __put_user(0, &sc_fpregs->q.reserved[i]);
+		if (unlikely(err))
+			break;
+	}
+
+	return err;
+}
+#else
+#define save_fp_state(task, regs) (0)
+#define restore_fp_state(task, regs) (0)
+#endif
+
+static long restore_sigcontext(struct pt_regs *regs,
+	struct sigcontext __user *sc)
+{
+	long err;
+	/* sc_regs is structured the same as the start of pt_regs */
+	err = __copy_from_user(regs, &sc->sc_regs, sizeof(sc->sc_regs));
+	/* Restore the floating-point state. */
+	if (has_fpu)
+		err |= restore_fp_state(regs, &sc->sc_fpregs);
+	if (has_dsp)
+		err |= restore_dsp_state(regs, &sc->sc_dspregs);
 	return err;
 }
 
@@ -124,14 +179,13 @@ static long setup_sigcontext(struct rt_sigframe __user *frame,
 {
 	struct sigcontext __user *sc = &frame->uc.uc_mcontext;
 	long err;
-	size_t i;
 	/* sc_regs is structured the same as the start of pt_regs */
 	err = __copy_to_user(&sc->sc_regs, regs, sizeof(sc->sc_regs));
 	/* Save the floating-point state. */
-	err |= save_d_state(regs, &sc->sc_fpregs.d);
-	/* We support no other extension state at this time. */
-	for (i = 0; i < ARRAY_SIZE(sc->sc_fpregs.q.reserved); i++)
-		err |= __put_user(0, &sc->sc_fpregs.q.reserved[i]);
+	if (has_fpu)
+		err |= save_fp_state(regs, &sc->sc_fpregs);
+	if (has_dsp)
+		err |= save_dsp_state(regs, &sc->sc_dspregs);
 	return err;
 }
 
diff --git a/arch/riscv/kernel/sleep.S b/arch/riscv/kernel/sleep.S
new file mode 100644
index 00000000..d3ad49d3
--- /dev/null
+++ b/arch/riscv/kernel/sleep.S
@@ -0,0 +1,108 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2017 Andes Technology Corporation */
+
+#include <asm/asm.h>
+#include <asm/asm-offsets.h>
+#include <asm/csr.h>
+.text
+.global riscv_suspend2ram
+
+riscv_suspend2ram:
+	addi sp, sp, -(PT_SIZE_ON_STACK)
+	REG_S x1,  PT_RA(sp)
+	REG_S x3,  PT_GP(sp)
+	REG_S x4,  PT_TP(sp)
+	REG_S x5,  PT_T0(sp)
+	REG_S x6,  PT_T1(sp)
+	REG_S x7,  PT_T2(sp)
+	REG_S x8,  PT_S0(sp)
+	REG_S x9,  PT_S1(sp)
+	REG_S x10, PT_A0(sp)
+	REG_S x11, PT_A1(sp)
+	REG_S x12, PT_A2(sp)
+	REG_S x13, PT_A3(sp)
+	REG_S x14, PT_A4(sp)
+	REG_S x15, PT_A5(sp)
+	REG_S x16, PT_A6(sp)
+	REG_S x17, PT_A7(sp)
+	REG_S x18, PT_S2(sp)
+	REG_S x19, PT_S3(sp)
+	REG_S x20, PT_S4(sp)
+	REG_S x21, PT_S5(sp)
+	REG_S x22, PT_S6(sp)
+	REG_S x23, PT_S7(sp)
+	REG_S x24, PT_S8(sp)
+	REG_S x25, PT_S9(sp)
+	REG_S x26, PT_S10(sp)
+	REG_S x27, PT_S11(sp)
+	REG_S x28, PT_T3(sp)
+	REG_S x29, PT_T4(sp)
+	REG_S x30, PT_T5(sp)
+	REG_S x31, PT_T6(sp)
+
+	/* waiting for wake up source device to wake up */
+
+	// get pending vector $t0
+	la t0, plic_base
+
+	REG_L t0, 0(t0)
+
+	li s0, 0x1000
+	add t0, t0, s0
+
+	// get wake_mask $t1
+	la t1, wake_mask
+
+	REG_L t1, 0(t1)
+
+self_loop:
+	wfi
+	mv s0, t0
+	mv s1, t1
+	mv t2, x0
+	li t3, 32
+loop1:
+	beq t2, t3, self_loop
+	lw t4, 0(s0)
+	lw t5, 0(s1)
+	addi s0, s0, 4
+	addi s1, s1, 4
+	addi t2, t2, 1
+	beq t5, x0, loop1
+	and t4, t4, t5
+	bne t4, x0, cpu_resume
+	j loop1
+
+cpu_resume:
+	REG_L x1,  PT_RA(sp)
+	REG_L x3,  PT_GP(sp)
+	REG_L x4,  PT_TP(sp)
+	REG_L x5,  PT_T0(sp)
+	REG_L x6,  PT_T1(sp)
+	REG_L x7,  PT_T2(sp)
+	REG_L x8,  PT_S0(sp)
+	REG_L x9,  PT_S1(sp)
+	REG_L x10, PT_A0(sp)
+	REG_L x11, PT_A1(sp)
+	REG_L x12, PT_A2(sp)
+	REG_L x13, PT_A3(sp)
+	REG_L x14, PT_A4(sp)
+	REG_L x15, PT_A5(sp)
+	REG_L x16, PT_A6(sp)
+	REG_L x17, PT_A7(sp)
+	REG_L x18, PT_S2(sp)
+	REG_L x19, PT_S3(sp)
+	REG_L x20, PT_S4(sp)
+	REG_L x21, PT_S5(sp)
+	REG_L x22, PT_S6(sp)
+	REG_L x23, PT_S7(sp)
+	REG_L x24, PT_S8(sp)
+	REG_L x25, PT_S9(sp)
+	REG_L x26, PT_S10(sp)
+	REG_L x27, PT_S11(sp)
+	REG_L x28, PT_T3(sp)
+	REG_L x29, PT_T4(sp)
+	REG_L x30, PT_T5(sp)
+	REG_L x31, PT_T6(sp)
+	addi sp, sp, (PT_SIZE_ON_STACK)
+	ret
diff --git a/arch/riscv/kernel/smpboot.c b/arch/riscv/kernel/smpboot.c
index f741458c..125b3c02 100644
--- a/arch/riscv/kernel/smpboot.c
+++ b/arch/riscv/kernel/smpboot.c
@@ -30,12 +30,15 @@
 #include <linux/irq.h>
 #include <linux/of.h>
 #include <linux/sched/task_stack.h>
+#include <linux/sched/hotplug.h>
+#include <linux/suspend.h>
 #include <asm/irq.h>
 #include <asm/mmu_context.h>
 #include <asm/tlbflush.h>
 #include <asm/sections.h>
 #include <asm/sbi.h>
-
+#include <asm/andesv5/smu.h>
+#include <asm/andesv5/proc.h>
 void *__cpu_up_stack_pointer[NR_CPUS];
 void *__cpu_up_task_pointer[NR_CPUS];
 
@@ -81,10 +84,11 @@ int __cpu_up(unsigned int cpu, struct task_struct *tidle)
 	smp_mb();
 	__cpu_up_stack_pointer[cpu] = task_stack_page(tidle) + THREAD_SIZE;
 	__cpu_up_task_pointer[cpu] = tidle;
-
+	arch_send_call_function_single_ipi(cpu);
 	while (!cpu_online(cpu))
 		cpu_relax();
 
+	pr_notice("CPU%u: online\n", cpu);
 	return 0;
 }
 
@@ -92,10 +96,96 @@ void __init smp_cpus_done(unsigned int max_cpus)
 {
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+/*
+ * __cpu_disable runs on the processor to be shutdown.
+ */
+int __cpu_disable(void)
+{
+	unsigned int cpu = smp_processor_id();
+	int ret;
+
+	set_cpu_online(cpu, false);
+	irq_migrate_all_off_this_cpu();
+
+	return 0;
+}
+/*
+ * called on the thread which is asking for a CPU to be shutdown -
+ * waits until shutdown has completed, or it is timed out.
+ */
+void __cpu_die(unsigned int cpu)
+{
+	int err = 0;
+
+	if (!cpu_wait_death(cpu, 5)) {
+		pr_err("CPU %u: didn't die\n", cpu);
+		return;
+	}
+	pr_notice("CPU%u: shutdown\n", cpu);
+}
+/*
+ * Called from the idle thread for the CPU which has been shutdown.
+ */
+extern int suspend_begin;
+void cpu_play_dead(void)
+{
+	unsigned long sipval, sieval, scauseval;
+	int cpu = smp_processor_id();
+
+	idle_task_exit();
+
+	(void)cpu_report_death();
+
+#ifdef CONFIG_ATCSMU
+	if (suspend_begin == PM_SUSPEND_MEM) {
+		// Disable higher privilege's non-wakeup event
+		sbi_suspend_prepare(false, false);
+		// set SMU wakeup enable & MISC control
+		set_wakeup_enable(cpu, 1 << PCS_WAKE_MSIP_OFF);
+		// set SMU light sleep command
+		set_sleep(cpu, DeepSleep_CTL);
+		// backup, suspend and resume
+		sbi_suspend_mem();
+		// enable privilege
+		sbi_suspend_prepare(false, true);
+		goto exit_dead;
+	}
+	sbi_suspend_prepare(false, false);
+	set_wakeup_enable(cpu, 1 << PCS_WAKE_MSIP_OFF);
+	set_sleep(cpu, LightSleep_CTL);
+	cpu_dcache_disable(NULL);
+	wait_for_interrupt();
+	cpu_dcache_enable(NULL);
+	sbi_suspend_prepare(false, true);
+	goto exit_dead;
+#endif
+	/* Do not disable software interrupt to restart cpu after WFI */
+	csr_clear(sie, SIE_STIE | SIE_SEIE);
+
+	/* clear all pending flags */
+	csr_write(sip, 0);
+	/* clear any previous scause data */
+	csr_write(scause, 0);
+
+	do {
+		wait_for_interrupt();
+		sipval = csr_read(sip);
+		sieval = csr_read(sie);
+		scauseval = csr_read(scause);
+	/* only break if wfi returns for an enabled interrupt */
+	} while ((sipval & sieval) == 0 &&
+		 (scauseval & INTERRUPT_CAUSE_SOFTWARE) == 0);
+exit_dead:
+	boot_sec_cpu();
+}
+
+
+#endif
 /*
  * C entry point for a secondary processor.
  */
-asmlinkage void __init smp_callin(void)
+asmlinkage void smp_callin(void)
 {
 	struct mm_struct *mm = &init_mm;
 
@@ -104,9 +194,8 @@ asmlinkage void __init smp_callin(void)
 	current->active_mm = mm;
 
 	trap_init();
-	init_clockevent();
 	notify_cpu_starting(smp_processor_id());
-	set_cpu_online(smp_processor_id(), 1);
+	set_cpu_online(smp_processor_id(), true);
 	local_flush_tlb_all();
 	local_irq_enable();
 	preempt_disable();
diff --git a/arch/riscv/kernel/time.c b/arch/riscv/kernel/time.c
index 2463fcca..94e220ed 100644
--- a/arch/riscv/kernel/time.c
+++ b/arch/riscv/kernel/time.c
@@ -35,27 +35,34 @@ void riscv_timer_interrupt(void)
 	 */
 	struct clock_event_device *evdev = this_cpu_ptr(&riscv_clock_event);
 
+	/*
+	 * There are no direct SBI calls to clear pending timer interrupt bit.
+	 * Disable timer interrupt to ignore pending interrupt until next
+	 * interrupt.
+	 */
+	csr_clear(sie, SIE_STIE);
 	evdev->event_handler(evdev);
 #endif
 }
 
-void __init init_clockevent(void)
-{
-	timer_probe();
-	csr_set(sie, SIE_STIE);
-}
-
-void __init time_init(void)
+static long __init timebase_frequency(void)
 {
 	struct device_node *cpu;
 	u32 prop;
 
 	cpu = of_find_node_by_path("/cpus");
-	if (!cpu || of_property_read_u32(cpu, "timebase-frequency", &prop))
-		panic(KERN_WARNING "RISC-V system with no 'timebase-frequency' in DTS\n");
-	riscv_timebase = prop;
+	if (cpu && !of_property_read_u32(cpu, "timebase-frequency", &prop))
+		return prop;
+	cpu = of_find_node_by_path("/cpus/cpu@0");
+	if (cpu && !of_property_read_u32(cpu, "timebase-frequency", &prop))
+		return prop;
 
-	lpj_fine = riscv_timebase / HZ;
+	panic(KERN_WARNING "RISC-V system with no 'timebase-frequency' in DTS\n");
+}
 
-	init_clockevent();
+void __init time_init(void)
+{
+	riscv_timebase = timebase_frequency();
+	lpj_fine = riscv_timebase / HZ;
+	timer_probe();
 }
diff --git a/arch/riscv/kernel/traps.c b/arch/riscv/kernel/traps.c
index 93132cb5..c713f6a6 100644
--- a/arch/riscv/kernel/traps.c
+++ b/arch/riscv/kernel/traps.c
@@ -130,6 +130,17 @@ DO_ERROR_INFO(do_trap_ecall_s,
 DO_ERROR_INFO(do_trap_ecall_m,
 	SIGILL, ILL_ILLTRP, "environment call from M-mode");
 
+#ifdef CONFIG_GENERIC_BUG
+static inline unsigned long get_break_insn_length(unsigned long pc)
+{
+	bug_insn_t insn;
+
+	if (probe_kernel_address((bug_insn_t *)pc, insn))
+		return 0;
+	return (((insn & __INSN_LENGTH_MASK) == __INSN_LENGTH_32) ? 4UL : 2UL);
+}
+#endif /* CONFIG_GENERIC_BUG */
+
 asmlinkage void do_trap_break(struct pt_regs *regs)
 {
 #ifdef CONFIG_GENERIC_BUG
@@ -141,8 +152,8 @@ asmlinkage void do_trap_break(struct pt_regs *regs)
 		case BUG_TRAP_TYPE_NONE:
 			break;
 		case BUG_TRAP_TYPE_WARN:
-			regs->sepc += sizeof(bug_insn_t);
-			return;
+			regs->sepc += get_break_insn_length(regs->sepc);
+			break;
 		case BUG_TRAP_TYPE_BUG:
 			die(regs, "Kernel BUG");
 		}
@@ -150,7 +161,6 @@ asmlinkage void do_trap_break(struct pt_regs *regs)
 #endif /* CONFIG_GENERIC_BUG */
 
 	do_trap_siginfo(SIGTRAP, TRAP_BRKPT, regs->sepc, current);
-	regs->sepc += 0x4;
 }
 
 #ifdef CONFIG_GENERIC_BUG
@@ -158,15 +168,18 @@ int is_valid_bugaddr(unsigned long pc)
 {
 	bug_insn_t insn;
 
-	if (pc < PAGE_OFFSET)
+	if (pc < VMALLOC_START)
 		return 0;
 	if (probe_kernel_address((bug_insn_t __user *)pc, insn))
 		return 0;
-	return (insn == __BUG_INSN);
+	if ((insn & __INSN_LENGTH_MASK) == __INSN_LENGTH_32)
+		return (insn == __BUG_INSN_32);
+	else
+		return ((insn & __COMPRESSED_INSN_MASK) == __BUG_INSN_16);
 }
 #endif /* CONFIG_GENERIC_BUG */
 
-void __init trap_init(void)
+void trap_init(void)
 {
 	/*
 	 * Set sup0 scratch register to 0, indicating to exception vector
@@ -175,6 +188,6 @@ void __init trap_init(void)
 	csr_write(sscratch, 0);
 	/* Set the exception vector address */
 	csr_write(stvec, &handle_exception);
-	/* Enable all interrupts */
-	csr_write(sie, -1);
+	/* Enable all interrupts but timer interrupt*/
+	csr_set(sie, SIE_SSIE | SIE_SEIE);
 }
diff --git a/arch/riscv/kernel/vdso/.gitignore b/arch/riscv/kernel/vdso/.gitignore
deleted file mode 100644
index 97c2d69d..00000000
--- a/arch/riscv/kernel/vdso/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-vdso.lds
-*.tmp
diff --git a/arch/riscv/kernel/vmlinux.lds.S b/arch/riscv/kernel/vmlinux.lds.S
index ece84991..01b97b62 100644
--- a/arch/riscv/kernel/vmlinux.lds.S
+++ b/arch/riscv/kernel/vmlinux.lds.S
@@ -54,6 +54,7 @@ SECTIONS
 		KPROBES_TEXT
 		ENTRY_TEXT
 		IRQENTRY_TEXT
+		SOFTIRQENTRY_TEXT
 		*(.fixup)
 		_etext = .;
 	}
@@ -74,7 +75,7 @@ SECTIONS
 		*(.sbss*)
 	}
 
-	BSS_SECTION(0, 0, 0)
+	BSS_SECTION(0x10, 0, 0)
 
 	EXCEPTION_TABLE(0x10)
 	NOTES
diff --git a/arch/riscv/lib/Makefile b/arch/riscv/lib/Makefile
index 596c2ca4..d9d84274 100644
--- a/arch/riscv/lib/Makefile
+++ b/arch/riscv/lib/Makefile
@@ -1,6 +1,5 @@
 lib-y	+= delay.o
 lib-y	+= memcpy.o
 lib-y	+= memset.o
+lib-y	+= memmove.o
 lib-y	+= uaccess.o
-
-lib-$(CONFIG_32BIT) += udivdi3.o
diff --git a/arch/riscv/lib/delay.c b/arch/riscv/lib/delay.c
index dce8ae24..61a89d71 100644
--- a/arch/riscv/lib/delay.c
+++ b/arch/riscv/lib/delay.c
@@ -88,10 +88,15 @@ EXPORT_SYMBOL(__delay);
 
 void udelay(unsigned long usecs)
 {
-	unsigned long ucycles = usecs * lpj_fine * UDELAY_MULT;
+	u64 ucycles = (u64)usecs * lpj_fine * UDELAY_MULT;
+	u64 n;
+	u32 rem;
 
 	if (unlikely(usecs > MAX_UDELAY_US)) {
-		__delay((u64)usecs * riscv_timebase / 1000000ULL);
+		n = (u64)usecs * riscv_timebase;
+		rem = do_div(n, 1000000);
+
+		__delay(n);
 		return;
 	}
 
diff --git a/arch/riscv/lib/memcpy.S b/arch/riscv/lib/memcpy.S
index 80f9c1a5..9528a218 100644
--- a/arch/riscv/lib/memcpy.S
+++ b/arch/riscv/lib/memcpy.S
@@ -15,7 +15,8 @@
 #include <asm/asm.h>
 
 /* void *memcpy(void *, const void *, size_t) */
-ENTRY(memcpy)
+ENTRY(__memcpy)
+WEAK(memcpy)
 	move t6, a0  /* Preserve return value */
 
 	/* Defer to byte-oriented copy for small sizes */
@@ -112,4 +113,4 @@ ENTRY(memcpy)
 	bltu a1, a3, 5b
 6:
 	ret
-END(memcpy)
+END(__memcpy)
diff --git a/arch/riscv/lib/memmove.S b/arch/riscv/lib/memmove.S
new file mode 100644
index 00000000..7c27e63b
--- /dev/null
+++ b/arch/riscv/lib/memmove.S
@@ -0,0 +1,64 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#include <linux/linkage.h>
+#include <asm/asm.h>
+
+ENTRY(__memmove)
+WEAK(memmove)
+	move	t0, a0
+	move	t1, a1
+
+	beq 	a0, a1, exit_memcpy
+	beqz	a2, exit_memcpy
+	srli	t2, a2, 0x2
+
+	slt	t3, a0, a1
+	beqz	t3, do_reverse
+
+	andi	a2, a2, 0x3
+	li	t4, 1
+	beqz	t2, byte_copy
+
+word_copy:
+	lw	t3, 0(a1)
+	addi	t2, t2, -1
+	addi	a1, a1, 4
+	sw	t3, 0(a0)
+	addi	a0, a0, 4
+	bnez	t2, word_copy
+	beqz	a2, exit_memcpy
+	j	byte_copy
+
+do_reverse:
+	add	a0, a0, a2
+	add	a1, a1, a2
+	andi	a2, a2, 0x3
+	li	t4, -1
+	beqz	t2, reverse_byte_copy
+
+reverse_word_copy:
+	addi	a1, a1, -4
+	addi	t2, t2, -1
+	lw	t3, 0(a1)
+	addi	a0, a0, -4
+	sw	t3, 0(a0)
+	bnez	t2, reverse_word_copy
+	beqz	a2, exit_memcpy
+
+reverse_byte_copy:
+	addi	a0, a0, -1
+	addi	a1, a1, -1
+byte_copy:
+	lb	t3, 0(a1)
+	addi	a2, a2, -1
+	sb	t3, 0(a0)
+	add	a1, a1, t4
+	add	a0, a0, t4
+	bnez	a2, byte_copy
+
+exit_memcpy:
+	move a0, t0
+	move a1, t1
+	ret
+
+END(memmove)
diff --git a/arch/riscv/lib/memset.S b/arch/riscv/lib/memset.S
index a790107c..fc19b1d9 100644
--- a/arch/riscv/lib/memset.S
+++ b/arch/riscv/lib/memset.S
@@ -16,7 +16,8 @@
 #include <asm/asm.h>
 
 /* void *memset(void *, int, size_t) */
-ENTRY(memset)
+ENTRY(__memset)
+WEAK(memset)
 	move t0, a0  /* Preserve return value */
 
 	/* Defer to byte-oriented fill for small sizes */
@@ -117,4 +118,4 @@ ENTRY(memset)
 	bltu t0, a3, 5b
 6:
 	ret
-END(memset)
+END(__memset)
diff --git a/arch/riscv/lib/uaccess.S b/arch/riscv/lib/uaccess.S
index 58fb2877..b607cdb9 100644
--- a/arch/riscv/lib/uaccess.S
+++ b/arch/riscv/lib/uaccess.S
@@ -19,50 +19,33 @@ ENTRY(__copy_user)
 	li t6, SR_SUM
 	csrs sstatus, t6
 
-	add a3, a1, a2
-	/* Use word-oriented copy only if low-order bits match */
-	andi t0, a0, SZREG-1
-	andi t1, a1, SZREG-1
-	bne t0, t1, 2f
+	beqz a2, exit			/* if n is zero just exit */
+	srli t0, a2, LGREG   	/* t0: number of word to copy */
+	andi t1, a2, SZREG -1	/* t1: bytes less than a word to copy */
+	beqz t0, byte_copy		/* Only less than a word to byte copy */
 
-	addi t0, a1, SZREG-1
-	andi t1, a3, ~(SZREG-1)
-	andi t0, t0, ~(SZREG-1)
-	/*
-	 * a3: terminal address of source region
-	 * t0: lowest XLEN-aligned address in source
-	 * t1: highest XLEN-aligned address in source
-	 */
-	bgeu t0, t1, 2f
-	bltu a1, t0, 4f
-1:
+word_copy:
 	fixup REG_L, t2, (a1), 10f
 	fixup REG_S, t2, (a0), 10f
 	addi a1, a1, SZREG
 	addi a0, a0, SZREG
-	bltu a1, t1, 1b
-2:
-	bltu a1, a3, 5f
+	addi t0, t0, -1			/* Decrease word count */
+	bnez t0, word_copy		/* Continue looping to copy all words */
+	beqz t1, exit			/* Done word copy and no left bytes to copy */
 
-3:
+byte_copy:
+	fixup lbu, t2, (a1), 10f
+	fixup  sb, t2, (a0), 10f
+	addi a1, a1, 1
+	addi a0, a0, 1
+	addi t1, t1, -1			/* Decrease byte count */
+	bnez t1, byte_copy		/* Contine looping to clear all left bytes */
+
+exit:
 	/* Disable access to user memory */
 	csrc sstatus, t6
 	li a0, 0
 	ret
-4: /* Edge case: unalignment */
-	fixup lbu, t2, (a1), 10f
-	fixup sb, t2, (a0), 10f
-	addi a1, a1, 1
-	addi a0, a0, 1
-	bltu a1, t0, 4b
-	j 1b
-5: /* Edge case: remainder */
-	fixup lbu, t2, (a1), 10f
-	fixup sb, t2, (a0), 10f
-	addi a1, a1, 1
-	addi a0, a0, 1
-	bltu a1, a3, 5b
-	j 3b
 ENDPROC(__copy_user)
 
 
@@ -84,7 +67,7 @@ ENTRY(__clear_user)
 	bgeu t0, t1, 2f
 	bltu a0, t0, 4f
 1:
-	fixup REG_S, zero, (a0), 10f
+	fixup REG_S, zero, (a0), 11f
 	addi a0, a0, SZREG
 	bltu a0, t1, 1b
 2:
@@ -96,12 +79,12 @@ ENTRY(__clear_user)
 	li a0, 0
 	ret
 4: /* Edge case: unalignment */
-	fixup sb, zero, (a0), 10f
+	fixup sb, zero, (a0), 11f
 	addi a0, a0, 1
 	bltu a0, t0, 4b
 	j 1b
 5: /* Edge case: remainder */
-	fixup sb, zero, (a0), 10f
+	fixup sb, zero, (a0), 11f
 	addi a0, a0, 1
 	bltu a0, a3, 5b
 	j 3b
@@ -109,9 +92,14 @@ ENDPROC(__clear_user)
 
 	.section .fixup,"ax"
 	.balign 4
+	/* Fixup code for __copy_user(10) and __clear_user(11) */
 10:
 	/* Disable access to user memory */
 	csrs sstatus, t6
-	sub a0, a3, a0
+	mv a0, a2
+	ret
+11:
+	csrs sstatus, t6
+	mv a0, a1
 	ret
 	.previous
diff --git a/arch/riscv/lib/udivdi3.S b/arch/riscv/lib/udivdi3.S
deleted file mode 100644
index cb01ae5b..00000000
--- a/arch/riscv/lib/udivdi3.S
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2016-2017 Free Software Foundation, Inc.
- *
- *   This program is free software; you can redistribute it and/or
- *   modify it under the terms of the GNU General Public License
- *   as published by the Free Software Foundation, version 2.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- */
-
-  .globl __udivdi3
-__udivdi3:
-  mv    a2, a1
-  mv    a1, a0
-  li    a0, -1
-  beqz  a2, .L5
-  li    a3, 1
-  bgeu  a2, a1, .L2
-.L1:
-  blez  a2, .L2
-  slli  a2, a2, 1
-  slli  a3, a3, 1
-  bgtu  a1, a2, .L1
-.L2:
-  li    a0, 0
-.L3:
-  bltu  a1, a2, .L4
-  sub   a1, a1, a2
-  or    a0, a0, a3
-.L4:
-  srli  a3, a3, 1
-  srli  a2, a2, 1
-  bnez  a3, .L3
-.L5:
-  ret
diff --git a/arch/riscv/mm/Makefile b/arch/riscv/mm/Makefile
index eb22ab49..9e362bfd 100644
--- a/arch/riscv/mm/Makefile
+++ b/arch/riscv/mm/Makefile
@@ -3,3 +3,8 @@ obj-y += fault.o
 obj-y += extable.o
 obj-y += ioremap.o
 obj-y += cacheflush.o
+obj-y += dma-mapping.o
+obj-$(CONFIG_HIGHMEM) += highmem.o
+obj-$(CONFIG_KASAN)   += kasan_init.o
+KASAN_SANITIZE_fault.o := n
+KASAN_SANITIZE_kasan_init.o := n
diff --git a/arch/riscv/mm/dma-mapping.c b/arch/riscv/mm/dma-mapping.c
new file mode 100644
index 00000000..2d04bfbe
--- /dev/null
+++ b/arch/riscv/mm/dma-mapping.c
@@ -0,0 +1,106 @@
+#include <linux/dma-direct.h>
+#include <linux/swiotlb.h>
+
+
+/********************************************
+ * The following APIs are for dummy DMA ops *
+ ********************************************/
+
+static void *__dummy_alloc(struct device *dev, size_t size,
+			   dma_addr_t *dma_handle, gfp_t flags,
+			   unsigned long attrs)
+{
+	return NULL;
+}
+
+static void __dummy_free(struct device *dev, size_t size,
+			 void *vaddr, dma_addr_t dma_handle,
+			 unsigned long attrs)
+{
+}
+
+static int __dummy_mmap(struct device *dev,
+			struct vm_area_struct *vma,
+			void *cpu_addr, dma_addr_t dma_addr, size_t size,
+			unsigned long attrs)
+{
+	return -ENXIO;
+}
+
+static dma_addr_t __dummy_map_page(struct device *dev, struct page *page,
+				   unsigned long offset, size_t size,
+				   enum dma_data_direction dir,
+				   unsigned long attrs)
+{
+	return 0;
+}
+
+static void __dummy_unmap_page(struct device *dev, dma_addr_t dev_addr,
+			       size_t size, enum dma_data_direction dir,
+			       unsigned long attrs)
+{
+}
+
+static int __dummy_map_sg(struct device *dev, struct scatterlist *sgl,
+			  int nelems, enum dma_data_direction dir,
+			  unsigned long attrs)
+{
+	return 0;
+}
+
+static void __dummy_unmap_sg(struct device *dev,
+			     struct scatterlist *sgl, int nelems,
+			     enum dma_data_direction dir,
+			     unsigned long attrs)
+{
+}
+
+static void __dummy_sync_single(struct device *dev,
+				dma_addr_t dev_addr, size_t size,
+				enum dma_data_direction dir)
+{
+}
+
+static void __dummy_sync_sg(struct device *dev,
+			    struct scatterlist *sgl, int nelems,
+			    enum dma_data_direction dir)
+{
+}
+
+static int __dummy_mapping_error(struct device *hwdev, dma_addr_t dma_addr)
+{
+	return 1;
+}
+
+static int __dummy_dma_supported(struct device *hwdev, u64 mask)
+{
+	return 0;
+}
+
+const struct dma_map_ops dummy_dma_ops = {
+	.alloc                  = __dummy_alloc,
+	.free                   = __dummy_free,
+	.mmap                   = __dummy_mmap,
+	.map_page               = __dummy_map_page,
+	.unmap_page             = __dummy_unmap_page,
+	.map_sg                 = __dummy_map_sg,
+	.unmap_sg               = __dummy_unmap_sg,
+	.sync_single_for_cpu    = __dummy_sync_single,
+	.sync_single_for_device = __dummy_sync_single,
+	.sync_sg_for_cpu        = __dummy_sync_sg,
+	.sync_sg_for_device     = __dummy_sync_sg,
+	.mapping_error          = __dummy_mapping_error,
+	.dma_supported          = __dummy_dma_supported,
+};
+EXPORT_SYMBOL(dummy_dma_ops);
+
+extern const struct dma_map_ops swiotlb_noncoh_dma_ops;
+void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
+			const struct iommu_ops *iommu, bool coherent)
+{
+	if(coherent)
+		dev->dma_ops = &swiotlb_dma_ops;
+	else
+		dev->dma_ops = &swiotlb_noncoh_dma_ops;
+	dev->archdata.dma_coherent = coherent;
+}
diff --git a/arch/riscv/mm/fault.c b/arch/riscv/mm/fault.c
index 148c98ca..369de69e 100644
--- a/arch/riscv/mm/fault.c
+++ b/arch/riscv/mm/fault.c
@@ -29,6 +29,7 @@
 
 #include <asm/pgalloc.h>
 #include <asm/ptrace.h>
+#include <asm/cacheflush.h>
 
 /*
  * This routine handles page faults.  It determines the address and the
@@ -280,6 +281,8 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 		pte_k = pte_offset_kernel(pmd_k, addr);
 		if (!pte_present(*pte_k))
 			goto no_context;
+
+		local_flush_tlb_page(addr);
 		return;
 	}
 }
diff --git a/arch/riscv/mm/highmem.c b/arch/riscv/mm/highmem.c
new file mode 100644
index 00000000..9d45d396
--- /dev/null
+++ b/arch/riscv/mm/highmem.c
@@ -0,0 +1,75 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2005-2017 Andes Technology Corporation
+
+#include <linux/export.h>
+#include <linux/highmem.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/interrupt.h>
+#include <linux/bootmem.h>
+#include <asm/fixmap.h>
+#include <asm/pgtable.h>
+#include <asm/tlbflush.h>
+
+void *kmap(struct page *page)
+{
+	unsigned long vaddr;
+	might_sleep();
+	if (!PageHighMem(page))
+		return page_address(page);
+	vaddr = (unsigned long)kmap_high(page);
+	return (void *)vaddr;
+}
+
+EXPORT_SYMBOL(kmap);
+
+void kunmap(struct page *page)
+{
+	BUG_ON(in_interrupt());
+	if (!PageHighMem(page))
+		return;
+	kunmap_high(page);
+}
+
+EXPORT_SYMBOL(kunmap);
+
+void *kmap_atomic(struct page *page)
+{
+	unsigned int idx;
+	unsigned long vaddr;
+	int type;
+	pte_t *ptep;
+
+	preempt_disable();
+	pagefault_disable();
+
+	if (!PageHighMem(page))
+		return page_address(page);
+
+	type = kmap_atomic_idx_push();
+
+	idx = type + KM_TYPE_NR * smp_processor_id();
+	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
+
+	ptep = pte_offset_kernel(pmd_off_k(vaddr), vaddr);
+	set_pte(ptep, mk_pte(page, kmap_prot));
+
+	return (void *)vaddr;
+}
+
+EXPORT_SYMBOL(kmap_atomic);
+
+void __kunmap_atomic(void *kvaddr)
+{
+	if (kvaddr >= (void *)FIXADDR_START && kvaddr <=(void *)FIXADDR_TOP) {
+		unsigned long vaddr = (unsigned long)kvaddr;
+		pte_t *ptep;
+		kmap_atomic_idx_pop();
+		ptep = pte_offset_kernel(pmd_off_k(vaddr), vaddr);
+		set_pte(ptep, __pte(0));
+	}
+	pagefault_enable();
+	preempt_enable();
+}
+
+EXPORT_SYMBOL(__kunmap_atomic);
diff --git a/arch/riscv/mm/init.c b/arch/riscv/mm/init.c
index c77df814..c6d68fab 100644
--- a/arch/riscv/mm/init.c
+++ b/arch/riscv/mm/init.c
@@ -28,9 +28,14 @@ static void __init zone_sizes_init(void)
 {
 	unsigned long max_zone_pfns[MAX_NR_ZONES] = { 0, };
 
-	max_zone_pfns[ZONE_DMA32] = PFN_DOWN(min(4UL * SZ_1G, max_low_pfn));
+#ifdef CONFIG_ZONE_DMA32
+	max_zone_pfns[ZONE_DMA32] = PFN_DOWN(min(4UL * SZ_1G,
+					(unsigned long) PFN_PHYS(max_low_pfn)));
+#endif
 	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
-
+#ifdef CONFIG_HIGHMEM
+	max_zone_pfns[ZONE_HIGHMEM] = max_pfn;
+#endif
 	free_area_init_nodes(max_zone_pfns);
 }
 
@@ -39,11 +44,101 @@ void setup_zero_page(void)
 	memset((void *)empty_zero_page, 0, PAGE_SIZE);
 }
 
+#ifdef CONFIG_HIGHMEM
+static pmd_t *fixmap_pmd_p;
+static void __init fixedrange_init(void)
+{
+    unsigned long vaddr;
+    unsigned long pfn;
+    pgd_t *pgd;
+    p4d_t *p4d;
+    pud_t *pud;
+    pmd_t *pmd;
+    pte_t *pkmap_p;
+
+    /*
+     * Fixed mappings:
+     */
+    vaddr = __fix_to_virt(__end_of_fixed_addresses - 1);
+    pgd = swapper_pg_dir + pgd_index(vaddr);
+    p4d = p4d_offset(pgd, vaddr);
+    pud = pud_offset(p4d, vaddr);
+    pmd = pmd_offset(pud, vaddr);
+    fixmap_pmd_p = (pmd_t *) __va(memblock_alloc(PAGE_SIZE, PAGE_SIZE));
+	if (!fixmap_pmd_p)
+		panic("%s: Failed to allocate %lu bytes align=0x%lx\n",
+		      __func__, PAGE_SIZE, PAGE_SIZE);
+    memset(fixmap_pmd_p, 0, PAGE_SIZE);
+	pfn = PFN_DOWN(__pa(fixmap_pmd_p));
+    set_pmd(pmd, __pmd((pfn << _PAGE_PFN_SHIFT) |
+						pgprot_val(__pgprot(_PAGE_TABLE))));
+
+    /*
+     * Permanent kmaps:
+     */
+    vaddr = PKMAP_BASE;
+
+    pgd = swapper_pg_dir + pgd_index(vaddr);
+    p4d = p4d_offset(pgd, vaddr);
+    pud = pud_offset(p4d, vaddr);
+    pmd = pmd_offset(pud, vaddr);
+    pkmap_p = (pte_t *) __va(memblock_alloc(PAGE_SIZE, PAGE_SIZE));
+	if (!pkmap_p)
+		panic("%s: Failed to allocate %lu bytes align=0x%lx\n",
+		      __func__, PAGE_SIZE, PAGE_SIZE);
+    memset(pkmap_p, 0, PAGE_SIZE);
+	pfn = PFN_DOWN(__pa(pkmap_p));
+    set_pmd(pmd, __pmd((pfn  << _PAGE_PFN_SHIFT) |
+						pgprot_val(__pgprot(_PAGE_TABLE))));
+	/* Adjust pkmap page table base */
+	pkmap_page_table = pkmap_p + pte_index(vaddr);
+
+}
+
+static inline void __init free_highmem(void)
+{
+    unsigned long pfn;
+    for (pfn = PFN_UP(__pa(high_memory)); pfn < max_pfn; pfn++) {
+        phys_addr_t paddr = (phys_addr_t) pfn << PAGE_SHIFT;
+        if (!memblock_is_reserved(paddr))
+            free_highmem_page(pfn_to_page(pfn));
+    }
+}
+
+static inline void print_mlk(char *name, unsigned long b, unsigned long t)
+{
+	pr_notice("%12s : 0x%08lx - 0x%08lx   (%4ld kB)\n", name, b, t,
+		  (((t) - (b)) >> 10));
+}
+
+static inline void print_mlm(char *name, unsigned long b, unsigned long t)
+{
+	pr_notice("%12s : 0x%08lx - 0x%08lx   (%4ld MB)\n", name, b, t,
+		  (((t) - (b)) >> 20));
+}
+
+static void print_vm_layout(void)
+{
+	pr_notice("Virtual kernel memory layout:\n");
+	print_mlm("vmalloc", (unsigned long)VMALLOC_START,
+		  (unsigned long)VMALLOC_END);
+	print_mlk("pkmap", (unsigned long)PKMAP_BASE,
+		  (unsigned long)VMALLOC_START);
+	print_mlk("fixmap", (unsigned long)FIXADDR_START,
+		  (unsigned long)FIXADDR_TOP);
+	print_mlm("lowmem", (unsigned long)PAGE_OFFSET,
+		  (unsigned long)high_memory);
+}
+#endif /* CONFIG_HIGHMEM */
+
 void __init paging_init(void)
 {
 	setup_zero_page();
 	local_flush_tlb_all();
 	zone_sizes_init();
+#ifdef CONFIG_HIGHMEM
+	fixedrange_init();
+#endif /* CONFIG_HIGHMEM */
 }
 
 void __init mem_init(void)
@@ -53,6 +148,11 @@ void __init mem_init(void)
 #endif /* CONFIG_FLATMEM */
 
 	high_memory = (void *)(__va(PFN_PHYS(max_low_pfn)));
+
+#ifdef CONFIG_HIGHMEM
+	free_highmem();
+	print_vm_layout();
+#endif
 	free_all_bootmem();
 
 	mem_init_print_info(NULL);
diff --git a/arch/riscv/mm/ioremap.c b/arch/riscv/mm/ioremap.c
index 70ef2724..31c7857d 100644
--- a/arch/riscv/mm/ioremap.c
+++ b/arch/riscv/mm/ioremap.c
@@ -18,7 +18,7 @@
 #include <linux/io.h>
 
 #include <asm/pgtable.h>
-
+#include <asm/sbi.h>
 /*
  * Remap an arbitrary physical address space into the kernel virtual
  * address space. Needed when the kernel wants to access high addresses
@@ -42,7 +42,7 @@ static void __iomem *__ioremap_caller(phys_addr_t addr, size_t size,
 
 	/* Page-align mappings */
 	offset = addr & (~PAGE_MASK);
-	addr &= PAGE_MASK;
+	addr -= offset;
 	size = PAGE_ALIGN(size + offset);
 
 	area = get_vm_area_caller(size, VM_IOREMAP, caller);
@@ -71,13 +71,48 @@ static void __iomem *__ioremap_caller(phys_addr_t addr, size_t size,
  *
  * Must be freed with iounmap.
  */
-void __iomem *ioremap(phys_addr_t offset, unsigned long size)
+
+#ifdef CONFIG_PMA
+#define MAX_PMA 16
+unsigned long pma_used[MAX_PMA];
+#endif
+
+void __iomem *ioremap(phys_addr_t offset, size_t size)
 {
 	return __ioremap_caller(offset, size, PAGE_KERNEL,
 		__builtin_return_address(0));
 }
 EXPORT_SYMBOL(ioremap);
 
+void __iomem *ioremap_nocache(phys_addr_t offset, size_t size)
+{
+	void __iomem *ret;
+	int i;
+
+	pgprot_t pgprot = pgprot_noncached(PAGE_KERNEL);
+	ret =  __ioremap_caller(offset, size, pgprot,
+		__builtin_return_address(0));
+#ifdef CONFIG_PMA
+	if(!pa_msb){    // PMA enable --> pa_msb==0 --> sbi_set_pma()
+		/* Start to setting PMA */
+		/* Check whether the value of size is power of 2 */
+		if ((size & (size-1)) != 0) {
+			printk("The value of size is not power of 2\n");
+			BUG();
+		}
+		/* Setting PMA register */
+		for (i = 0; i < MAX_PMA; i++) {
+			if (!pma_used[i]) {
+				pma_used[i] = (unsigned long)ret;
+				break;
+			}
+		}
+		sbi_set_pma(offset, (unsigned long)ret, size);
+	}
+#endif
+	return ret;
+}
+EXPORT_SYMBOL(ioremap_nocache);
 
 /**
  * iounmap - Free a IO remapping
@@ -87,6 +122,20 @@ EXPORT_SYMBOL(ioremap);
  */
 void iounmap(volatile void __iomem *addr)
 {
+	int i;
+
 	vunmap((void *)((unsigned long)addr & PAGE_MASK));
+#ifdef CONFIG_PMA
+	if(!pa_msb){
+		/* Free PMA regitser */
+		for (i = 0; i < MAX_PMA; i++) {
+			if (pma_used[i] == (unsigned long)addr) {
+				pma_used[i] = 0;
+				sbi_free_pma((unsigned long)addr);
+				break;
+			}
+		}
+	}
+#endif
 }
 EXPORT_SYMBOL(iounmap);
diff --git a/arch/riscv/mm/kasan_init.c b/arch/riscv/mm/kasan_init.c
new file mode 100644
index 00000000..cc438666
--- /dev/null
+++ b/arch/riscv/mm/kasan_init.c
@@ -0,0 +1,93 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/bootmem.h>
+#include <linux/init_task.h>
+#include <linux/kasan.h>
+#include <linux/kernel.h>
+#include <linux/memblock.h>
+#include <asm/tlbflush.h>
+#include <asm/pgtable.h>
+
+asmlinkage void __init kasan_early_init(void)
+{
+	uintptr_t i;
+	pgd_t *pgd = pgd_offset_k(KASAN_SHADOW_START);
+
+	for (i = 0; i < PTRS_PER_PTE; ++i)
+		set_pte(kasan_zero_pte + i,
+			mk_pte(virt_to_page(kasan_zero_page), PAGE_KERNEL));
+
+	for (i = 0; i < PTRS_PER_PMD; ++i)
+		set_pmd(kasan_zero_pmd + i,
+			pfn_pmd(PFN_DOWN(__pa((uintptr_t)kasan_zero_pte)),
+			__pgprot(_PAGE_TABLE)));
+
+	for (i = KASAN_SHADOW_START; i < KASAN_SHADOW_END;
+	     i += PGDIR_SIZE, ++pgd)
+		set_pgd(pgd,
+			pfn_pgd(PFN_DOWN(__pa(((uintptr_t)kasan_zero_pmd))),
+			__pgprot(_PAGE_TABLE)));
+}
+
+static void __init populate(void *start, void *end)
+{
+	unsigned long i, j;
+	unsigned long vaddr = (unsigned long)start & PAGE_MASK;
+	unsigned long vend = PAGE_ALIGN((unsigned long)end);
+	unsigned long n_pages = (vend - vaddr) / PAGE_SIZE;
+	unsigned long n_pmds = (n_pages % PTRS_PER_PTE) ? n_pages / PTRS_PER_PTE + 1 :
+								n_pages / PTRS_PER_PTE;
+
+	pgd_t *pgd = pgd_offset_k(vaddr);
+	pmd_t *pmd = memblock_virt_alloc(n_pmds * sizeof(pmd_t), PAGE_SIZE);
+	pte_t *pte = memblock_virt_alloc(n_pages * sizeof(pte_t), PAGE_SIZE);
+
+	for (i = 0; i < n_pages; i++) {
+		phys_addr_t phys = memblock_alloc_base(PAGE_SIZE, PAGE_SIZE,
+						MEMBLOCK_ALLOC_ACCESSIBLE);
+
+		set_pte(pte + i, pfn_pte(PHYS_PFN(phys), PAGE_KERNEL));
+	}
+
+	for (i = 0; i < n_pages; ++pmd, i += PTRS_PER_PTE)
+		set_pmd(pmd, pfn_pmd(PFN_DOWN(__pa((uintptr_t)(pte + i))),
+				__pgprot(_PAGE_TABLE)));
+
+	for (i = vaddr; i < vend; i += PGDIR_SIZE, ++pgd)
+		set_pgd(pgd, pfn_pgd(PFN_DOWN(__pa(((uintptr_t)pmd))),
+				__pgprot(_PAGE_TABLE)));
+
+	local_flush_tlb_all();
+	memset(start, 0, end - start);
+}
+
+void __init kasan_init(void)
+{
+	struct memblock_region *reg;
+	int i;
+
+	kasan_populate_zero_shadow((void *)KASAN_SHADOW_START,
+			(void *)kasan_mem_to_shadow((void *)VMALLOC_END));
+
+	for_each_memblock(memory, reg) {
+		void *start = (void *)__va(reg->base);
+		void *end = (void *)__va(reg->base + reg->size);
+
+		if (reg->base == 0xffffffc400000000)
+			__asm__("ebreak\n");
+		if (start >= end)
+			break;
+
+		populate(kasan_mem_to_shadow(start),
+			 kasan_mem_to_shadow(end));
+	};
+
+	for (i = 0; i < PTRS_PER_PTE; i++)
+		set_pte(&kasan_zero_pte[i],
+			mk_pte(virt_to_page(kasan_zero_page),
+			__pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_ACCESSED)));
+
+	memset(kasan_zero_page, 0, PAGE_SIZE);
+
+	init_task.kasan_depth = 0;
+}
diff --git a/arch/riscv/platforms/Kconfig b/arch/riscv/platforms/Kconfig
new file mode 100644
index 00000000..bd201d81
--- /dev/null
+++ b/arch/riscv/platforms/Kconfig
@@ -0,0 +1,26 @@
+choice
+	prompt "platform type"
+	default PLAT_AE350
+
+config PLAT_AE350
+	bool "ae350 platform"
+
+endchoice
+
+if PLAT_AE350
+source "arch/riscv/platforms/ae350/Kconfig"
+endif
+
+menu "Common Platform Options"
+
+config PLATFORM_AHBDMA
+	prompt "platform AHB DMA support"
+	bool
+	default y
+
+config ATCSMU
+        bool "ATCSMU Support"
+        depends on RISCV && PLAT_AE350
+        help
+         Say N here if you want to disable SMU support
+endmenu
diff --git a/arch/riscv/platforms/Makefile b/arch/riscv/platforms/Makefile
new file mode 100644
index 00000000..a95c2e44
--- /dev/null
+++ b/arch/riscv/platforms/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_PLATFORM_AHBDMA) += dmad_intc.o
+obj-$(CONFIG_PLAT_AE350)	+= ae350/
\ No newline at end of file
diff --git a/arch/riscv/platforms/ae350/Kconfig b/arch/riscv/platforms/ae350/Kconfig
new file mode 100644
index 00000000..9c818fff
--- /dev/null
+++ b/arch/riscv/platforms/ae350/Kconfig
@@ -0,0 +1,10 @@
+menu "AE3XX Platform Options"
+
+config ATCCPUFREQ
+	def_bool y
+	depends on CPU_FREQ
+config ATCDMAC300
+	def_bool y
+	depends on PLATFORM_AHBDMA
+
+endmenu
diff --git a/arch/riscv/platforms/ae350/Makefile b/arch/riscv/platforms/ae350/Makefile
new file mode 100644
index 00000000..ccd3c264
--- /dev/null
+++ b/arch/riscv/platforms/ae350/Makefile
@@ -0,0 +1,2 @@
+obj-y	+= atcdmac300.o
+obj-$(CONFIG_ATCSMU) += atcsmu.o
diff --git a/arch/riscv/platforms/ae350/atcdmac300.c b/arch/riscv/platforms/ae350/atcdmac300.c
new file mode 100644
index 00000000..e635328f
--- /dev/null
+++ b/arch/riscv/platforms/ae350/atcdmac300.c
@@ -0,0 +1,2531 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 Andes Technology Corporation
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/completion.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/sizes.h>
+#include <asm/types.h>
+#include <asm/io.h>
+#include <asm/dmad.h>
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_dma.h>
+#include <linux/math64.h>
+#include <asm/div64.h>
+
+resource_size_t	dmac_base;
+
+static inline addr_t REG_READ(unsigned long r)
+{
+	return readl((volatile void __iomem *) (unsigned long) r);
+}
+
+static inline void REG_WRITE(addr_t d, unsigned long r)
+{
+	writel(d, (volatile void __iomem *) (unsigned long) r);
+}
+
+#if (defined(CONFIG_PLATFORM_AHBDMA))
+#define DMAD_AHB_MAX_CHANNELS           DMAC_MAX_CHANNELS
+
+#define DMAD_DRB_POOL_SIZE              32	/* 128 */
+
+
+static inline addr_t din(unsigned long r)
+{
+	return REG_READ(r);
+}
+
+static inline void dout(addr_t d, unsigned long r)
+{
+	REG_WRITE(d,r);
+}
+
+/* reg/io supplementals */
+
+static void setbl(addr_t bit, unsigned long reg)
+{
+	REG_WRITE(REG_READ(reg) | (addr_t) ((addr_t) 1 << bit), reg);
+}
+
+static inline void clrbl(addr_t bit, unsigned long reg)
+{
+	REG_WRITE(REG_READ(reg) & (~((addr_t) ((addr_t) 1 << bit))), reg);
+}
+
+static inline addr_t getbl(addr_t bit, unsigned long reg)
+{
+ return REG_READ(reg) & (addr_t) ((addr_t) 1 << bit);
+}
+/******************************************************************************/
+
+enum DMAD_DRQ_FLAGS {
+	DMAD_DRQ_STATE_READY = 0x00000001,	/* channel allocation status */
+	DMAD_DRQ_STATE_ABORT = 0x00000002,	/* abort drb alloc block-wait */
+	DMAD_DRQ_DIR_A1_TO_A0 = 0x00000004,	/* Transfer direction */
+};
+
+#define DMAD_DRQ_DIR_MASK  DMAD_DRQ_DIR_A1_TO_A0
+
+/* DMA request queue, one instance per channel */
+typedef struct dmad_drq {
+	u32 state;		/* enum DMAD_DRQ_STATE */
+
+	unsigned long channel_base;	/* register base address */
+	unsigned long enable_port;	/* enable register */
+	unsigned long src_port;	/* source address register */
+	unsigned long dst_port;	/* dest address register */
+	unsigned long cyc_port;	/* size(cycle) register */
+
+	u32 flags;		/* enum DMAD_CHREQ_FLAGS */
+
+	spinlock_t drb_pool_lock;
+	dmad_drb *drb_pool;	/* drb pool */
+
+	unsigned long fre_head;		/* free list head */
+	unsigned long fre_tail;		/* free list tail */
+
+	unsigned long rdy_head;		/* ready list head */
+	unsigned long rdy_tail;		/* ready list tail */
+
+	unsigned long sbt_head;		/* submitted list head */
+	unsigned long sbt_tail;		/* submitted list tail */
+
+	u32 data_width;		/* dma transfer data width */
+
+	struct completion drb_alloc_sync;
+
+	/* client supplied callback function, executed in interrupt context
+	 * client private data to be passed to data argument of completion_cb().
+	 */
+	void (*completion_cb) (int channel, u16 status, void *data);
+	void *completion_data;
+
+	/* ring-mode fields are valid for DMAD_FLAGS_RING_MODE */
+	dma_addr_t ring_base;	/* ring buffer base address */
+	int ring_size;	/* size (of data width) */
+	unsigned long ring_port;	/* for setup/fetch hw_ptr */
+	dmad_drb *ring_drb;
+
+	addr_t dev_addr;	/* device data port */
+
+	int periods;		/* interrupts periods */
+	int period_size;	/* of dma data with */
+	dma_addr_t period_bytes;	/* Period size, in bytes */
+
+	/* ring_size - period_size * periods */
+	dma_addr_t remnant_size;
+
+	dma_addr_t sw_ptr;	/* sw pointer */
+	int sw_p_idx;		/* current ring_ptr */
+	dma_addr_t sw_p_off;	/* offset to period base */
+
+} dmad_drq;
+
+static inline void dmad_enable_channel(dmad_drq * drq)
+{
+	setbl(CHEN, drq->enable_port);
+}
+
+static inline void dmad_disable_channel(dmad_drq * drq)
+{
+	clrbl(CHEN, drq->enable_port);
+}
+
+static inline addr_t dmad_is_channel_enabled(dmad_drq * drq)
+{
+	return (addr_t) getbl(CHEN, drq->enable_port);
+}
+
+/* system irq number (per channel, ahb) */
+static const unsigned int ahb_irqs[DMAD_AHB_MAX_CHANNELS] = {
+	DMA_IRQ0,
+	DMA_IRQ1,
+	DMA_IRQ2,
+	DMA_IRQ3,
+	DMA_IRQ4,
+	DMA_IRQ5,
+	DMA_IRQ6,
+	DMA_IRQ7,
+};
+
+/* Driver data structure, one instance per system */
+typedef struct DMAD_DATA_STRUCT {
+	/* Driver data initialization flag */
+
+	/* DMA queue pool access control object */
+	spinlock_t drq_pool_lock;
+
+	/* DMA queue base address, to ease alloc/free flow */
+	dmad_drq *drq_pool;
+	/* DMA queue for AHB DMA channels */
+	dmad_drq *ahb_drq_pool;
+	void *plat;
+} DMAD_DATA;
+
+/* Driver data structure instance, one instance per system */
+
+static DMAD_DATA dmad __attribute__ ((aligned(8))) = {
+
+	.drq_pool_lock = __SPIN_LOCK_UNLOCKED(dmad.drq_pool_lock),
+	.drq_pool = 0,
+	.ahb_drq_pool = 0,
+	.plat = 0,
+};
+
+/**
+ * dmad_next_drb - static function
+ * @drb_pool : [in] The raw DRB pool of a DMA channel
+ * @node     : [in] The node number to lookup its next node
+ * @drb      : [out] The drb next to the "node" node number
+ *
+ * Lookup next DRB of the specified node number. "drb" is null if reaches end
+ * of the list.
+ */
+static inline void dmad_next_drb(dmad_drb * drb_pool, u32 node, dmad_drb ** drb)
+{
+	if (likely(drb_pool[node].next != 0))
+		*drb = &drb_pool[drb_pool[node].next];
+	else
+		*drb = 0;
+}
+
+/**
+ * dmad_prev_drb - static function
+ * @drb_pool : [in] The raw DRB pool of a DMA channel
+ * @node     : [in] The node number to lookup its previous node
+ * @drb      : [out] The drb previous to the "node" node number
+ *
+ * Lookup previous DRB of the specified node number. "drb" is null if reaches
+ * head-end of the list.
+ */
+static inline void dmad_prev_drb(dmad_drb * drb_pool, u32 node, dmad_drb ** drb)
+{
+	if (unlikely(drb_pool[node].prev != 0))
+		*drb = &drb_pool[drb_pool[node].prev];
+	else
+		*drb = 0;
+}
+
+/**
+ * dmad_detach_node - static function
+ * @drb_pool : [in] The raw DRB pool of a DMA channel
+ * @head     : [in/out] Reference to the head node number
+ * @tail     : [in/out] Reference to the tail node number
+ * @node     : [in] The node to be dettached from the queue
+ *
+ * Detached a DRB specified by the node number from the queue.  The head and
+ * tail records will be updated accordingly.
+ */
+static inline void dmad_detach_node(dmad_drb * drb_pool,
+				    unsigned long * head, unsigned long * tail, u32 node)
+{
+	if (likely(drb_pool[node].prev != 0)) {
+		/* prev->next = this->next (= 0, if this is a tail) */
+		drb_pool[drb_pool[node].prev].next = drb_pool[node].next;
+	} else {
+		/* this node is head, move head to next node
+		 * (= 0, if this is the only one node) */
+		*head = drb_pool[node].next;
+	}
+
+	if (unlikely(drb_pool[node].next != 0)) {
+		/* next->prev = this->prev (= 0, if this is a head) */
+		drb_pool[drb_pool[node].next].prev = drb_pool[node].prev;
+	} else {
+		/* this node is tail, move tail to previous node
+		 * (= 0, if this is the only one node) */
+		*tail = drb_pool[node].prev;
+	}
+
+	drb_pool[node].prev = drb_pool[node].next = 0;
+}
+
+/**
+ * dmad_detach_head - static function
+ * @drb_pool : [in] The raw DRB pool of a DMA channel
+ * @head     : [in/out] Reference to the head node number
+ * @tail     : [in/out] Reference to the tail node number
+ * @drb      : [out] The detached head node; null if the queue is empty
+ *
+ * Detached a DRB from the head of the queue.  The head and tail records will
+ * be updated accordingly.
+ */
+static inline void dmad_detach_head(dmad_drb * drb_pool,
+				    unsigned long * head, unsigned long * tail, dmad_drb ** drb)
+{
+	if (unlikely(*head == 0)) {
+		*drb = NULL;
+		return;
+	}
+
+	*drb = &drb_pool[*head];
+
+	if (likely((*drb)->next != 0)) {
+		/* next->prev = this->prev (= 0, if this is a head) */
+		drb_pool[(*drb)->next].prev = 0;
+
+		/* prev->next = this->next (do nothing, if this is a head) */
+
+		/* head = this->next */
+		*head = (*drb)->next;
+	} else {
+		/* head = tail = 0 */
+		*head = 0;
+		*tail = 0;
+	}
+
+	/* this->prev = this->next = 0 (do nothing, if save code size) */
+	(*drb)->prev = (*drb)->next = 0;
+}
+
+/**
+ * dmad_get_head - static function
+ * @drb_pool : [in] The raw DRB pool of a DMA channel
+ * @head     : [in/out] Reference to the head node number
+ * @tail     : [in/out] Reference to the tail node number
+ * @drb      : [out] The head node; null if the queue is empty
+ *
+ * Get a DRB from the head of the queue.  The head and tail records remain
+ * unchanged.
+ */
+static inline void dmad_get_head(dmad_drb * drb_pool, const unsigned long * head,
+				 const unsigned long * tail, dmad_drb ** drb)
+{
+	if (unlikely(*head == 0)) {
+		*drb = NULL;
+		return;
+	}
+
+	*drb = &drb_pool[*head];
+}
+
+/**
+ * dmad_detach_tail - static function
+ * @drb_pool : [in] The raw DRB pool of a DMA channel
+ * @head     : [in/out] Reference to the head node number
+ * @tail     : [in/out] Reference to the tail node number
+ * @drb      : [out] The tail node; null if the queue is empty
+ *
+ * Detached a DRB from the head of the queue.  The head and tail records will
+ * be updated accordingly.
+ */
+static inline void dmad_detach_tail(dmad_drb * drb_pool,
+				    unsigned long * head, unsigned long * tail, dmad_drb ** drb)
+{
+	if (unlikely(*tail == 0)) {
+		*drb = NULL;
+		return;
+	}
+
+	*drb = &drb_pool[*tail];
+
+	if (likely((*drb)->prev != 0)) {
+		/* prev->next = this->next (= 0, if this is a tail) */
+		drb_pool[(*drb)->prev].next = 0;
+
+		/* next->prev = this->prev (do nothing, if this is a tail) */
+
+		/* tail = this->prev */
+		*tail = (*drb)->prev;
+	} else {
+		/* head = tail = 0 */
+		*head = 0;
+		*tail = 0;
+	}
+
+	/* this->next = this->prev = 0 (do nothing, if save code size) */
+	(*drb)->prev = (*drb)->next = 0;
+}
+
+/**
+ * dmad_get_tail - static function
+ * @drb_pool : [in] The raw DRB pool of a DMA channel
+ * @head     : [in/out] Reference to the head node number
+ * @tail     : [in/out] Reference to the tail node number
+ * @drb      : [out] The tail node; null if the queue is empty
+ *
+ * Get a DRB from the tail of the queue.  The head and tail records remain
+ * unchanged.
+ */
+static inline void dmad_get_tail(dmad_drb * drb_pool,
+				 unsigned long * head, unsigned long * tail, dmad_drb ** drb)
+{
+	if (unlikely(*tail == 0)) {
+		*drb = NULL;
+		return;
+	}
+
+	*drb = &drb_pool[*tail];
+}
+
+/**
+ * dmad_attach_head - static function
+ * @drb_pool : [in] The raw DRB pool of a DMA channel
+ * @head     : [in/out] Reference to the head node number
+ * @tail     : [in/out] Reference to the tail node number
+ * @node     : [in] The node to be attached
+ *
+ * Attach a DRB node to the head of the queue.  The head and tail records will
+ * be updated accordingly.
+ */
+static inline void dmad_attach_head(dmad_drb * drb_pool,
+				    unsigned long * head, unsigned long * tail, u32 node)
+{
+	if (likely(*head != 0)) {
+		/* head->prev = this */
+		drb_pool[*head].prev = node;
+
+		/* this->next = head */
+		drb_pool[node].next = *head;
+		/* this->prev = 0 */
+		drb_pool[node].prev = 0;
+
+		/* head = node */
+		*head = node;
+	} else {
+		/* head = tail = node */
+		*head = *tail = node;
+		drb_pool[node].prev = drb_pool[node].next = 0;
+	}
+}
+
+/**
+ * dmad_attach_head - static function
+ * @drb_pool : [in] The raw DRB pool of a DMA channel
+ * @head     : [in/out] Reference to the head node number
+ * @tail     : [in/out] Reference to the tail node number
+ * @node     : [in] The node to be attached
+ *
+ * Attach a DRB node to the tail of the queue.  The head and tail records will
+ * be updated accordingly.
+ */
+static inline void dmad_attach_tail(dmad_drb * drb_pool,
+				    unsigned long * head, unsigned long * tail, u32 node)
+{
+	if (likely(*tail != 0)) {
+		/* tail->next = this */
+		drb_pool[*tail].next = node;
+
+		/* this->prev = tail */
+		drb_pool[node].prev = *tail;
+		/* this->next = 0 */
+		drb_pool[node].next = 0;
+
+		/* tail = node */
+		*tail = node;
+	} else {
+		/* head = tail = node */
+		*head = *tail = node;
+		drb_pool[node].prev = drb_pool[node].next = 0;
+	}
+}
+
+#ifdef CONFIG_PLATFORM_AHBDMA
+
+/**
+ * dmad_ahb_isr - AHB DMA interrupt service routine
+ *
+ * @irq    : [in] The irq number
+ * @dev_id : [in] The identifier to identify the asserted channel
+ *
+ * This is the ISR that services all AHB DMA channels.
+ */
+static irqreturn_t dmad_ahb_isr(int irq, void *dev_id)
+{
+	dmad_drq *drq;
+	dmad_drb *drb, *drb_iter;
+	u32 channel = ((unsigned long) dev_id) - 1;
+	u8 tc_int = 0;
+	u8 err_int = 0;
+	u8 abt_int = 0;
+	u8 cpl_events = 1;
+
+	dmad_dbg("%s() >> channel(%d)\n", __func__, channel);
+
+	if (channel >= DMAD_AHB_MAX_CHANNELS) {
+		dmad_err("%s() invlaid channel number: %d!\n",
+			 __func__, channel);
+		return IRQ_HANDLED;
+	}
+
+	/* Fetch channel's DRQ struct (DMA Request Queue) */
+	drq = (dmad_drq *) & dmad.ahb_drq_pool[channel];
+
+	/* Check DMA status register to get channel number */
+	if (likely(getbl(channel+TC_OFFSET, (unsigned long)INT_STA))) {
+
+		/* Mark as TC int */
+		tc_int = 1;
+
+		/* DMAC INT TC status clear */
+		setbl(channel+TC_OFFSET, (unsigned long)INT_STA);
+
+	} else if (getbl(channel+ERR_OFFSET, (unsigned long)INT_STA)) {
+
+		/* Mark as ERR int */
+		err_int = 1;
+
+		/* DMAC INT ERR status clear */
+		setbl(channel+ERR_OFFSET, (unsigned long)INT_STA);
+
+	} else if (getbl(channel+ABT_OFFSET, (unsigned long)INT_STA)) {
+
+		/* Mark as ABT int */
+		abt_int = 1;
+
+		/* DMAC INT ABT status clear */
+		setbl(channel+INT_STA, (unsigned long)INT_STA);
+
+	} else {
+
+		dmad_err("%s() possible false-fired ahb dma int,"
+			 "channel %d status-reg: status(0x%08x)\n",
+			 __func__, channel,din((unsigned long)INT_STA));
+
+		/* Stop DMA channel (make sure the channel will be stopped) */
+		clrbl(CH_EN, drq->enable_port);
+		return IRQ_HANDLED;
+	}
+
+	/* DMAC
+	 * Stop DMA channel temporarily */
+	dmad_disable_channel(drq);
+
+	spin_lock(&drq->drb_pool_lock);
+
+	/* Lookup/detach latest submitted DRB (DMA Request Block) from
+	 * the DRQ (DMA Request Queue), so ISR could kick off next DRB */
+	dmad_detach_head(drq->drb_pool, &drq->sbt_head, &drq->sbt_tail, &drb);
+	if (drb == NULL) {
+		spin_unlock(&drq->drb_pool_lock);
+		/* submitted list could be empty if client cancel all requests
+		 * of the channel. */
+		return IRQ_HANDLED;
+	}
+
+	/* release blocking of drb-allocation, if any ... */
+	if (unlikely((drq->fre_head == 0) &&
+		     (drq->flags & DMAD_FLAGS_SLEEP_BLOCK))) {
+		complete_all(&drq->drb_alloc_sync);
+	}
+
+	/* Process DRBs according to interrupt reason */
+	if (tc_int) {
+
+		dmad_dbg("dma finish\n");
+
+		dmad_dbg("finish drb(%d 0x%08x) addr0(0x%08x) "
+			 "addr1(0x%08x) size(0x%08x)\n",
+			 drb->node, (u32) drb, drb->src_addr,
+			 drb->dst_addr, drb->req_cycle);
+
+		if (drb->req_cycle == 0)
+			cpl_events = 0;
+
+		// Mark DRB state as completed
+		drb->state = DMAD_DRB_STATE_COMPLETED;
+		if (cpl_events && drb->sync)
+			complete_all(drb->sync);
+
+		dmad_attach_tail(drq->drb_pool, &drq->fre_head,
+				 &drq->fre_tail, drb->node);
+
+		// Check whether there are pending requests in the DRQ
+		if (drq->sbt_head != 0) {
+
+			// Lookup next DRB (DMA Request Block)
+			drb_iter = &drq->drb_pool[drq->sbt_head];
+
+			dmad_dbg("exec drb(%d 0x%08x) addr0(0x%08x) "
+				 "addr1(0x%08x) size(0x%08x)\n",
+				 drb_iter->node, (u32) drb_iter,
+				 drb_iter->src_addr, drb_iter->dst_addr,
+				 drb_iter->req_cycle);
+
+			// Kick-off DMA for next DRB
+			// - Source and destination address
+			if (drq->flags & DMAD_DRQ_DIR_A1_TO_A0) {
+				dout(drb_iter->addr1, (unsigned long)drq->src_port);
+				dout(drb_iter->addr0, (unsigned long)drq->dst_port);
+			} else {
+				dout(drb_iter->addr0, (unsigned long)drq->src_port);
+				dout(drb_iter->addr1, (unsigned long)drq->dst_port);
+			}
+
+			/* - Transfer size (in units of source width) */
+			dout(drb_iter->req_cycle, (unsigned long)drq->cyc_port);
+
+			/* Kick off next request */
+			dmad_enable_channel(drq);
+
+			drb_iter->state = DMAD_DRB_STATE_EXECUTED;
+
+		} else {
+			/* No pending requests, keep the DMA channel stopped */
+		}
+
+	} else {
+
+		dmad_err("%s() ahb dma channel %d error!\n", __func__, channel);
+
+		/* Zero out src, dst, and size */
+		dout(0, (unsigned long)drq->src_port);
+		dout(0, (unsigned long)drq->dst_port);
+		dout(0, (unsigned long)drq->cyc_port);
+
+		/* Remove all pending requests in the queue */
+		drb_iter = drb;
+		while (drb_iter) {
+
+			dmad_err("abort drb ");
+
+			if (drb_iter->req_cycle == 0)
+				cpl_events = 0;
+
+			/* Mark DRB state as abort */
+			drb_iter->state = DMAD_DRB_STATE_ABORT;
+
+			if (cpl_events && drb_iter->sync)
+				complete_all(drb_iter->sync);
+
+			dmad_attach_tail(drq->drb_pool, &drq->fre_head,
+					 &drq->fre_tail, drb_iter->node);
+
+			/* Detach next submitted DRB (DMA Request Block)
+			 * from the DRQ (DMA Request Queue) */
+			dmad_detach_head(drq->drb_pool, &drq->sbt_head,
+					 &drq->sbt_tail, &drb_iter);
+		}
+	}
+
+	spin_unlock(&drq->drb_pool_lock);
+
+	/* dispatch interrupt-context level callbacks */
+	if (cpl_events && drq->completion_cb) {
+		/* signal DMA driver that new node is available */
+		drq->completion_cb(channel, tc_int, drq->completion_data);
+	}
+
+	dmad_dbg("%s() <<\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * dmad_ahb_config_dir - prepare command reg according to tx direction
+ * @ch_req       : [in] Reference to the DMA request descriptor structure
+ * @channel_cmds : [out] Reference to array of command words to be prepared with
+ * @return       : none
+ *
+ * Prepare command registers according to transfer direction ...
+ *   channel_cmd[0]  DMAC_CSR
+ *   channel_cmd[1]  DMAC_CFG
+ *
+ * This function only serves as local helper.  No protection wrappers.
+ */
+static void dmad_ahb_config_dir(dmad_chreq * ch_req, unsigned long * channel_cmds)
+{
+	dmad_drq *drq = (dmad_drq *) ch_req->drq;
+	dmad_ahb_chreq *ahb_req = (dmad_ahb_chreq *) (&ch_req->ahb_req);
+	channel_control ch_ctl;
+	dmad_dbg("%s() channel_cmds(0x%08x)\n",__func__, channel_cmds[0]);
+	channel_cmds[0] &= ~(u32)(SRCWIDTH_MASK|SRCADDRCTRL_MASK|
+		DSTWIDTH_MASK|DSTADDRCTRL_MASK|
+		SRC_HS|DST_HS|SRCREQSEL_MASK|DSTREQSEL_MASK);
+
+	if (ahb_req->tx_dir == 0) {
+		dmad_dbg("%s() addr0 --> addr1\n", __func__);
+		memcpy((u8 *)&ch_ctl.sWidth,(u8 *)&ahb_req->addr0_width,12);
+		memcpy((u8 *)&ch_ctl.dWidth,(u8 *)&ahb_req->addr1_width,12);
+		drq->flags &= ~(addr_t) DMAD_DRQ_DIR_A1_TO_A0;
+	}else{
+		dmad_dbg("%s() addr0 <-- addr1\n", __func__);
+		memcpy((u8 *)&ch_ctl.sWidth,(u8 *)&ahb_req->addr1_width,12);
+		memcpy((u8 *)&ch_ctl.dWidth,(u8 *)&ahb_req->addr0_width,12);
+		drq->flags |= (addr_t) DMAD_DRQ_DIR_A1_TO_A0;
+	}
+	channel_cmds[0] |=(((ch_ctl.sWidth << SRCWIDTH) &SRCWIDTH_MASK) |
+		((ch_ctl.sCtrl << SRCADDRCTRL) &SRCADDRCTRL_MASK) |
+		((ch_ctl.dWidth << DSTWIDTH) &DSTWIDTH_MASK) |
+		((ch_ctl.dCtrl << DSTADDRCTRL) &DSTADDRCTRL_MASK));
+	drq->data_width = ch_ctl.sWidth;
+	if (likely(ahb_req->hw_handshake != 0)) {
+		if (ch_ctl.sReqn != DMAC_REQN_NONE)
+		{
+			channel_cmds[0] |= (SRC_HS |
+				((ch_ctl.sReqn <<SRCREQSEL)&SRCREQSEL_MASK));
+		}
+		if (ch_ctl.dReqn != DMAC_REQN_NONE)
+		{
+			channel_cmds[0] |= (DST_HS |
+				((ch_ctl.dReqn <<DSTREQSEL)&DSTREQSEL_MASK));
+		}
+	}
+	dmad_dbg("%s() channel_cmds(0x%08x)\n",
+		 __func__, channel_cmds[0]);
+}
+
+/**
+ * dmad_ahb_init - initialize a ahb dma channel
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @return : 0 if success, non-zero if any error
+ *
+ * Register AHB DMA ISR and performs hw initialization for the given DMA
+ * channel.
+ */
+static int dmad_ahb_init(dmad_chreq * ch_req)
+{
+	int err = 0;
+	dmad_drq *drq = (dmad_drq *) ch_req->drq;
+	dmad_ahb_chreq *ahb_req = (dmad_ahb_chreq *) (&ch_req->ahb_req);
+	u32 channel = (u32) ch_req->channel;
+
+	unsigned long channel_base = drq->channel_base;
+	addr_t channel_cmds[1];
+	unsigned long lock_flags;
+	dmad_dbg("%s()\n", __func__);
+	/* register interrupt handler */
+	err = request_irq(ahb_irqs[channel], dmad_ahb_isr, 0,
+			  "AHB_DMA", (void *)(unsigned long)(channel + 1));
+	if (unlikely(err != 0)) {
+		dmad_err("unable to request IRQ %d for AHB DMA "
+			 "(error %d)\n", ahb_irqs[channel], err);
+		free_irq(ahb_irqs[channel], (void *)(unsigned long)(channel + 1));
+		return err;
+	}
+	spin_lock_irqsave(&dmad.drq_pool_lock, lock_flags);
+
+	/* - INT TC/ERR/ABT status clear */
+	setbl(channel+TC_OFFSET, (unsigned long)INT_STA);
+	setbl(channel+ABT_OFFSET, (unsigned long)INT_STA);
+	setbl(channel+ERR_OFFSET, (unsigned long)INT_STA);
+
+	/* - SYNC */
+	if (ahb_req->sync != (getbl(REQSYNC, CFG)>>REQSYNC))
+	{
+		printk("sync configuration error !\n");
+		return EINVAL;
+	}
+	if(ahb_req->priority > PRIORITY_HIGH)
+		ahb_req->priority = PRIORITY_HIGH;
+
+	channel_cmds[0] = (ahb_req->priority << PRIORITY_SHIFT);
+	channel_cmds[0] |= (ahb_req->burst_size << SBURST_SIZE_SHIFT) &
+	    SBURST_SIZE_MASK;
+
+	if (0 ==
+	    (ch_req->flags & (DMAD_FLAGS_RING_MODE | DMAD_FLAGS_BIDIRECTION)))
+		ahb_req->tx_dir = 0;
+
+	dmad_ahb_config_dir(ch_req, (unsigned long *)channel_cmds);
+	dout(channel_cmds[0], (unsigned long)drq->enable_port);
+
+	/* SRCADR and DESADR */
+	dout(0, (unsigned long) drq->src_port);
+	dout(0, (unsigned long) drq->dst_port);
+	/* CYC (transfer size) */
+	dout(0, (unsigned long) drq->cyc_port);
+	/* LLP */
+	dout(0, (unsigned long)channel_base + CH_LLP_LOW_OFF);
+
+	/* TOT_SIZE - not now */
+	spin_unlock_irqrestore(&dmad.drq_pool_lock, lock_flags);
+
+	return err;
+}
+
+#endif /* CONFIG_PLATFORM_AHBDMA */
+/**
+ * dmad_channel_init - initialize given dma channel
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @return : 0 if success, non-zero if any error
+ *
+ * This function serves as the abstraction layer of dmad_ahb_init()
+ * and dmad_apb_init() functions.
+ */
+static int dmad_channel_init(dmad_chreq * ch_req)
+{
+	int err = 0;
+
+	dmad_dbg("%s()\n", __func__);
+
+	if (unlikely(ch_req == NULL))
+		return -EFAULT;
+
+	if (unlikely(ch_req->drq == NULL))
+		return -EBADR;
+
+	/* Initialize DMA controller */
+	if (ch_req->controller == DMAD_DMAC_AHB_CORE)
+		err = dmad_ahb_init(ch_req);
+	return err;
+}
+
+static inline void dmad_reset_channel(dmad_drq * drq)
+{
+	/* disable dma controller */
+	dmad_disable_channel(drq);
+
+	/* Source and destination address */
+	dout(0, (unsigned long)drq->src_port);
+	dout(0, (unsigned long)drq->dst_port);
+
+	/* Transfer size (in units of source width) */
+	dout(0, (unsigned long)drq->cyc_port);
+}
+
+/**
+ * dmad_channel_reset - reset given dma channel
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @return : 0 if success, non-zero if any error
+ *
+ * This function serves as the abstraction layer of dmad_ahb_reset()
+ * and dmad_apb_reset() functions.
+ */
+static int dmad_channel_reset(dmad_chreq * ch_req)
+{
+	u32 channel = (u32) ch_req->channel;
+	unsigned long lock_flags;
+	int err = 0;
+
+	dmad_dbg("%s()\n", __func__);
+
+	if (unlikely(ch_req == NULL))
+		return -EFAULT;
+
+	if (unlikely(ch_req->drq == NULL))
+		return -EBADR;
+
+	spin_lock_irqsave(&((dmad_drq *) ch_req->drq)->drb_pool_lock,
+			  lock_flags);
+
+	/* stop DMA channel */
+	dmad_reset_channel((dmad_drq *) ch_req->drq);
+
+	spin_unlock_irqrestore(&((dmad_drq *) ch_req->drq)->drb_pool_lock,
+			       lock_flags);
+
+	/* unregister interrupt handler */
+	if (ch_req->controller == DMAD_DMAC_AHB_CORE)
+		free_irq(ahb_irqs[channel], (void *)(unsigned long)(channel + 1));
+
+	return err;
+}
+
+/**
+ * dmad_channel_alloc - allocates and initialize a dma channel
+ * @ch_req : [in/out] Reference to the DMA request descriptor structure
+ * @return : 0 if success, non-zero if any error
+ *
+ * This function allocates a DMA channel according to client's request
+ * parameters.  ISR and HW state will also be initialized accordingly.
+ */
+int dmad_channel_alloc(dmad_chreq * ch_req)
+{
+	dmad_drq *drq_iter = NULL;
+	dmad_drb *drb_iter;
+	int err = 0;
+	u32 i = 0;
+	dmad_dbg("%s()\n", __func__);
+
+	if (ch_req == NULL) {
+		printk(KERN_ERR "%s() invalid argument!\n", __func__);
+		return -EFAULT;
+	}
+
+	spin_lock(&dmad.drq_pool_lock);
+
+	/* locate an available DMA channel */
+	if (ch_req->controller == DMAD_DMAC_AHB_CORE) {
+
+		drq_iter = dmad.ahb_drq_pool;
+
+		if ((ch_req->ahb_req.src_reqn != DMAC_REQN_NONE) ||
+		    (ch_req->ahb_req.dst_reqn != DMAC_REQN_NONE)) {
+			/* [2007-12-03] It looks current board have problem to
+			 * do dma traffic for APB devices on DMAC channel 0/1.
+			 * Redirect all APB devices to start from channel 2.
+			 */
+
+			/* [todo] include USB controller ? */
+			drq_iter = &dmad.ahb_drq_pool[2];
+			for (i = 2; i < DMAD_AHB_MAX_CHANNELS; ++i, ++drq_iter) {
+				if (!(drq_iter->state & DMAD_DRQ_STATE_READY))
+					break;
+			}
+		} else {
+			/* channel for other devices is free to allocate */
+			for (i = 0; i < DMAD_AHB_MAX_CHANNELS; ++i, ++drq_iter) {
+				if (!(drq_iter->state & DMAD_DRQ_STATE_READY))
+					break;
+			}
+		}
+		if (unlikely(i == DMAD_AHB_MAX_CHANNELS)) {
+			spin_unlock(&dmad.drq_pool_lock);
+			dmad_err("out of available channels (AHB DMAC)!\n");
+			return -ENOSPC;
+		}
+
+		dmad_dbg("allocated channel: %d (AHB DMAC)\n", i);
+	}
+
+	if (drq_iter == NULL) {
+		spin_unlock(&dmad.drq_pool_lock);
+		printk(KERN_ERR "%s() invalid argument!\n", __func__);
+		return -EFAULT;
+	}
+
+	spin_unlock(&dmad.drq_pool_lock);
+	memset(drq_iter, 0, sizeof(dmad_drq));
+
+	/* Initialize DMA channel's DRB pool as list of free DRBs */
+	drq_iter->drb_pool =
+	    kmalloc(DMAD_DRB_POOL_SIZE * sizeof(dmad_drb), GFP_ATOMIC);
+
+	if (drq_iter->drb_pool == NULL) {
+		printk(KERN_ERR "%s() failed to allocate drb pool!\n",
+		       __func__);
+		return -ENOMEM;
+	}
+
+	/* Allocate the DMA channel */
+	drq_iter->state = DMAD_DRQ_STATE_READY;
+	drq_iter->flags = ch_req->flags;
+
+	/* Initialize synchronization object for DMA queue access control */
+	spin_lock_init(&drq_iter->drb_pool_lock);
+
+	/* Initialize synchronization object for free drb notification */
+	init_completion(&drq_iter->drb_alloc_sync);
+
+	/* Record the channel number in client's struct */
+	ch_req->channel = i;
+	/* Record the channel's queue handle in client's struct */
+	ch_req->drq = drq_iter;
+
+	if (ch_req->controller == DMAD_DMAC_AHB_CORE) {
+		drq_iter->channel_base = (unsigned long) DMAC_BASE_CH(i);
+		drq_iter->enable_port = (unsigned long) CH_CTL(i);
+		drq_iter->src_port = (unsigned long) CH_SRC_L(i);
+		drq_iter->dst_port = (unsigned long) CH_DST_L(i);
+		drq_iter->cyc_port = (unsigned long) CH_SIZE(i);
+	}
+	/* drb-0 is an invalid node - for node validation */
+	drb_iter = &drq_iter->drb_pool[0];
+	drb_iter->prev = 0;
+	drb_iter->next = 0;
+	drb_iter->node = 0;
+	++drb_iter;
+
+	/* init other drbs - link in order */
+	for (i = 1; i < DMAD_DRB_POOL_SIZE; ++i, ++drb_iter) {
+		drb_iter->prev = i - 1;
+		drb_iter->next = i + 1;
+		drb_iter->node = i;
+	}
+	drq_iter->drb_pool[DMAD_DRB_POOL_SIZE - 1].next = 0;
+
+	/* Initialize channel's DRB free-list, ready-list, and submitted-list */
+	drq_iter->fre_head = 1;
+	drq_iter->fre_tail = DMAD_DRB_POOL_SIZE - 1;
+	drq_iter->rdy_head = drq_iter->rdy_tail = 0;
+	drq_iter->sbt_head = drq_iter->sbt_tail = 0;
+
+	/* initialize ring buffer mode resources */
+	if (ch_req->flags & DMAD_FLAGS_RING_MODE) {
+
+		int remnant = (int)ch_req->ring_size -
+		    (int)ch_req->periods * (int)ch_req->period_size;
+		if (remnant == 0) {
+			drq_iter->periods = ch_req->periods;
+		} else if (remnant > 0) {
+			drq_iter->periods = ch_req->periods;	// + 1;
+		} else {
+			dmad_err("%s() Error - buffer_size < "
+				 "periods * period_size!\n", __func__);
+			err = -EFAULT;
+			goto _err_exit;
+		}
+
+		drq_iter->ring_size = ch_req->ring_size;
+		drq_iter->period_size = ch_req->period_size;
+		drq_iter->remnant_size = (dma_addr_t) remnant;
+
+		drq_iter->ring_base = (dma_addr_t) ch_req->ring_base;
+		drq_iter->dev_addr = (dma_addr_t) ch_req->dev_addr;
+
+		if (ch_req->controller == DMAD_DMAC_AHB_CORE) {
+			if ((ch_req->ahb_req.ring_ctrl == DMAC_CSR_AD_DEC) ||
+			    (ch_req->ahb_req.dev_ctrl == DMAC_CSR_AD_DEC)) {
+				dmad_err("%s() Error - decremental"
+					 " addressing DMA is not supported in"
+					 " ring mode currently!\n", __func__);
+				err = -EFAULT;
+				goto _err_exit;
+			}
+
+			if (ch_req->ahb_req.ring_ctrl == DMAC_CSR_AD_FIX) {
+				dmad_err("%s() Error - ring address control is "
+					 "fixed in ring DMA mode!\n", __func__);
+				err = -EFAULT;
+				goto _err_exit;
+			}
+
+			drq_iter->period_bytes =
+			    DMAC_CYCLE_TO_BYTES(ch_req->period_size,
+						ch_req->ahb_req.ring_width);
+
+			/* 0 - addr0 to addr1; 1 - addr1 to addr0 */
+			if (ch_req->ahb_req.tx_dir == 0)
+				drq_iter->ring_port =(unsigned long) drq_iter->src_port;
+			else
+				drq_iter->ring_port =(unsigned long) drq_iter->dst_port;
+
+		}
+
+		dmad_dbg("%s() ring: base(0x%08x) port(0x%08x) periods(0x%08x)"
+			 " period_size(0x%08x) period_bytes(0x%08x)"
+			 " remnant_size(0x%08x)\n",
+			 __func__, drq_iter->ring_base, drq_iter->ring_port,
+			 drq_iter->periods, drq_iter->period_size,
+			 drq_iter->period_bytes, drq_iter->remnant_size);
+	}
+
+	drq_iter->completion_cb = ch_req->completion_cb;
+	drq_iter->completion_data = ch_req->completion_data;
+
+	/* Initialize the channel && register isr */
+	err = dmad_channel_init(ch_req);
+
+_err_exit:
+
+	if (err != 0) {
+		spin_lock(&dmad.drq_pool_lock);
+
+		kfree(drq_iter->drb_pool);
+		memset(drq_iter, 0, sizeof(dmad_drq));
+
+		ch_req->channel = -1;
+		ch_req->drq = (void *)0;
+
+		spin_unlock(&dmad.drq_pool_lock);
+
+		dmad_err("Failed to initialize APB DMA! "
+			 "Channel allocation aborted!\n");
+	}
+
+	return err;
+}
+
+EXPORT_SYMBOL_GPL(dmad_channel_alloc);
+
+/**
+ * dmad_channel_free - release a dma channel
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @return : 0 if success, non-zero if any error
+ *
+ * This function releases a DMA channel.  The channel is available for future
+ * allocation after the invokation.
+ */
+int dmad_channel_free(dmad_chreq * ch_req)
+{
+	dmad_drq *drq;
+
+	dmad_dbg("%s()\n", __func__);
+
+	if (unlikely(ch_req == NULL)) {
+		dmad_err("null ch_req!\n");
+		return -EFAULT;
+	}
+
+	drq = (dmad_drq *) ch_req->drq;
+
+	if (unlikely(drq == NULL)) {
+		dmad_err("null ch_req->drq!\n");
+		return -EBADR;
+	}
+	if (unlikely((ch_req->channel < 0) ||
+		     ((drq->state & DMAD_DRQ_STATE_READY) == 0))) {
+		dmad_err("try to free a free channel!\n");
+		return -EBADR;
+	}
+
+	/* Stop/abort channel I/O
+	 * (forced to shutdown and should be protected against isr)
+	 */
+	dmad_drain_requests(ch_req, 1);
+	dmad_channel_reset(ch_req);
+
+	dmad_dbg("freed channel: %d\n", ch_req->channel);
+
+	spin_lock(&dmad.drq_pool_lock);
+
+	kfree(drq->drb_pool);
+	memset(drq, 0, sizeof(dmad_drq));
+
+	ch_req->drq = 0;
+	ch_req->channel = (u32) - 1;
+
+	spin_unlock(&dmad.drq_pool_lock);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(dmad_channel_free);
+
+/**
+ * dmad_channel_enable - enable/disable a dma channel
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @enable : [in] 1 to enable the channel, 0 to disable
+ * @return : 0 if success, non-zero if any error
+ *
+ * Enable or disable the given DMA channel.
+ */
+int dmad_channel_enable(const dmad_chreq * ch_req, u8 enable)
+{
+	dmad_drq *drq;
+	unsigned long lock_flags;
+
+	dmad_dbg("%s()\n", __func__);
+
+	if (unlikely(ch_req == NULL))
+		return -EFAULT;
+
+	drq = (dmad_drq *) ch_req->drq;
+
+	if (unlikely(drq == NULL))
+		return -EBADR;
+
+	spin_lock_irqsave(&drq->drb_pool_lock, lock_flags);
+
+	/* Enable/disable DMA channel */
+	if (enable)
+		dmad_enable_channel(drq);
+	else
+		dmad_disable_channel(drq);
+
+	spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(dmad_channel_enable);
+
+/**
+ * dmad_config_channel_dir - config dma channel transfer direction
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @dir    : [in] DMAD_DRQ_DIR_A0_TO_A1 or DMAD_DRQ_DIR_A1_TO_A0
+ * @return : 0 if success, non-zero if any error
+ *
+ * Reconfigure the channel transfer direction.  This function works only if
+ * the channel was allocated with the DMAD_FLAGS_BIDIRECTION flags.  Note
+ * that bi-direction mode and ring mode are mutual-exclusive from user's
+ * perspective.
+ */
+int dmad_config_channel_dir(dmad_chreq * ch_req, u8 dir)
+{
+	dmad_drq *drq;
+	addr_t channel_cmds[1];
+	unsigned long lock_flags;
+	u8 cur_dir;
+
+	if (unlikely(ch_req == NULL))
+		return -EFAULT;
+
+	drq = (dmad_drq *) ch_req->drq;
+
+	if (unlikely(drq == NULL))
+		return -EBADR;
+
+	if (unlikely(!(ch_req->flags & DMAD_FLAGS_BIDIRECTION))) {
+		dmad_err("%s() Channel is not configured as"
+			 " bidirectional!\n", __func__);
+		return -EFAULT;
+	}
+
+	cur_dir = drq->flags & DMAD_DRQ_DIR_MASK;
+	if (dir == cur_dir) {
+		dmad_dbg("%s() cur_dir(%d) == dir(%d) skip reprogramming hw.\n",
+			 __func__, cur_dir, dir);
+		return 0;
+	}
+
+	spin_lock_irqsave(&drq->drb_pool_lock, lock_flags);
+
+	if (unlikely((drq->sbt_head != 0) /*||dmad_is_channel_enabled(drq) */ )) {
+		spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+		dmad_err("%s() Cannot change direction while the "
+			 "channel has pending requests!\n", __func__);
+		return -EFAULT;
+	}
+
+	if (ch_req->controller == DMAD_DMAC_AHB_CORE) {
+		channel_cmds[0] = din((unsigned long)drq->enable_port);
+		ch_req->ahb_req.tx_dir = dir;
+		dmad_ahb_config_dir(ch_req, (unsigned long *)channel_cmds);
+		dout(channel_cmds[0], (unsigned long)drq->enable_port);
+	}
+
+	spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(dmad_config_channel_dir);
+
+/**
+ * dmad_max_size_per_drb - return maximum transfer size per drb
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @return : The maximum transfer size per drb, in bytes.
+ *
+ * Calculate the maximum transfer size per drb according to the setting of
+ * data width during channel initialization.
+ *
+ * Return size is aligned to 4-byte boundary; this ensures the alignment
+ * requirement of dma starting address if the function was used in a loop to
+ * separate a large size dma transfer.
+ */
+u32 dmad_max_size_per_drb(dmad_chreq * ch_req)
+{
+	addr_t size = 0;
+	addr_t data_width = (addr_t) ((dmad_drq *) ch_req->drq)->data_width;
+
+	if (ch_req->controller == DMAD_DMAC_AHB_CORE) {
+		size = DMAC_CYCLE_TO_BYTES(DMAC_TOT_SIZE_MASK & ((addr_t) ~ 3),
+					   data_width);
+	}
+
+	dmad_dbg("%s() - 0x%08x bytes\n", __func__, size);
+
+	return size;
+}
+
+EXPORT_SYMBOL_GPL(dmad_max_size_per_drb);
+
+/**
+ * dmad_bytes_to_cycles - calculate drb transfer size, in cycles
+ * @ch_req    : [in] Reference to the DMA request descriptor structure
+ * @byte_size : [in] The DMA transfer size to be converted, in bytes
+ * @return    : The drb transfer size, in cycles.
+ *
+ * Calculate the drb transfer cycle according to the setting of channel data
+ * width and burst setting.
+ *
+ * AHB DMA : unit is number of "data width".
+ * APB DMA : unit is number of "data width * burst size"
+ *
+ * APB Note: According to specification, decrement addressing seems to regard
+ *           the burst size setting.  For code efficiency,
+ *           dmad_make_req_cycles() does not take care of this case and might
+ *           produce wrong result.
+ */
+u32 dmad_bytes_to_cycles(dmad_chreq * ch_req, u32 byte_size)
+{
+	addr_t cycle = 0;
+	addr_t data_width = (addr_t) ((dmad_drq *) ch_req->drq)->data_width;
+
+	if (ch_req->controller == DMAD_DMAC_AHB_CORE) {
+		cycle = DMAC_BYTES_TO_CYCLE(byte_size, data_width);
+	}
+
+	dmad_dbg("%s() - 0x%08x bytes --> 0x%08x cycles\n",
+		 __func__, byte_size, cycle);
+	return cycle;
+}
+
+EXPORT_SYMBOL_GPL(dmad_bytes_to_cycles);
+
+/**
+ * dmad_alloc_drb_internal - allocate a dma-request-block of a dma channel
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @drb    : [out] Reference to a drb pointer to receive the allocated drb
+ * @return : 0 if success, non-zero if any error
+ *
+ * Allocates a DRB (DMA request block) of the given DMA channel.  DRB is a
+ * single dma request which will be pushed into the submission queue of the
+ * given DMA channel.  This is a lightweight internal version of
+ * dmad_alloc_drb() majorly for use in ring mode.  Critical access to the
+ * drb pool should be protected before entering this function.
+ */
+static inline int dmad_alloc_drb_internal(dmad_drq * drq, dmad_drb ** drb)
+{
+	/* Initialize drb ptr in case of fail allocation */
+	*drb = NULL;
+
+	if (unlikely(drq->fre_head == 0)) {
+		return -EAGAIN;
+	}
+
+	dmad_detach_head(drq->drb_pool, &drq->fre_head, &drq->fre_tail, drb);
+
+	dmad_attach_tail(drq->drb_pool,
+			 &drq->rdy_head, &drq->rdy_tail, (*drb)->node);
+
+	(*drb)->state = DMAD_DRB_STATE_READY;
+	(*drb)->sync = 0;
+
+	dmad_dbg("%s() drb(%d 0x%08x)\n", __func__, (*drb)->node, (u32) (*drb));
+
+	return 0;
+}
+
+/**
+ * dmad_alloc_drb - allocate a dma-request-block of a dma channel
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @drb    : [out] Reference to a drb pointer to receive the allocated drb
+ * @return : 0 if success, non-zero if any error
+ *
+ * Allocates a DRB (DMA request block) of the given DMA channel.  DRB is a
+ * single dma request which will be pushed into the submission queue of the
+ * given DMA channel.
+ */
+int dmad_alloc_drb(dmad_chreq * ch_req, dmad_drb ** drb)
+{
+	dmad_drq *drq;
+	unsigned long lock_flags;
+
+	dmad_dbg("%s()\n", __func__);
+
+	if (unlikely(ch_req == NULL)) {
+		dmad_err("null ch_req!\n");
+		return -EFAULT;
+	}
+
+	drq = (dmad_drq *) ch_req->drq;
+
+	if (likely(drq == NULL)) {
+		dmad_err("null ch_req->drq!\n");
+		return -EBADR;
+	}
+
+	spin_lock_irqsave(&drq->drb_pool_lock, lock_flags);
+
+	/* Initialize drb ptr in case of fail allocation */
+	*drb = NULL;
+
+	if (unlikely(drq->fre_head == 0)) {
+
+		drq->state &= (u32) ~ DMAD_DRQ_STATE_ABORT;
+
+		spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+
+_wait_for_free_drbs:
+
+		/* Wait for free urbs */
+		if (drq->flags & DMAD_FLAGS_SLEEP_BLOCK) {
+
+			int timeout =
+			    wait_for_completion_interruptible_timeout(&drq->
+								      drb_alloc_sync,
+								      msecs_to_jiffies
+								      (6000));
+
+			/* reset sync object */
+			reinit_completion(&drq->drb_alloc_sync);
+
+			if (timeout < 0) {
+				dmad_err("%s() wait for"
+					 " completion error! (%d)\n",
+					 __func__, timeout);
+				return timeout;
+			}
+
+		} else if (drq->flags & DMAD_FLAGS_SPIN_BLOCK) {
+
+			u32 timeout = 0x00ffffff;
+
+			while ((drq->fre_head == 0) && (--timeout != 0)) {
+			}
+			if (timeout == 0) {
+				dmad_err("%s() polling wait for "
+					 "completion timeout!\n", __func__);
+				return -EAGAIN;
+			}
+
+		} else {
+			return -EAGAIN;
+		}
+
+		spin_lock_irqsave(&drq->drb_pool_lock, lock_flags);
+
+		/* check whether all the requests of the channel has been
+		 * abandoned or not */
+		if (unlikely(drq->state & DMAD_DRQ_STATE_ABORT)) {
+			dmad_dbg("%s() drb-allocation aborted due"
+				 " to cancel-request ...\n", __func__);
+			drq->state &= (u32) ~ DMAD_DRQ_STATE_ABORT;
+			spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+			return -ECANCELED;
+		}
+
+		/* check again to avoid non-atomic operation between above
+		 * two calls */
+		if (unlikely(drq->fre_head == 0)) {
+			dmad_dbg("%s() lost free drbs ... "
+				 "continue waiting ...\n", __func__);
+			spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+			goto _wait_for_free_drbs;
+		}
+	}
+
+	dmad_detach_head(drq->drb_pool, &drq->fre_head, &drq->fre_tail, drb);
+
+	dmad_attach_tail(drq->drb_pool,
+			 &drq->rdy_head, &drq->rdy_tail, (*drb)->node);
+
+	(*drb)->state = DMAD_DRB_STATE_READY;
+	(*drb)->sync = 0;
+
+	dmad_dbg("%s() drb(%d 0x%08x)\n", __func__, (*drb)->node, (u32) (*drb));
+
+	drq->state &= (u32) ~ DMAD_DRQ_STATE_ABORT;
+
+	spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(dmad_alloc_drb);
+
+/**
+ * dmad_free_drb - free a dma-request-block of a dma channel
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @drb    : [in] Reference to a drb to be freed
+ * @return : 0 if success, non-zero if any error
+ *
+ * Frees a DRB (DMA request block) of the given DMA channel.  DRB is a
+ * single dma request which will be pushed into the submission queue of the
+ * given DMA channel.
+ */
+int dmad_free_drb(dmad_chreq * ch_req, dmad_drb * drb)
+{
+	dmad_drq *drq;
+	unsigned long lock_flags;
+
+	dmad_dbg("%s()\n", __func__);
+
+	if (unlikely(ch_req == NULL)) {
+		dmad_err("null ch_req!\n");
+		return -EFAULT;
+	}
+
+	drq = (dmad_drq *) ch_req->drq;
+
+	if (unlikely(drq == NULL)) {
+		dmad_err("null ch_req->drq!\n");
+		return -EBADR;
+	}
+
+	spin_lock_irqsave(&drq->drb_pool_lock, lock_flags);
+
+	/****************************************************
+	 * Following code requires _safe_exit return path
+	 */
+
+	if (unlikely((drq->rdy_head == 0) || (drb->node == 0) ||
+		     (drb->state != DMAD_DRB_STATE_READY) ||
+		     (drb->node >= DMAD_DRB_POOL_SIZE))) {
+		dmad_err("Ready-queue is empty or invalid node!\n");
+
+		spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+		return -EBADR;
+	}
+
+	dmad_detach_node(drq->drb_pool,
+			 &drq->rdy_head, &drq->rdy_tail, drb->node);
+	dmad_attach_tail(drq->drb_pool,
+			 &drq->fre_head, &drq->fre_tail, drb->node);
+
+	drb->state = DMAD_DRB_STATE_FREE;
+	drb->sync = 0;
+
+	spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(dmad_free_drb);
+
+/**
+ * dmad_submit_request_internal - submit a dma-request-block to the dma channel
+ * @ch_req     : [in] Reference to the DMA request descriptor structure
+ * @drb        : [in] Reference to a drb to be submitted
+ * @keep_fired : [in] non-zero to kickoff dma even the channel has stopped due
+ *                    to finishing its previous request
+ * @return     : 0 if success, non-zero if any error
+ *
+ * Submit a DRB (DMA request block) of the given DMA channel to submission
+ * queue.  DRB is a single dma request which will be pushed into the
+ * submission queue of the given DMA channel.  This is a lightweight internal
+ * version of dmad_alloc_drb() majorly for use in ring mode.  Critical access to
+ * the drb pool should be protected before entering this function.
+ */
+static inline int dmad_submit_request_internal(dmad_drq * drq, dmad_drb * drb)
+{
+	if (drb->state == DMAD_DRB_STATE_READY) {
+		/* Detach user node from ready list */
+		dmad_detach_node(drq->drb_pool,
+				 &drq->rdy_head, &drq->rdy_tail, drb->node);
+
+		dmad_attach_tail(drq->drb_pool,
+				 &drq->sbt_head, &drq->sbt_tail, drb->node);
+
+		drb->state = DMAD_DRB_STATE_SUBMITTED;
+
+		dmad_dbg("%s() submit drb(%d 0x%08x) addr0(0x%08x) "
+			 "addr1(0x%08x) size(0x%08x) state(%d)\n", __func__,
+			 drb->node, (u32) drb, drb->src_addr, drb->dst_addr,
+			 drb->req_cycle, drb->state);
+	} else {
+		dmad_dbg("%s() skip drb(%d 0x%08x) addr0(0x%08x) addr1(0x%08x)"
+			 " size(0x%08x) state(%d)\n", __func__,
+			 drb->node, (u32) drb, drb->src_addr, drb->dst_addr,
+			 drb->req_cycle, drb->state);
+	}
+
+	return 0;
+}
+
+/**
+ * dmad_submit_request - submit a dma-request-block to the dma channel
+ * @ch_req     : [in] Reference to the DMA request descriptor structure
+ * @drb        : [in] Reference to a drb to be submitted
+ * @keep_fired : [in] non-zero to kickoff dma even the channel has stopped due
+ *                    to finishing its previous request
+ * @return     : 0 if success, non-zero if any error
+ *
+ * Submit a DRB (DMA request block) of the given DMA channel to submission
+ * queue.  DRB is a single dma request which will be pushed into the
+ * submission queue of the given DMA channel.
+ */
+int dmad_submit_request(dmad_chreq * ch_req, dmad_drb * drb, u8 keep_fired)
+{
+	dmad_drq *drq;
+	unsigned long lock_flags;
+	dmad_dbg("%s()\n", __func__);
+
+	if (unlikely(ch_req == NULL)) {
+		dmad_err("null ch_req!\n");
+		return -EFAULT;
+	}
+
+	drq = (dmad_drq *) ch_req->drq;
+
+	if (unlikely(drq == NULL)) {
+		dmad_err("null ch_req->drq!\n");
+		return -EBADR;
+	}
+	spin_lock_irqsave(&drq->drb_pool_lock, lock_flags);
+
+	/******************************************************
+	 * Following code require _safe_exit return path
+	 */
+
+	if (unlikely((drq->rdy_head == 0) || (drb->node == 0) ||
+		     (drb->node >= DMAD_DRB_POOL_SIZE))) {
+					printk("node error\n");
+		spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+		return -EBADR;
+	}
+
+	/* Detach user node from ready list */
+	dmad_detach_node(drq->drb_pool, &drq->rdy_head, &drq->rdy_tail,
+			 drb->node);
+
+	/* Queue DRB to the end of the submitted list */
+	dmad_dbg("submit drb(%d 0x%08x) addr0(0x%08x) addr1(0x%08x) "
+		 "size(0x%08x) sync(0x%08x) fire(%d)\n",
+		 drb->node, (u32) drb, drb->src_addr, drb->dst_addr,
+		 drb->req_cycle, (u32) drb->sync, keep_fired);
+
+	/* Check if submission is performed to an empty queue */
+	if (unlikely(keep_fired && (drq->sbt_head == 0))) {
+		/* DMA is not running, so kick off transmission */
+		dmad_dbg("kickoff dma engine.\n");
+
+		dmad_attach_tail(drq->drb_pool,
+				 &drq->sbt_head, &drq->sbt_tail, drb->node);
+		/* Source and destination address */
+		if (drq->flags & DMAD_DRQ_DIR_A1_TO_A0) {
+			dout(drb->addr1, (unsigned long) drq->src_port);
+			dout(drb->addr0, (unsigned long) drq->dst_port);
+		} else {
+			dout(drb->addr0, (unsigned long) drq->src_port);
+			dout(drb->addr1, (unsigned long) drq->dst_port);
+		}
+
+		/* Transfer size (in units of source width) */
+		dout(drb->req_cycle, (unsigned long) drq->cyc_port);
+
+		/* Enable DMA channel (Kick off transmission when client
+		 * enable it's transfer state) */
+		dmad_enable_channel(drq);
+		drb->state = DMAD_DRB_STATE_EXECUTED;
+	} else {
+		/* DMA is already running, so only queue DRB to the end of the
+		 * list */
+		dmad_attach_tail(drq->drb_pool,
+				 &drq->sbt_head, &drq->sbt_tail, drb->node);
+		drb->state = DMAD_DRB_STATE_SUBMITTED;
+	}
+	spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(dmad_submit_request);
+
+/**
+ * dmad_withdraw_request - cancel a submitted dma-request-block
+ * @ch_req     : [in] Reference to the DMA request descriptor structure
+ * @drb        : [in] Reference to a drb to be submitted
+ * @keep_fired : [in] non-zero to kickoff dma even the channel has stopped due
+ *                    to finishing its previous request
+ * @return     : 0 if success, non-zero if any error
+ *
+ * Cancel a submitted DRB (DMA request block) of the given DMA channel in its
+ * submission queue.  DRB is a single dma request which will be pushed into the
+ * submission queue of the given DMA channel. Cancellation fails if the DRB has
+ * already been kicked off.
+ */
+int dmad_withdraw_request(dmad_chreq * ch_req, dmad_drb * drb)
+{
+	dmad_drq *drq = 0;
+	unsigned long lock_flags;
+
+	dmad_dbg("%s()\n", __func__);
+
+	if (unlikely(ch_req == NULL)) {
+		dmad_err("null ch_req!\n");
+		return -EFAULT;
+	}
+
+	drq = (dmad_drq *) ch_req->drq;
+
+	if (unlikely(drq == NULL)) {
+		dmad_err("null ch_req->drq!\n");
+		return -EBADR;
+	}
+
+	if (unlikely(drq->sbt_head == 0))
+		return -EBADR;
+
+	if (unlikely((drb->node == 0) || (drb->node >= DMAD_DRB_POOL_SIZE)))
+		return -EBADR;
+
+	spin_lock_irqsave(&drq->drb_pool_lock, lock_flags);
+
+	if (unlikely((drq->sbt_head == 0) || (drb->node == 0) ||
+		     (drb->state != DMAD_DRB_STATE_SUBMITTED) ||
+		     (drb->node >= DMAD_DRB_POOL_SIZE))) {
+		dmad_err("Submitted-queue is empty or invalid node!\n");
+
+		spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+		return -EBADR;
+	}
+
+	dmad_dbg("cancel drb(%d 0x%08x) addr0(0x%08x) addr1(0x%08x) "
+		 "size(0x%08x) state(%d)\n",
+		 drb->node, (u32) drb, drb->src_addr, drb->dst_addr,
+		 drb->req_cycle, drb->state);
+
+	if (unlikely(drb->state == DMAD_DRB_STATE_EXECUTED)) {
+		dmad_dbg("Already running drb cannot be stopped currently!\n");
+
+		spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+		return 0;/*-EBADR; */
+	}
+
+	dmad_detach_node(drq->drb_pool,
+			 &drq->rdy_head, &drq->rdy_tail, drb->node);
+	dmad_attach_tail(drq->drb_pool,
+			 &drq->fre_head, &drq->fre_tail, drb->node);
+
+	drb->state = DMAD_DRB_STATE_FREE;
+
+	if (drb->sync)
+		complete_all(drb->sync);
+	drb->sync = 0;
+
+	spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(dmad_withdraw_request);
+
+/**
+ * dmad_kickoff_requests_internal - kickoff hw DMA transmission
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @return : 0 if success, non-zero if any error
+ *
+ * Kickoff hw DMA transmission of the given DMA channel.  This function is
+ * valid for both ring & non-ring mode.  This is a lightweight internal version
+ * of dmad_kickoff_requests() majorly for use in ring mode.  Critical access to
+ * the drb pool should be protected before entering this function.
+ */
+static inline int dmad_kickoff_requests_internal(dmad_drq * drq)
+{
+	dmad_drb *drb;
+
+	dmad_get_head(drq->drb_pool, &drq->sbt_head, &drq->sbt_tail, &drb);
+
+	if (!drb) {
+		dmad_err("%s() null drb!\n", __func__);
+		return -EBADR;
+	}
+
+	dmad_dbg("%s() drb(%d 0x%08x) addr0(0x%08x) addr1(0x%08x) "
+		 "size(0x%08x) state(%d)\n", __func__,
+		 drb->node, (u32) drb, drb->src_addr, drb->dst_addr,
+		 drb->req_cycle, drb->state);
+
+	if (drb->state == DMAD_DRB_STATE_SUBMITTED) {
+		/* Transfer size (in units of source width) */
+		dout(drb->req_cycle, (unsigned long) drq->cyc_port);
+
+		/* Source and destination address */
+		if (drq->flags & DMAD_DRQ_DIR_A1_TO_A0) {
+			dout(drb->addr1, (unsigned long) drq->src_port);
+			dout(drb->addr0, (unsigned long) drq->dst_port);
+		} else {
+			dout(drb->addr0, (unsigned long) drq->src_port);
+			dout(drb->addr1, (unsigned long) drq->dst_port);
+		}
+
+		drb->state = DMAD_DRB_STATE_EXECUTED;
+	}
+
+	/* Enable DMA channel */
+	if (!dmad_is_channel_enabled(drq)) {
+		dmad_enable_channel(drq);
+	}
+
+	return 0;
+}
+
+/**
+ * dmad_kickoff_requests - kickoff hw DMA transmission of the given DMA channel
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @return : 0 if success, non-zero if any error
+ *
+ * Kickoff hw DMA transmission of the given DMA channel.  This function is
+ * valid for both ring & non-ring mode.
+ */
+int dmad_kickoff_requests(dmad_chreq * ch_req)
+{
+	dmad_drq *drq = 0;
+	dmad_drb *drb = 0;
+	unsigned long lock_flags;
+	dma_addr_t req_cycle;
+
+	dmad_dbg("%s()\n", __func__);
+
+	if (unlikely(ch_req == NULL)) {
+		dmad_err("null ch_req!\n");
+		return -EFAULT;
+	}
+
+	drq = (dmad_drq *) ch_req->drq;
+
+	if (unlikely(drq == NULL)) {
+		dmad_err("null ch_req->drq!\n");
+		return -EBADR;
+	}
+
+	spin_lock_irqsave(&drq->drb_pool_lock, lock_flags);
+
+	dmad_get_head(drq->drb_pool, &drq->sbt_head, &drq->sbt_tail, &drb);
+
+	dmad_dbg("drq(0x%08x) channel_base(0x%08x)\n",
+		 (u32) drq, drq->channel_base);
+	dmad_dbg("kick off drb(%d 0x%08x) addr0(0x%08x) addr1(0x%08x) "
+		 "size(0x%08x) state(%d) a1_to_a0(%d)\n",
+		 (u32) drb->node, (u32) drb, drb->addr0, drb->addr1,
+		 drb->req_cycle, drb->state,
+		 drq->flags & DMAD_DRQ_DIR_A1_TO_A0);
+
+	/* do nothing if no drbs are in the submission queue */
+	if (unlikely((drb == 0) || (drb->state != DMAD_DRB_STATE_SUBMITTED))) {
+		dmad_dbg("%s() invalid drb(%d 0x%08x) or drb-state(%d)!\n",
+			 __func__,
+			 drb->node, (u32) drb, drb ? drb->state : 0xffffffff);
+		spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+		return 0;
+	}
+
+	req_cycle = drb->req_cycle;
+
+	if (unlikely(req_cycle == 0)) {
+		dmad_dbg("%s() zero transfer size!\n", __func__);
+		goto _safe_exit;
+	}
+
+	/* Transfer size (in units of source width) */
+	dout(req_cycle, (unsigned long) drq->cyc_port);
+
+	/* Source and destination address */
+	if (drq->flags & DMAD_DRQ_DIR_A1_TO_A0) {
+		dout(drb->addr1, (unsigned long) drq->src_port);
+		dout(drb->addr0, (unsigned long) drq->dst_port);
+	} else {
+		dout(drb->addr0, (unsigned long) drq->src_port);
+		dout(drb->addr1, (unsigned long) drq->dst_port);
+	}
+
+	drb->state = DMAD_DRB_STATE_EXECUTED;
+
+	/* Enable DMA channel */
+	dmad_enable_channel(drq);
+
+_safe_exit:
+	spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(dmad_kickoff_requests);
+
+/**
+ * dmad_probe_hw_ptr_src - probe DMA source hw-address of the given channel
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @return : physical address of current HW source pointer
+ *
+ * Probe DMA source hw-address of the given channel.
+ */
+dma_addr_t dmad_probe_hw_ptr_src(dmad_chreq * ch_req)
+{
+	return (dma_addr_t) din(((dmad_drq *) ch_req->drq)->src_port);
+}
+
+EXPORT_SYMBOL_GPL(dmad_probe_hw_ptr_src);
+
+/**
+ * dmad_probe_hw_ptr_dst - probe DMA destination hw-address of the given channel
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @return : physical address of current HW destination pointer
+ *
+ * Probe DMA destination hw-address of the given channel.
+ */
+dma_addr_t dmad_probe_hw_ptr_dst(dmad_chreq * ch_req)
+{
+	return (dma_addr_t) din(((dmad_drq *) ch_req->drq)->dst_port);
+}
+
+EXPORT_SYMBOL_GPL(dmad_probe_hw_ptr_dst);
+
+/**
+ * dmad_update_ring - update DMA ring buffer base && size of the given channel
+ * @ch_req : [in] Reference to the DMA request descriptor structure
+ * @size   : [in] The new ring buffer size, in unit of data width (cycles)
+ * @return : 0 if success, non-zero if any error
+ *
+ * Update DMA ring buffer size of the given channel.  This function is valid
+ * only if the channel is initialized as ring buffer mode.
+ */
+int dmad_update_ring(dmad_chreq * ch_req)
+{
+	unsigned long lock_flags;
+	dmad_drq *drq = (dmad_drq *) ch_req->drq;
+	int remnant;
+
+	if (unlikely(dmad_is_channel_enabled(drq))) {
+		dmad_err("%s() Error - dma channel should be "
+			 "disabled before updating ring size!\n", __func__);
+		return -EFAULT;
+	}
+
+	spin_lock_irqsave(&drq->drb_pool_lock, lock_flags);
+
+	/* todo: range checking */
+
+	remnant = (int)ch_req->ring_size -
+	    (int)ch_req->periods * (int)ch_req->period_size;
+	if (remnant == 0) {
+		drq->periods = ch_req->periods;
+	} else if (remnant > 0) {
+		drq->periods = ch_req->periods;	// + 1;
+	} else {
+		dmad_err("%s() Error - buffer_size < "
+			 "periods * period_size!\n", __func__);
+		spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+		return -EFAULT;
+	}
+
+	drq->ring_base = ch_req->ring_base;
+	drq->ring_size = ch_req->ring_size;
+	drq->period_size = ch_req->period_size;
+	drq->remnant_size = (dma_addr_t) remnant;
+
+	if (ch_req->controller == DMAD_DMAC_AHB_CORE) {
+		drq->period_bytes =
+		    DMAC_CYCLE_TO_BYTES(drq->period_size, drq->data_width);
+	}
+
+	spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+
+	dmad_dbg("%s() ring: base(0x%08x) port(0x%08x) periods(0x%08x) "
+		 "period_size(0x%08x) period_bytes(0x%08x) "
+		 "remnant_size(0x%08x)\n",
+		 __func__, drq->ring_base, drq->ring_port,
+		 drq->periods, drq->period_size, drq->period_bytes,
+		 drq->remnant_size);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(dmad_update_ring);
+
+/**
+ * dmad_update_ring_sw_ptr - update DMA ring buffer sw-pointer
+ * @ch_req     : [in] Reference to the DMA request descriptor structure
+ * @sw_ptr     : [in] The new sw-pointer for the hw-pointer to chase of
+ * @keep_fired : [in] non-zero to kickoff dma even the channel has stopped due
+ *                    to finishing its previous request
+ * @return     : 0 if success, non-zero if any error
+ *
+ * Update DMA ring buffer sw-pointer of the given channel on the fly.  This
+ * function is valid only if the channel is initialized as ring buffer mode.
+ * Uint of sw_ptr is in number of dma data width.
+ */
+int dmad_update_ring_sw_ptr(dmad_chreq * ch_req,
+			    dma_addr_t sw_ptr, u8 keep_fired)
+{
+	dmad_drq *drq;
+	unsigned long lock_flags;
+	dma_addr_t hw_off = 0, ring_ptr;
+	dma_addr_t sw_p_off, ring_p_off, period_bytes;
+	dma_addr_t remnant_size;
+	int period_size;
+	int sw_p_idx, ring_p_idx, period, periods;
+	dmad_drb *drb = NULL;
+
+	/*if (ch_req == NULL) { */
+	/*    dmad_dbg("%s() null ch_req!\n", __func__); */
+	/*    return -EFAULT; */
+	/*} */
+
+	drq = (dmad_drq *) ch_req->drq;
+
+	/*if (drq == NULL) { */
+	/*    dmad_dbg("%s() null ch_req->drq!\n", __func__); */
+	/*    return -EBADR; */
+	/*} */
+
+	if (unlikely(sw_ptr > drq->ring_size)) {
+//		dmad_err("%s() Invalid ring buffer sw-pointer ");
+		return -EBADR;
+	}
+
+	spin_lock_irqsave(&drq->drb_pool_lock, lock_flags);
+
+	periods = drq->periods;
+	period_size = drq->period_size;
+	period_bytes = drq->period_bytes;
+	remnant_size = drq->remnant_size;
+
+	ring_ptr = drq->sw_ptr;
+	ring_p_idx = drq->sw_p_idx;
+	ring_p_off = drq->sw_p_off;
+
+	sw_p_idx = div_u64(sw_ptr, period_size);
+	__iter_div_u64_rem(sw_ptr, period_size, &sw_p_off);
+
+	if (remnant_size && (sw_p_idx == periods)) {
+		--sw_p_idx;
+		sw_p_off += period_size;
+	}
+
+	dmad_dbg("%s() ring_ptr(0x%08x) ring_p_idx(0x%08x) "
+		 "ring_p_off(0x%08x)\n",
+		 __func__, ring_ptr, ring_p_idx, ring_p_off);
+	dmad_dbg("%s() sw_ptr(0x%08x) sw_p_idx(0x%08x) sw_p_off(0x%08x)\n",
+		 __func__, sw_ptr, sw_p_idx, sw_p_off);
+
+	if (drq->ring_drb &&
+	    (drq->ring_drb->state & (DMAD_DRB_STATE_READY |
+				     DMAD_DRB_STATE_SUBMITTED |
+				     DMAD_DRB_STATE_EXECUTED))) {
+		drb = drq->ring_drb;
+	} else {
+		/* alloc new drb if there is none yet at ring_ptr */
+		if (0 != dmad_alloc_drb_internal(drq, &drb)) {
+			dmad_err("%s() drb allocation failed!\n", __func__);
+			spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+			return -ENOSPC;
+		}
+		drb->addr0 = ((dma_addr_t) ring_p_idx * period_bytes) +
+		    drq->ring_base;
+		drb->addr1 = drq->dev_addr;
+		drb->req_cycle = 0;	// redundent, though, no harm to performance
+
+		dmad_dbg("init_drb(%d 0x%08x) addr0(0x%08x) addr1(0x%08x) "
+			 "size(0x%08x) state(%d)\n",
+			 (u32) drb->node, (u32) drb, drb->src_addr,
+			 drb->dst_addr, drb->req_cycle, drb->state);
+
+		drq->ring_drb = drb;
+	}
+
+	/* Following code-path has been optimized.  The design flow is expanded
+	 * below for reference.
+	 *
+	 *   if (sw_ptr >= ring_ptr)
+	 *       if (sw_p_idx == ring_p_idx)
+	 *           ring_drb::req_cycle <- sw_p_off
+	 *           if (ring_drb::state == executed)
+	 *               hw_cycle <- sw_p_idx
+	 *           fi
+	 *       else
+	 *           ring_drb::req_cycle <- period_size
+	 *           if (ring_drb::state == executed)
+	 *               hw_cycle <- period_size
+	 *           fi
+	 *           for (i = ring_p_idx+1 ~ sw_p_idx-1)
+	 *               new_drb::ring_addr <- i * period_bytes + ring_base
+	 *               new_drb::req_cycle <- period_size
+	 *           rof
+	 *           sw_drb::ring_addr <- sw_p_idx * period_bytes + ring_base
+	 *           sw_drb::req_cycle <- sw_p_off
+	 *   else
+	 *       // sw_ptr < ring_ptr
+	 *       ring_drb::req_cycle <- period_size
+	 *       if (ring_drb::state == executed)
+	 *           hw_cycle <- period_size
+	 *       fi
+	 *       for (i = ring_p_idx+1 ~ idx_max)
+	 *           new_drb::ring_addr <- i * period_bytes + ring_base
+	 *           new_drb::req_cycle <- period_size
+	 *       rof
+	 *       for (i = 0 ~ sw_p_idx-1)
+	 *           new_drb::ring_addr <- i * period_bytes + ring_base
+	 *           new_drb::req_cycle <- period_size
+	 *       rof
+	 *       sw_drb::ring_addr <- sw_p_idx * period_bytes + ring_base
+	 *       sw_drb::req_cycle <- sw_p_off
+	 *   fi
+	 */
+	if ((sw_ptr >= ring_ptr) && (sw_p_idx == ring_p_idx) && (sw_p_off != 0)) {
+
+		dmad_dbg("update ring drb\n");
+
+		/* update drb size at ring_ptr */
+		drb->req_cycle = sw_p_off;
+
+		dmad_dbg("ring_drb(%d 0x%08x) addr0(0x%08x) addr1(0x%08x) "
+			 "size(0x%08x) state(%d)\n",
+			 (u32) drb->node, (u32) drb, drb->addr0, drb->addr1,
+			 drb->req_cycle, drb->state);
+
+		/* update hw dma size of this drb if it has been sent to the
+		 * controller */
+		if (drb->state == DMAD_DRB_STATE_EXECUTED) {
+			dmad_disable_channel(drq);
+
+			if (ch_req->controller == DMAD_DMAC_AHB_CORE)
+				hw_off = DMAC_BYTES_TO_CYCLE((addr_t)
+							     din((addr_t) drq->
+								 ring_port) -
+							     (addr_t) drb->
+							     addr0,
+							     drq->data_width);
+
+			dmad_dbg("hw_off(0x%08x) sw_p_off(0x%08x)\n",
+				 (u32) hw_off, (u32) sw_p_off);
+
+			if (sw_p_off < hw_off)
+				dmad_err("%s() underrun! sw_p_off(0x%08x) <"
+					 " hw_off(0x%08x)\n", __func__,
+					 (u32) sw_p_off, (u32) hw_off);
+			else
+				dout(sw_p_off - hw_off, (unsigned long)drq->cyc_port);
+
+			dmad_enable_channel(drq);
+
+		} else {
+			dmad_submit_request_internal(drq, drb);
+		}
+
+	} else {
+
+		dmad_dbg("fulfill ring drb - sw_ptr(0x%08x) ring_ptr(0x%08x)\n",
+			 (u32) sw_ptr, (u32) ring_ptr);
+
+		/* fulfill last drb at ring_ptr */
+		if (ring_p_idx == (periods - 1))
+			drb->req_cycle = period_size + remnant_size;
+		else
+			drb->req_cycle = period_size;
+
+		dmad_dbg("ring_drb(%d 0x%08x) addr0(0x%08x) addr1(0x%08x) "
+			 "size(0x%08x) state(%d)\n",
+			 (u32) drb->node, (u32) drb, drb->addr0, drb->addr1,
+			 drb->req_cycle, drb->state);
+
+		if (drb->state == DMAD_DRB_STATE_EXECUTED) {
+			dmad_disable_channel(drq);
+
+			if (ch_req->controller == DMAD_DMAC_AHB_CORE)
+				hw_off = DMAC_BYTES_TO_CYCLE((addr_t)
+							     din((addr_t) drq->
+								 ring_port) -
+							     (addr_t) drb->
+							     addr0,
+							     drq->data_width);
+
+			dmad_dbg("hw_off(0x%08x) period_size(0x%08x)\n",
+				 (u32) hw_off, (u32) period_size);
+
+			if (ring_p_idx == (periods - 1)) {
+				if (period_size < hw_off)
+					dmad_err("%s() illegal! "
+						 "period_size(0x%08x) + "
+						 "remnant_size(0x%08x) < "
+						 "hw_off(0x%08x)\n", __func__,
+						 (u32) period_size,
+						 (u32) remnant_size,
+						 (u32) hw_off);
+				else
+					dout(period_size + remnant_size -
+					     hw_off, (unsigned long)drq->cyc_port);
+			} else {
+				if (period_size < hw_off)
+					dmad_err("%s() illegal! "
+						 "period_size(0x%08x) < "
+						 "hw_off(0x%08x)\n", __func__,
+						 (u32) period_size,
+						 (u32) hw_off);
+				else
+					dout(period_size - hw_off,
+					     (unsigned long)drq->cyc_port);
+			}
+
+			dmad_enable_channel(drq);
+
+		} else {
+			dmad_submit_request_internal(drq, drb);
+		}
+
+		++ring_p_idx;
+
+		/* adjust sw_ptr period index ahead by one ring cycle */
+		//if (sw_ptr < ring_ptr) {
+		if (sw_p_idx < ring_p_idx) {
+			sw_p_idx += periods;
+		}
+
+		/* allocate in-between (ring_ptr+1 to sw_ptr-1)
+		 * full-cycle drbs */
+		for (period = ring_p_idx; period < sw_p_idx; ++period) {
+			if (0 != dmad_alloc_drb_internal(drq, &drb)) {
+				dmad_err("%s() drb allocation failed!\n",
+					 __func__);
+				spin_unlock_irqrestore(&drq->drb_pool_lock,
+						       lock_flags);
+				return -ENOSPC;
+			}
+
+			drb->addr0 = (dma_addr_t) (period % periods) *
+			    period_bytes + drq->ring_base;
+			drb->addr1 = drq->dev_addr;
+
+			if (period == (periods - 1)) {
+				drb->req_cycle = period_size + remnant_size;
+			} else {
+				drb->req_cycle = period_size;
+			}
+
+			dmad_dbg("inbtw_drb(%d 0x%08x) addr0(0x%08x) "
+				 "addr1(0x%08x) size(0x%08x) state(%d)\n",
+				 (u32) drb->node, (u32) drb, drb->addr0,
+				 drb->addr1, drb->req_cycle, drb->state);
+
+			dmad_submit_request_internal(drq, drb);
+		}
+
+		/* allocate drb right at sw_ptr */
+		if (0 != dmad_alloc_drb_internal(drq, &drb)) {
+			dmad_err("%s() drb allocation failed!\n", __func__);
+			spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+			return -ENOSPC;
+		}
+		drb->addr0 = (dma_addr_t) (sw_p_idx % periods) *
+		    period_bytes + drq->ring_base;
+		drb->addr1 = drq->dev_addr;
+		drb->req_cycle = sw_p_off;
+
+		dmad_dbg("swptr_drb(%d 0x%08x) addr0(0x%08x) addr1(0x%08x) "
+			 "size(0x%08x) state(%d)\n",
+			 (u32) drb->node, (u32) drb, drb->addr0, drb->addr1,
+			 drb->req_cycle, drb->state);
+
+		drq->ring_drb = drb;
+
+		if (sw_p_off > 0)
+			dmad_submit_request_internal(drq, drb);
+	}
+
+	__iter_div_u64_rem(sw_ptr, drq->ring_size, &drq->sw_ptr);
+	drq->sw_p_idx = sw_p_idx % periods;
+	drq->sw_p_off = sw_p_off;
+
+	if (likely(keep_fired)) {
+		dmad_kickoff_requests_internal(drq);
+	}
+
+	spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(dmad_update_ring_sw_ptr);
+
+/**
+ * dmad_probe_ring_hw_ptr - probe DMA ring buffer position of the given channel
+ * @ch_req     : [in] Reference to the DMA request descriptor structure
+ * @return     : Ring buffer position of current HW ring buffer pointer
+ *
+ * Probe DMA ring buffer position of the given channel.  The position is
+ * relative to the ring buffer base.  This function is valid only if the
+ * channel is initialized as ring buffer mode.
+ */
+dma_addr_t dmad_probe_ring_hw_ptr(dmad_chreq * ch_req)
+{
+	dmad_drq *drq = (dmad_drq *) ch_req->drq;
+	dma_addr_t cycles =
+	    (dma_addr_t) din(drq->ring_port) - (dma_addr_t) drq->ring_base;
+
+	if (ch_req->controller == DMAD_DMAC_AHB_CORE)
+		cycles = DMAC_BYTES_TO_CYCLE(cycles, drq->data_width);
+
+	return cycles;
+}
+
+EXPORT_SYMBOL_GPL(dmad_probe_ring_hw_ptr);
+
+/**
+ * dmad_channel_drain - cancel DMA transmission of the given DMA channel
+ * @controller : [in] One of the enum value of DMAD_DMAC_CORE
+ * @drq        : [in] Reference to the DMA queue structure (dmad_drq)
+ * @shutdown   : [in] Non-zero to force a immediate channel shutdown
+ * @return     : 0 if success, non-zero if any error
+ *
+ * Stop the DMA transmission and cancel all submitted requests of the given
+ * DMA channel.  This function drains a single channel and is the internal
+ * implementation of the interface routine dmad_drain_requests() and the
+ * module_exit function.
+ */
+static int dmad_channel_drain(u32 controller, dmad_drq * drq, u8 shutdown)
+{
+	dmad_drb *drb = 0;
+	unsigned long lock_flags;
+
+	if (unlikely(drq == NULL)) {
+		dmad_err("null ch_req->drq!\n");
+		return -EBADR;
+	}
+
+	spin_lock_irqsave(&drq->drb_pool_lock, lock_flags);
+
+	/* Stop DMA channel if forced to shutdown immediately */
+	if (shutdown) {
+		/* disable dma controller */
+		dmad_reset_channel(drq);
+
+		/* todo: more settings to stop DMA controller ?? */
+
+		/*if (drb->state == DMAD_DRB_STATE_EXECUTED) { */
+		/*} */
+	}
+
+	/* Detach DRBs in submit queue */
+	dmad_detach_head(drq->drb_pool, &drq->sbt_head, &drq->sbt_tail, &drb);
+
+	while (drb) {
+		dmad_dbg("cancel sbt drb(%d 0x%08x) addr0(0x%08x) "
+			 "addr1(0x%08x) size(0x%08x) state(%d)\n",
+			 drb->node, (u32) drb, drb->src_addr, drb->dst_addr,
+			 drb->req_cycle, (u32) drb->state);
+
+		/* Mark DRB state as abort */
+		drb->state = DMAD_DRB_STATE_ABORT;
+
+		if (drb->sync)
+			complete_all(drb->sync);
+
+		dmad_attach_tail(drq->drb_pool, &drq->fre_head, &drq->fre_tail,
+				 drb->node);
+
+		dmad_detach_head(drq->drb_pool, &drq->sbt_head, &drq->sbt_tail,
+				 &drb);
+	}
+
+	/* Detach DRBs in ready queue */
+	dmad_detach_head(drq->drb_pool, &drq->rdy_head, &drq->rdy_tail, &drb);
+
+	while (drb) {
+		dmad_dbg("cancel rdy drb(%d 0x%08x) addr0(0x%08x) "
+			 "addr1(0x%08x) size(0x%08x) state(%d)\n",
+			 drb->node, (u32) drb, drb->src_addr, drb->dst_addr,
+			 drb->req_cycle, (u32) drb->state);
+
+		/* Mark DRB state as abort */
+		drb->state = DMAD_DRB_STATE_ABORT;
+
+		dmad_attach_tail(drq->drb_pool, &drq->fre_head, &drq->fre_tail,
+				 drb->node);
+
+		/* Detach next submitted DRB (DMA Request Block) from the
+		 * DRQ (DMA Request Queue) */
+		dmad_detach_head(drq->drb_pool, &drq->rdy_head, &drq->rdy_tail,
+				 &drb);
+	}
+
+	drq->state |= DMAD_DRQ_STATE_ABORT;
+
+	drq->ring_drb = NULL;
+	drq->sw_ptr = 0;
+	drq->sw_p_idx = 0;
+	drq->sw_p_off = 0;
+
+	spin_unlock_irqrestore(&drq->drb_pool_lock, lock_flags);
+
+	if ( /*(drq->fre_head == 0) && */ (drq->flags & DMAD_FLAGS_SLEEP_BLOCK)) {
+		complete_all(&drq->drb_alloc_sync);
+	}
+
+	return 0;
+}
+
+/**
+ * dmad_cancel_requests - cancel DMA transmission of the given DMA channel
+ * @ch_req   : [in] Reference to the DMA request descriptor structure
+ * @shutdown : [in] Non-zero to force a immediate channel shutdown
+ * @return   : 0 if success, non-zero if any error
+ *
+ * Stop the DMA transmission and cancel all submitted requests of the given
+ * DMA channel.
+ */
+int dmad_drain_requests(dmad_chreq * ch_req, u8 shutdown)
+{
+	dmad_dbg("%s()\n", __func__);
+
+	if (ch_req == NULL) {
+		dmad_err("null ch_req!\n");
+		return -EFAULT;
+	}
+
+	return dmad_channel_drain(ch_req->controller, ch_req->drq, shutdown);
+}
+
+EXPORT_SYMBOL_GPL(dmad_drain_requests);
+
+/**
+ * dmad_probe_irq_source - probe DMA channel who asserts the shared sw-irq line
+ * @return : The channel number which asserts the shared sw-irq line
+ *
+ * Probe DMA channel who asserts the shared sw-irq line.
+ */
+int dmad_probe_irq_source_ahb(void)
+{
+	int channel;		/* interrupt channel number */
+
+	/* todo: spin_lock */
+
+	/* - Check DMA status register to get channel number */
+	for (channel = 0; channel < DMAD_AHB_MAX_CHANNELS; ++channel) {
+		if (getbl(channel+TC_OFFSET, (unsigned long)INT_STA))
+			return channel;
+	}
+
+	/* Perform DMA error checking if no valid channel was found who
+	 * assert the finish signal. */
+	for (channel = 0; channel < DMAD_AHB_MAX_CHANNELS; ++channel) {
+		if (getbl(channel+ERR_OFFSET, (unsigned long)INT_STA))
+			return channel;
+		if (getbl(channel+ABT_OFFSET, (unsigned long)INT_STA))
+			return channel;
+	}
+
+	/* todo: spin_unlock */
+
+	return -EFAULT;
+}
+
+EXPORT_SYMBOL_GPL(dmad_probe_irq_source_ahb);
+
+
+/**
+ * dmad_module_init - dma module-init function
+ * @return : 0 if success, non-zero if any error
+ */
+int dmad_module_init(void)
+{
+	int err = 0;
+	dmad_dbg("%s() >>\n", __func__);
+
+	/* clear device struct since the module may be load/unload many times */
+	memset(&dmad, 0, sizeof(dmad)-4);
+	dmad.drq_pool =
+	    kmalloc(DMAD_AHB_MAX_CHANNELS * sizeof(dmad_drq), GFP_KERNEL);
+	if (dmad.drq_pool == NULL) {
+		dmad_err("%s() failed to allocate drb pool!\n", __func__);
+		return -ENOMEM;
+	}
+	memset(dmad.drq_pool, 0,DMAD_AHB_MAX_CHANNELS*sizeof(dmad_drq));
+	spin_lock_init(&dmad.drq_pool_lock);
+	dmad.ahb_drq_pool = dmad.drq_pool;
+	dmad_dbg("DMA module init result: (%d)\n", err);
+	dmad_dbg("  AHB channels: %d\n;"
+		 "DRBs per channel: %d\n",
+		 DMAC_MAX_CHANNELS, DMAD_DRB_POOL_SIZE);
+
+	dmad_dbg("%s() return code (%d) <<\n", __func__, err);
+	return err;
+}
+
+/**
+ * dmad_module_init - dma module clean up function
+ */
+int __exit dmad_module_exit(struct platform_device *pdev)
+{
+	dmad_drq *drq;
+	u32 channel;
+	struct at_dma_platform_data *pdata;
+	pdata = dev_get_platdata(&pdev->dev);
+
+	dmad_dbg("%s() >>\n", __func__);
+
+	spin_lock(&dmad.drq_pool_lock);
+
+	/* cancel existing requests and unregister interrupt handler */
+	for (channel = 0; channel < DMAD_AHB_MAX_CHANNELS; ++channel) {
+
+		/* shutdown dma requests */
+		drq = (dmad_drq *) & dmad.ahb_drq_pool[channel];
+
+		if ((drq->state & DMAD_DRQ_STATE_READY) != 0)
+			dmad_channel_drain(DMAD_DMAC_AHB_CORE, drq, 1);
+
+		/* free registered irq handlers */
+		free_irq(ahb_irqs[channel], (void *)(unsigned long)(channel + 1));
+	}
+
+	spin_unlock(&dmad.drq_pool_lock);
+
+	if (dmad.drq_pool)
+		kfree(dmad.drq_pool);
+	memset(&dmad, 0, sizeof(dmad));
+
+	/* release I/O space */
+	release_region((uintptr_t)pdata->dmac_regs, resource_size(pdata->io));
+	dmad_dbg("DMA module unloaded!\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id atcdma100_of_id_table[] = {
+	{ .compatible = "andestech,atcdmac300" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, atcdma100_of_id_table);
+
+static struct at_dma_platform_data *
+at_dma_parse_dt(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct at_dma_platform_data *pdata;
+
+	if (!np) {
+		dev_err(&pdev->dev, "Missing DT data\n");
+		return NULL;
+	}
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return NULL;
+
+	if (of_property_read_u32(np, "dma-channels", &pdata->nr_channels))
+		return NULL;
+
+	return pdata;
+}
+#else
+static inline struct at_dma_platform_data *
+at_dma_parse_dt(struct platform_device *pdev)
+{
+	return NULL;
+}
+#endif
+
+static int atcdma_probe(struct platform_device *pdev)
+{
+	struct at_dma_platform_data *pdata;
+	struct resource 	*io=0;
+	struct resource *mem = NULL;
+	int			irq;
+
+	pdata = dev_get_platdata(&pdev->dev);
+	dmad.plat = pdev;
+
+	if (!pdata)
+		pdata = at_dma_parse_dt(pdev);
+	pdev->dev.platform_data = pdata;
+	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pdata->io = io;
+	mem = request_mem_region(io->start, resource_size(io), pdev->name);
+
+	if (!mem){
+		printk("failed to get io memory region resouce.\n");
+		return -EINVAL;
+	}
+
+	pdata->dmac_regs = (void __iomem *) ioremap(mem->start, resource_size(io));
+	dmac_base = (uintptr_t)pdata->dmac_regs;
+
+	irq = platform_get_irq(pdev, 0);
+
+	if (irq < 0)
+		return irq;
+
+	intc_ftdmac020_init_irq(irq);
+
+	return dmad_module_init();
+
+}
+
+static int __exit atcdma_remove(struct platform_device *pdev)
+{
+	return dmad_module_exit(pdev);
+}
+
+
+static struct platform_driver atcdma100_driver = {
+	.probe		= atcdma_probe,
+	.remove		= __exit_p(atcdma_remove),
+	.driver = {
+		.name	= "atcdmac100",
+		.of_match_table = of_match_ptr(atcdma100_of_id_table),
+	},
+};
+
+static int __init atcdma_init(void)
+{
+	return platform_driver_register(&atcdma100_driver);
+}
+subsys_initcall(atcdma_init);
+
+#endif /* CONFIG_PLATFORM_AHBDMA */
diff --git a/arch/riscv/platforms/ae350/atcsmu.c b/arch/riscv/platforms/ae350/atcsmu.c
new file mode 100644
index 00000000..9bc41b0b
--- /dev/null
+++ b/arch/riscv/platforms/ae350/atcsmu.c
@@ -0,0 +1,252 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/reboot.h>
+
+#include <asm/tlbflush.h>
+#include <asm/andesv5/smu.h>
+#include <asm/andesv5/proc.h>
+
+struct atc_smu atcsmu;
+int get_pd_type(unsigned int cpu)
+{
+	struct atc_smu *smu = &atcsmu;
+	unsigned int val = readl((void *)(smu->base +
+				CN_PCS_STATUS_OFF(cpu)));
+
+	return GET_PD_TYPE(val);
+}
+
+int get_pd_status(unsigned int cpu)
+{
+	struct atc_smu *smu = &atcsmu;
+	unsigned int val = readl((void *)(smu->base +
+				CN_PCS_STATUS_OFF(cpu)));
+
+	return GET_PD_STATUS(val);
+}
+
+void set_wakeup_enable(int cpu, unsigned int events)
+{
+	struct atc_smu *smu = &atcsmu;
+
+	if (cpu == 0)
+		events |= (1 << PCS_WAKE_DBG_OFF);
+	writel(events, (void *)(smu->base + CN_PCS_WE_OFF(cpu)));
+}
+
+void set_sleep(int cpu, unsigned char sleep)
+{
+	struct atc_smu *smu = &atcsmu;
+	unsigned int val = readl((void *)(smu->base + CN_PCS_CTL_OFF(cpu)));
+	unsigned char *ctl = (unsigned char *)&val;
+
+	// set sleep cmd
+	*ctl = 0;
+	*ctl = *ctl | SLEEP_CMD;
+	// set param
+	*ctl = *ctl | (sleep << PCS_CTL_PARAM_OFF);
+	writel(val, (void *)(smu->base + CN_PCS_CTL_OFF(cpu)));
+
+	pr_debug("PCS%d after setting up PCS_CTL register:\n"
+	       "PCS_WE: 0x%x\n"
+	       "The value wants to write into PCS_CTL:%x\n"
+	       "PCS_CTL: 0x%x\n"
+	       "PCS_STATUS: 0x%x\n",
+		cpu + 3,
+		readl((void *)(smu->base + CN_PCS_WE_OFF(cpu))),
+		val,
+		readl((void *)(smu->base + CN_PCS_CTL_OFF(cpu))),
+		readl((void *)(smu->base + CN_PCS_STATUS_OFF(cpu))));
+
+}
+
+extern int num_cpus;
+void andes_suspend2ram(void)
+{
+	unsigned int cpu, status, type;
+	int ready_cnt = num_cpus - 1;
+	int ready_cpu[NR_CPUS] = {0};
+#ifdef CONFIG_SMP
+	int id = smp_processor_id();
+#else
+	int id = 0;
+#endif
+	// Disable higher privilege's non-wakeup event
+	sbi_suspend_prepare(true, false);
+
+	// polling SMU other CPU's PD_status
+	while (ready_cnt) {
+		for (cpu = 0; cpu < num_cpus; cpu++) {
+			if (cpu == id || ready_cpu[cpu] == 1)
+				continue;
+
+			type = get_pd_type(cpu);
+			status = get_pd_status(cpu);
+
+			if(type == SLEEP && status == DeepSleep_STATUS) {
+				ready_cnt--;
+				ready_cpu[cpu] = 1;
+			}
+		}
+	}
+
+	// set SMU wakeup enable & MISC control
+	set_wakeup_enable(id, *wake_mask);
+	// set SMU light sleep command
+	set_sleep(id, DeepSleep_CTL);
+	// backup, suspend and resume
+	sbi_suspend_mem();
+	// enable privilege
+	sbi_suspend_prepare(true, true);
+}
+
+void andes_suspend2standby(void)
+{
+	unsigned int cpu, status, type;
+	int ready_cnt = num_cpus - 1;
+	int ready_cpu[NR_CPUS] = {0};
+#ifdef CONFIG_SMP
+	int id = smp_processor_id();
+#else
+	int id = 0;
+#endif
+	// Disable higher privilege's non-wakeup event
+	sbi_suspend_prepare(true, false);
+
+	// polling SMU other CPU's PD_status
+	while (ready_cnt) {
+		for (cpu = 0; cpu < num_cpus; cpu++) {
+			if (cpu == id || ready_cpu[cpu] == 1)
+				continue;
+
+			type = get_pd_type(cpu);
+			status = get_pd_status(cpu);
+
+			if(type == SLEEP && status == LightSleep_STATUS) {
+				ready_cnt--;
+				ready_cpu[cpu] = 1;
+			}
+		}
+	}
+	// set SMU wakeup enable & MISC control
+	set_wakeup_enable(id, *wake_mask);
+
+	// set SMU light sleep command
+	set_sleep(id, LightSleep_CTL);
+
+	// flush dcache & dcache off
+	cpu_dcache_disable(NULL);
+
+	// wfi
+	wait_for_interrupt();
+
+	// enable D-cache
+	cpu_dcache_enable(NULL);
+
+	// enable privilege
+	sbi_suspend_prepare(true, true);
+}
+
+static int atcsmu100_restart_call(struct notifier_block *nb,
+				  unsigned long action, void *data)
+{
+	int cpu_num = num_online_cpus();
+#ifdef CONFIG_SMP
+	int id = smp_processor_id();
+	int i;
+
+	for (i = 0; i < cpu_num; i++) {
+		int ret;
+		if (i == id)
+			continue;
+		ret = smp_call_function_single(i, cpu_dcache_disable,
+						NULL, true);
+		if (ret)
+			pr_err("Disable D-cache FAIL\n"
+				"ERROR CODE:%d\n", ret);
+	}
+#endif
+	cpu_dcache_disable(NULL);
+	cpu_l2c_disable();
+	sbi_restart(cpu_num);
+	return 0;
+}
+
+static struct notifier_block atcsmu100_restart = {
+	.notifier_call = atcsmu100_restart_call,
+	.priority = 128,
+};
+
+static int atcsmu_probe(struct platform_device *pdev)
+{
+	struct atc_smu *smu = &atcsmu;
+	int ret = -ENOENT;
+	int pcs = 0;
+
+	spin_lock_init(&smu->lock);
+
+	smu->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!smu->res)
+		goto err_exit;
+
+	ret = -EBUSY;
+
+	smu->res = request_mem_region(smu->res->start,
+					smu->res->end - smu->res->start+  1,
+					pdev->name);
+	if (!smu->res)
+		goto err_exit;
+
+	ret = -EINVAL;
+
+	smu->base = ioremap(smu->res->start,
+			    smu->res->end - smu->res->start + 1);
+	if (!smu->base)
+		goto err_ioremap;
+
+	for(pcs = 0; pcs < MAX_PCS_SLOT; pcs++)
+		writel(0xffdfffff, (void *)(smu->base + PCSN_WE_OFF(pcs)));
+
+	register_restart_handler(&atcsmu100_restart);
+
+	return 0;
+err_ioremap:
+	release_resource(smu->res);
+err_exit:
+	return ret;
+}
+
+static int __exit atcsmu_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id atcsmu_of_id_table[] = {
+	{ .compatible = "andestech,atcsmu" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, atcsmu_of_id_table);
+#endif
+
+static struct platform_driver atcsmu_driver = {
+	.probe = atcsmu_probe,
+	.remove = __exit_p(atcsmu_remove),
+	.driver = {
+		.name = "atcsmu",
+		.of_match_table = of_match_ptr(atcsmu_of_id_table),
+	},
+};
+
+static int __init atcsmu_init(void)
+{
+	int ret = platform_driver_register(&atcsmu_driver);
+
+	return ret;
+}
+subsys_initcall(atcsmu_init);
diff --git a/arch/riscv/platforms/dmad_intc.c b/arch/riscv/platforms/dmad_intc.c
new file mode 100644
index 00000000..5f831add
--- /dev/null
+++ b/arch/riscv/platforms/dmad_intc.c
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 Andes Technology Corporation
+ *
+ */
+
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/dmad.h>
+
+#ifdef CONFIG_PLATFORM_AHBDMA
+extern int dmad_probe_irq_source_ahb(void);
+void AHBDMA_irq_rounter(struct irq_desc *desc)
+{
+	int ahb_irq;
+	struct irq_desc *ahb_desc;
+
+	raw_spin_lock(&desc->lock);
+	ahb_irq = dmad_probe_irq_source_ahb();
+
+	if (ahb_irq >= 0) {
+		ahb_irq += DMA_IRQ0;
+		ahb_desc = irq_to_desc(ahb_irq);
+		ahb_desc->irq_data.irq = ahb_irq;
+		raw_spin_unlock(&desc->lock);
+		ahb_desc->handle_irq(ahb_desc);
+		raw_spin_lock(&desc->lock);
+	}
+	desc->irq_data.chip->irq_unmask(&desc->irq_data);
+	raw_spin_unlock(&desc->lock);
+}
+
+int intc_ftdmac020_init_irq(int irq)
+{
+	int i;
+	int ret;
+	/* Register all IRQ */
+	for (i = DMA_IRQ0;
+	     i < DMA_IRQ0 + DMA_IRQ_COUNT; i++) {
+		// level trigger
+		ret = irq_set_chip(i, &dummy_irq_chip);
+		irq_set_handler(i, handle_simple_irq);
+	}
+	irq_set_chained_handler(irq, AHBDMA_irq_rounter);
+	return 0;
+}
+#endif /* CONFIG_PLATFORM_AHBDMA */
diff --git a/arch/s390/Kconfig b/arch/s390/Kconfig
index 199ac3e4..6a64287e 100644
--- a/arch/s390/Kconfig
+++ b/arch/s390/Kconfig
@@ -35,9 +35,6 @@ config GENERIC_BUG
 config GENERIC_BUG_RELATIVE_POINTERS
 	def_bool y
 
-config ARCH_DMA_ADDR_T_64BIT
-	def_bool y
-
 config GENERIC_LOCKBREAK
 	def_bool y if SMP && PREEMPT
 
@@ -133,7 +130,6 @@ config S390
 	select HAVE_CMPXCHG_LOCAL
 	select HAVE_COPY_THREAD_TLS
 	select HAVE_DEBUG_KMEMLEAK
-	select HAVE_DMA_API_DEBUG
 	select HAVE_DMA_CONTIGUOUS
 	select DMA_DIRECT_OPS
 	select HAVE_DYNAMIC_FTRACE
@@ -709,7 +705,11 @@ config QDIO
 menuconfig PCI
 	bool "PCI support"
 	select PCI_MSI
+	select IOMMU_HELPER
 	select IOMMU_SUPPORT
+	select NEED_DMA_MAP_STATE
+	select NEED_SG_DMA_LENGTH
+
 	help
 	  Enable PCI support.
 
@@ -733,15 +733,6 @@ config PCI_DOMAINS
 config HAS_IOMEM
 	def_bool PCI
 
-config IOMMU_HELPER
-	def_bool PCI
-
-config NEED_SG_DMA_LENGTH
-	def_bool PCI
-
-config NEED_DMA_MAP_STATE
-	def_bool PCI
-
 config CHSC_SCH
 	def_tristate m
 	prompt "Support for CHSC subchannels"
diff --git a/arch/s390/boot/.gitignore b/arch/s390/boot/.gitignore
deleted file mode 100644
index 017d5912..00000000
--- a/arch/s390/boot/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-image
-bzImage
diff --git a/arch/s390/boot/compressed/.gitignore b/arch/s390/boot/compressed/.gitignore
deleted file mode 100644
index 2088cc14..00000000
--- a/arch/s390/boot/compressed/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-sizes.h
-vmlinux
-vmlinux.lds
-vmlinux.bin.full
diff --git a/arch/s390/kernel/.gitignore b/arch/s390/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/s390/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/s390/kernel/vdso32/.gitignore b/arch/s390/kernel/vdso32/.gitignore
deleted file mode 100644
index e45fba9d..00000000
--- a/arch/s390/kernel/vdso32/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vdso32.lds
diff --git a/arch/s390/kernel/vdso64/.gitignore b/arch/s390/kernel/vdso64/.gitignore
deleted file mode 100644
index 3fd18cf9..00000000
--- a/arch/s390/kernel/vdso64/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vdso64.lds
diff --git a/arch/s390/pci/pci_dma.c b/arch/s390/pci/pci_dma.c
index 2d15d84c..5dee7a92 100644
--- a/arch/s390/pci/pci_dma.c
+++ b/arch/s390/pci/pci_dma.c
@@ -668,15 +668,6 @@ void zpci_dma_exit(void)
 	kmem_cache_destroy(dma_region_table_cache);
 }
 
-#define PREALLOC_DMA_DEBUG_ENTRIES	(1 << 16)
-
-static int __init dma_debug_do_init(void)
-{
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
-	return 0;
-}
-fs_initcall(dma_debug_do_init);
-
 const struct dma_map_ops s390_pci_dma_ops = {
 	.alloc		= s390_dma_alloc,
 	.free		= s390_dma_free,
diff --git a/arch/s390/purgatory/.gitignore b/arch/s390/purgatory/.gitignore
deleted file mode 100644
index e9e66f17..00000000
--- a/arch/s390/purgatory/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-kexec-purgatory.c
-purgatory.ro
diff --git a/arch/s390/tools/.gitignore b/arch/s390/tools/.gitignore
deleted file mode 100644
index 71bd6f8e..00000000
--- a/arch/s390/tools/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-gen_facilities
-gen_opcode_table
diff --git a/arch/sh/Kconfig b/arch/sh/Kconfig
index 1851eaee..a97538b6 100644
--- a/arch/sh/Kconfig
+++ b/arch/sh/Kconfig
@@ -14,7 +14,6 @@ config SUPERH
 	select HAVE_OPROFILE
 	select HAVE_GENERIC_DMA_COHERENT
 	select HAVE_ARCH_TRACEHOOK
-	select HAVE_DMA_API_DEBUG
 	select HAVE_PERF_EVENTS
 	select HAVE_DEBUG_BUGVERBOSE
 	select ARCH_HAVE_CUSTOM_GPIO_H
@@ -51,6 +50,9 @@ config SUPERH
 	select HAVE_ARCH_AUDITSYSCALL
 	select HAVE_FUTEX_CMPXCHG if FUTEX
 	select HAVE_NMI
+	select NEED_DMA_MAP_STATE
+	select NEED_SG_DMA_LENGTH
+
 	help
 	  The SuperH is a RISC processor targeted for use in embedded systems
 	  and consumer electronics; it was also used in the Sega Dreamcast
@@ -161,12 +163,6 @@ config DMA_COHERENT
 config DMA_NONCOHERENT
 	def_bool !DMA_COHERENT
 
-config NEED_DMA_MAP_STATE
-	def_bool DMA_NONCOHERENT
-
-config NEED_SG_DMA_LENGTH
-	def_bool y
-
 config PGTABLE_LEVELS
 	default 3 if X2TLB
 	default 2
diff --git a/arch/sh/boot/.gitignore b/arch/sh/boot/.gitignore
deleted file mode 100644
index 541087d2..00000000
--- a/arch/sh/boot/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-zImage
-vmlinux*
-uImage*
diff --git a/arch/sh/boot/compressed/.gitignore b/arch/sh/boot/compressed/.gitignore
deleted file mode 100644
index edff113f..00000000
--- a/arch/sh/boot/compressed/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-ashiftrt.S
-ashldi3.c
-ashlsi3.S
-ashrsi3.S
-lshrsi3.S
-vmlinux.bin.*
diff --git a/arch/sh/kernel/.gitignore b/arch/sh/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/sh/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/sh/kernel/vsyscall/.gitignore b/arch/sh/kernel/vsyscall/.gitignore
deleted file mode 100644
index 40836ad9..00000000
--- a/arch/sh/kernel/vsyscall/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vsyscall.lds
diff --git a/arch/sh/mm/consistent.c b/arch/sh/mm/consistent.c
index f1b44697..fceb2adf 100644
--- a/arch/sh/mm/consistent.c
+++ b/arch/sh/mm/consistent.c
@@ -20,18 +20,9 @@
 #include <asm/cacheflush.h>
 #include <asm/addrspace.h>
 
-#define PREALLOC_DMA_DEBUG_ENTRIES	4096
-
 const struct dma_map_ops *dma_ops;
 EXPORT_SYMBOL(dma_ops);
 
-static int __init dma_init(void)
-{
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
-	return 0;
-}
-fs_initcall(dma_init);
-
 void *dma_generic_alloc_coherent(struct device *dev, size_t size,
 				 dma_addr_t *dma_handle, gfp_t gfp,
 				 unsigned long attrs)
diff --git a/arch/sparc/Kconfig b/arch/sparc/Kconfig
index 8767e45f..435dbc03 100644
--- a/arch/sparc/Kconfig
+++ b/arch/sparc/Kconfig
@@ -25,7 +25,6 @@ config SPARC
 	select RTC_CLASS
 	select RTC_DRV_M48T59
 	select RTC_SYSTOHC
-	select HAVE_DMA_API_DEBUG
 	select HAVE_ARCH_JUMP_LABEL if SPARC64
 	select GENERIC_IRQ_SHOW
 	select ARCH_WANT_IPC_PARSE_VERSION
@@ -44,6 +43,8 @@ config SPARC
 	select ARCH_HAS_SG_CHAIN
 	select CPU_NO_EFFICIENT_FFS
 	select LOCKDEP_SMALL if LOCKDEP
+	select NEED_DMA_MAP_STATE
+	select NEED_SG_DMA_LENGTH
 
 config SPARC32
 	def_bool !64BIT
@@ -67,6 +68,7 @@ config SPARC64
 	select HAVE_SYSCALL_TRACEPOINTS
 	select HAVE_CONTEXT_TRACKING
 	select HAVE_DEBUG_KMEMLEAK
+	select IOMMU_HELPER
 	select SPARSE_IRQ
 	select RTC_DRV_CMOS
 	select RTC_DRV_BQ4802
@@ -102,14 +104,6 @@ config ARCH_ATU
 	bool
 	default y if SPARC64
 
-config ARCH_DMA_ADDR_T_64BIT
-	bool
-	default y if ARCH_ATU
-
-config IOMMU_HELPER
-	bool
-	default y if SPARC64
-
 config STACKTRACE_SUPPORT
 	bool
 	default y if SPARC64
@@ -146,12 +140,6 @@ config ZONE_DMA
 	bool
 	default y if SPARC32
 
-config NEED_DMA_MAP_STATE
-	def_bool y
-
-config NEED_SG_DMA_LENGTH
-	def_bool y
-
 config GENERIC_ISA_DMA
 	bool
 	default y if SPARC32
diff --git a/arch/sparc/boot/.gitignore b/arch/sparc/boot/.gitignore
deleted file mode 100644
index fc6f3986..00000000
--- a/arch/sparc/boot/.gitignore
+++ /dev/null
@@ -1,8 +0,0 @@
-btfix.S
-btfixupprep
-image
-zImage
-tftpboot.img
-vmlinux.aout
-piggyback
-
diff --git a/arch/sparc/include/asm/iommu-common.h b/arch/sparc/include/asm/iommu-common.h
new file mode 100644
index 00000000..802c90c7
--- /dev/null
+++ b/arch/sparc/include/asm/iommu-common.h
@@ -0,0 +1,53 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _LINUX_IOMMU_COMMON_H
+#define _LINUX_IOMMU_COMMON_H
+
+#include <linux/spinlock_types.h>
+#include <linux/device.h>
+#include <asm/page.h>
+
+#define IOMMU_POOL_HASHBITS     4
+#define IOMMU_NR_POOLS          (1 << IOMMU_POOL_HASHBITS)
+#define IOMMU_ERROR_CODE	(~(unsigned long) 0)
+
+struct iommu_pool {
+	unsigned long	start;
+	unsigned long	end;
+	unsigned long	hint;
+	spinlock_t	lock;
+};
+
+struct iommu_map_table {
+	unsigned long		table_map_base;
+	unsigned long		table_shift;
+	unsigned long		nr_pools;
+	void			(*lazy_flush)(struct iommu_map_table *);
+	unsigned long		poolsize;
+	struct iommu_pool	pools[IOMMU_NR_POOLS];
+	u32			flags;
+#define	IOMMU_HAS_LARGE_POOL	0x00000001
+#define	IOMMU_NO_SPAN_BOUND	0x00000002
+#define	IOMMU_NEED_FLUSH	0x00000004
+	struct iommu_pool	large_pool;
+	unsigned long		*map;
+};
+
+extern void iommu_tbl_pool_init(struct iommu_map_table *iommu,
+				unsigned long num_entries,
+				u32 table_shift,
+				void (*lazy_flush)(struct iommu_map_table *),
+				bool large_pool, u32 npools,
+				bool skip_span_boundary_check);
+
+extern unsigned long iommu_tbl_range_alloc(struct device *dev,
+					   struct iommu_map_table *iommu,
+					   unsigned long npages,
+					   unsigned long *handle,
+					   unsigned long mask,
+					   unsigned int align_order);
+
+extern void iommu_tbl_range_free(struct iommu_map_table *iommu,
+				 u64 dma_addr, unsigned long npages,
+				 unsigned long entry);
+
+#endif
diff --git a/arch/sparc/include/asm/iommu_64.h b/arch/sparc/include/asm/iommu_64.h
index 9ed6b54c..0ef6dedf 100644
--- a/arch/sparc/include/asm/iommu_64.h
+++ b/arch/sparc/include/asm/iommu_64.h
@@ -17,7 +17,7 @@
 #define IOPTE_WRITE   0x0000000000000002UL
 
 #define IOMMU_NUM_CTXS	4096
-#include <linux/iommu-common.h>
+#include <asm/iommu-common.h>
 
 struct iommu_arena {
 	unsigned long	*map;
diff --git a/arch/sparc/kernel/.gitignore b/arch/sparc/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/sparc/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/sparc/kernel/Makefile b/arch/sparc/kernel/Makefile
index 76cb5775..cf864084 100644
--- a/arch/sparc/kernel/Makefile
+++ b/arch/sparc/kernel/Makefile
@@ -59,7 +59,7 @@ obj-$(CONFIG_SPARC32)   += leon_pmc.o
 
 obj-$(CONFIG_SPARC64)   += reboot.o
 obj-$(CONFIG_SPARC64)   += sysfs.o
-obj-$(CONFIG_SPARC64)   += iommu.o
+obj-$(CONFIG_SPARC64)   += iommu.o iommu-common.o
 obj-$(CONFIG_SPARC64)   += central.o
 obj-$(CONFIG_SPARC64)   += starfire.o
 obj-$(CONFIG_SPARC64)   += power.o
@@ -74,8 +74,6 @@ obj-$(CONFIG_SPARC64)	+= pcr.o
 obj-$(CONFIG_SPARC64)	+= nmi.o
 obj-$(CONFIG_SPARC64_SMP) += cpumap.o
 
-obj-y                     += dma.o
-
 obj-$(CONFIG_PCIC_PCI)    += pcic.o
 obj-$(CONFIG_LEON_PCI)    += leon_pci.o
 obj-$(CONFIG_SPARC_GRPCI2)+= leon_pci_grpci2.o
diff --git a/arch/sparc/kernel/dma.c b/arch/sparc/kernel/dma.c
deleted file mode 100644
index f73e7597..00000000
--- a/arch/sparc/kernel/dma.c
+++ /dev/null
@@ -1,13 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/kernel.h>
-#include <linux/dma-mapping.h>
-#include <linux/dma-debug.h>
-
-#define PREALLOC_DMA_DEBUG_ENTRIES       (1 << 15)
-
-static int __init dma_init(void)
-{
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
-	return 0;
-}
-fs_initcall(dma_init);
diff --git a/arch/sparc/kernel/iommu-common.c b/arch/sparc/kernel/iommu-common.c
new file mode 100644
index 00000000..59cb1669
--- /dev/null
+++ b/arch/sparc/kernel/iommu-common.c
@@ -0,0 +1,264 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * IOMMU mmap management and range allocation functions.
+ * Based almost entirely upon the powerpc iommu allocator.
+ */
+
+#include <linux/export.h>
+#include <linux/bitmap.h>
+#include <linux/bug.h>
+#include <linux/iommu-helper.h>
+#include <linux/dma-mapping.h>
+#include <linux/hash.h>
+#include <asm/iommu-common.h>
+
+static unsigned long iommu_large_alloc = 15;
+
+static	DEFINE_PER_CPU(unsigned int, iommu_hash_common);
+
+static inline bool need_flush(struct iommu_map_table *iommu)
+{
+	return ((iommu->flags & IOMMU_NEED_FLUSH) != 0);
+}
+
+static inline void set_flush(struct iommu_map_table *iommu)
+{
+	iommu->flags |= IOMMU_NEED_FLUSH;
+}
+
+static inline void clear_flush(struct iommu_map_table *iommu)
+{
+	iommu->flags &= ~IOMMU_NEED_FLUSH;
+}
+
+static void setup_iommu_pool_hash(void)
+{
+	unsigned int i;
+	static bool do_once;
+
+	if (do_once)
+		return;
+	do_once = true;
+	for_each_possible_cpu(i)
+		per_cpu(iommu_hash_common, i) = hash_32(i, IOMMU_POOL_HASHBITS);
+}
+
+/*
+ * Initialize iommu_pool entries for the iommu_map_table. `num_entries'
+ * is the number of table entries. If `large_pool' is set to true,
+ * the top 1/4 of the table will be set aside for pool allocations
+ * of more than iommu_large_alloc pages.
+ */
+void iommu_tbl_pool_init(struct iommu_map_table *iommu,
+			 unsigned long num_entries,
+			 u32 table_shift,
+			 void (*lazy_flush)(struct iommu_map_table *),
+			 bool large_pool, u32 npools,
+			 bool skip_span_boundary_check)
+{
+	unsigned int start, i;
+	struct iommu_pool *p = &(iommu->large_pool);
+
+	setup_iommu_pool_hash();
+	if (npools == 0)
+		iommu->nr_pools = IOMMU_NR_POOLS;
+	else
+		iommu->nr_pools = npools;
+	BUG_ON(npools > IOMMU_NR_POOLS);
+
+	iommu->table_shift = table_shift;
+	iommu->lazy_flush = lazy_flush;
+	start = 0;
+	if (skip_span_boundary_check)
+		iommu->flags |= IOMMU_NO_SPAN_BOUND;
+	if (large_pool)
+		iommu->flags |= IOMMU_HAS_LARGE_POOL;
+
+	if (!large_pool)
+		iommu->poolsize = num_entries/iommu->nr_pools;
+	else
+		iommu->poolsize = (num_entries * 3 / 4)/iommu->nr_pools;
+	for (i = 0; i < iommu->nr_pools; i++) {
+		spin_lock_init(&(iommu->pools[i].lock));
+		iommu->pools[i].start = start;
+		iommu->pools[i].hint = start;
+		start += iommu->poolsize; /* start for next pool */
+		iommu->pools[i].end = start - 1;
+	}
+	if (!large_pool)
+		return;
+	/* initialize large_pool */
+	spin_lock_init(&(p->lock));
+	p->start = start;
+	p->hint = p->start;
+	p->end = num_entries;
+}
+
+unsigned long iommu_tbl_range_alloc(struct device *dev,
+				struct iommu_map_table *iommu,
+				unsigned long npages,
+				unsigned long *handle,
+				unsigned long mask,
+				unsigned int align_order)
+{
+	unsigned int pool_hash = __this_cpu_read(iommu_hash_common);
+	unsigned long n, end, start, limit, boundary_size;
+	struct iommu_pool *pool;
+	int pass = 0;
+	unsigned int pool_nr;
+	unsigned int npools = iommu->nr_pools;
+	unsigned long flags;
+	bool large_pool = ((iommu->flags & IOMMU_HAS_LARGE_POOL) != 0);
+	bool largealloc = (large_pool && npages > iommu_large_alloc);
+	unsigned long shift;
+	unsigned long align_mask = 0;
+
+	if (align_order > 0)
+		align_mask = ~0ul >> (BITS_PER_LONG - align_order);
+
+	/* Sanity check */
+	if (unlikely(npages == 0)) {
+		WARN_ON_ONCE(1);
+		return IOMMU_ERROR_CODE;
+	}
+
+	if (largealloc) {
+		pool = &(iommu->large_pool);
+		pool_nr = 0; /* to keep compiler happy */
+	} else {
+		/* pick out pool_nr */
+		pool_nr =  pool_hash & (npools - 1);
+		pool = &(iommu->pools[pool_nr]);
+	}
+	spin_lock_irqsave(&pool->lock, flags);
+
+ again:
+	if (pass == 0 && handle && *handle &&
+	    (*handle >= pool->start) && (*handle < pool->end))
+		start = *handle;
+	else
+		start = pool->hint;
+
+	limit = pool->end;
+
+	/* The case below can happen if we have a small segment appended
+	 * to a large, or when the previous alloc was at the very end of
+	 * the available space. If so, go back to the beginning. If a
+	 * flush is needed, it will get done based on the return value
+	 * from iommu_area_alloc() below.
+	 */
+	if (start >= limit)
+		start = pool->start;
+	shift = iommu->table_map_base >> iommu->table_shift;
+	if (limit + shift > mask) {
+		limit = mask - shift + 1;
+		/* If we're constrained on address range, first try
+		 * at the masked hint to avoid O(n) search complexity,
+		 * but on second pass, start at 0 in pool 0.
+		 */
+		if ((start & mask) >= limit || pass > 0) {
+			spin_unlock(&(pool->lock));
+			pool = &(iommu->pools[0]);
+			spin_lock(&(pool->lock));
+			start = pool->start;
+		} else {
+			start &= mask;
+		}
+	}
+
+	if (dev)
+		boundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,
+				      1 << iommu->table_shift);
+	else
+		boundary_size = ALIGN(1ULL << 32, 1 << iommu->table_shift);
+
+	boundary_size = boundary_size >> iommu->table_shift;
+	/*
+	 * if the skip_span_boundary_check had been set during init, we set
+	 * things up so that iommu_is_span_boundary() merely checks if the
+	 * (index + npages) < num_tsb_entries
+	 */
+	if ((iommu->flags & IOMMU_NO_SPAN_BOUND) != 0) {
+		shift = 0;
+		boundary_size = iommu->poolsize * iommu->nr_pools;
+	}
+	n = iommu_area_alloc(iommu->map, limit, start, npages, shift,
+			     boundary_size, align_mask);
+	if (n == -1) {
+		if (likely(pass == 0)) {
+			/* First failure, rescan from the beginning.  */
+			pool->hint = pool->start;
+			set_flush(iommu);
+			pass++;
+			goto again;
+		} else if (!largealloc && pass <= iommu->nr_pools) {
+			spin_unlock(&(pool->lock));
+			pool_nr = (pool_nr + 1) & (iommu->nr_pools - 1);
+			pool = &(iommu->pools[pool_nr]);
+			spin_lock(&(pool->lock));
+			pool->hint = pool->start;
+			set_flush(iommu);
+			pass++;
+			goto again;
+		} else {
+			/* give up */
+			n = IOMMU_ERROR_CODE;
+			goto bail;
+		}
+	}
+	if (iommu->lazy_flush &&
+	    (n < pool->hint || need_flush(iommu))) {
+		clear_flush(iommu);
+		iommu->lazy_flush(iommu);
+	}
+
+	end = n + npages;
+	pool->hint = end;
+
+	/* Update handle for SG allocations */
+	if (handle)
+		*handle = end;
+bail:
+	spin_unlock_irqrestore(&(pool->lock), flags);
+
+	return n;
+}
+
+static struct iommu_pool *get_pool(struct iommu_map_table *tbl,
+				   unsigned long entry)
+{
+	struct iommu_pool *p;
+	unsigned long largepool_start = tbl->large_pool.start;
+	bool large_pool = ((tbl->flags & IOMMU_HAS_LARGE_POOL) != 0);
+
+	/* The large pool is the last pool at the top of the table */
+	if (large_pool && entry >= largepool_start) {
+		p = &tbl->large_pool;
+	} else {
+		unsigned int pool_nr = entry / tbl->poolsize;
+
+		BUG_ON(pool_nr >= tbl->nr_pools);
+		p = &tbl->pools[pool_nr];
+	}
+	return p;
+}
+
+/* Caller supplies the index of the entry into the iommu map table
+ * itself when the mapping from dma_addr to the entry is not the
+ * default addr->entry mapping below.
+ */
+void iommu_tbl_range_free(struct iommu_map_table *iommu, u64 dma_addr,
+			  unsigned long npages, unsigned long entry)
+{
+	struct iommu_pool *pool;
+	unsigned long flags;
+	unsigned long shift = iommu->table_shift;
+
+	if (entry == IOMMU_ERROR_CODE) /* use default addr->entry mapping */
+		entry = (dma_addr - iommu->table_map_base) >> shift;
+	pool = get_pool(iommu, entry);
+
+	spin_lock_irqsave(&(pool->lock), flags);
+	bitmap_clear(iommu->map, entry, npages);
+	spin_unlock_irqrestore(&(pool->lock), flags);
+}
diff --git a/arch/sparc/kernel/iommu.c b/arch/sparc/kernel/iommu.c
index b08dc341..40d008b0 100644
--- a/arch/sparc/kernel/iommu.c
+++ b/arch/sparc/kernel/iommu.c
@@ -14,7 +14,7 @@
 #include <linux/errno.h>
 #include <linux/iommu-helper.h>
 #include <linux/bitmap.h>
-#include <linux/iommu-common.h>
+#include <asm/iommu-common.h>
 
 #ifdef CONFIG_PCI
 #include <linux/pci.h>
diff --git a/arch/sparc/kernel/ldc.c b/arch/sparc/kernel/ldc.c
index 86b625f9..c0fa3ef6 100644
--- a/arch/sparc/kernel/ldc.c
+++ b/arch/sparc/kernel/ldc.c
@@ -16,7 +16,7 @@
 #include <linux/list.h>
 #include <linux/init.h>
 #include <linux/bitmap.h>
-#include <linux/iommu-common.h>
+#include <asm/iommu-common.h>
 
 #include <asm/hypervisor.h>
 #include <asm/iommu.h>
diff --git a/arch/sparc/kernel/pci_sun4v.c b/arch/sparc/kernel/pci_sun4v.c
index 24936722..565d9ac8 100644
--- a/arch/sparc/kernel/pci_sun4v.c
+++ b/arch/sparc/kernel/pci_sun4v.c
@@ -16,7 +16,7 @@
 #include <linux/export.h>
 #include <linux/log2.h>
 #include <linux/of_device.h>
-#include <linux/iommu-common.h>
+#include <asm/iommu-common.h>
 
 #include <asm/iommu.h>
 #include <asm/irq.h>
diff --git a/arch/sparc/vdso/.gitignore b/arch/sparc/vdso/.gitignore
deleted file mode 100644
index ef925b99..00000000
--- a/arch/sparc/vdso/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-vdso.lds
-vdso-image-*.c
-vdso2c
diff --git a/arch/sparc/vdso/vdso32/.gitignore b/arch/sparc/vdso/vdso32/.gitignore
deleted file mode 100644
index e45fba9d..00000000
--- a/arch/sparc/vdso/vdso32/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vdso32.lds
diff --git a/arch/um/.gitignore b/arch/um/.gitignore
deleted file mode 100644
index a73d3a1c..00000000
--- a/arch/um/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-kernel/config.c
-kernel/config.tmp
-kernel/vmlinux.lds
diff --git a/arch/unicore32/.gitignore b/arch/unicore32/.gitignore
deleted file mode 100644
index 947e99c2..00000000
--- a/arch/unicore32/.gitignore
+++ /dev/null
@@ -1,21 +0,0 @@
-#
-# Generated include files
-#
-include/generated
-#
-# Generated ld script file
-#
-kernel/vmlinux.lds
-#
-# Generated images in boot
-#
-boot/Image
-boot/zImage
-boot/uImage
-#
-# Generated files in boot/compressed
-#
-boot/compressed/piggy.S
-boot/compressed/piggy.gzip
-boot/compressed/vmlinux
-boot/compressed/vmlinux.lds
diff --git a/arch/unicore32/Kconfig b/arch/unicore32/Kconfig
index 462e59a7..03f991e4 100644
--- a/arch/unicore32/Kconfig
+++ b/arch/unicore32/Kconfig
@@ -19,6 +19,8 @@ config UNICORE32
 	select ARCH_WANT_FRAME_POINTERS
 	select GENERIC_IOMAP
 	select MODULES_USE_ELF_REL
+	select NEED_DMA_MAP_STATE
+	select SWIOTLB
 	help
 	  UniCore-32 is 32-bit Instruction Set Architecture,
 	  including a series of low-power-consumption RISC chip
@@ -61,9 +63,6 @@ config ARCH_MAY_HAVE_PC_FDC
 config ZONE_DMA
 	def_bool y
 
-config NEED_DMA_MAP_STATE
-       def_bool y
-
 source "init/Kconfig"
 
 source "kernel/Kconfig.freezer"
diff --git a/arch/unicore32/mm/Kconfig b/arch/unicore32/mm/Kconfig
index e9154a59..82759b6a 100644
--- a/arch/unicore32/mm/Kconfig
+++ b/arch/unicore32/mm/Kconfig
@@ -39,14 +39,3 @@ config CPU_TLB_SINGLE_ENTRY_DISABLE
 	default y
 	help
 	  Say Y here to disable the TLB single entry operations.
-
-config SWIOTLB
-	def_bool y
-	select DMA_DIRECT_OPS
-
-config IOMMU_HELPER
-	def_bool SWIOTLB
-
-config NEED_SG_DMA_LENGTH
-	def_bool SWIOTLB
-
diff --git a/arch/x86/.gitignore b/arch/x86/.gitignore
deleted file mode 100644
index 5a82bac5..00000000
--- a/arch/x86/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-boot/compressed/vmlinux
-tools/test_get_len
-tools/insn_sanity
-tools/insn_decoder_test
-purgatory/kexec-purgatory.c
-purgatory/purgatory.ro
-
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index c07f492b..a05d0291 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -28,6 +28,8 @@ config X86_64
 	select ARCH_USE_CMPXCHG_LOCKREF
 	select HAVE_ARCH_SOFT_DIRTY
 	select MODULES_USE_ELF_RELA
+	select NEED_DMA_MAP_STATE
+	select SWIOTLB
 	select X86_DEV_DMA_OPS
 	select ARCH_HAS_SYSCALL_WRAPPER
 
@@ -134,7 +136,6 @@ config X86
 	select HAVE_C_RECORDMCOUNT
 	select HAVE_DEBUG_KMEMLEAK
 	select HAVE_DEBUG_STACKOVERFLOW
-	select HAVE_DMA_API_DEBUG
 	select HAVE_DMA_CONTIGUOUS
 	select HAVE_DYNAMIC_FTRACE
 	select HAVE_DYNAMIC_FTRACE_WITH_REGS
@@ -236,13 +237,6 @@ config ARCH_MMAP_RND_COMPAT_BITS_MAX
 config SBUS
 	bool
 
-config NEED_DMA_MAP_STATE
-	def_bool y
-	depends on X86_64 || INTEL_IOMMU || DMA_API_DEBUG || SWIOTLB
-
-config NEED_SG_DMA_LENGTH
-	def_bool y
-
 config GENERIC_ISA_DMA
 	def_bool y
 	depends on ISA_DMA_API
@@ -875,6 +869,7 @@ config DMI
 
 config GART_IOMMU
 	bool "Old AMD GART IOMMU support"
+	select IOMMU_HELPER
 	select SWIOTLB
 	depends on X86_64 && PCI && AMD_NB
 	---help---
@@ -896,6 +891,7 @@ config GART_IOMMU
 
 config CALGARY_IOMMU
 	bool "IBM Calgary IOMMU support"
+	select IOMMU_HELPER
 	select SWIOTLB
 	depends on X86_64 && PCI
 	---help---
@@ -923,20 +919,6 @@ config CALGARY_IOMMU_ENABLED_BY_DEFAULT
 	  Calgary anyway, pass 'iommu=calgary' on the kernel command line.
 	  If unsure, say Y.
 
-# need this always selected by IOMMU for the VIA workaround
-config SWIOTLB
-	def_bool y if X86_64
-	---help---
-	  Support for software bounce buffers used on x86-64 systems
-	  which don't have a hardware IOMMU. Using this PCI devices
-	  which can only access 32-bits of memory can be used on systems
-	  with more than 3 GB of memory.
-	  If unsure, say Y.
-
-config IOMMU_HELPER
-	def_bool y
-	depends on CALGARY_IOMMU || GART_IOMMU || SWIOTLB || AMD_IOMMU
-
 config MAXSMP
 	bool "Enable Maximum number of SMP Processors and NUMA Nodes"
 	depends on X86_64 && SMP && DEBUG_KERNEL
@@ -1458,6 +1440,7 @@ config HIGHMEM
 config X86_PAE
 	bool "PAE (Physical Address Extension) Support"
 	depends on X86_32 && !HIGHMEM4G
+	select PHYS_ADDR_T_64BIT
 	select SWIOTLB
 	---help---
 	  PAE is required for NX support, and furthermore enables
@@ -1485,14 +1468,6 @@ config X86_5LEVEL
 
 	  Say N if unsure.
 
-config ARCH_PHYS_ADDR_T_64BIT
-	def_bool y
-	depends on X86_64 || X86_PAE
-
-config ARCH_DMA_ADDR_T_64BIT
-	def_bool y
-	depends on X86_64 || HIGHMEM64G
-
 config X86_DIRECT_GBPAGES
 	def_bool y
 	depends on X86_64 && !DEBUG_PAGEALLOC
diff --git a/arch/x86/boot/.gitignore b/arch/x86/boot/.gitignore
deleted file mode 100644
index 09d25dd0..00000000
--- a/arch/x86/boot/.gitignore
+++ /dev/null
@@ -1,12 +0,0 @@
-bootsect
-bzImage
-cpustr.h
-mkcpustr
-voffset.h
-zoffset.h
-setup
-setup.bin
-setup.elf
-fdimage
-mtools.conf
-image.iso
diff --git a/arch/x86/boot/compressed/.gitignore b/arch/x86/boot/compressed/.gitignore
deleted file mode 100644
index 4a46fab7..00000000
--- a/arch/x86/boot/compressed/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-relocs
-vmlinux.bin.all
-vmlinux.relocs
-vmlinux.lds
-mkpiggy
-piggy.S
diff --git a/arch/x86/boot/tools/.gitignore b/arch/x86/boot/tools/.gitignore
deleted file mode 100644
index 378eac25..00000000
--- a/arch/x86/boot/tools/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-build
diff --git a/arch/x86/entry/vdso/.gitignore b/arch/x86/entry/vdso/.gitignore
deleted file mode 100644
index aae8ffdd..00000000
--- a/arch/x86/entry/vdso/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-vdso.lds
-vdsox32.lds
-vdso32-syscall-syms.lds
-vdso32-sysenter-syms.lds
-vdso32-int80-syms.lds
-vdso-image-*.c
-vdso2c
diff --git a/arch/x86/entry/vdso/vdso32/.gitignore b/arch/x86/entry/vdso/vdso32/.gitignore
deleted file mode 100644
index e45fba9d..00000000
--- a/arch/x86/entry/vdso/vdso32/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vdso32.lds
diff --git a/arch/x86/include/asm/dma-mapping.h b/arch/x86/include/asm/dma-mapping.h
index 89ce4bfd..ef597478 100644
--- a/arch/x86/include/asm/dma-mapping.h
+++ b/arch/x86/include/asm/dma-mapping.h
@@ -33,7 +33,7 @@ static inline const struct dma_map_ops *get_arch_dma_ops(struct bus_type *bus)
 int arch_dma_supported(struct device *dev, u64 mask);
 #define arch_dma_supported arch_dma_supported
 
-bool arch_dma_alloc_attrs(struct device **dev, gfp_t *gfp);
+bool arch_dma_alloc_attrs(struct device **dev);
 #define arch_dma_alloc_attrs arch_dma_alloc_attrs
 
 #endif
diff --git a/arch/x86/kernel/.gitignore b/arch/x86/kernel/.gitignore
deleted file mode 100644
index 08f4fd73..00000000
--- a/arch/x86/kernel/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-vsyscall.lds
-vsyscall_32.lds
-vmlinux.lds
diff --git a/arch/x86/kernel/cpu/.gitignore b/arch/x86/kernel/cpu/.gitignore
deleted file mode 100644
index 667df55a..00000000
--- a/arch/x86/kernel/cpu/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-capflags.c
diff --git a/arch/x86/kernel/pci-dma.c b/arch/x86/kernel/pci-dma.c
index 77625b60..c7113fd1 100644
--- a/arch/x86/kernel/pci-dma.c
+++ b/arch/x86/kernel/pci-dma.c
@@ -55,9 +55,6 @@ struct device x86_dma_fallback_dev = {
 };
 EXPORT_SYMBOL(x86_dma_fallback_dev);
 
-/* Number of entries preallocated for DMA-API debugging */
-#define PREALLOC_DMA_DEBUG_ENTRIES       65536
-
 void __init pci_iommu_alloc(void)
 {
 	struct iommu_table_entry *p;
@@ -76,7 +73,7 @@ void __init pci_iommu_alloc(void)
 	}
 }
 
-bool arch_dma_alloc_attrs(struct device **dev, gfp_t *gfp)
+bool arch_dma_alloc_attrs(struct device **dev)
 {
 	if (!*dev)
 		*dev = &x86_dma_fallback_dev;
@@ -189,7 +186,6 @@ EXPORT_SYMBOL(arch_dma_supported);
 static int __init pci_iommu_init(void)
 {
 	struct iommu_table_entry *p;
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
 
 #ifdef CONFIG_PCI
 	dma_debug_add_bus(&pci_bus_type);
diff --git a/arch/x86/lib/.gitignore b/arch/x86/lib/.gitignore
deleted file mode 100644
index 8df89f0a..00000000
--- a/arch/x86/lib/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-inat-tables.c
diff --git a/arch/x86/realmode/rm/.gitignore b/arch/x86/realmode/rm/.gitignore
deleted file mode 100644
index b6ed3a25..00000000
--- a/arch/x86/realmode/rm/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-pasyms.h
-realmode.lds
-realmode.relocs
diff --git a/arch/x86/tools/.gitignore b/arch/x86/tools/.gitignore
deleted file mode 100644
index be0ed065..00000000
--- a/arch/x86/tools/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-relocs
diff --git a/arch/x86/um/vdso/.gitignore b/arch/x86/um/vdso/.gitignore
deleted file mode 100644
index 9cac6d07..00000000
--- a/arch/x86/um/vdso/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-vdso-syms.lds
-vdso.lds
diff --git a/arch/xtensa/Kconfig b/arch/xtensa/Kconfig
index c921e8bc..17df3322 100644
--- a/arch/xtensa/Kconfig
+++ b/arch/xtensa/Kconfig
@@ -19,7 +19,6 @@ config XTENSA
 	select HAVE_ARCH_KASAN if MMU
 	select HAVE_CC_STACKPROTECTOR
 	select HAVE_DEBUG_KMEMLEAK
-	select HAVE_DMA_API_DEBUG
 	select HAVE_DMA_CONTIGUOUS
 	select HAVE_EXIT_THREAD
 	select HAVE_FUNCTION_TRACER
diff --git a/arch/xtensa/boot/.gitignore b/arch/xtensa/boot/.gitignore
deleted file mode 100644
index 38177c7e..00000000
--- a/arch/xtensa/boot/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-uImage
-zImage.redboot
diff --git a/arch/xtensa/boot/boot-elf/.gitignore b/arch/xtensa/boot/boot-elf/.gitignore
deleted file mode 100644
index 5ff8fbb8..00000000
--- a/arch/xtensa/boot/boot-elf/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-boot.lds
diff --git a/arch/xtensa/boot/lib/.gitignore b/arch/xtensa/boot/lib/.gitignore
deleted file mode 100644
index 1629a616..00000000
--- a/arch/xtensa/boot/lib/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-inffast.c
-inflate.c
-inftrees.c
diff --git a/arch/xtensa/kernel/.gitignore b/arch/xtensa/kernel/.gitignore
deleted file mode 100644
index c5f676c3..00000000
--- a/arch/xtensa/kernel/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-vmlinux.lds
diff --git a/arch/xtensa/kernel/pci-dma.c b/arch/xtensa/kernel/pci-dma.c
index 732631ce..392b4a80 100644
--- a/arch/xtensa/kernel/pci-dma.c
+++ b/arch/xtensa/kernel/pci-dma.c
@@ -261,12 +261,3 @@ const struct dma_map_ops xtensa_dma_map_ops = {
 	.mapping_error = xtensa_dma_mapping_error,
 };
 EXPORT_SYMBOL(xtensa_dma_map_ops);
-
-#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)
-
-static int __init xtensa_dma_init(void)
-{
-	dma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);
-	return 0;
-}
-fs_initcall(xtensa_dma_init);
diff --git a/certs/.gitignore b/certs/.gitignore
deleted file mode 100644
index f51aea4a..00000000
--- a/certs/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-#
-# Generated files
-#
-x509_certificate_list
diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 4a3ac31c..3b011878 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -20,6 +20,7 @@
 #include <linux/sizes.h>
 #include <linux/limits.h>
 #include <linux/clk/clk-conf.h>
+#include <linux/platform_device.h>
 
 #include <asm/irq.h>
 
@@ -193,14 +194,16 @@ static const struct dev_pm_ops amba_pm = {
 /*
  * Primecells are part of the Advanced Microcontroller Bus Architecture,
  * so we call the bus "amba".
+ * DMA configuration for platform and AMBA bus is same. So here we reuse
+ * platform's DMA config routine.
  */
 struct bus_type amba_bustype = {
 	.name		= "amba",
 	.dev_groups	= amba_dev_groups,
 	.match		= amba_match,
 	.uevent		= amba_uevent,
+	.dma_configure	= platform_dma_configure,
 	.pm		= &amba_pm,
-	.force_dma	= true,
 };
 
 static int __init amba_init(void)
diff --git a/drivers/atm/.gitignore b/drivers/atm/.gitignore
deleted file mode 100644
index fc0ae5eb..00000000
--- a/drivers/atm/.gitignore
+++ /dev/null
@@ -1,5 +0,0 @@
-# Ignore generated files
-fore200e_mkfirm
-fore200e_pca_fw.c
-pca200e.bin
-pca200e_ecd.bin2
diff --git a/drivers/base/Makefile b/drivers/base/Makefile
index b074f242..704f4429 100644
--- a/drivers/base/Makefile
+++ b/drivers/base/Makefile
@@ -8,10 +8,7 @@ obj-y			:= component.o core.o bus.o dd.o syscore.o \
 			   topology.o container.o property.o cacheinfo.o \
 			   devcon.o
 obj-$(CONFIG_DEVTMPFS)	+= devtmpfs.o
-obj-$(CONFIG_DMA_CMA) += dma-contiguous.o
 obj-y			+= power/
-obj-$(CONFIG_HAS_DMA)	+= dma-mapping.o
-obj-$(CONFIG_HAVE_GENERIC_DMA_COHERENT) += dma-coherent.o
 obj-$(CONFIG_ISA_BUS_API)	+= isa.o
 obj-y				+= firmware_loader/
 obj-$(CONFIG_NUMA)	+= node.o
diff --git a/drivers/base/dma-coherent.c b/drivers/base/dma-coherent.c
deleted file mode 100644
index 597d4089..00000000
--- a/drivers/base/dma-coherent.c
+++ /dev/null
@@ -1,434 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Coherent per-device memory handling.
- * Borrowed from i386
- */
-#include <linux/io.h>
-#include <linux/slab.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/dma-mapping.h>
-
-struct dma_coherent_mem {
-	void		*virt_base;
-	dma_addr_t	device_base;
-	unsigned long	pfn_base;
-	int		size;
-	int		flags;
-	unsigned long	*bitmap;
-	spinlock_t	spinlock;
-	bool		use_dev_dma_pfn_offset;
-};
-
-static struct dma_coherent_mem *dma_coherent_default_memory __ro_after_init;
-
-static inline struct dma_coherent_mem *dev_get_coherent_memory(struct device *dev)
-{
-	if (dev && dev->dma_mem)
-		return dev->dma_mem;
-	return NULL;
-}
-
-static inline dma_addr_t dma_get_device_base(struct device *dev,
-					     struct dma_coherent_mem * mem)
-{
-	if (mem->use_dev_dma_pfn_offset)
-		return (mem->pfn_base - dev->dma_pfn_offset) << PAGE_SHIFT;
-	else
-		return mem->device_base;
-}
-
-static int dma_init_coherent_memory(
-	phys_addr_t phys_addr, dma_addr_t device_addr, size_t size, int flags,
-	struct dma_coherent_mem **mem)
-{
-	struct dma_coherent_mem *dma_mem = NULL;
-	void __iomem *mem_base = NULL;
-	int pages = size >> PAGE_SHIFT;
-	int bitmap_size = BITS_TO_LONGS(pages) * sizeof(long);
-	int ret;
-
-	if (!size) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	mem_base = memremap(phys_addr, size, MEMREMAP_WC);
-	if (!mem_base) {
-		ret = -EINVAL;
-		goto out;
-	}
-	dma_mem = kzalloc(sizeof(struct dma_coherent_mem), GFP_KERNEL);
-	if (!dma_mem) {
-		ret = -ENOMEM;
-		goto out;
-	}
-	dma_mem->bitmap = kzalloc(bitmap_size, GFP_KERNEL);
-	if (!dma_mem->bitmap) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	dma_mem->virt_base = mem_base;
-	dma_mem->device_base = device_addr;
-	dma_mem->pfn_base = PFN_DOWN(phys_addr);
-	dma_mem->size = pages;
-	dma_mem->flags = flags;
-	spin_lock_init(&dma_mem->spinlock);
-
-	*mem = dma_mem;
-	return 0;
-
-out:
-	kfree(dma_mem);
-	if (mem_base)
-		memunmap(mem_base);
-	return ret;
-}
-
-static void dma_release_coherent_memory(struct dma_coherent_mem *mem)
-{
-	if (!mem)
-		return;
-
-	memunmap(mem->virt_base);
-	kfree(mem->bitmap);
-	kfree(mem);
-}
-
-static int dma_assign_coherent_memory(struct device *dev,
-				      struct dma_coherent_mem *mem)
-{
-	if (!dev)
-		return -ENODEV;
-
-	if (dev->dma_mem)
-		return -EBUSY;
-
-	dev->dma_mem = mem;
-	return 0;
-}
-
-int dma_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,
-				dma_addr_t device_addr, size_t size, int flags)
-{
-	struct dma_coherent_mem *mem;
-	int ret;
-
-	ret = dma_init_coherent_memory(phys_addr, device_addr, size, flags, &mem);
-	if (ret)
-		return ret;
-
-	ret = dma_assign_coherent_memory(dev, mem);
-	if (ret)
-		dma_release_coherent_memory(mem);
-	return ret;
-}
-EXPORT_SYMBOL(dma_declare_coherent_memory);
-
-void dma_release_declared_memory(struct device *dev)
-{
-	struct dma_coherent_mem *mem = dev->dma_mem;
-
-	if (!mem)
-		return;
-	dma_release_coherent_memory(mem);
-	dev->dma_mem = NULL;
-}
-EXPORT_SYMBOL(dma_release_declared_memory);
-
-void *dma_mark_declared_memory_occupied(struct device *dev,
-					dma_addr_t device_addr, size_t size)
-{
-	struct dma_coherent_mem *mem = dev->dma_mem;
-	unsigned long flags;
-	int pos, err;
-
-	size += device_addr & ~PAGE_MASK;
-
-	if (!mem)
-		return ERR_PTR(-EINVAL);
-
-	spin_lock_irqsave(&mem->spinlock, flags);
-	pos = PFN_DOWN(device_addr - dma_get_device_base(dev, mem));
-	err = bitmap_allocate_region(mem->bitmap, pos, get_order(size));
-	spin_unlock_irqrestore(&mem->spinlock, flags);
-
-	if (err != 0)
-		return ERR_PTR(err);
-	return mem->virt_base + (pos << PAGE_SHIFT);
-}
-EXPORT_SYMBOL(dma_mark_declared_memory_occupied);
-
-static void *__dma_alloc_from_coherent(struct dma_coherent_mem *mem,
-		ssize_t size, dma_addr_t *dma_handle)
-{
-	int order = get_order(size);
-	unsigned long flags;
-	int pageno;
-	void *ret;
-
-	spin_lock_irqsave(&mem->spinlock, flags);
-
-	if (unlikely(size > (mem->size << PAGE_SHIFT)))
-		goto err;
-
-	pageno = bitmap_find_free_region(mem->bitmap, mem->size, order);
-	if (unlikely(pageno < 0))
-		goto err;
-
-	/*
-	 * Memory was found in the coherent area.
-	 */
-	*dma_handle = mem->device_base + (pageno << PAGE_SHIFT);
-	ret = mem->virt_base + (pageno << PAGE_SHIFT);
-	spin_unlock_irqrestore(&mem->spinlock, flags);
-	memset(ret, 0, size);
-	return ret;
-err:
-	spin_unlock_irqrestore(&mem->spinlock, flags);
-	return NULL;
-}
-
-/**
- * dma_alloc_from_dev_coherent() - allocate memory from device coherent pool
- * @dev:	device from which we allocate memory
- * @size:	size of requested memory area
- * @dma_handle:	This will be filled with the correct dma handle
- * @ret:	This pointer will be filled with the virtual address
- *		to allocated area.
- *
- * This function should be only called from per-arch dma_alloc_coherent()
- * to support allocation from per-device coherent memory pools.
- *
- * Returns 0 if dma_alloc_coherent should continue with allocating from
- * generic memory areas, or !0 if dma_alloc_coherent should return @ret.
- */
-int dma_alloc_from_dev_coherent(struct device *dev, ssize_t size,
-		dma_addr_t *dma_handle, void **ret)
-{
-	struct dma_coherent_mem *mem = dev_get_coherent_memory(dev);
-
-	if (!mem)
-		return 0;
-
-	*ret = __dma_alloc_from_coherent(mem, size, dma_handle);
-	if (*ret)
-		return 1;
-
-	/*
-	 * In the case where the allocation can not be satisfied from the
-	 * per-device area, try to fall back to generic memory if the
-	 * constraints allow it.
-	 */
-	return mem->flags & DMA_MEMORY_EXCLUSIVE;
-}
-EXPORT_SYMBOL(dma_alloc_from_dev_coherent);
-
-void *dma_alloc_from_global_coherent(ssize_t size, dma_addr_t *dma_handle)
-{
-	if (!dma_coherent_default_memory)
-		return NULL;
-
-	return __dma_alloc_from_coherent(dma_coherent_default_memory, size,
-			dma_handle);
-}
-
-static int __dma_release_from_coherent(struct dma_coherent_mem *mem,
-				       int order, void *vaddr)
-{
-	if (mem && vaddr >= mem->virt_base && vaddr <
-		   (mem->virt_base + (mem->size << PAGE_SHIFT))) {
-		int page = (vaddr - mem->virt_base) >> PAGE_SHIFT;
-		unsigned long flags;
-
-		spin_lock_irqsave(&mem->spinlock, flags);
-		bitmap_release_region(mem->bitmap, page, order);
-		spin_unlock_irqrestore(&mem->spinlock, flags);
-		return 1;
-	}
-	return 0;
-}
-
-/**
- * dma_release_from_dev_coherent() - free memory to device coherent memory pool
- * @dev:	device from which the memory was allocated
- * @order:	the order of pages allocated
- * @vaddr:	virtual address of allocated pages
- *
- * This checks whether the memory was allocated from the per-device
- * coherent memory pool and if so, releases that memory.
- *
- * Returns 1 if we correctly released the memory, or 0 if the caller should
- * proceed with releasing memory from generic pools.
- */
-int dma_release_from_dev_coherent(struct device *dev, int order, void *vaddr)
-{
-	struct dma_coherent_mem *mem = dev_get_coherent_memory(dev);
-
-	return __dma_release_from_coherent(mem, order, vaddr);
-}
-EXPORT_SYMBOL(dma_release_from_dev_coherent);
-
-int dma_release_from_global_coherent(int order, void *vaddr)
-{
-	if (!dma_coherent_default_memory)
-		return 0;
-
-	return __dma_release_from_coherent(dma_coherent_default_memory, order,
-			vaddr);
-}
-
-static int __dma_mmap_from_coherent(struct dma_coherent_mem *mem,
-		struct vm_area_struct *vma, void *vaddr, size_t size, int *ret)
-{
-	if (mem && vaddr >= mem->virt_base && vaddr + size <=
-		   (mem->virt_base + (mem->size << PAGE_SHIFT))) {
-		unsigned long off = vma->vm_pgoff;
-		int start = (vaddr - mem->virt_base) >> PAGE_SHIFT;
-		int user_count = vma_pages(vma);
-		int count = PAGE_ALIGN(size) >> PAGE_SHIFT;
-
-		*ret = -ENXIO;
-		if (off < count && user_count <= count - off) {
-			unsigned long pfn = mem->pfn_base + start + off;
-			*ret = remap_pfn_range(vma, vma->vm_start, pfn,
-					       user_count << PAGE_SHIFT,
-					       vma->vm_page_prot);
-		}
-		return 1;
-	}
-	return 0;
-}
-
-/**
- * dma_mmap_from_dev_coherent() - mmap memory from the device coherent pool
- * @dev:	device from which the memory was allocated
- * @vma:	vm_area for the userspace memory
- * @vaddr:	cpu address returned by dma_alloc_from_dev_coherent
- * @size:	size of the memory buffer allocated
- * @ret:	result from remap_pfn_range()
- *
- * This checks whether the memory was allocated from the per-device
- * coherent memory pool and if so, maps that memory to the provided vma.
- *
- * Returns 1 if @vaddr belongs to the device coherent pool and the caller
- * should return @ret, or 0 if they should proceed with mapping memory from
- * generic areas.
- */
-int dma_mmap_from_dev_coherent(struct device *dev, struct vm_area_struct *vma,
-			   void *vaddr, size_t size, int *ret)
-{
-	struct dma_coherent_mem *mem = dev_get_coherent_memory(dev);
-
-	return __dma_mmap_from_coherent(mem, vma, vaddr, size, ret);
-}
-EXPORT_SYMBOL(dma_mmap_from_dev_coherent);
-
-int dma_mmap_from_global_coherent(struct vm_area_struct *vma, void *vaddr,
-				   size_t size, int *ret)
-{
-	if (!dma_coherent_default_memory)
-		return 0;
-
-	return __dma_mmap_from_coherent(dma_coherent_default_memory, vma,
-					vaddr, size, ret);
-}
-
-/*
- * Support for reserved memory regions defined in device tree
- */
-#ifdef CONFIG_OF_RESERVED_MEM
-#include <linux/of.h>
-#include <linux/of_fdt.h>
-#include <linux/of_reserved_mem.h>
-
-static struct reserved_mem *dma_reserved_default_memory __initdata;
-
-static int rmem_dma_device_init(struct reserved_mem *rmem, struct device *dev)
-{
-	struct dma_coherent_mem *mem = rmem->priv;
-	int ret;
-
-	if (!mem) {
-		ret = dma_init_coherent_memory(rmem->base, rmem->base,
-					       rmem->size,
-					       DMA_MEMORY_EXCLUSIVE, &mem);
-		if (ret) {
-			pr_err("Reserved memory: failed to init DMA memory pool at %pa, size %ld MiB\n",
-				&rmem->base, (unsigned long)rmem->size / SZ_1M);
-			return ret;
-		}
-	}
-	mem->use_dev_dma_pfn_offset = true;
-	rmem->priv = mem;
-	dma_assign_coherent_memory(dev, mem);
-	return 0;
-}
-
-static void rmem_dma_device_release(struct reserved_mem *rmem,
-				    struct device *dev)
-{
-	if (dev)
-		dev->dma_mem = NULL;
-}
-
-static const struct reserved_mem_ops rmem_dma_ops = {
-	.device_init	= rmem_dma_device_init,
-	.device_release	= rmem_dma_device_release,
-};
-
-static int __init rmem_dma_setup(struct reserved_mem *rmem)
-{
-	unsigned long node = rmem->fdt_node;
-
-	if (of_get_flat_dt_prop(node, "reusable", NULL))
-		return -EINVAL;
-
-#ifdef CONFIG_ARM
-	if (!of_get_flat_dt_prop(node, "no-map", NULL)) {
-		pr_err("Reserved memory: regions without no-map are not yet supported\n");
-		return -EINVAL;
-	}
-
-	if (of_get_flat_dt_prop(node, "linux,dma-default", NULL)) {
-		WARN(dma_reserved_default_memory,
-		     "Reserved memory: region for default DMA coherent area is redefined\n");
-		dma_reserved_default_memory = rmem;
-	}
-#endif
-
-	rmem->ops = &rmem_dma_ops;
-	pr_info("Reserved memory: created DMA memory pool at %pa, size %ld MiB\n",
-		&rmem->base, (unsigned long)rmem->size / SZ_1M);
-	return 0;
-}
-
-static int __init dma_init_reserved_memory(void)
-{
-	const struct reserved_mem_ops *ops;
-	int ret;
-
-	if (!dma_reserved_default_memory)
-		return -ENOMEM;
-
-	ops = dma_reserved_default_memory->ops;
-
-	/*
-	 * We rely on rmem_dma_device_init() does not propagate error of
-	 * dma_assign_coherent_memory() for "NULL" device.
-	 */
-	ret = ops->device_init(dma_reserved_default_memory, NULL);
-
-	if (!ret) {
-		dma_coherent_default_memory = dma_reserved_default_memory->priv;
-		pr_info("DMA: default coherent area is set\n");
-	}
-
-	return ret;
-}
-
-core_initcall(dma_init_reserved_memory);
-
-RESERVEDMEM_OF_DECLARE(dma, "shared-dma-pool", rmem_dma_setup);
-#endif
diff --git a/drivers/base/dma-contiguous.c b/drivers/base/dma-contiguous.c
deleted file mode 100644
index d987dcd1..00000000
--- a/drivers/base/dma-contiguous.c
+++ /dev/null
@@ -1,278 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Contiguous Memory Allocator for DMA mapping framework
- * Copyright (c) 2010-2011 by Samsung Electronics.
- * Written by:
- *	Marek Szyprowski <m.szyprowski@samsung.com>
- *	Michal Nazarewicz <mina86@mina86.com>
- */
-
-#define pr_fmt(fmt) "cma: " fmt
-
-#ifdef CONFIG_CMA_DEBUG
-#ifndef DEBUG
-#  define DEBUG
-#endif
-#endif
-
-#include <asm/page.h>
-#include <asm/dma-contiguous.h>
-
-#include <linux/memblock.h>
-#include <linux/err.h>
-#include <linux/sizes.h>
-#include <linux/dma-contiguous.h>
-#include <linux/cma.h>
-
-#ifdef CONFIG_CMA_SIZE_MBYTES
-#define CMA_SIZE_MBYTES CONFIG_CMA_SIZE_MBYTES
-#else
-#define CMA_SIZE_MBYTES 0
-#endif
-
-struct cma *dma_contiguous_default_area;
-
-/*
- * Default global CMA area size can be defined in kernel's .config.
- * This is useful mainly for distro maintainers to create a kernel
- * that works correctly for most supported systems.
- * The size can be set in bytes or as a percentage of the total memory
- * in the system.
- *
- * Users, who want to set the size of global CMA area for their system
- * should use cma= kernel parameter.
- */
-static const phys_addr_t size_bytes = (phys_addr_t)CMA_SIZE_MBYTES * SZ_1M;
-static phys_addr_t size_cmdline = -1;
-static phys_addr_t base_cmdline;
-static phys_addr_t limit_cmdline;
-
-static int __init early_cma(char *p)
-{
-	pr_debug("%s(%s)\n", __func__, p);
-	size_cmdline = memparse(p, &p);
-	if (*p != '@')
-		return 0;
-	base_cmdline = memparse(p + 1, &p);
-	if (*p != '-') {
-		limit_cmdline = base_cmdline + size_cmdline;
-		return 0;
-	}
-	limit_cmdline = memparse(p + 1, &p);
-
-	return 0;
-}
-early_param("cma", early_cma);
-
-#ifdef CONFIG_CMA_SIZE_PERCENTAGE
-
-static phys_addr_t __init __maybe_unused cma_early_percent_memory(void)
-{
-	struct memblock_region *reg;
-	unsigned long total_pages = 0;
-
-	/*
-	 * We cannot use memblock_phys_mem_size() here, because
-	 * memblock_analyze() has not been called yet.
-	 */
-	for_each_memblock(memory, reg)
-		total_pages += memblock_region_memory_end_pfn(reg) -
-			       memblock_region_memory_base_pfn(reg);
-
-	return (total_pages * CONFIG_CMA_SIZE_PERCENTAGE / 100) << PAGE_SHIFT;
-}
-
-#else
-
-static inline __maybe_unused phys_addr_t cma_early_percent_memory(void)
-{
-	return 0;
-}
-
-#endif
-
-/**
- * dma_contiguous_reserve() - reserve area(s) for contiguous memory handling
- * @limit: End address of the reserved memory (optional, 0 for any).
- *
- * This function reserves memory from early allocator. It should be
- * called by arch specific code once the early allocator (memblock or bootmem)
- * has been activated and all other subsystems have already allocated/reserved
- * memory.
- */
-void __init dma_contiguous_reserve(phys_addr_t limit)
-{
-	phys_addr_t selected_size = 0;
-	phys_addr_t selected_base = 0;
-	phys_addr_t selected_limit = limit;
-	bool fixed = false;
-
-	pr_debug("%s(limit %08lx)\n", __func__, (unsigned long)limit);
-
-	if (size_cmdline != -1) {
-		selected_size = size_cmdline;
-		selected_base = base_cmdline;
-		selected_limit = min_not_zero(limit_cmdline, limit);
-		if (base_cmdline + size_cmdline == limit_cmdline)
-			fixed = true;
-	} else {
-#ifdef CONFIG_CMA_SIZE_SEL_MBYTES
-		selected_size = size_bytes;
-#elif defined(CONFIG_CMA_SIZE_SEL_PERCENTAGE)
-		selected_size = cma_early_percent_memory();
-#elif defined(CONFIG_CMA_SIZE_SEL_MIN)
-		selected_size = min(size_bytes, cma_early_percent_memory());
-#elif defined(CONFIG_CMA_SIZE_SEL_MAX)
-		selected_size = max(size_bytes, cma_early_percent_memory());
-#endif
-	}
-
-	if (selected_size && !dma_contiguous_default_area) {
-		pr_debug("%s: reserving %ld MiB for global area\n", __func__,
-			 (unsigned long)selected_size / SZ_1M);
-
-		dma_contiguous_reserve_area(selected_size, selected_base,
-					    selected_limit,
-					    &dma_contiguous_default_area,
-					    fixed);
-	}
-}
-
-/**
- * dma_contiguous_reserve_area() - reserve custom contiguous area
- * @size: Size of the reserved area (in bytes),
- * @base: Base address of the reserved area optional, use 0 for any
- * @limit: End address of the reserved memory (optional, 0 for any).
- * @res_cma: Pointer to store the created cma region.
- * @fixed: hint about where to place the reserved area
- *
- * This function reserves memory from early allocator. It should be
- * called by arch specific code once the early allocator (memblock or bootmem)
- * has been activated and all other subsystems have already allocated/reserved
- * memory. This function allows to create custom reserved areas for specific
- * devices.
- *
- * If @fixed is true, reserve contiguous area at exactly @base.  If false,
- * reserve in range from @base to @limit.
- */
-int __init dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t base,
-				       phys_addr_t limit, struct cma **res_cma,
-				       bool fixed)
-{
-	int ret;
-
-	ret = cma_declare_contiguous(base, size, limit, 0, 0, fixed,
-					"reserved", res_cma);
-	if (ret)
-		return ret;
-
-	/* Architecture specific contiguous memory fixup. */
-	dma_contiguous_early_fixup(cma_get_base(*res_cma),
-				cma_get_size(*res_cma));
-
-	return 0;
-}
-
-/**
- * dma_alloc_from_contiguous() - allocate pages from contiguous area
- * @dev:   Pointer to device for which the allocation is performed.
- * @count: Requested number of pages.
- * @align: Requested alignment of pages (in PAGE_SIZE order).
- * @gfp_mask: GFP flags to use for this allocation.
- *
- * This function allocates memory buffer for specified device. It uses
- * device specific contiguous memory area if available or the default
- * global one. Requires architecture specific dev_get_cma_area() helper
- * function.
- */
-struct page *dma_alloc_from_contiguous(struct device *dev, size_t count,
-				       unsigned int align, gfp_t gfp_mask)
-{
-	if (align > CONFIG_CMA_ALIGNMENT)
-		align = CONFIG_CMA_ALIGNMENT;
-
-	return cma_alloc(dev_get_cma_area(dev), count, align, gfp_mask);
-}
-
-/**
- * dma_release_from_contiguous() - release allocated pages
- * @dev:   Pointer to device for which the pages were allocated.
- * @pages: Allocated pages.
- * @count: Number of allocated pages.
- *
- * This function releases memory allocated by dma_alloc_from_contiguous().
- * It returns false when provided pages do not belong to contiguous area and
- * true otherwise.
- */
-bool dma_release_from_contiguous(struct device *dev, struct page *pages,
-				 int count)
-{
-	return cma_release(dev_get_cma_area(dev), pages, count);
-}
-
-/*
- * Support for reserved memory regions defined in device tree
- */
-#ifdef CONFIG_OF_RESERVED_MEM
-#include <linux/of.h>
-#include <linux/of_fdt.h>
-#include <linux/of_reserved_mem.h>
-
-#undef pr_fmt
-#define pr_fmt(fmt) fmt
-
-static int rmem_cma_device_init(struct reserved_mem *rmem, struct device *dev)
-{
-	dev_set_cma_area(dev, rmem->priv);
-	return 0;
-}
-
-static void rmem_cma_device_release(struct reserved_mem *rmem,
-				    struct device *dev)
-{
-	dev_set_cma_area(dev, NULL);
-}
-
-static const struct reserved_mem_ops rmem_cma_ops = {
-	.device_init	= rmem_cma_device_init,
-	.device_release = rmem_cma_device_release,
-};
-
-static int __init rmem_cma_setup(struct reserved_mem *rmem)
-{
-	phys_addr_t align = PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order);
-	phys_addr_t mask = align - 1;
-	unsigned long node = rmem->fdt_node;
-	struct cma *cma;
-	int err;
-
-	if (!of_get_flat_dt_prop(node, "reusable", NULL) ||
-	    of_get_flat_dt_prop(node, "no-map", NULL))
-		return -EINVAL;
-
-	if ((rmem->base & mask) || (rmem->size & mask)) {
-		pr_err("Reserved memory: incorrect alignment of CMA region\n");
-		return -EINVAL;
-	}
-
-	err = cma_init_reserved_mem(rmem->base, rmem->size, 0, rmem->name, &cma);
-	if (err) {
-		pr_err("Reserved memory: unable to setup CMA region\n");
-		return err;
-	}
-	/* Architecture specific contiguous memory fixup. */
-	dma_contiguous_early_fixup(rmem->base, rmem->size);
-
-	if (of_get_flat_dt_prop(node, "linux,cma-default", NULL))
-		dma_contiguous_set_default(cma);
-
-	rmem->ops = &rmem_cma_ops;
-	rmem->priv = cma;
-
-	pr_info("Reserved memory: created CMA memory pool at %pa, size %ld MiB\n",
-		&rmem->base, (unsigned long)rmem->size / SZ_1M);
-
-	return 0;
-}
-RESERVEDMEM_OF_DECLARE(cma, "shared-dma-pool", rmem_cma_setup);
-#endif
diff --git a/drivers/base/dma-mapping.c b/drivers/base/dma-mapping.c
deleted file mode 100644
index d82566d6..00000000
--- a/drivers/base/dma-mapping.c
+++ /dev/null
@@ -1,368 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * drivers/base/dma-mapping.c - arch-independent dma-mapping routines
- *
- * Copyright (c) 2006  SUSE Linux Products GmbH
- * Copyright (c) 2006  Tejun Heo <teheo@suse.de>
- */
-
-#include <linux/acpi.h>
-#include <linux/dma-mapping.h>
-#include <linux/export.h>
-#include <linux/gfp.h>
-#include <linux/of_device.h>
-#include <linux/slab.h>
-#include <linux/vmalloc.h>
-
-/*
- * Managed DMA API
- */
-struct dma_devres {
-	size_t		size;
-	void		*vaddr;
-	dma_addr_t	dma_handle;
-	unsigned long	attrs;
-};
-
-static void dmam_release(struct device *dev, void *res)
-{
-	struct dma_devres *this = res;
-
-	dma_free_attrs(dev, this->size, this->vaddr, this->dma_handle,
-			this->attrs);
-}
-
-static int dmam_match(struct device *dev, void *res, void *match_data)
-{
-	struct dma_devres *this = res, *match = match_data;
-
-	if (this->vaddr == match->vaddr) {
-		WARN_ON(this->size != match->size ||
-			this->dma_handle != match->dma_handle);
-		return 1;
-	}
-	return 0;
-}
-
-/**
- * dmam_alloc_coherent - Managed dma_alloc_coherent()
- * @dev: Device to allocate coherent memory for
- * @size: Size of allocation
- * @dma_handle: Out argument for allocated DMA handle
- * @gfp: Allocation flags
- *
- * Managed dma_alloc_coherent().  Memory allocated using this function
- * will be automatically released on driver detach.
- *
- * RETURNS:
- * Pointer to allocated memory on success, NULL on failure.
- */
-void *dmam_alloc_coherent(struct device *dev, size_t size,
-			   dma_addr_t *dma_handle, gfp_t gfp)
-{
-	struct dma_devres *dr;
-	void *vaddr;
-
-	dr = devres_alloc(dmam_release, sizeof(*dr), gfp);
-	if (!dr)
-		return NULL;
-
-	vaddr = dma_alloc_coherent(dev, size, dma_handle, gfp);
-	if (!vaddr) {
-		devres_free(dr);
-		return NULL;
-	}
-
-	dr->vaddr = vaddr;
-	dr->dma_handle = *dma_handle;
-	dr->size = size;
-
-	devres_add(dev, dr);
-
-	return vaddr;
-}
-EXPORT_SYMBOL(dmam_alloc_coherent);
-
-/**
- * dmam_free_coherent - Managed dma_free_coherent()
- * @dev: Device to free coherent memory for
- * @size: Size of allocation
- * @vaddr: Virtual address of the memory to free
- * @dma_handle: DMA handle of the memory to free
- *
- * Managed dma_free_coherent().
- */
-void dmam_free_coherent(struct device *dev, size_t size, void *vaddr,
-			dma_addr_t dma_handle)
-{
-	struct dma_devres match_data = { size, vaddr, dma_handle };
-
-	dma_free_coherent(dev, size, vaddr, dma_handle);
-	WARN_ON(devres_destroy(dev, dmam_release, dmam_match, &match_data));
-}
-EXPORT_SYMBOL(dmam_free_coherent);
-
-/**
- * dmam_alloc_attrs - Managed dma_alloc_attrs()
- * @dev: Device to allocate non_coherent memory for
- * @size: Size of allocation
- * @dma_handle: Out argument for allocated DMA handle
- * @gfp: Allocation flags
- * @attrs: Flags in the DMA_ATTR_* namespace.
- *
- * Managed dma_alloc_attrs().  Memory allocated using this function will be
- * automatically released on driver detach.
- *
- * RETURNS:
- * Pointer to allocated memory on success, NULL on failure.
- */
-void *dmam_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,
-		gfp_t gfp, unsigned long attrs)
-{
-	struct dma_devres *dr;
-	void *vaddr;
-
-	dr = devres_alloc(dmam_release, sizeof(*dr), gfp);
-	if (!dr)
-		return NULL;
-
-	vaddr = dma_alloc_attrs(dev, size, dma_handle, gfp, attrs);
-	if (!vaddr) {
-		devres_free(dr);
-		return NULL;
-	}
-
-	dr->vaddr = vaddr;
-	dr->dma_handle = *dma_handle;
-	dr->size = size;
-	dr->attrs = attrs;
-
-	devres_add(dev, dr);
-
-	return vaddr;
-}
-EXPORT_SYMBOL(dmam_alloc_attrs);
-
-#ifdef CONFIG_HAVE_GENERIC_DMA_COHERENT
-
-static void dmam_coherent_decl_release(struct device *dev, void *res)
-{
-	dma_release_declared_memory(dev);
-}
-
-/**
- * dmam_declare_coherent_memory - Managed dma_declare_coherent_memory()
- * @dev: Device to declare coherent memory for
- * @phys_addr: Physical address of coherent memory to be declared
- * @device_addr: Device address of coherent memory to be declared
- * @size: Size of coherent memory to be declared
- * @flags: Flags
- *
- * Managed dma_declare_coherent_memory().
- *
- * RETURNS:
- * 0 on success, -errno on failure.
- */
-int dmam_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,
-				 dma_addr_t device_addr, size_t size, int flags)
-{
-	void *res;
-	int rc;
-
-	res = devres_alloc(dmam_coherent_decl_release, 0, GFP_KERNEL);
-	if (!res)
-		return -ENOMEM;
-
-	rc = dma_declare_coherent_memory(dev, phys_addr, device_addr, size,
-					 flags);
-	if (!rc)
-		devres_add(dev, res);
-	else
-		devres_free(res);
-
-	return rc;
-}
-EXPORT_SYMBOL(dmam_declare_coherent_memory);
-
-/**
- * dmam_release_declared_memory - Managed dma_release_declared_memory().
- * @dev: Device to release declared coherent memory for
- *
- * Managed dmam_release_declared_memory().
- */
-void dmam_release_declared_memory(struct device *dev)
-{
-	WARN_ON(devres_destroy(dev, dmam_coherent_decl_release, NULL, NULL));
-}
-EXPORT_SYMBOL(dmam_release_declared_memory);
-
-#endif
-
-/*
- * Create scatter-list for the already allocated DMA buffer.
- */
-int dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,
-		 void *cpu_addr, dma_addr_t handle, size_t size)
-{
-	struct page *page = virt_to_page(cpu_addr);
-	int ret;
-
-	ret = sg_alloc_table(sgt, 1, GFP_KERNEL);
-	if (unlikely(ret))
-		return ret;
-
-	sg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);
-	return 0;
-}
-EXPORT_SYMBOL(dma_common_get_sgtable);
-
-/*
- * Create userspace mapping for the DMA-coherent memory.
- */
-int dma_common_mmap(struct device *dev, struct vm_area_struct *vma,
-		    void *cpu_addr, dma_addr_t dma_addr, size_t size)
-{
-	int ret = -ENXIO;
-#ifndef CONFIG_ARCH_NO_COHERENT_DMA_MMAP
-	unsigned long user_count = vma_pages(vma);
-	unsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;
-	unsigned long off = vma->vm_pgoff;
-
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
-
-	if (dma_mmap_from_dev_coherent(dev, vma, cpu_addr, size, &ret))
-		return ret;
-
-	if (off < count && user_count <= (count - off))
-		ret = remap_pfn_range(vma, vma->vm_start,
-				      page_to_pfn(virt_to_page(cpu_addr)) + off,
-				      user_count << PAGE_SHIFT,
-				      vma->vm_page_prot);
-#endif	/* !CONFIG_ARCH_NO_COHERENT_DMA_MMAP */
-
-	return ret;
-}
-EXPORT_SYMBOL(dma_common_mmap);
-
-#ifdef CONFIG_MMU
-static struct vm_struct *__dma_common_pages_remap(struct page **pages,
-			size_t size, unsigned long vm_flags, pgprot_t prot,
-			const void *caller)
-{
-	struct vm_struct *area;
-
-	area = get_vm_area_caller(size, vm_flags, caller);
-	if (!area)
-		return NULL;
-
-	if (map_vm_area(area, prot, pages)) {
-		vunmap(area->addr);
-		return NULL;
-	}
-
-	return area;
-}
-
-/*
- * remaps an array of PAGE_SIZE pages into another vm_area
- * Cannot be used in non-sleeping contexts
- */
-void *dma_common_pages_remap(struct page **pages, size_t size,
-			unsigned long vm_flags, pgprot_t prot,
-			const void *caller)
-{
-	struct vm_struct *area;
-
-	area = __dma_common_pages_remap(pages, size, vm_flags, prot, caller);
-	if (!area)
-		return NULL;
-
-	area->pages = pages;
-
-	return area->addr;
-}
-
-/*
- * remaps an allocated contiguous region into another vm_area.
- * Cannot be used in non-sleeping contexts
- */
-
-void *dma_common_contiguous_remap(struct page *page, size_t size,
-			unsigned long vm_flags,
-			pgprot_t prot, const void *caller)
-{
-	int i;
-	struct page **pages;
-	struct vm_struct *area;
-
-	pages = kmalloc(sizeof(struct page *) << get_order(size), GFP_KERNEL);
-	if (!pages)
-		return NULL;
-
-	for (i = 0; i < (size >> PAGE_SHIFT); i++)
-		pages[i] = nth_page(page, i);
-
-	area = __dma_common_pages_remap(pages, size, vm_flags, prot, caller);
-
-	kfree(pages);
-
-	if (!area)
-		return NULL;
-	return area->addr;
-}
-
-/*
- * unmaps a range previously mapped by dma_common_*_remap
- */
-void dma_common_free_remap(void *cpu_addr, size_t size, unsigned long vm_flags)
-{
-	struct vm_struct *area = find_vm_area(cpu_addr);
-
-	if (!area || (area->flags & vm_flags) != vm_flags) {
-		WARN(1, "trying to free invalid coherent area: %p\n", cpu_addr);
-		return;
-	}
-
-	unmap_kernel_range((unsigned long)cpu_addr, PAGE_ALIGN(size));
-	vunmap(cpu_addr);
-}
-#endif
-
-/*
- * Common configuration to enable DMA API use for a device
- */
-#include <linux/pci.h>
-
-int dma_configure(struct device *dev)
-{
-	struct device *bridge = NULL, *dma_dev = dev;
-	enum dev_dma_attr attr;
-	int ret = 0;
-
-	if (dev_is_pci(dev)) {
-		bridge = pci_get_host_bridge_device(to_pci_dev(dev));
-		dma_dev = bridge;
-		if (IS_ENABLED(CONFIG_OF) && dma_dev->parent &&
-		    dma_dev->parent->of_node)
-			dma_dev = dma_dev->parent;
-	}
-
-	if (dma_dev->of_node) {
-		ret = of_dma_configure(dev, dma_dev->of_node);
-	} else if (has_acpi_companion(dma_dev)) {
-		attr = acpi_get_dma_attr(to_acpi_device_node(dma_dev->fwnode));
-		if (attr != DEV_DMA_NOT_SUPPORTED)
-			ret = acpi_dma_configure(dev, attr);
-	}
-
-	if (bridge)
-		pci_put_host_bridge_device(bridge);
-
-	return ret;
-}
-
-void dma_deconfigure(struct device *dev)
-{
-	of_dma_deconfigure(dev);
-	acpi_dma_deconfigure(dev);
-}
diff --git a/drivers/base/init.c b/drivers/base/init.c
index dd85b05a..908e6520 100644
--- a/drivers/base/init.c
+++ b/drivers/base/init.c
@@ -30,9 +30,9 @@ void __init driver_init(void)
 	/* These are also core pieces, but must come after the
 	 * core core pieces.
 	 */
+	of_core_init();
 	platform_bus_init();
 	cpu_dev_init();
 	memory_dev_init();
 	container_dev_init();
-	of_core_init();
 }
diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 8075ddc7..c0ff1e73 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -1130,6 +1130,22 @@ int platform_pm_restore(struct device *dev)
 
 #endif /* CONFIG_HIBERNATE_CALLBACKS */
 
+int platform_dma_configure(struct device *dev)
+{
+	enum dev_dma_attr attr;
+	int ret = 0;
+
+	if (dev->of_node) {
+		ret = of_dma_configure(dev, dev->of_node, true);
+	} else if (has_acpi_companion(dev)) {
+		attr = acpi_get_dma_attr(to_acpi_device_node(dev->fwnode));
+		if (attr != DEV_DMA_NOT_SUPPORTED)
+			ret = acpi_dma_configure(dev, attr);
+	}
+
+	return ret;
+}
+
 static const struct dev_pm_ops platform_dev_pm_ops = {
 	.runtime_suspend = pm_generic_runtime_suspend,
 	.runtime_resume = pm_generic_runtime_resume,
@@ -1141,8 +1157,8 @@ struct bus_type platform_bus_type = {
 	.dev_groups	= platform_dev_groups,
 	.match		= platform_match,
 	.uevent		= platform_uevent,
+	.dma_configure	= platform_dma_configure,
 	.pm		= &platform_dev_pm_ops,
-	.force_dma	= true,
 };
 EXPORT_SYMBOL_GPL(platform_bus_type);
 
diff --git a/drivers/bcma/main.c b/drivers/bcma/main.c
index e6986c76..fc1f4acd 100644
--- a/drivers/bcma/main.c
+++ b/drivers/bcma/main.c
@@ -207,7 +207,7 @@ static void bcma_of_fill_device(struct device *parent,
 
 	core->irq = bcma_of_get_irq(parent, core, 0);
 
-	of_dma_configure(&core->dev, node);
+	of_dma_configure(&core->dev, node, false);
 }
 
 unsigned int bcma_core_irq(struct bcma_device *core, int num)
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index 34968a38..cf7eacba 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -287,10 +287,12 @@ source "drivers/clk/mvebu/Kconfig"
 source "drivers/clk/qcom/Kconfig"
 source "drivers/clk/renesas/Kconfig"
 source "drivers/clk/samsung/Kconfig"
+source "drivers/clk/sifive/Kconfig"
 source "drivers/clk/sprd/Kconfig"
 source "drivers/clk/sunxi-ng/Kconfig"
 source "drivers/clk/tegra/Kconfig"
 source "drivers/clk/ti/Kconfig"
 source "drivers/clk/uniphier/Kconfig"
+source "drivers/clk/sifive/Kconfig"
 
 endmenu
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index de6d06ac..b2c829e6 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -87,6 +87,7 @@ obj-$(CONFIG_COMMON_CLK_QCOM)		+= qcom/
 obj-y					+= renesas/
 obj-$(CONFIG_ARCH_ROCKCHIP)		+= rockchip/
 obj-$(CONFIG_COMMON_CLK_SAMSUNG)	+= samsung/
+obj-y					+= sifive/
 obj-$(CONFIG_ARCH_SIRF)			+= sirf/
 obj-$(CONFIG_ARCH_SOCFPGA)		+= socfpga/
 obj-$(CONFIG_PLAT_SPEAR)		+= spear/
diff --git a/drivers/clk/sifive/Kconfig b/drivers/clk/sifive/Kconfig
new file mode 100644
index 00000000..c97972de
--- /dev/null
+++ b/drivers/clk/sifive/Kconfig
@@ -0,0 +1,10 @@
+config CLK_U54_PRCI
+	bool "PRCI driver for U54 SoCs"
+	depends on RISCV
+	---help---
+	  Supports Power Reset Clock interface found in U540 SoCs
+
+config CLK_GEMGXL_MGMT
+	bool "TX clock switch for GEMGXL in U540 SoCs"
+	---help---
+	  Supports clock muxing between 10/100Mbit and 1Gbit TX clock on U540 SoCs
diff --git a/drivers/clk/sifive/Makefile b/drivers/clk/sifive/Makefile
new file mode 100644
index 00000000..7784d2ee
--- /dev/null
+++ b/drivers/clk/sifive/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_CLK_U54_PRCI)	+= u54-prci.o
+obj-$(CONFIG_CLK_GEMGXL_MGMT)	+= gemgxl-mgmt.o
diff --git a/drivers/clk/sifive/gemgxl-mgmt.c b/drivers/clk/sifive/gemgxl-mgmt.c
new file mode 100644
index 00000000..00b07580
--- /dev/null
+++ b/drivers/clk/sifive/gemgxl-mgmt.c
@@ -0,0 +1,129 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Copyright (C) 2018 SiFive, Inc.
+ */
+
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+struct sifive_gemgxl_mgmt {
+	void __iomem *reg;
+	unsigned long rate;
+	struct clk_hw hw;
+};
+
+#define to_sifive_gemgxl_mgmt(mgmt) container_of(mgmt, struct sifive_gemgxl_mgmt, hw)
+
+static unsigned long sifive_gemgxl_mgmt_recalc_rate(struct clk_hw *hw,
+				      unsigned long parent_rate)
+{
+	struct sifive_gemgxl_mgmt *mgmt = to_sifive_gemgxl_mgmt(hw);
+	return mgmt->rate;
+}
+
+static long sifive_gemgxl_mgmt_round_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long *parent_rate)
+{
+	if (WARN_ON(rate < 2500000)) {
+		return 2500000;
+	} else if (rate == 2500000) {
+		return 2500000;
+	} else if (WARN_ON(rate < 13750000)) {
+		return 2500000;
+	} else if (WARN_ON(rate < 25000000)) {
+		return 25000000;
+	} else if (rate == 25000000) {
+		return 25000000;
+	} else if (WARN_ON(rate < 75000000)) {
+		return 25000000;
+	} else if (WARN_ON(rate < 125000000)) {
+		return 125000000;
+	} else if (rate == 125000000) {
+		return 125000000;
+	} else {
+		WARN_ON(rate > 125000000);
+		return 125000000;
+	}
+}
+
+static int sifive_gemgxl_mgmt_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long parent_rate)
+{
+	struct sifive_gemgxl_mgmt *mgmt = to_sifive_gemgxl_mgmt(hw);
+	rate = sifive_gemgxl_mgmt_round_rate(hw, rate, &parent_rate);
+	iowrite32(rate != 125000000, mgmt->reg);
+	mgmt->rate = rate;
+	return 0;
+}
+
+static const struct clk_ops sifive_gemgxl_mgmt_ops = {
+	.recalc_rate = sifive_gemgxl_mgmt_recalc_rate,
+	.round_rate = sifive_gemgxl_mgmt_round_rate,
+	.set_rate = sifive_gemgxl_mgmt_set_rate,
+};
+
+static int sifive_gemgxl_mgmt_probe(struct platform_device *pdev)
+{
+	struct clk_init_data init;
+	struct sifive_gemgxl_mgmt *mgmt;
+	struct resource *res;
+	struct clk *clk;
+
+	mgmt = devm_kzalloc(&pdev->dev, sizeof(*mgmt), GFP_KERNEL);
+	if (!mgmt)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mgmt->reg = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(mgmt->reg))
+		return PTR_ERR(mgmt->reg);
+
+	init.name = pdev->dev.of_node->name;
+	init.ops = &sifive_gemgxl_mgmt_ops;
+	init.flags = 0;
+	init.num_parents = 0;
+
+	mgmt->rate = 0;
+	mgmt->hw.init = &init;
+
+	clk = clk_register(NULL, &mgmt->hw);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	of_clk_add_provider(pdev->dev.of_node, of_clk_src_simple_get, clk);
+
+	dev_info(&pdev->dev, "Registered clock switch '%s'\n", init.name);
+
+	return 0;
+}
+
+static const struct of_device_id sifive_gemgxl_mgmt_of_match[] = {
+	{ .compatible = "sifive,cadencegemgxlmgmt0", },
+	{}
+};
+
+static struct platform_driver sifive_gemgxl_mgmt_driver = {
+	.driver	= {
+		.name = "sifive-gemgxl-mgmt",
+		.of_match_table = sifive_gemgxl_mgmt_of_match,
+	},
+	.probe = sifive_gemgxl_mgmt_probe,
+};
+
+static int __init sifive_gemgxl_mgmt_init(void)
+{
+	return platform_driver_register(&sifive_gemgxl_mgmt_driver);
+}
+core_initcall(sifive_gemgxl_mgmt_init);
diff --git a/drivers/clk/sifive/u54-prci.c b/drivers/clk/sifive/u54-prci.c
new file mode 100644
index 00000000..b8a93d1e
--- /dev/null
+++ b/drivers/clk/sifive/u54-prci.c
@@ -0,0 +1,314 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Copyright (C) 2018 SiFive, Inc.
+ */
+
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/log2.h>
+
+#define CORE_CLOCK 0
+#define GEMTX_CLOCK 1
+#define PRCI_CLOCKS 2
+
+#define MIN_REF 7000000ULL
+#define MAX_REF 200000000ULL
+#define MAX_PARENT 600000000ULL
+#define MAX_VCO 4800000000ULL
+#define MAX_DIV 64ULL
+#define MAX_R 64ULL
+
+#define PLL_LOCK 0x80000000ULL
+#define NAME_LEN 40ULL
+
+struct sifive_u54_prci_driver;
+
+struct sifive_u54_prci_pll {
+	struct clk_hw hw;
+	struct sifive_u54_prci_driver *driver;
+	char name[NAME_LEN];
+	u32 freq;
+	u32 glcm;
+};
+
+struct sifive_u54_prci_driver {
+	struct clk_onecell_data table;
+	struct clk *clks[PRCI_CLOCKS];
+	struct sifive_u54_prci_pll plls[PRCI_CLOCKS];
+	void __iomem *reg;
+};
+
+#define to_sifive_u54_prci_pll(hw) container_of(hw, struct sifive_u54_prci_pll, hw)
+
+struct sifive_u54_pll_cfg {
+	unsigned long r, f, q, a;
+};
+
+static struct sifive_u54_pll_cfg sifive_u54_pll_cfg(u32 reg)
+{
+	struct sifive_u54_pll_cfg cfg;
+	cfg.r = (reg >>  0) & 0x3f;
+	cfg.f = (reg >>  6) & 0x1ff;
+	cfg.q = (reg >> 15) & 0x7;
+	cfg.a = (reg >> 18) & 0x7;
+	return cfg;
+}
+
+static u32 sifive_u54_pll_reg(struct sifive_u54_pll_cfg cfg)
+{
+	u32 reg = 0;
+	reg |= (cfg.r & 0x3f)  << 0;
+	reg |= (cfg.f & 0x1ff) << 6;
+	reg |= (cfg.q & 0x7)   << 15;
+	reg |= (cfg.a & 0x7)   << 18;
+	reg |= 1<<25; // internal feedback
+	return reg;
+}
+
+static unsigned long sifive_u54_pll_rate(struct sifive_u54_pll_cfg cfg, unsigned long parent)
+{
+	return (parent*2*(cfg.f+1) / (cfg.r+1)) >> cfg.q;
+}
+
+static struct sifive_u54_pll_cfg sifive_u54_pll_configure(unsigned long target, unsigned long parent)
+{
+	struct sifive_u54_pll_cfg cfg;
+	unsigned long scale, ratio, best_delta, filter;
+	u32 max_r, best_r, best_f, r;
+
+	/* Confirm input frequency is within bounds */
+	if (WARN_ON(parent > MAX_PARENT)) { parent = MAX_PARENT; }
+	if (WARN_ON(parent < MIN_REF))    { parent = MIN_REF; }
+
+	/* Calculate the Q shift and target VCO */
+	scale = MAX_VCO / target;
+	if (scale <= 1) {
+		cfg.q = 1;
+		target = MAX_VCO;
+	} else if (scale > MAX_DIV) {
+		cfg.q = ilog2(MAX_DIV);
+		target = MAX_VCO/2;
+	} else {
+		cfg.q = ilog2(scale);
+		target = target << cfg.q;
+	}
+
+	/* Precalcualte the target ratio */
+	ratio = (target << 20) / parent;
+
+	/* Placeholder values */
+	best_r = 0;
+	best_f = 0;
+	best_delta = MAX_VCO;
+
+	/* Consider all values for R which land within [MIN_REF, MAX_REF]; prefer smaller R */
+	max_r = min(MAX_R, parent / MIN_REF);
+	for (r = DIV_ROUND_UP(parent, MAX_REF); r <= max_r; ++r) {
+		/* What is the best F we can pick in this case? */
+		u32 f = (ratio*r + (1<<20)) >> 21;
+		unsigned long ref = parent / r;
+		unsigned long vco = ref * f * 2;
+		unsigned long delta;
+
+		/* Ensure rounding didn't take us out of range */
+		if (vco > target) --f;
+		if (vco < MAX_VCO/2) ++f;
+		vco = ref * f * 2;
+
+		delta = abs(target - vco);
+		if (delta < best_delta) {
+			best_delta = delta;
+			best_r = r;
+			best_f = f;
+		}
+	}
+
+	cfg.r = best_r - 1;
+	cfg.f = best_f - 1;
+
+	/* Pick the best PLL jitter filter */
+	filter = parent / best_r;
+	BUG_ON(filter < 7000000);
+	if (filter < 11000000) {
+		cfg.a = 1;
+	} else if (filter < 18000000) {
+		cfg.a = 2;
+	} else if (filter < 30000000) {
+		cfg.a = 3;
+	} else if (filter < 50000000) {
+		cfg.a = 4;
+	} else if (filter < 80000000) {
+		cfg.a = 5;
+	} else if (filter < 130000000) {
+		cfg.a = 6;
+	} else {
+		BUG_ON (filter > 200000000);
+		cfg.a = 7;
+	}
+
+	return cfg;
+}
+
+static unsigned long sifive_u54_prci_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct sifive_u54_prci_pll *pll = to_sifive_u54_prci_pll(hw);
+	struct sifive_u54_prci_driver *driver = pll->driver;
+
+	u32 reg = ioread32(driver->reg + pll->freq);
+	struct sifive_u54_pll_cfg cfg = sifive_u54_pll_cfg(reg);
+
+	return sifive_u54_pll_rate(cfg, parent_rate);
+}
+
+static long sifive_u54_prci_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *parent_rate)
+{
+	struct sifive_u54_pll_cfg cfg = sifive_u54_pll_configure(rate, *parent_rate);
+	return sifive_u54_pll_rate(cfg, *parent_rate);
+}
+
+static int sifive_u54_prci_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)
+{
+	struct sifive_u54_prci_pll *pll = to_sifive_u54_prci_pll(hw);
+	struct sifive_u54_prci_driver *driver = pll->driver;
+
+	struct sifive_u54_pll_cfg cfg = sifive_u54_pll_configure(rate, parent_rate);
+	u32 reg = sifive_u54_pll_reg(cfg);
+
+	/* Switch to reg clock and reconfigure PLL */
+	iowrite32(1, driver->reg + pll->glcm);
+	iowrite32(reg, driver->reg + pll->freq);
+
+	/* Wait for lock and switch back to PLL */
+	while (!(ioread32(driver->reg + pll->freq) & PLL_LOCK));
+	iowrite32(0, driver->reg + pll->glcm);
+
+	return 0;
+}
+
+static const struct clk_ops sifive_u54_prci_ops_rw = {
+	.recalc_rate = sifive_u54_prci_recalc_rate,
+	.round_rate = sifive_u54_prci_round_rate,
+	.set_rate = sifive_u54_prci_set_rate,
+};
+
+static const struct clk_ops sifive_u54_prci_ops_ro = {
+	.recalc_rate = sifive_u54_prci_recalc_rate,
+};
+
+static ssize_t sifive_u54_pll_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sifive_u54_prci_driver *driver = dev_get_drvdata(dev);
+	return sprintf(buf, "%ld", clk_get_rate(driver->clks[0]));
+}
+
+static ssize_t sifive_u54_pll_rate_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct sifive_u54_prci_driver *driver = dev_get_drvdata(dev);
+	unsigned long rate;
+	char *endp;
+
+	rate = simple_strtoul(buf, &endp, 0);
+	if (*endp != 0 && *endp != '\n')
+		return -EINVAL;
+
+	clk_set_rate(driver->clks[0], rate);
+	return count;
+}
+
+static DEVICE_ATTR(rate, 0644, sifive_u54_pll_show, sifive_u54_pll_rate_store);
+
+static int sifive_u54_prci_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct clk_init_data init;
+	struct sifive_u54_prci_driver *driver;
+	struct resource *res;
+	const char *parent;
+	int i;
+
+	parent = of_clk_get_parent_name(dev->of_node, 0);
+	if (!parent) {
+		dev_err(dev, "No OF parent clocks found\n");
+		return -EINVAL;
+	}
+
+	driver = devm_kzalloc(dev, sizeof(*driver), GFP_KERNEL);
+	if (!driver) {
+		dev_err(dev, "Out of memory\n");
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	driver->reg = devm_ioremap_resource(dev, res);
+	if (IS_ERR(driver->reg))
+		return PTR_ERR(driver->reg);
+
+	/* Link the data structure */
+	driver->table.clk_num = PRCI_CLOCKS;
+	driver->table.clks = &driver->clks[0];
+	dev_set_drvdata(dev, driver);
+
+	/* Describe the clocks */
+	snprintf(driver->plls[CORE_CLOCK].name, NAME_LEN, "%s.core", dev->of_node->name);
+	driver->plls[CORE_CLOCK].freq = 0x4;
+	driver->plls[CORE_CLOCK].glcm = 0x24;
+	snprintf(driver->plls[GEMTX_CLOCK].name, NAME_LEN, "%s.gemtx", dev->of_node->name);
+	driver->plls[GEMTX_CLOCK].freq = 0x1c;
+	driver->plls[GEMTX_CLOCK].glcm = 0; /* None; cannot be set_rate */
+
+	/* Export the clocks */
+	for (i = 0; i < PRCI_CLOCKS; ++i) {
+		init.name = &driver->plls[i].name[0];
+		init.ops = driver->plls[i].glcm ? &sifive_u54_prci_ops_rw : &sifive_u54_prci_ops_ro;
+		init.num_parents = 1;
+		init.parent_names = &parent;
+		init.flags = 0;
+
+		driver->plls[i].driver = driver;
+		driver->plls[i].hw.init = &init;
+
+		driver->clks[i] = devm_clk_register(dev, &driver->plls[i].hw);
+		if (IS_ERR(driver->clks[i])) {
+			dev_err(dev, "Failed to register clock %d, %ld\n", i, PTR_ERR(driver->clks[i]));
+			return PTR_ERR(driver->clks[i]);
+		}
+	}
+
+	of_clk_add_provider(dev->of_node, of_clk_src_onecell_get, &driver->table);
+	device_create_file(dev, &dev_attr_rate);
+	dev_info(dev, "Registered U54 core clocks\n");
+
+	return 0;
+}
+
+static const struct of_device_id sifive_u54_prci_of_match[] = {
+	{ .compatible = "sifive,aloeprci0", },
+	{}
+};
+
+static struct platform_driver sifive_u54_prci_driver = {
+	.driver	= {
+		.name = "sifive-u54-prci",
+		.of_match_table = sifive_u54_prci_of_match,
+	},
+	.probe = sifive_u54_prci_probe,
+};
+
+static int __init sifive_u54_prci_init(void)
+{
+	return platform_driver_register(&sifive_u54_prci_driver);
+}
+core_initcall(sifive_u54_prci_init);
diff --git a/drivers/clocksource/Kconfig b/drivers/clocksource/Kconfig
index 8e8a0975..8183d106 100644
--- a/drivers/clocksource/Kconfig
+++ b/drivers/clocksource/Kconfig
@@ -607,4 +607,14 @@ config ATCPIT100_TIMER
 	help
 	  This option enables support for the Andestech ATCPIT100 timers.
 
+config RISCV_TIMER
+	bool "Timer for the RISC-V platform" if COMPILE_TEST
+	depends on RISCV
+	select TIMER_PROBE
+	select TIMER_OF
+	help
+	  This enables the per-hart timer built into all RISC-V systems, which
+	  is accessed via both the SBI and the rdcycle instruction.  This is
+	  required for all RISC-V systems.
+
 endmenu
diff --git a/drivers/clocksource/Makefile b/drivers/clocksource/Makefile
index 00caf37e..ded31f72 100644
--- a/drivers/clocksource/Makefile
+++ b/drivers/clocksource/Makefile
@@ -78,3 +78,4 @@ obj-$(CONFIG_H8300_TPU)			+= h8300_tpu.o
 obj-$(CONFIG_CLKSRC_ST_LPC)		+= clksrc_st_lpc.o
 obj-$(CONFIG_X86_NUMACHIP)		+= numachip.o
 obj-$(CONFIG_ATCPIT100_TIMER)		+= timer-atcpit100.o
+obj-$(CONFIG_RISCV_TIMER)		+= riscv_timer.o
diff --git a/drivers/clocksource/riscv_timer.c b/drivers/clocksource/riscv_timer.c
new file mode 100644
index 00000000..f4147db3
--- /dev/null
+++ b/drivers/clocksource/riscv_timer.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2012 Regents of the University of California
+ * Copyright (C) 2017 SiFive
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/delay.h>
+#include <linux/timer_riscv.h>
+#include <linux/sched_clock.h>
+#include <linux/cpu.h>
+#include <asm/sbi.h>
+
+#define MINDELTA 100
+#define MAXDELTA 0x7fffffff
+
+/*
+ * See <linux/timer_riscv.h> for the rationale behind pre-allocating per-cpu
+ * timers on RISC-V systems.
+ */
+DECLARE_PER_CPU(struct clock_event_device, riscv_clock_event);
+DECLARE_PER_CPU(struct clocksource, riscv_clocksource);
+
+static int next_event(unsigned long delta, struct clock_event_device *ce)
+{
+	/*
+	 * time_init() allocates a timer for each CPU.  Since we're writing the
+	 * timer comparison register here we can't allow the timers to cross
+	 * harts.
+	 */
+	BUG_ON(ce != this_cpu_ptr(&riscv_clock_event));
+	csr_set(sie, SIE_STIE);
+	sbi_set_timer(get_cycles64() + delta);
+	return 0;
+}
+
+DEFINE_PER_CPU(struct clock_event_device, riscv_clock_event) = {
+	.name           = "riscv_timer_clockevent",
+	.features       = CLOCK_EVT_FEAT_ONESHOT,
+	.rating         = 100,
+	.set_state_oneshot  = NULL,
+	.set_state_shutdown = NULL,
+	.set_next_event = next_event,
+};
+
+DEFINE_PER_CPU(bool, riscv_clock_event_enabled) = false;
+
+static unsigned long long rdtime(struct clocksource *cs)
+{
+	/*
+	 * It's guarnteed that all the timers across all the harts are
+	 * synchronized within one tick of each other, so while this could
+	 * technically go backwards when hopping between CPUs, practically it
+	 * won't happen.
+	 */
+	return get_cycles64();
+}
+
+DEFINE_PER_CPU(struct clocksource, riscv_clocksource) = {
+	.name = "riscv_clocksource",
+	.rating = 300,
+	.mask = CLOCKSOURCE_MASK(BITS_PER_LONG),
+	.flags = CLOCK_SOURCE_IS_CONTINUOUS,
+	.read = rdtime,
+};
+
+static int hart_of_timer(struct device_node *dev)
+{
+	u32 hart;
+
+	if (!dev)
+		return -1;
+	if (!of_device_is_compatible(dev, "riscv"))
+		return -1;
+	if (of_property_read_u32(dev, "reg", &hart))
+		return -1;
+
+	return hart;
+}
+
+static u64 notrace timer_riscv_sched_read(void)
+{
+	return get_cycles64();
+}
+
+static int timer_riscv_starting_cpu(unsigned int cpu)
+{
+	struct clock_event_device *ce = per_cpu_ptr(&riscv_clock_event, cpu);
+
+	ce->cpumask = cpumask_of(cpu);
+	clockevents_config_and_register(ce, riscv_timebase, MINDELTA, MAXDELTA);
+	/* Enable timer interrupt for this cpu */
+	csr_set(sie, SIE_STIE);
+
+	return 0;
+}
+
+static int timer_riscv_dying_cpu(unsigned int cpu)
+{
+	/* Disable timer interrupt for this cpu */
+	csr_clear(sie, SIE_STIE);
+
+	return 0;
+}
+
+static int __init timer_riscv_init_dt(struct device_node *n)
+{
+	int err = 0;
+	int cpu_id = hart_of_timer(n);
+	struct clocksource *cs = per_cpu_ptr(&riscv_clocksource, cpu_id);
+
+	if (cpu_id == smp_processor_id()) {
+		clocksource_register_hz(cs, riscv_timebase);
+		sched_clock_register(timer_riscv_sched_read, 64, riscv_timebase);
+
+		err = cpuhp_setup_state(CPUHP_AP_RISCV_TIMER_STARTING,
+			 "clockevents/riscv/timer:starting",
+			 timer_riscv_starting_cpu, timer_riscv_dying_cpu);
+		if (err)
+			pr_err("RISCV timer register failed [%d] for cpu = [%d]\n",
+			       err, cpu_id);
+	}
+	return err;
+}
+
+TIMER_OF_DECLARE(riscv_timer, "riscv", timer_riscv_init_dt);
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 8d24ade3..f502fc00 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -99,6 +99,10 @@ obj-$(CONFIG_CPU_FREQ_PMAC64)		+= pmac64-cpufreq.o
 obj-$(CONFIG_PPC_PASEMI_CPUFREQ)	+= pasemi-cpufreq.o
 obj-$(CONFIG_POWERNV_CPUFREQ)		+= powernv-cpufreq.o
 
+##################################################################################
+# RISCV platform drivers
+obj-$(CONFIG_ATCCPUFREQ)            += riscv-cpufreq.o
+
 ##################################################################################
 # Other platform drivers
 obj-$(CONFIG_BMIPS_CPUFREQ)		+= bmips-cpufreq.o
diff --git a/drivers/cpufreq/riscv-cpufreq.c b/drivers/cpufreq/riscv-cpufreq.c
new file mode 100644
index 00000000..9787225a
--- /dev/null
+++ b/drivers/cpufreq/riscv-cpufreq.c
@@ -0,0 +1,176 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <linux/timex.h>
+#include <linux/of_platform.h>
+
+#include <asm/sbi.h>
+
+#define LV_MASK	0xF0
+#define LV_OFF	4
+
+#define NUM_LV	16
+#define LOW_LV	15
+#define HIGH_LV	0
+#define PERIOD	(policy->cpuinfo.max_freq / NUM_LV)
+
+void read_powerbrake(void *arg)
+{
+	int *ret = arg;
+
+	*ret = sbi_read_powerbrake();
+}
+
+void write_powerbrake(void *arg)
+{
+	int *val = arg;
+
+	sbi_write_powerbrake(*val);
+}
+
+static unsigned int riscv_cpufreq_get(unsigned int cpu)
+{
+	int val, max;
+	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+
+	smp_call_function_single(cpu, read_powerbrake, &val, 1);
+	val = (val & LV_MASK) >> LV_OFF;
+
+	max = (LOW_LV - val + 1) * PERIOD;
+	return max;
+}
+
+static int riscv_cpufreq_set_policy(struct cpufreq_policy *policy)
+{
+	int val, i;
+	unsigned int cpu = policy->cpu;
+
+	if (!policy)
+		return -EINVAL;
+
+	if (policy->min == 0 && policy->max == 0) {
+		pr_err ("Cannot set zero freq\n");
+		return -EINVAL;
+	}
+	val = (policy->min + policy->max) / 2;
+	switch (policy->policy) {
+		case CPUFREQ_POLICY_POWERSAVE:
+			val = (val + policy->min) / 2;
+			break;
+		case CPUFREQ_POLICY_PERFORMANCE:
+			val = (val + policy->max) / 2;
+			break;
+		default:
+			pr_err ("Not Support this governor\n");
+			break;
+	}
+
+	if (val < 0) {
+		pr_err ("The freq is valid\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Powerbrake register has 16 level,
+	 * so we divide the xxxkHZ into 16 parts.
+	 *
+	 * EX: 100MHZ->100*1000kHZ
+	 *	|    |    |........|
+	 * Mhz	0  6250 12500    16*6250
+	 */
+
+	// transfer MHZ to kHZ, and divided to 16 level
+	for (i = 1; i <= NUM_LV; i++) {
+		if (val <= i * PERIOD) {
+			val = LOW_LV - (i - 1);
+			break;
+		}
+	}
+	val = val << LV_OFF;
+
+	return smp_call_function_single(cpu, write_powerbrake, &val, 1);
+}
+
+static int riscv_cpufreq_verify_policy(struct cpufreq_policy *policy)
+{
+	if (!policy)
+		return -EINVAL;
+
+	cpufreq_verify_within_cpu_limits(policy);
+
+	if((policy->policy != CPUFREQ_POLICY_POWERSAVE) &&
+	   (policy->policy != CPUFREQ_POLICY_PERFORMANCE))
+		return -EINVAL;
+
+	return 0;
+}
+
+static void riscv_get_policy(struct cpufreq_policy *policy)
+{
+	int val;
+
+	smp_call_function_single(policy->cpu, read_powerbrake, &val, 1);
+	val = (val & LV_MASK) >> LV_OFF;
+
+	/*
+	 * Powerbrake register has 16 level,
+	 * so we divide the xxxkHZ into 16 parts.
+	 *
+	 * EX: 100MHZ->100*1000kHZ
+	 *	|    |    |........|
+	 * Mhz	0  6250 12500    16*6250
+	 */
+	policy->min = (LOW_LV - val) * PERIOD;
+	policy->max = (LOW_LV - val + 1) * PERIOD;
+	policy->policy = CPUFREQ_POLICY_POWERSAVE;
+}
+
+static int riscv_cpufreq_cpu_init(struct cpufreq_policy *policy)
+{
+	u32 max_freq;
+	struct device_node *cpu;
+
+	cpu = of_get_cpu_node(policy->cpu, NULL);
+
+        if (!cpu)
+                return -ENODEV;
+
+	pr_debug("init cpufreq on CPU %d\n", policy->cpu);
+	if (of_property_read_u32(cpu, "clock-frequency", &max_freq)) {
+		pr_err("%s missing clock-frequency\n", cpu->name);
+		return -EINVAL;
+	}
+        of_node_put(cpu);
+
+	policy->cpuinfo.min_freq = 0;
+	policy->cpuinfo.max_freq = max_freq / 1000; /* kHZ */
+	riscv_get_policy(policy);
+
+	return 0;
+}
+
+static struct cpufreq_driver riscv_cpufreq_driver = {
+	.flags		= CPUFREQ_CONST_LOOPS,
+	.verify		= riscv_cpufreq_verify_policy,
+	.setpolicy	= riscv_cpufreq_set_policy,
+	.get		= riscv_cpufreq_get,
+	.init		= riscv_cpufreq_cpu_init,
+	.name		= "riscv_cpufreq",
+};
+
+static int __init riscv_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&riscv_cpufreq_driver);
+}
+
+static void __exit riscv_cpufreq_exit(void)
+{
+	cpufreq_unregister_driver(&riscv_cpufreq_driver);
+}
+
+MODULE_AUTHOR("Nick Hu <nickhu@andestech.com>");
+MODULE_DESCRIPTION("Riscv cpufreq driver.");
+MODULE_LICENSE("GPL");
+module_init(riscv_cpufreq_init);
+module_exit(riscv_cpufreq_exit);
diff --git a/drivers/crypto/vmx/.gitignore b/drivers/crypto/vmx/.gitignore
deleted file mode 100644
index af4a7ce4..00000000
--- a/drivers/crypto/vmx/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-aesp8-ppc.S
-ghashp8-ppc.S
diff --git a/drivers/dma/qcom/hidma_mgmt.c b/drivers/dma/qcom/hidma_mgmt.c
index 000c7019..d64edeb6 100644
--- a/drivers/dma/qcom/hidma_mgmt.c
+++ b/drivers/dma/qcom/hidma_mgmt.c
@@ -398,7 +398,7 @@ static int __init hidma_mgmt_of_populate_channels(struct device_node *np)
 		}
 		of_node_get(child);
 		new_pdev->dev.of_node = child;
-		of_dma_configure(&new_pdev->dev, child);
+		of_dma_configure(&new_pdev->dev, child, true);
 		/*
 		 * It is assumed that calling of_msi_configure is safe on
 		 * platforms with or without MSI support.
diff --git a/drivers/eisa/.gitignore b/drivers/eisa/.gitignore
deleted file mode 100644
index 4b335c0a..00000000
--- a/drivers/eisa/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-devlist.h
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index b960f6f3..987ff6e5 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -218,6 +218,16 @@ config GPIO_FTGPIO010
 	  Support for common GPIOs from the Faraday FTGPIO010 IP core, found in
 	  Cortina systems Gemini platforms, Moxa ART and others.
 
+config GPIO_ATCGPIO100
+	tristate "Andes ATCGPIO100 GPIO support"
+	depends on RISCV && PLAT_AE350 && OF_GPIO
+	select GPIOLIB_IRQCHIP
+	select IRQ_DOMAIN
+	select GPIO_GENERIC
+	help
+	  Support for common GPIOs from the Andestech ATCGPIO100 IP core, found in
+	  Andes RISC-V AE350 platform.
+
 config GPIO_GENERIC_PLATFORM
 	tristate "Generic memory-mapped GPIO controller support (MMIO platform device)"
 	select GPIO_GENERIC
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 1324c8f9..9c490dd3 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -51,6 +51,7 @@ obj-$(CONFIG_GPIO_EP93XX)	+= gpio-ep93xx.o
 obj-$(CONFIG_GPIO_EXAR)		+= gpio-exar.o
 obj-$(CONFIG_GPIO_F7188X)	+= gpio-f7188x.o
 obj-$(CONFIG_GPIO_FTGPIO010)	+= gpio-ftgpio010.o
+obj-$(CONFIG_GPIO_ATCGPIO100)  += gpio-atcgpio100.o
 obj-$(CONFIG_GPIO_GE_FPGA)	+= gpio-ge.o
 obj-$(CONFIG_GPIO_GPIO_MM)	+= gpio-gpio-mm.o
 obj-$(CONFIG_GPIO_GRGPIO)	+= gpio-grgpio.o
diff --git a/drivers/gpio/gpio-atcgpio100.c b/drivers/gpio/gpio-atcgpio100.c
new file mode 100644
index 00000000..2cdcddbe
--- /dev/null
+++ b/drivers/gpio/gpio-atcgpio100.c
@@ -0,0 +1,308 @@
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/err.h>
+
+#define GPIO_DATA_OUT			0x24
+#define GPIO_DATA_IN			0x20
+#define PIN_DIR				0x28
+#define PIN_PULL_ENABLE			0x40
+#define PIN_PULL_TYPE			0x44
+#define INT_ENABLE			0x50
+#define INT_STATE			0x64
+#define INT_MODE(ch)			(0x54+((ch/8)<<2))
+#define HIGH_LEVEL			2
+#define LOW_LEVEL			3
+#define NEGATIVE_EDGE			5
+#define POSITIVE_EDGE			6
+#define DUAL_EDGE			7
+#define DEBOUNCE_ENABLE			0x70
+
+#define ATCGPIO100_VIRTUAL_IRQ_BASE	32
+
+struct atcgpio_priv {
+	struct gpio_chip gc;
+	struct irq_chip	chip;
+	void __iomem *base;
+	int virq_base;
+	spinlock_t lock;
+};
+
+#define GPIO_READL(offset, base)	\
+	readl((void __iomem *)base + (offset))
+
+#define GPIO_WRITEL(val, offset, base)	\
+	writel((val), (void __iomem *)base + (offset))
+
+static inline struct atcgpio_priv *atcgpio_irq_data_get_data(struct irq_data *d)
+{
+	struct gpio_chip *chip = irq_data_get_irq_chip_data(d);
+
+	return gpiochip_get_data(chip);
+}
+
+static int atcirq_to_gpio(unsigned int irq)
+{
+	return irq - gpio_to_irq(0);
+}
+
+static int atcgpio_to_irq(struct gpio_chip *gc, unsigned int offset)
+{
+	struct atcgpio_priv *priv;
+
+	priv = gpiochip_get_data(gc);
+
+	return priv->virq_base+ offset;
+}
+
+static int atcgpio_get(struct gpio_chip *gc, unsigned int gpio)
+{
+	struct atcgpio_priv *priv;
+
+	priv = gpiochip_get_data(gc);
+
+	return (GPIO_READL(GPIO_DATA_IN, priv->base) >> gpio & 1);
+}
+
+static void atcgpio_set(struct gpio_chip *gc, unsigned int gpio, int data)
+{
+	unsigned long val;
+	struct atcgpio_priv *priv;
+
+	priv = gpiochip_get_data(gc);
+
+	if (data)
+		val = GPIO_READL(GPIO_DATA_OUT, priv->base) | (0x1UL << gpio);
+	else
+		val = GPIO_READL(GPIO_DATA_OUT, priv->base) & ~(0x1UL << gpio);
+
+	GPIO_WRITEL(val, GPIO_DATA_OUT, priv->base);
+}
+
+static int atcgpio_dir_in(struct gpio_chip *gc, unsigned int gpio)
+{
+	unsigned long val;
+	unsigned long flags;
+	struct atcgpio_priv *priv;
+
+	priv = gpiochip_get_data(gc);
+	spin_lock_irqsave(&priv->lock, flags);
+	val = GPIO_READL(PIN_DIR, priv->base) & ~(0x1UL << gpio);
+	GPIO_WRITEL(val, PIN_DIR, priv->base);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+
+static int atcgpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int data)
+{
+	unsigned long val;
+	unsigned long flags;
+	struct atcgpio_priv *priv;
+
+	priv = gpiochip_get_data(gc);
+	spin_lock_irqsave(&priv->lock, flags);
+	val = GPIO_READL(PIN_DIR, priv->base) | (0x1UL << gpio);
+	GPIO_WRITEL(val, PIN_DIR, priv->base);
+	gc->set(gc, gpio, data);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+
+static void atcgpio_irq_ack(struct irq_data *data)
+{
+	struct atcgpio_priv *priv;
+	unsigned long flags;
+
+	priv = atcgpio_irq_data_get_data(data);
+	spin_lock_irqsave(&priv->lock, flags);
+	GPIO_WRITEL(0x1UL << atcirq_to_gpio(data->irq), INT_STATE, priv->base);
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static void atcgpio_irq_unmask(struct irq_data *data)
+{
+	unsigned long val;
+	unsigned long flags;
+	struct atcgpio_priv *priv;
+	
+	priv = atcgpio_irq_data_get_data(data);
+	spin_lock_irqsave(&priv->lock, flags);
+	val = GPIO_READL(INT_ENABLE, priv->base) | (0x1UL << atcirq_to_gpio(data->irq));
+	GPIO_WRITEL(val, INT_ENABLE, priv->base);
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static void atcgpio_irq_mask(struct irq_data *data)
+{
+	unsigned long val;
+	unsigned long flags;
+	struct atcgpio_priv *priv;
+
+	priv = atcgpio_irq_data_get_data(data);
+	spin_lock_irqsave(&priv->lock, flags);
+	val = GPIO_READL(INT_ENABLE, priv->base) & ~(0x1UL << atcirq_to_gpio(data->irq));
+	GPIO_WRITEL(val, INT_ENABLE, priv->base);
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static int atcgpio_irq_set_type(struct irq_data *data, unsigned int flow_type)
+{
+	unsigned long gpio = atcirq_to_gpio(data->irq);
+	unsigned long ch = gpio%8;
+	unsigned long mode_off = ch<<2;
+	unsigned long val;
+	unsigned long flags;
+	struct atcgpio_priv *priv;
+
+	priv = atcgpio_irq_data_get_data(data);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	val = GPIO_READL(INT_MODE(gpio), priv->base);
+	val &= ~(7<<mode_off);
+	if (flow_type & IRQF_TRIGGER_RISING && flow_type & IRQF_TRIGGER_FALLING)
+		GPIO_WRITEL(val | DUAL_EDGE<<mode_off, INT_MODE(gpio), priv->base);
+	else if (flow_type & IRQF_TRIGGER_FALLING)
+		GPIO_WRITEL(val | NEGATIVE_EDGE<<mode_off, INT_MODE(gpio), priv->base);
+	else if (flow_type & IRQF_TRIGGER_RISING)
+		GPIO_WRITEL(val | POSITIVE_EDGE<<mode_off, INT_MODE(gpio), priv->base);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+
+static void gpio_irq_router(struct irq_desc *desc)
+{
+	unsigned long status;
+	struct atcgpio_priv *priv;
+	int i = 0;
+
+	priv = irq_desc_get_handler_data(desc);
+	status = GPIO_READL(INT_STATE, priv->base);
+	status &= ~((1 << 22) | (1 << 25) | (1 << 26));
+
+	while (status) {
+		if (status & 0x1UL)
+			generic_handle_irq(gpio_to_irq(i));
+		status >>= 1;
+		i++;
+	}
+}
+
+static int atcgpio100_gpio_probe(struct platform_device *pdev)
+{
+	struct resource *res, *irq_res;
+	int ret, err;
+	struct atcgpio_priv *priv;
+	struct gpio_chip *gc;
+	struct irq_chip *ic;
+
+	priv = devm_kzalloc(&pdev->dev,	sizeof(*priv), GFP_KERNEL);
+
+	if (!priv)
+		return -ENOMEM;
+
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "failed to request atcgpio100 resource\n");
+		return -ENOENT;
+	}
+
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq_res) {
+		dev_err(&pdev->dev, "failed to request atcgpio100 irq\n");
+		return -ENOENT;
+	}
+
+	priv->virq_base = ATCGPIO100_VIRTUAL_IRQ_BASE;
+	priv->base = devm_ioremap_resource(&pdev->dev, res);
+	spin_lock_init(&priv->lock);
+
+	if (IS_ERR((void *)priv->base))
+		return PTR_ERR((void *)priv->base);
+
+	/* disable interrupt */
+	GPIO_WRITEL(0x00000000UL, INT_ENABLE, priv->base);
+	/* clear interrupt */
+	GPIO_WRITEL(0x0000FFFFUL, INT_STATE, priv->base);
+	/* enable de-bouncing */
+	GPIO_WRITEL(0x0000FFFFUL, DEBOUNCE_ENABLE, priv->base);
+	/* enable interrupt */
+	GPIO_WRITEL(0x0000FFFFUL, INT_ENABLE, priv->base);
+	gc = &priv->gc;
+	gc->owner = THIS_MODULE;
+	gc->parent = &pdev->dev;
+	gc->label = "atcgpio100";
+	gc->base = 0;
+	gc->ngpio = 16;
+	gc->direction_output = atcgpio_dir_out;
+	gc->direction_input = atcgpio_dir_in;
+	gc->set = atcgpio_set;
+	gc->get = atcgpio_get;
+	gc->to_irq = atcgpio_to_irq;
+	ic = &priv->chip;
+	ic->name = "ATCGPIO100_irq";
+	ic->irq_ack = atcgpio_irq_ack;
+	ic->irq_mask = atcgpio_irq_mask;
+	ic->irq_unmask = atcgpio_irq_unmask;
+	ic->irq_set_type = atcgpio_irq_set_type;
+
+	err = gpiochip_add_data(gc, priv);
+	if (err < 0)
+		return err;
+
+	platform_set_drvdata(pdev, priv);
+	
+	ret = gpiochip_irqchip_add(&priv->gc, ic,priv->virq_base,
+		handle_level_irq,IRQ_TYPE_NONE);
+
+	if (ret) {
+		dev_err(&pdev->dev, "could not add irqchip\n");
+		gpiochip_remove(&priv->gc);
+		return ret;
+	}
+	gpiochip_set_chained_irqchip(&priv->gc, ic,irq_res->start, gpio_irq_router);
+	pr_info("ATCGPIO100 module inserted\n");
+
+	return 0;
+}
+
+static int atcgpio100_gpio_remove(struct platform_device *pdev)
+{
+	struct atcgpio_priv *priv = platform_get_drvdata(pdev);
+
+	/* disable interrupt */
+	GPIO_WRITEL(0x00000000UL, INT_ENABLE, priv->base);
+	gpiochip_remove(&priv->gc);
+	pr_info("GPIO module removed\n");
+	
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id atcgpio100_gpio_match[] = {
+	{
+		.compatible = "andestech,atcgpio100",
+	},
+	{ },
+};
+#endif
+
+static struct platform_driver atcgpio100_gpio_driver = {
+	.probe		= atcgpio100_gpio_probe,
+	.driver		= {
+		.name	= "atcgpio100_gpio",
+		.of_match_table = of_match_ptr(atcgpio100_gpio_match),
+	},
+	.remove		= atcgpio100_gpio_remove,
+};
+
+module_platform_driver(atcgpio100_gpio_driver);
+MODULE_DESCRIPTION("ATCGPIO100");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/radeon/.gitignore b/drivers/gpu/drm/radeon/.gitignore
deleted file mode 100644
index 403eb3a5..00000000
--- a/drivers/gpu/drm/radeon/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-mkregtable
-*_reg_safe.h
-
diff --git a/drivers/gpu/host1x/bus.c b/drivers/gpu/host1x/bus.c
index 88a3558b..815bdb42 100644
--- a/drivers/gpu/host1x/bus.c
+++ b/drivers/gpu/host1x/bus.c
@@ -314,6 +314,11 @@ static int host1x_device_match(struct device *dev, struct device_driver *drv)
 	return strcmp(dev_name(dev), drv->name) == 0;
 }
 
+static int host1x_dma_configure(struct device *dev)
+{
+	return of_dma_configure(dev, dev->of_node, true);
+}
+
 static const struct dev_pm_ops host1x_device_pm_ops = {
 	.suspend = pm_generic_suspend,
 	.resume = pm_generic_resume,
@@ -326,8 +331,8 @@ static const struct dev_pm_ops host1x_device_pm_ops = {
 struct bus_type host1x_bus_type = {
 	.name = "host1x",
 	.match = host1x_device_match,
+	.dma_configure	= host1x_dma_configure,
 	.pm = &host1x_device_pm_ops,
-	.force_dma = true,
 };
 
 static void __host1x_device_del(struct host1x_device *device)
@@ -416,7 +421,7 @@ static int host1x_device_add(struct host1x *host1x,
 	device->dev.bus = &host1x_bus_type;
 	device->dev.parent = host1x->dev;
 
-	of_dma_configure(&device->dev, host1x->dev->of_node);
+	of_dma_configure(&device->dev, host1x->dev->of_node, true);
 
 	err = host1x_device_parse_dt(device, driver);
 	if (err < 0) {
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 8d21b982..cf5d1b2e 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -382,6 +382,31 @@ config I2C_AT91
 	  the latency to fill the transmission register is too long. If you
 	  are facing this situation, use the i2c-gpio driver.
 
+config I2C_ATCIIC100
+	tristate "Andes AE350 I2C interface"
+	depends on PLAT_AE350
+	help
+	  This supports the use of the I2C interface on Andes AE350
+	  processors.
+
+choice
+	depends on I2C_ATCIIC100
+	prompt "Transfer mode selection"
+	default ATCIIC_PIO
+config ATCIIC_PIO
+	bool "Pio mode"
+config ATCIIC_IRQ
+	bool "Irq mode"
+endchoice
+
+config ATCIIC100_DEBUG
+	bool "atciic100 debugging"
+default n
+	depends on I2C_ATCIIC100 != n
+	help
+	  This is an option for use by developers; most people should
+	  say N here.  This enables atciic100 driver debugging.
+
 config I2C_AU1550
 	tristate "Au1550/Au1200/Au1300 SMBus interface"
 	depends on MIPS_ALCHEMY
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 189e34ba..0a59d89c 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_I2C_POWERMAC)	+= i2c-powermac.o
 obj-$(CONFIG_I2C_ALTERA)	+= i2c-altera.o
 obj-$(CONFIG_I2C_ASPEED)	+= i2c-aspeed.o
 obj-$(CONFIG_I2C_AT91)		+= i2c-at91.o
+obj-$(CONFIG_I2C_ATCIIC100)	+= i2c-atciic100.o
 obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
 obj-$(CONFIG_I2C_AXXIA)		+= i2c-axxia.o
 obj-$(CONFIG_I2C_BCM2835)	+= i2c-bcm2835.o
diff --git a/drivers/i2c/busses/i2c-atciic100.c b/drivers/i2c/busses/i2c-atciic100.c
new file mode 100755
index 00000000..6ba0cb8c
--- /dev/null
+++ b/drivers/i2c/busses/i2c-atciic100.c
@@ -0,0 +1,554 @@
+/*
+    i2c Support for Andes's ATCIIC100 Two-Wire Interface (TWI)
+    Copyright (C) 2016 Rick Chen
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+*/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <linux/interrupt.h>
+
+#include <linux/of.h>
+#include <linux/of_device.h>
+
+
+#define SUPPORT_AT24C128_BY_BOARD	0
+
+#define DRV_NAME	"atciic100"
+
+/* ID and Revision Register */
+#define IDREV	0x00
+#define ID_OFF	12
+#define ID_MSK	0xfffff
+#define ID	0x02021
+/* Configuration Register */
+#define CFG	0x10
+#define FIFOSIZE_MASK	0x3
+
+/* INterrupt Enable Register */
+#define INTEN	0x14
+
+/* Status Register */
+#define STA	0x18
+
+#define LINESDA	(1<<14)
+#define LINESCL	(1<<13)
+#define GENCALL	(1<<12)
+#define BBUSY	(1<<11)
+#define ACK	(1<<10)
+#define COMPL	(1<<9)
+#define BRECV	(1<<8)
+#define BTRAN	(1<<7)
+#define START	(1<<6)
+#define STOP	(1<<5)
+#define ALOSE	(1<<4)
+#define ADDRHIT	(1<<3)
+#define FIFOHAF	(1<<2)
+#define FIFOFUL	(1<<1)
+#define FIFOETY	(1<<0)
+#define STAW1C	(COMPL|BRECV|BTRAN|START|STOP|ALOSE|ADDRHIT)
+
+/* Address Register */
+#define ADR	0x1c
+
+/* Data Register */
+#define DAT	0x20
+
+/* Control Register */
+#define CTL	0x24
+#define PSTART	(1<<12)
+#define PADDR	(1<<11)
+#define PDATA	(1<<10)
+#define PSTOP	(1<<9)
+#define DIR_RX	(1<<8)
+#define DCNTMSK	0xff
+
+/* Command Register */
+#define CMD	0x28
+#define ISSUE_DATA	0x1
+#define RESPOND_ACK	0x2
+#define RESPOND_NACK	0x3
+#define CLEAR_FIFO	0x4
+#define RESET_IIC	0x5
+
+/* Setup Register */
+#define SETUP	0x2c
+#define MASTER	(1<<2)
+#define ADDR10	(1<<1)
+#define IICEN	(1<<0)
+
+#define xget buf[i++] = IIC(DAT)
+#define xput IIC(DAT) = buf[i++]
+
+#define XFER_TIMEOUT	0xf000
+#define MODE_PIO	0
+#define MODE_IRQ	1
+#ifdef CONFIG_ATCIIC_PIO
+#define XFER_MODE	MODE_PIO
+#else
+#define XFER_MODE	MODE_IRQ
+#endif
+
+#ifdef CONFIG_ATCIIC100_DEBUG
+#define PRINTK printk
+#else
+#define PRINTK(x...)
+#endif
+
+
+#define IIC(reg)		(*( volatile u32 *)( iface->regs_base + reg))
+
+
+#define xwait(c,b,eq,m)\
+cnt=c;\
+while((IIC(STA)&b) eq b)\
+if(!(cnt--))\
+{\
+	PRINTK("wait %s error\n",m);\
+	return -EIO;\
+}\
+
+#define xfer_wait(c,b,eq,m,act1,act2)\
+while(length--)\
+{\
+	act1;\
+	xwait(c,b,eq,m)\
+	act2;\
+}\
+
+struct atciic {
+	int			irq;
+	spinlock_t		lock;
+	char			read_write;
+	u8			fifolen;
+	u8			mode;
+	u8			command;
+	u8			*ptr;
+	int			readNum;
+	int			writeNum;
+	int			cur_mode;
+	int			addr_hit;
+	int			cmpl;
+	int			manual_stop;
+	int			result;
+	struct i2c_adapter	adap;
+	struct completion	complete;
+	struct i2c_msg 		*pmsg;
+	int			msg_num;
+	int			cur_msg;
+	u16			saved_clkdiv;
+	u16			saved_control;
+	void __iomem		*regs_base;
+	struct resource		*res;
+};
+
+static u32 xrecev(struct atciic *iface)
+{
+	volatile u32 status_wait=0;
+	if(iface->readNum >= iface->fifolen){
+		IIC(INTEN) = (COMPL|FIFOFUL);
+		status_wait = FIFOFUL;
+	}
+	else{
+		IIC(INTEN) = COMPL;
+		status_wait = COMPL;
+	}
+	return status_wait;
+}
+
+static irqreturn_t atciic_irq(int irq, void *dev_id)
+{
+	struct atciic *iface = dev_id;
+	int i = 0;
+	unsigned long flags;
+	volatile u32 status = IIC(STA);
+	volatile u32 rleft = (IIC(CTL)&0xff);
+	char flen = iface->fifolen;
+	unsigned char *buf = iface->ptr;
+	spin_lock_irqsave(&iface->lock, flags);
+	IIC(STA) = status;
+	if(status & ADDRHIT)
+		iface->addr_hit = 1;
+
+	if (iface->pmsg->flags & I2C_M_RD){
+		if(status & xrecev(iface)){
+			flen = iface->readNum - rleft;
+			iface->readNum -= flen;
+			while(flen--) xget;
+			xrecev(iface);
+		}
+	}
+	else{
+		IIC(INTEN) = (COMPL|FIFOETY);
+		flen = iface->writeNum > flen ? flen : iface->writeNum;
+		if(status & FIFOETY){
+			iface->writeNum -= flen;
+			while(flen--) xput;
+		}
+	}
+	iface->ptr += i;
+	spin_unlock_irqrestore(&iface->lock, flags);
+	if(status & COMPL){
+		IIC(INTEN) = 0;
+		iface->cmpl = 1;
+		if(iface->addr_hit==1)
+			complete(&iface->complete);
+	}
+	return IRQ_HANDLED;
+}
+
+static int irq_transfer(struct atciic *iface)
+{
+	if (!wait_for_completion_timeout(&iface->complete,iface->adap.timeout)) {
+		iface->result = -EIO;
+		PRINTK("%s(%s) fail , addrhit 0x%x , cmpl 0x%x , %s %d , int 0x%lx , status 0x%lx\n",
+		(iface->pmsg->flags & I2C_M_RD) ? "read" : "write",
+		iface->mode ? "irq" : "pio",
+		iface->addr_hit,
+		iface->cmpl,
+		(iface->pmsg->flags & I2C_M_RD) ? "readNum" : "writeNum",
+		(iface->pmsg->flags & I2C_M_RD) ? iface->readNum : iface->writeNum,
+		IIC(INTEN),IIC(STA));
+	}
+	reinit_completion(&(iface->complete));
+	return iface->result;
+}
+
+static int pio_transfer(struct atciic *iface)
+{
+	int length = iface->pmsg->len;
+	unsigned char *buf = iface->pmsg->buf;
+	int cnt=XFER_TIMEOUT;
+	int i=0;
+	if (iface->pmsg->flags & I2C_M_RD){
+		xfer_wait(XFER_TIMEOUT,FIFOETY,==,"fifo empty",,xget);
+		xwait(XFER_TIMEOUT,COMPL,!=,"cmpl");
+	}
+	else{
+		xwait(XFER_TIMEOUT,ADDRHIT,!=,"addrhit");
+		xfer_wait(XFER_TIMEOUT,FIFOFUL,==,"fifofull",xput,);
+		xwait(XFER_TIMEOUT,COMPL,!=,"cmpl");
+	}
+	return 0;
+}
+
+static int atciic_transfer(struct atciic *iface)
+{
+	if(iface->mode == MODE_PIO)
+		return pio_transfer(iface);
+	else if(iface->mode == MODE_IRQ)
+		return irq_transfer(iface);
+	else
+		return -EIO;
+}
+
+/*
+ * Adjust timeout depend on transaction time.
+ *
+ */
+static void calculate_timeout(struct i2c_adapter *adap,int length)
+{
+	if(length > 4)
+		adap->timeout = 3 * HZ;
+	else
+		adap->timeout = HZ/8;
+}
+
+/*
+ * Generic i2c master receive.
+ *
+ */
+static int atciic_read(struct i2c_adapter *adap, unsigned char *buf, int length)
+{
+	int rc = 0;
+	struct atciic *iface = adap->algo_data;
+	iface->readNum = length;
+	iface->result = 0;
+	IIC(CTL) &= ~0xff;
+	IIC(CTL) |= ((length&0xff)|DIR_RX);
+	if(iface->mode == MODE_IRQ)
+		IIC(INTEN) = (FIFOFUL|COMPL);
+	IIC(CMD) = ISSUE_DATA;
+	rc = atciic_transfer(iface);
+	return rc;
+}
+
+/*
+ * Generic i2c master transmit.
+ *
+ */
+static int atciic_write(struct i2c_adapter *adap, unsigned char *buf, int length)
+{
+	int rc = 0;
+	struct atciic *iface = adap->algo_data;
+	iface->result = 0;
+	iface->writeNum = length;
+	IIC(CTL) &= ~(DIR_RX|DCNTMSK);
+	IIC(CTL) |= (length&0xff);
+	if(iface->mode == MODE_IRQ)
+		IIC(INTEN) = (FIFOETY|COMPL);
+	/* Write cycle time issue */
+	mdelay(5);
+	IIC(CMD) = ISSUE_DATA;
+	rc = atciic_transfer(iface);
+	return rc;
+}
+
+/*
+ * Generic i2c master transfer entrypoint.
+ *
+ */
+static int atciic_xfer(struct i2c_adapter *adap, struct i2c_msg *pmsg, int num)
+{
+	int i, ret;
+	u16 rw;
+	int retry = adap->retries;
+	struct atciic *iface = adap->algo_data;
+	struct i2c_msg *msg;
+	if((pmsg->flags & I2C_M_RD)&&(pmsg->len==1))
+		retry = 0;
+xfer_start:
+	msg = pmsg;
+	dev_dbg(&adap->dev, "atciic_xfer: processing %d messages:\n", num);
+	for (i = 0; i < num; i++) {
+		if(msg->len>0x100)
+			return -EIO;
+		dev_dbg(&adap->dev, " #%d: %sing %d byte%s %s 0x%02x\n", i,
+			pmsg->flags & I2C_M_RD ? "read" : "writ",
+			pmsg->len, pmsg->len > 1 ? "s" : "",
+			pmsg->flags & I2C_M_RD ? "from" : "to",	pmsg->addr);
+		iface->addr_hit = 0;
+		iface->cmpl = 0;
+		iface->pmsg = msg;
+		rw = iface->pmsg->flags & I2C_M_RD;
+		iface->ptr = msg->buf;
+		IIC(INTEN) = 0;
+		IIC(ADR) = (msg->addr);
+		if (msg->len && msg->buf) {	/* sanity check */
+			calculate_timeout(adap,msg->len);
+			if (msg->flags & I2C_M_RD){
+				ret = atciic_read(adap, msg->buf, msg->len);
+			}
+			else{
+				ret = atciic_write(adap, msg->buf, msg->len);
+			}
+			IIC(STA) = STAW1C;
+			if (ret){
+				if(retry--){
+					printk("xfer %s(%s) retry\n",
+						rw ? "read" : "write",
+						iface->mode ? "irq" : "pio");
+					goto xfer_start;
+				}
+				else
+					return ret;
+			}
+		}
+		dev_dbg(&adap->dev, "transfer complete\n");
+		msg++;		/* next message */
+	}
+	return i;
+}
+
+/*
+ * Return list of supported functionality.
+ */
+static u32 atciic_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | \
+		I2C_FUNC_SMBUS_READ_BYTE | \
+		I2C_FUNC_SMBUS_WRITE_BYTE | \
+		I2C_FUNC_SMBUS_READ_BYTE_DATA | \
+		I2C_FUNC_SMBUS_WRITE_BYTE_DATA | \
+		I2C_FUNC_SMBUS_READ_WORD_DATA | \
+		I2C_FUNC_SMBUS_READ_BLOCK_DATA | \
+		I2C_FUNC_SMBUS_WRITE_BLOCK_DATA | \
+		I2C_FUNC_SMBUS_READ_I2C_BLOCK | \
+		I2C_FUNC_SMBUS_WRITE_I2C_BLOCK | \
+		I2C_FUNC_SMBUS_WRITE_WORD_DATA;
+}
+
+static struct i2c_algorithm atciic_algorithm = {
+	.master_xfer	= atciic_xfer,
+	.functionality	= atciic_func,
+};
+
+#if SUPPORT_AT24C128_BY_BOARD
+#include <linux/i2c/at24.h>
+
+static struct at24_platform_data at24c128 = {
+	.byte_len	= 0x00020000,
+	.page_size	= 64,
+	.flags		= AT24_FLAG_ADDR16,
+};
+
+static struct i2c_board_info __initdata ae300_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("24c128", 0x50),
+		.platform_data = &at24c128,
+	},
+};
+
+void __init ae300_add_device_i2c(struct i2c_board_info *devices, int nr_devices)
+{
+	i2c_register_board_info(0, devices, nr_devices);
+}
+#endif
+
+/*
+ * Main initialization routine.
+ */
+static int atciic_probe(struct platform_device *pdev)
+{
+	struct i2c_adapter *padap;
+	struct atciic *iface;
+	int rc;
+#if SUPPORT_AT24C128_BY_BOARD
+	ae300_add_device_i2c(ae300_i2c_devices,ARRAY_SIZE(ae300_i2c_devices));
+#endif
+	iface = kzalloc(sizeof(struct atciic), GFP_KERNEL);
+	if (!iface) {
+		dev_err(&pdev->dev, "Cannot allocate atciic\n");
+		rc = -ENOMEM;
+		goto out_error_nomem;
+	}
+	spin_lock_init(&(iface->lock));
+	iface->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (iface->res == NULL) {
+		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
+		rc = -ENOMEM;
+		goto out_error_get_res;
+	}
+
+	if (!iface->res) {
+		rc = -ENOMEM;
+		goto out_error_get_res;
+	}
+
+	iface->regs_base = devm_ioremap_resource(&pdev->dev, iface->res);
+
+	if (iface->regs_base == NULL) {
+		dev_err(&pdev->dev, "Cannot map IO\n");
+		rc = -ENXIO;
+		goto out_error_get_io;
+	}
+	if(((IIC(IDREV)>>ID_OFF)&ID_MSK)!=ID)
+	{
+		dev_err(&pdev->dev, "I2C version NOT match\n");
+		rc = -ENXIO;
+		goto out_error_get_io;
+	}
+	iface->irq = platform_get_irq(pdev, 0);
+	if (iface->irq < 0) {
+		dev_err(&pdev->dev, "No IRQ specified\n");
+		rc = -ENOENT;
+		goto out_error_get_io;
+	}
+
+	rc = request_irq(iface->irq, atciic_irq,0, pdev->name, iface);
+	if (rc) {
+		dev_err(&pdev->dev, "Can't get IRQ %d !\n", iface->irq);
+		rc = -ENODEV;
+		goto out_error_req_irq;
+	}
+	iface->mode= XFER_MODE;
+	init_completion(&(iface->complete));
+	padap = &iface->adap;
+	strlcpy(padap->name, pdev->name, sizeof(padap->name));
+	padap->algo = &atciic_algorithm;
+	padap->class = I2C_CLASS_HWMON;
+	padap->dev.parent = &pdev->dev;
+	padap->algo_data = iface;
+	padap->timeout = 3 * HZ;
+	padap->retries = 1;
+	rc = i2c_add_numbered_adapter(padap);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "Can't add i2c adapter!\n");
+		goto out_error_add_adapter;
+	}
+	platform_set_drvdata(pdev, padap);
+	padap = platform_get_drvdata(pdev);
+	iface->fifolen = (1<<((IIC(CFG) & FIFOSIZE_MASK)+1));
+	IIC(SETUP) |= (MASTER|IICEN);
+
+	dev_info(&pdev->dev, "Andes i2c bus driver.\n");
+	return 0;
+
+out_error_add_adapter:
+	free_irq(iface->irq, iface);
+out_error_req_irq:
+out_error_get_io:
+	release_mem_region(iface->res->start, resource_size(iface->res));
+out_error_get_res:
+	kfree(iface);
+out_error_nomem:
+	return rc;
+
+}
+
+static int atciic_remove(struct platform_device *pdev)
+{
+	struct i2c_adapter *adapter = platform_get_drvdata(pdev);
+	struct atciic *iface = adapter->algo_data;
+	i2c_del_adapter(adapter);
+	platform_set_drvdata(pdev, NULL);
+	release_mem_region(iface->res->start, resource_size(iface->res));
+	free_irq(iface->irq, iface);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int atciic_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	return 0;
+}
+
+static int atciic_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#else
+#define atciic_suspend	NULL
+#define atciic_resume	NULL
+#endif
+
+#ifdef CONFIG_OF
+static const struct of_device_id atc_iic_dt_match[] = {
+	{ .compatible = "andestech,atciic100" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, atc_iic_dt_match);
+#endif
+
+static struct platform_driver atciic_platform_driver = {
+
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table	= of_match_ptr(atc_iic_dt_match),
+	},
+	.probe		= atciic_probe,
+	.remove		= atciic_remove,
+};
+
+module_platform_driver(atciic_platform_driver);
+MODULE_AUTHOR("Rick Chen");
+MODULE_AUTHOR("Dylan Jhong");
+MODULE_DESCRIPTION("I2C driver for Andes atciic100");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:atciic100");
diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig
index df171cb8..5b714a06 100644
--- a/drivers/iommu/Kconfig
+++ b/drivers/iommu/Kconfig
@@ -146,6 +146,7 @@ config INTEL_IOMMU
 	select DMA_DIRECT_OPS
 	select IOMMU_API
 	select IOMMU_IOVA
+	select NEED_DMA_MAP_STATE
 	select DMAR_TABLE
 	help
 	  DMA remapping (DMAR) devices support enables independent address
diff --git a/drivers/irqchip/Kconfig b/drivers/irqchip/Kconfig
index e9233db1..984abf2a 100644
--- a/drivers/irqchip/Kconfig
+++ b/drivers/irqchip/Kconfig
@@ -8,7 +8,7 @@ config ARM_GIC
 	bool
 	select IRQ_DOMAIN
 	select IRQ_DOMAIN_HIERARCHY
-	select MULTI_IRQ_HANDLER
+	select GENERIC_IRQ_MULTI_HANDLER
 	select GENERIC_IRQ_EFFECTIVE_AFF_MASK
 
 config ARM_GIC_PM
@@ -34,7 +34,7 @@ config GIC_NON_BANKED
 config ARM_GIC_V3
 	bool
 	select IRQ_DOMAIN
-	select MULTI_IRQ_HANDLER
+	select GENERIC_IRQ_MULTI_HANDLER
 	select IRQ_DOMAIN_HIERARCHY
 	select PARTITION_PERCPU
 	select GENERIC_IRQ_EFFECTIVE_AFF_MASK
@@ -66,7 +66,7 @@ config ARM_NVIC
 config ARM_VIC
 	bool
 	select IRQ_DOMAIN
-	select MULTI_IRQ_HANDLER
+	select GENERIC_IRQ_MULTI_HANDLER
 
 config ARM_VIC_NR
 	int
@@ -93,14 +93,14 @@ config ATMEL_AIC_IRQ
 	bool
 	select GENERIC_IRQ_CHIP
 	select IRQ_DOMAIN
-	select MULTI_IRQ_HANDLER
+	select GENERIC_IRQ_MULTI_HANDLER
 	select SPARSE_IRQ
 
 config ATMEL_AIC5_IRQ
 	bool
 	select GENERIC_IRQ_CHIP
 	select IRQ_DOMAIN
-	select MULTI_IRQ_HANDLER
+	select GENERIC_IRQ_MULTI_HANDLER
 	select SPARSE_IRQ
 
 config I8259
@@ -137,7 +137,7 @@ config DW_APB_ICTL
 config FARADAY_FTINTC010
 	bool
 	select IRQ_DOMAIN
-	select MULTI_IRQ_HANDLER
+	select GENERIC_IRQ_MULTI_HANDLER
 	select SPARSE_IRQ
 
 config HISILICON_IRQ_MBIGEN
@@ -162,7 +162,7 @@ config CLPS711X_IRQCHIP
 	bool
 	depends on ARCH_CLPS711X
 	select IRQ_DOMAIN
-	select MULTI_IRQ_HANDLER
+	select GENERIC_IRQ_MULTI_HANDLER
 	select SPARSE_IRQ
 	default y
 
@@ -181,7 +181,7 @@ config OMAP_IRQCHIP
 config ORION_IRQCHIP
 	bool
 	select IRQ_DOMAIN
-	select MULTI_IRQ_HANDLER
+	select GENERIC_IRQ_MULTI_HANDLER
 
 config PIC32_EVIC
 	bool
@@ -372,3 +372,28 @@ config QCOM_PDC
 	  IRQs for Qualcomm Technologies Inc (QTI) mobile chips.
 
 endmenu
+
+config RISCV_INTC
+	def_bool y if RISCV
+	#bool "RISC-V Interrupt Controller"
+	depends on RISCV
+	default y
+	help
+	   This enables support for the local interrupt controller found in
+	   standard RISC-V systems.  The local interrupt controller handles
+	   timer interrupts, software interrupts, and hardware interrupts.
+	   Without a local interrupt controller the system will be unable to
+	   handle any interrupts, including those passed via the PLIC.
+
+config RISCV_PLIC
+	bool "Platform-Level Interrupt Controller"
+	depends on RISCV
+	default y
+	help
+	   This enables support for the PLIC chip found in standard RISC-V
+	   systems.  The PLIC controls devices interrupts and connects them to
+	   each core's local interrupt controller.  Aside from timer and
+	   software interrupts, all other interrupt sources (MSI, GPIO, etc)
+	   are subordinate to the PLIC.
+
+	   If you don't know what to do here, say Y.
diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
index 5ed465ab..432fcd23 100644
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -87,3 +87,5 @@ obj-$(CONFIG_MESON_IRQ_GPIO)		+= irq-meson-gpio.o
 obj-$(CONFIG_GOLDFISH_PIC) 		+= irq-goldfish-pic.o
 obj-$(CONFIG_NDS32)			+= irq-ativic32.o
 obj-$(CONFIG_QCOM_PDC)			+= qcom-pdc.o
+obj-$(CONFIG_RISCV_INTC)		+= irq-riscv-intc.o
+obj-$(CONFIG_RISCV_PLIC)		+= irq-riscv-plic.o
diff --git a/drivers/irqchip/irq-riscv-intc.c b/drivers/irqchip/irq-riscv-intc.c
new file mode 100644
index 00000000..bead3eca
--- /dev/null
+++ b/drivers/irqchip/irq-riscv-intc.c
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2012 Regents of the University of California
+ * Copyright (C) 2017 SiFive
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/interrupt.h>
+#include <linux/ftrace.h>
+#include <linux/of.h>
+#include <linux/seq_file.h>
+
+#include <asm/ptrace.h>
+#include <asm/sbi.h>
+#include <asm/smp.h>
+
+#ifdef CONFIG_PERF_EVENTS
+#include <asm/perf_event.h>
+#endif
+
+#define PTR_BITS (8 * sizeof(uintptr_t))
+
+struct riscv_irq_data {
+	struct irq_chip		chip;
+	struct irq_domain	*domain;
+	int			hart;
+	char			name[20];
+};
+DEFINE_PER_CPU(struct riscv_irq_data, riscv_irq_data);
+
+static void riscv_software_interrupt(void)
+{
+#ifdef CONFIG_SMP
+	irqreturn_t ret;
+
+	ret = handle_ipi();
+
+	WARN_ON(ret == IRQ_NONE);
+#else
+	/*
+	 * We currently only use software interrupts to pass inter-processor
+	 * interrupts, so if a non-SMP system gets a software interrupt then we
+	 * don't know what to do.
+	 */
+	pr_warning("Software Interrupt without CONFIG_SMP\n");
+#endif
+}
+
+void riscv_intc_irq(struct pt_regs *regs)
+{
+	struct pt_regs *old_regs = set_irq_regs(regs);
+	struct irq_domain *domain;
+	unsigned long cause = csr_read(scause);
+	/*
+	 * The high order bit of the trap cause register is always set for
+	 * interrupts, which allows us to differentiate them from exceptions
+	 * quickly.  The INTERRUPT_CAUSE_* macros don't contain that bit, so we
+	 * need to mask it off here.
+	 */
+	WARN_ON((cause & (1UL << (PTR_BITS - 1))) == 0);
+	cause = cause & ~(1UL << (PTR_BITS - 1));
+
+	irq_enter();
+
+	/*
+	 * There are three classes of interrupt: timer, software, and
+	 * external devices.  We dispatch between them here.  External
+	 * device interrupts use the generic IRQ mechanisms.
+	 */
+	switch (cause) {
+	case INTERRUPT_CAUSE_TIMER:
+		riscv_timer_interrupt();
+		break;
+	case INTERRUPT_CAUSE_SOFTWARE:
+		riscv_software_interrupt();
+		break;
+#ifdef CONFIG_PERF_EVENTS
+	case INTERRUPT_CAUSE_PMU:
+		riscv_perf_interrupt(regs);
+		break;
+#endif
+	default:
+		domain = per_cpu(riscv_irq_data, smp_processor_id()).domain;
+		generic_handle_irq(irq_find_mapping(domain, cause));
+		break;
+	}
+
+	irq_exit();
+	set_irq_regs(old_regs);
+}
+
+static int riscv_irqdomain_map(struct irq_domain *d, unsigned int irq,
+			       irq_hw_number_t hwirq)
+{
+	struct riscv_irq_data *data = d->host_data;
+
+	irq_set_chip_and_handler(irq, &data->chip, handle_simple_irq);
+	irq_set_chip_data(irq, data);
+	irq_set_noprobe(irq);
+	irq_set_affinity(irq, cpumask_of(data->hart));
+
+	return 0;
+}
+
+static const struct irq_domain_ops riscv_irqdomain_ops = {
+	.map	= riscv_irqdomain_map,
+	.xlate	= irq_domain_xlate_onecell,
+};
+
+/*
+ * On RISC-V systems local interrupts are masked or unmasked by writing the SIE
+ * (Supervisor Interrupt Enable) CSR.  As CSRs can only be written on the local
+ * hart, these functions can only be called on the hart that corresponds to the
+ * IRQ chip.  They are only called internally to this module, so they BUG_ON if
+ * this condition is violated rather than attempting to handle the error by
+ * forwarding to the target hart, as that's already expected to have been done.
+ */
+static void riscv_irq_mask(struct irq_data *d)
+{
+	struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);
+
+	BUG_ON(smp_processor_id() != data->hart);
+	csr_clear(sie, 1 << (long)d->hwirq);
+}
+
+static void riscv_irq_unmask(struct irq_data *d)
+{
+	struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);
+
+	BUG_ON(smp_processor_id() != data->hart);
+	csr_set(sie, 1 << (long)d->hwirq);
+}
+
+/* Callbacks for twiddling SIE on another hart. */
+static void riscv_irq_enable_helper(void *d)
+{
+	riscv_irq_unmask(d);
+}
+
+static void riscv_irq_disable_helper(void *d)
+{
+	riscv_irq_mask(d);
+}
+
+static void riscv_remote_ctrl(unsigned int cpu, void (*fn)(void *d),
+                              struct irq_data *data)
+{
+	smp_call_function_single(cpu, fn, data, true);
+}
+
+static void riscv_irq_enable(struct irq_data *d)
+{
+	struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);
+
+	/*
+	 * It's only possible to write SIE on the current hart.  This jumps
+	 * over to the target hart if it's not the current one.  It's invalid
+	 * to write SIE on a hart that's not currently running.
+	 */
+	if (data->hart == smp_processor_id())
+		riscv_irq_unmask(d);
+	else if (cpu_online(data->hart)) // BUG: other cores not be brought in this phase
+		riscv_remote_ctrl(data->hart, riscv_irq_enable_helper, d);
+	//else
+		//WARN_ON_ONCE(1);
+}
+
+static void riscv_irq_disable(struct irq_data *d)
+{
+	struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);
+
+	/*
+	 * It's only possible to write SIE on the current hart.  This jumps
+	 * over to the target hart if it's not the current one.  It's invalid
+	 * to write SIE on a hart that's not currently running.
+	 */
+	if (data->hart == smp_processor_id())
+		riscv_irq_mask(d);
+	else if (cpu_online(data->hart))
+		riscv_remote_ctrl(data->hart, riscv_irq_disable_helper, d);
+	else
+		WARN_ON_ONCE(1);
+}
+
+static int __init riscv_intc_init(struct device_node *node, struct device_node *parent)
+{
+	int hart;
+	struct riscv_irq_data *data;
+
+	if (parent)
+		return 0;
+
+	hart = riscv_of_processor_hart(node->parent);
+	if (hart < 0)
+		return -EIO;
+
+	data = &per_cpu(riscv_irq_data, hart);
+	snprintf(data->name, sizeof(data->name), "riscv,cpu_intc,%d", hart);
+	data->hart = hart;
+	data->chip.name = data->name;
+	data->chip.irq_mask = riscv_irq_mask;
+	data->chip.irq_unmask = riscv_irq_unmask;
+	data->chip.irq_enable = riscv_irq_enable;
+	data->chip.irq_disable = riscv_irq_disable;
+	data->domain = irq_domain_add_linear(node, PTR_BITS,
+					     &riscv_irqdomain_ops, data);
+	if (!data->domain)
+		goto error_add_linear;
+
+	set_handle_irq(&riscv_intc_irq);
+
+	pr_info("%s: %lu local interrupts mapped\n", data->name, PTR_BITS);
+	return 0;
+
+error_add_linear:
+	pr_warning("%s: unable to add IRQ domain\n",
+		   data->name);
+	return -ENXIO;
+}
+
+IRQCHIP_DECLARE(riscv, "riscv,cpu-intc", riscv_intc_init);
diff --git a/drivers/irqchip/irq-riscv-plic.c b/drivers/irqchip/irq-riscv-plic.c
new file mode 100644
index 00000000..8750470a
--- /dev/null
+++ b/drivers/irqchip/irq-riscv-plic.c
@@ -0,0 +1,593 @@
+/*
+ * Copyright (C) 2017 SiFive
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+
+/*
+ * From the RISC-V Privlidged Spec v1.10:
+ *
+ * Global interrupt sources are assigned small unsigned integer identifiers,
+ * beginning at the value 1.  An interrupt ID of 0 is reserved to mean “no
+ * interrupt”.  Interrupt identifiers are also used to break ties when two or
+ * more interrupt sources have the same assigned priority. Smaller values of
+ * interrupt ID take precedence over larger values of interrupt ID.
+ *
+ * While the RISC-V supervisor spec doesn't define the maximum number of
+ * devices supported by the PLIC, the largest number supported by devices
+ * marked as 'riscv,plic0' (which is the only device type this driver supports,
+ * and is the only extant PLIC as of now) is 1024.  As mentioned above, device
+ * 0 is defined to be non-existant so this device really only supports 1023
+ * devices.
+ */
+#define MAX_DEVICES	1024
+#define MAX_USE_REGS	(MAX_DEVICES / 32)
+#define MAX_CONTEXTS	15872
+
+/*
+ * The PLIC consists of memory-mapped control registers, with a memory map as
+ * follows:
+ *
+ * base + 0x000000: Reserved (interrupt source 0 does not exist)
+ * base + 0x000004: Interrupt source 1 priority
+ * base + 0x000008: Interrupt source 2 priority
+ * ...
+ * base + 0x000FFC: Interrupt source 1023 priority
+ * base + 0x001000: Pending 0
+ * base + 0x001FFF: Pending
+ * base + 0x002000: Enable bits for sources 0-31 on context 0
+ * base + 0x002004: Enable bits for sources 32-63 on context 0
+ * ...
+ * base + 0x0020FC: Enable bits for sources 992-1023 on context 0
+ * base + 0x002080: Enable bits for sources 0-31 on context 1
+ * ...
+ * base + 0x002100: Enable bits for sources 0-31 on context 2
+ * ...
+ * base + 0x1F1F80: Enable bits for sources 992-1023 on context 15871
+ * base + 0x1F1F84: Reserved
+ * ...              (higher context IDs would fit here, but wouldn't fit
+ *                   inside the per-context priority vector)
+ * base + 0x1FFFFC: Reserved
+ * base + 0x200000: Priority threshold for context 0
+ * base + 0x200004: Claim/complete for context 0
+ * base + 0x200008: Reserved
+ * ...
+ * base + 0x200FFC: Reserved
+ * base + 0x201000: Priority threshold for context 1
+ * base + 0x201004: Claim/complete for context 1
+ * ...
+ * base + 0xFFE000: Priority threshold for context 15871
+ * base + 0xFFE004: Claim/complete for context 15871
+ * base + 0xFFE008: Reserved
+ * ...
+ * base + 0xFFFFFC: Reserved
+ *
+ * V5 Support:
+ *
+ * base + 0x000000: V5 Feature enable register (vectored/preempt)
+ *
+ * base + 0x001000: V5 Interrupt pending array
+ * base + 0x001080: V5 Trigger type array (read-only)
+ * base + 0x001100: V5 Number of interrupts and targets (read-only)
+ * base + 0x001104: V5 Version and max priority register (read-only)
+ *
+ * base + 0x200400: V5 Preempted priority stack for context 0
+ * ...
+ * base + 0x20041F: V5 Preempted priority stack for context 0
+ * base + 0x201400: V5 Preempted priority stack for context 1
+ * base + 0xFFE400: V5 Preempted priority stack for context 15871
+ */
+
+/* Each interrupt source has a priority register associated with it. */
+#define PRIORITY_BASE		0
+#define PRIORITY_PER_ID		4
+
+/*
+ * Each hart context has a vector of interupt enable bits associated with it.
+ * There's one bit for each interrupt source.
+ */
+#define ENABLE_BASE		0x2000
+#define ENABLE_PER_HART		0x80
+
+/*
+ * Each hart context has a set of control registers associated with it.  Right
+ * now there's only two: a source priority threshold over which the hart will
+ * take an interrupt, and a register to claim interrupts.
+ */
+#define CONTEXT_BASE		0x200000
+#define CONTEXT_PER_HART	0x1000
+#define CONTEXT_THRESHOLD	0
+#define CONTEXT_CLAIM		4
+
+/* V5 Support */
+#ifdef CONFIG_PLIC_NCEPLIC100
+#define FEATURE_ENABLE_BASE	0
+#define FEATURE_PREEMPT		0
+#define FEATURE_VECTORED	1
+
+#define INFO_BASE		0x1000
+#define INFO_PENDING_RW		0x0
+#define INFO_TRIGGER_TYPE	0x80
+#define INFO_NUMBER		0x100
+#define INFO_VER_AND_MAX	0x104
+
+#define CONTEXT_PREEMPT		0x400	// base on CONTEXT_BASE
+#endif
+
+/*
+ * PLIC devices are named like 'riscv,plic0,%llx', this is enough space to
+ * store that name.
+ */
+#define PLIC_DATA_NAME_SIZE 30
+
+struct plic_handler {
+	bool			present;
+	int			contextid;
+	struct plic_data	*data;
+};
+
+struct plic_data {
+	struct irq_chip		chip;
+	struct irq_domain	*domain;
+	u32			ndev;
+	void __iomem		*reg;
+	int			handlers;
+	struct plic_handler	*handler;
+	char			name[PLIC_DATA_NAME_SIZE];
+	spinlock_t		lock;
+};
+
+/* Addressing helper functions. */
+static inline
+u32 __iomem *plic_enable_vector(struct plic_data *data, int contextid)
+{
+	return data->reg + ENABLE_BASE + contextid * ENABLE_PER_HART;
+}
+
+static inline
+u32 __iomem *plic_priority(struct plic_data *data, int hwirq)
+{
+	return data->reg + PRIORITY_BASE + hwirq * PRIORITY_PER_ID;
+}
+
+static inline
+u32 __iomem *plic_hart_threshold(struct plic_data *data, int contextid)
+{
+	return data->reg + CONTEXT_BASE + CONTEXT_PER_HART * contextid + CONTEXT_THRESHOLD;
+}
+
+static inline
+u32 __iomem *plic_hart_claim(struct plic_data *data, int contextid)
+{
+	return data->reg + CONTEXT_BASE + CONTEXT_PER_HART * contextid + CONTEXT_CLAIM;
+}
+
+/* V5 support */
+#ifdef CONFIG_PLIC_NCEPLIC100
+static inline
+u32 __iomem *plic_hart_feature_enable(struct plic_data *data)
+{
+	return data->reg + FEATURE_ENABLE_BASE;
+}
+
+static inline
+u32 __iomem *plic_hart_pending(struct plic_data *data)
+{
+	return data->reg + INFO_BASE + INFO_PENDING_RW;
+}
+
+static inline
+u32 __iomem *plic_hart_trigger_type(struct plic_data *data)
+{
+	return data->reg + INFO_BASE + INFO_TRIGGER_TYPE;
+}
+
+static inline
+u32 __iomem *plic_hart_number(struct plic_data *data)
+{
+	return data->reg + INFO_BASE + INFO_NUMBER;
+}
+
+static inline
+u32 __iomem *plic_hart_version_and_max(struct plic_data *data)
+{
+	return data->reg + INFO_BASE + INFO_VER_AND_MAX;
+}
+
+static inline
+u32 __iomem *plic_hart_preempt(struct plic_data *data, int contextid)
+{
+	return data->reg +
+	       CONTEXT_BASE + CONTEXT_PER_HART * contextid + CONTEXT_PREEMPT;
+}
+#endif
+
+/*
+ * Handling an interrupt is a two-step process: first you claim the interrupt
+ * by reading the claim register, then you complete the interrupt by writing
+ * that source ID back to the same claim register.  This automatically enables
+ * and disables the interrupt, so there's nothing else to do.
+ */
+static inline
+u32 plic_claim(struct plic_data *data, int contextid)
+{
+	return readl(plic_hart_claim(data, contextid));
+}
+
+static inline
+void plic_complete(struct plic_data *data, int contextid, u32 claim)
+{
+	writel(claim, plic_hart_claim(data, contextid));
+}
+
+/* Explicit interrupt masking. */
+static void plic_disable(struct plic_data *data, int contextid, int hwirq)
+{
+	u32 __iomem *reg = plic_enable_vector(data, contextid) + (hwirq / 32);
+	u32 mask = ~(1 << (hwirq % 32));
+
+	spin_lock(&data->lock);
+	writel(readl(reg) & mask, reg);
+	spin_unlock(&data->lock);
+}
+
+static void plic_enable(struct plic_data *data, int contextid, int hwirq)
+{
+	u32 __iomem *reg = plic_enable_vector(data, contextid) + (hwirq / 32);
+	u32 bit = 1 << (hwirq % 32);
+
+	spin_lock(&data->lock);
+	writel(readl(reg) | bit, reg);
+	spin_unlock(&data->lock);
+}
+
+/*
+ * There is no need to mask/unmask PLIC interrupts
+ * They are "masked" by reading claim and "unmasked" when writing it back.
+ */
+static void plic_irq_mask(struct irq_data *d) { }
+static void plic_irq_unmask(struct irq_data *d) { }
+
+static void plic_irq_enable(struct irq_data *d)
+{
+	struct plic_data *data = irq_data_get_irq_chip_data(d);
+	void __iomem *priority = plic_priority(data, d->hwirq);
+	int i;
+
+	writel(1, priority);
+	for (i = 0; i < data->handlers; ++i)
+		if (data->handler[i].present)
+			plic_enable(data, i, d->hwirq);
+}
+
+static void plic_irq_disable(struct irq_data *d)
+{
+	struct plic_data *data = irq_data_get_irq_chip_data(d);
+	void __iomem *priority = plic_priority(data, d->hwirq);
+	int i;
+
+	writel(0, priority);
+	for (i = 0; i < data->handlers; ++i)
+		if (data->handler[i].present)
+			plic_disable(data, i, d->hwirq);
+}
+
+static void plic_irq_eoi(struct irq_data *d)
+{
+	/* FIXME: I can't figure out what's going on here: when I set the PLIC
+	 * driver to use hadle_fasteoi_irq I end up with !handler here.  The
+	 * difference is that here we get an irq_data and use
+	 * common.handler_data, while in the working version we get an
+	 * irq_desc and use irq_common_data.handler_data. */
+	struct plic_handler *handler = d->common->handler_data;
+	BUG_ON(!handler);
+	plic_complete(handler->data, handler->contextid, d->hwirq);
+}
+
+static int plic_irqdomain_map(struct irq_domain *d, unsigned int irq,
+			      irq_hw_number_t hwirq)
+{
+	struct plic_data *data = d->host_data;
+
+	/* FIXME: ... I want to set handle_fasteoi_irq here. */
+	irq_set_chip_and_handler(irq, &data->chip, handle_simple_irq);
+	irq_set_chip_data(irq, data);
+	irq_set_noprobe(irq);
+
+	return 0;
+}
+
+/* V5 Support */
+#ifdef CONFIG_PLIC_NCEPLIC100
+static void plic_enable_preempt(struct plic_data *data)
+{
+	u32 __iomem *reg = plic_hart_feature_enable(data);
+	u32 mask = 1 << FEATURE_PREEMPT;
+
+	spin_lock(&data->lock);
+	writel(readl(reg) | mask, reg);
+	spin_unlock(&data->lock);
+}
+
+static void plic_disable_preempt(struct plic_data *data)
+{
+	u32 __iomem *reg = plic_hart_feature_enable(data);
+	u32 mask = ~(1 << FEATURE_PREEMPT);
+
+	spin_lock(&data->lock);
+	writel(readl(reg) & mask, reg);
+	spin_unlock(&data->lock);
+}
+
+static void plic_enable_pending(struct plic_data *data, int hwirq, int val)
+{
+	u32 __iomem *reg = plic_hart_pending(data) + (hwirq / 32);
+	u32 bit = 1 << (hwirq % 32);
+
+	spin_lock(&data->lock);
+	writel(readl(reg) | bit, reg);
+	spin_unlock(&data->lock);
+}
+
+static void plic_disable_pending(struct plic_data *data, int hwirq, int val)
+{
+	u32 __iomem *reg = plic_hart_pending(data) + (hwirq / 32);
+	u32 mask = ~(1 << (hwirq % 32));
+
+	spin_lock(&data->lock);
+	writel(readl(reg) & mask, reg);
+	spin_unlock(&data->lock);
+}
+
+static u32 plic_get_pending(struct plic_data *data, int hwirq)
+{
+	u32 __iomem *reg = plic_hart_pending(data) + (hwirq / 32);
+	u32 mask = 1 << (hwirq % 32);
+
+	return (readl(reg) & mask) >> (hwirq % 32);
+}
+
+static u32 plic_get_trigger_type(struct plic_data *data, int hwirq)
+{
+	u32 __iomem *reg = plic_hart_trigger_type(data) + (hwirq / 32);
+	u32 mask = 1 << (hwirq % 32);
+
+	return (readl(reg) & mask) >> (hwirq % 32);
+}
+
+static u32 plic_get_target_total(struct plic_data *data)
+{
+	return readl(plic_hart_number(data)) & 0x0000ffff;
+}
+
+static u32 plic_get_interrupt_total(struct plic_data *data)
+{
+	return readl(plic_hart_number(data)) >> 16;
+}
+
+static u32 plic_get_version(struct plic_data *data)
+{
+	return readl(plic_hart_version_and_max(data)) & 0x0000ffff;
+}
+
+static u32 plic_get_max_priority(struct plic_data *data)
+{
+	return readl(plic_hart_version_and_max(data)) >> 16;
+}
+#endif
+
+static const struct irq_domain_ops plic_irqdomain_ops = {
+	.map	= plic_irqdomain_map,
+	.xlate	= irq_domain_xlate_onecell,
+};
+
+u32 __iomem *plic_base;
+unsigned int *wake_mask;
+unsigned int *orig;
+
+static int plic_set_wake(struct irq_data *d, unsigned int on)
+{
+	struct plic_data *data = irq_data_get_irq_chip_data(d);
+	u32 bit[MAX_USE_REGS];
+	u32 offset = d->hwirq / 32;
+	int i;
+
+	plic_base = data->reg;
+	bit[offset] = 1 << (d->hwirq % 32);
+
+	if (on)
+		__assign_bit(d->hwirq, (unsigned long *)wake_mask, true);
+	else
+		__assign_bit(d->hwirq, (unsigned long *)wake_mask, false);
+
+	for(i = 0; i < data->handlers; ++i) {
+		if (data->handler[i].present) {
+			unsigned int int_mask[MAX_USE_REGS];
+			u32 __iomem *reg = plic_enable_vector(data,
+						data->handler[i].contextid)
+						+ offset;
+			u32 target_area = i * MAX_USE_REGS;
+
+			int_mask[offset] = readl(reg);
+			if (on) {
+				if (int_mask[offset] & bit[offset])
+					__assign_bit(d->hwirq,
+						    (unsigned long *)&orig[target_area],
+						    true);
+				else
+					__assign_bit(d->hwirq,
+						    (unsigned long *)&orig[target_area],
+						    false);
+
+				__assign_bit(d->hwirq, (unsigned long *)int_mask, true);
+			} else {
+				if (!(orig[target_area] & bit[offset]))
+					__assign_bit(d->hwirq,
+						(unsigned long *)int_mask, false);
+
+				__assign_bit(d->hwirq, (unsigned long *)&orig[target_area],
+					    false);
+			}
+			writel(int_mask[offset], reg);
+		}
+	}
+	return 0;
+}
+
+static void plic_chained_handle_irq(struct irq_desc *desc)
+{
+	struct plic_handler *handler = irq_desc_get_handler_data(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct irq_domain *domain = handler->data->domain;
+	u32 what;
+
+	chained_irq_enter(chip, desc);
+
+	while ((what = plic_claim(handler->data, handler->contextid))) {
+		int irq = irq_find_mapping(domain, what);
+
+		if (irq > 0)
+			generic_handle_irq(irq);
+		else
+			handle_bad_irq(desc);
+		plic_complete(handler->data, handler->contextid, what);
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+static int plic_init(struct device_node *node, struct device_node *parent)
+{
+	struct plic_data *data;
+	struct resource resource;
+	int i, ok = 0;
+	int out = -1;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (WARN_ON(!data))
+		return -ENOMEM;
+
+	spin_lock_init(&data->lock);
+
+	data->reg = of_iomap(node, 0);
+	if (WARN_ON(!data->reg)) {
+		out = -EIO;
+		goto free_data;
+	}
+
+	of_property_read_u32(node, "riscv,ndev", &data->ndev);
+	if (WARN_ON(!data->ndev)) {
+		out = -EINVAL;
+		goto free_reg;
+	}
+
+	data->handlers = of_irq_count(node);
+	if (WARN_ON(!data->handlers)) {
+		out = -EINVAL;
+		goto free_reg;
+	}
+
+	data->handler =
+		kcalloc(data->handlers, sizeof(*data->handler), GFP_KERNEL);
+	if (WARN_ON(!data->handler)) {
+		out = -ENOMEM;
+		goto free_reg;
+	}
+
+	data->domain = irq_domain_add_linear(node, data->ndev+1, &plic_irqdomain_ops, data);
+	if (WARN_ON(!data->domain)) {
+		out = -ENOMEM;
+		goto free_handler;
+	}
+
+	wake_mask = kzalloc(MAX_USE_REGS * sizeof(u32), GFP_KERNEL);
+	if (WARN_ON(!wake_mask))
+		return -ENOMEM;
+
+	orig = kzalloc(data->handlers * MAX_USE_REGS * sizeof(u32), GFP_KERNEL);
+	if (WARN_ON(!orig))
+		return -ENOMEM;
+
+	of_address_to_resource(node, 0, &resource);
+	snprintf(data->name, sizeof(data->name),
+		 "riscv,plic0,%llx", resource.start);
+	data->chip.name = data->name;
+	data->chip.irq_mask = plic_irq_mask;
+	data->chip.irq_unmask = plic_irq_unmask;
+	data->chip.irq_enable = plic_irq_enable;
+	data->chip.irq_disable = plic_irq_disable;
+	data->chip.irq_eoi = plic_irq_eoi;
+	data->chip.irq_set_wake = plic_set_wake;
+
+	for (i = 0; i < data->handlers; ++i) {
+		struct plic_handler *handler = &data->handler[i];
+		struct of_phandle_args parent;
+		int parent_irq, hwirq;
+
+		handler->present = false;
+
+		if (of_irq_parse_one(node, i, &parent))
+			continue;
+		/* skip context holes */
+		if (parent.args[0] == -1)
+			continue;
+
+		/* skip any contexts that lead to inactive harts */
+		if (of_device_is_compatible(parent.np, "riscv,cpu-intc") &&
+		    parent.np->parent &&
+		    riscv_of_processor_hart(parent.np->parent) < 0)
+			continue;
+
+		parent_irq = irq_create_of_mapping(&parent);
+		if (!parent_irq)
+			continue;
+
+		handler->present = true;
+		handler->contextid = i;
+		handler->data = data;
+		/* hwirq prio must be > this to trigger an interrupt */
+		writel(0, plic_hart_threshold(data, i));
+
+		for (hwirq = 1; hwirq <= data->ndev; ++hwirq)
+			plic_disable(data, i, hwirq);
+		irq_set_chained_handler_and_data(parent_irq, plic_chained_handle_irq, handler);
+		++ok;
+	}
+
+	pr_info("%s: mapped %d interrupts to %d/%d handlers\n",
+	        data->name, data->ndev, ok, data->handlers);
+	WARN_ON(!ok);
+	return 0;
+
+free_handler:
+	kfree(data->handler);
+free_reg:
+	iounmap(data->reg);
+free_data:
+	kfree(data);
+	kfree(wake_mask);
+	kfree(orig);
+	return out;
+}
+
+IRQCHIP_DECLARE(plic0, "riscv,plic0", plic_init);
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 9589f9c9..742f0432 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -509,6 +509,14 @@ config MMC_DAVINCI
           If you have an DAVINCI board with a Multimedia Card slot,
           say Y or M here.  If unsure, say N.
 
+config MMC_FTSDC
+        tristate "Andestech SDC Multimedia Card Interface support"
+        depends on RISCV
+        help
+          This selects the TI DAVINCI Multimedia card Interface.
+          If you have an DAVINCI board with a Multimedia Card slot,
+          say Y or M here.  If unsure, say N.
+
 config MMC_GOLDFISH
 	tristate "goldfish qemu Multimedia Card Interface support"
 	depends on HAS_DMA
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 6aead248..2dcd29ea 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_MMC_ATMELMCI)	+= atmel-mci.o
 obj-$(CONFIG_MMC_TIFM_SD)	+= tifm_sd.o
 obj-$(CONFIG_MMC_MVSDIO)	+= mvsdio.o
 obj-$(CONFIG_MMC_DAVINCI)       += davinci_mmc.o
+obj-$(CONFIG_MMC_FTSDC)         += ftsdc010.o
 obj-$(CONFIG_MMC_GOLDFISH)	+= android-goldfish.o
 obj-$(CONFIG_MMC_SPI)		+= mmc_spi.o
 ifeq ($(CONFIG_OF),y)
diff --git a/drivers/mmc/host/ftsdc010.c b/drivers/mmc/host/ftsdc010.c
new file mode 100644
index 00000000..56448a30
--- /dev/null
+++ b/drivers/mmc/host/ftsdc010.c
@@ -0,0 +1,1557 @@
+/* drivers/mmc/host/ftsdc010.c
+ *  Copyright (C) 2010 Andestech
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/card.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <asm/io.h>
+#include <asm/dmad.h>
+#include "ftsdc010.h"
+#include "../core/core.h"
+
+#define DRIVER_NAME "ftsdc010"
+#define REG_READ(addr) readl((host->base + addr))
+#define REG_WRITE(data, addr) writel((data), (host->base + addr))
+
+enum dbg_channels {
+	dbg_err   = (1 << 0),
+	dbg_debug = (1 << 1),
+	dbg_info  = (1 << 2),
+	dbg_irq   = (1 << 3),
+	dbg_sg    = (1 << 4),
+	dbg_dma   = (1 << 5),
+	dbg_pio   = (1 << 6),
+	dbg_fail  = (1 << 7),
+	dbg_conf  = (1 << 8),
+};
+
+static struct workqueue_struct *mywq;
+
+static const int dbgmap_err   = dbg_fail;
+static const int dbgmap_info  = dbg_info | dbg_conf;
+static const int dbgmap_debug = dbg_err | dbg_debug | dbg_info | dbg_conf;
+#define dbg(host, channels, args...)		  \
+	do {					  \
+	if (dbgmap_err & channels) 		  \
+		dev_err(&host->pdev->dev, args);  \
+	else if (dbgmap_info & channels)	  \
+		dev_info(&host->pdev->dev, args); \
+	else if (dbgmap_debug & channels)	  \
+		dev_dbg(&host->pdev->dev, args);  \
+	} while (0)
+static void finalize_request(struct ftsdc_host *host);
+static void ftsdc_send_request(struct mmc_host *mmc);
+#ifdef CONFIG_MMC_DEBUG
+static void dbg_dumpregs(struct ftsdc_host *host, char *prefix)
+{
+	u32 con, cmdarg, r0, r1, r2, r3, rcmd, dcon, dtimer,
+	    dlen, sta, clr, imask, pcon, ccon, bwidth, scon1,
+	    scon2, ssta, fea;
+
+	con	= REG_READ(SDC_CMD_REG);
+	cmdarg	= REG_READ(SDC_ARGU_REG);
+	r0	= REG_READ(SDC_RESPONSE0_REG);
+	r1	= REG_READ(SDC_RESPONSE1_REG);
+	r2	= REG_READ(SDC_RESPONSE2_REG);
+	r3	= REG_READ(SDC_RESPONSE3_REG);
+	rcmd	= REG_READ(SDC_RSP_CMD_REG);
+	dcon	= REG_READ(SDC_DATA_CTRL_REG);
+	dtimer	= REG_READ(SDC_DATA_TIMER_REG);
+	dlen	= REG_READ(SDC_DATA_LEN_REG);
+	sta	= REG_READ(SDC_STATUS_REG);
+	clr	= REG_READ(SDC_CLEAR_REG);
+	imask	= REG_READ(SDC_INT_MASK_REG);
+	pcon	= REG_READ(SDC_POWER_CTRL_REG);
+	ccon	= REG_READ(SDC_CLOCK_CTRL_REG);
+	bwidth	= REG_READ(SDC_BUS_WIDTH_REG);
+	scon1	= REG_READ(SDC_SDIO_CTRL1_REG);
+	scon2	= REG_READ(SDC_SDIO_CTRL2_REG);
+	ssta	= REG_READ(SDC_SDIO_STATUS_REG);
+	fea	= REG_READ(SDC_FEATURE_REG);
+
+	dbg(host, dbg_debug, "%s CON:[%08x]  STA:[%08x]  INT:[%08x], PWR:[%08x], CLK:[%08x]\n",
+				prefix, con, sta, imask, pcon, ccon);
+
+	dbg(host, dbg_debug, "%s DCON:[%08x] DTIME:[%08x]"
+			       " DLEN:[%08x] DWIDTH:[%08x]\n",
+				prefix, dcon, dtimer, dlen, bwidth);
+
+	dbg(host, dbg_debug, "%s R0:[%08x]   R1:[%08x]"
+			       "   R2:[%08x]   R3:[%08x]\n",
+			       prefix, r0, r1, r2, r3);
+
+	dbg(host, dbg_debug, "%s SCON1:[%08x]   SCON2:[%08x]"
+			       "   SSTA:[%08x]   FEA:[%08x]\n",
+				prefix, scon1, scon2, ssta, fea);
+}
+
+static void prepare_dbgmsg(struct ftsdc_host *host, struct mmc_command *cmd,
+			   int stop)
+{
+	snprintf(host->dbgmsg_cmd, 300,
+		 "#%u%s op:%i arg:0x%08x flags:0x08%x retries:%u",
+		 host->ccnt, (stop ? " (STOP)" : ""),
+		 cmd->opcode, cmd->arg, cmd->flags, cmd->retries);
+
+	if (cmd->data) {
+		snprintf(host->dbgmsg_dat, 300,
+			 "#%u bsize:%u blocks:%u bytes:%u",
+			 host->dcnt, cmd->data->blksz,
+			 cmd->data->blocks,
+			 cmd->data->blocks * cmd->data->blksz);
+	} else {
+		host->dbgmsg_dat[0] = '\0';
+	}
+}
+
+static void dbg_dumpcmd(struct ftsdc_host *host, struct mmc_command *cmd,
+			int fail)
+{
+	unsigned int dbglvl = fail ? dbg_fail : dbg_debug;
+
+	if (!cmd)
+		return;
+
+	if (cmd->error == 0) {
+		dbg(host, dbglvl, "CMD[OK] %s R0:0x%08x\n",
+			host->dbgmsg_cmd, cmd->resp[0]);
+	} else {
+		dbg(host, dbglvl, "CMD[ERR %i] %s Status:%s\n",
+			cmd->error, host->dbgmsg_cmd, host->status);
+	}
+
+	if (!cmd->data)
+		return;
+
+	if (cmd->data->error == 0) {
+		dbg(host, dbglvl, "DAT[OK] %s\n", host->dbgmsg_dat);
+	} else {
+		dbg(host, dbglvl, "DAT[ERR %i] %s DCNT:0x%08x\n",
+			cmd->data->error, host->dbgmsg_dat,
+			REG_READ(SDC_DATA_LEN_REG));
+	}
+}
+#else
+static void dbg_dumpcmd(struct ftsdc_host *host,
+			struct mmc_command *cmd, int fail) { }
+
+static void prepare_dbgmsg(struct ftsdc_host *host, struct mmc_command *cmd,
+			   int stop) { }
+
+static void dbg_dumpregs(struct ftsdc_host *host, char *prefix) { }
+
+#endif /* CONFIG_MMC_DEBUG */
+
+static inline bool ftsdc_dmaexist(struct ftsdc_host *host)
+{
+	return (host->dma_req != NULL);
+}
+
+static inline u32 enable_imask(struct ftsdc_host *host, u32 imask)
+{
+	u32 newmask;
+
+#ifdef CONFIG_MMC_DEBUG
+	if (imask & SDC_STATUS_REG_SDIO_INTR) printk("\n*** E ***\n");
+#endif
+	newmask = REG_READ(SDC_INT_MASK_REG);
+	newmask |= imask;
+
+	REG_WRITE(newmask, SDC_INT_MASK_REG);
+
+	return newmask;
+}
+
+static inline u32 disable_imask(struct ftsdc_host *host, u32 imask)
+{
+	u32 newmask;
+
+#ifdef CONFIG_MMC_DEBUG
+	if (imask & SDC_STATUS_REG_SDIO_INTR) printk("\n*** D ***\n");
+#endif
+	newmask = REG_READ(SDC_INT_MASK_REG);
+	newmask &= ~imask;
+
+	REG_WRITE(newmask, SDC_INT_MASK_REG);
+
+	return newmask;
+}
+
+static inline void clear_imask(struct ftsdc_host *host)
+{
+	u32 mask = REG_READ(SDC_INT_MASK_REG);
+
+	/* preserve the SDIO IRQ mask state */
+	mask &= (SDC_INT_MASK_REG_SDIO_INTR | SDC_INT_MASK_REG_CARD_CHANGE);
+	REG_WRITE(mask, SDC_INT_MASK_REG);
+}
+
+static inline void get_data_buffer(struct ftsdc_host *host)
+{
+	struct scatterlist *sg;
+
+	BUG_ON(host->buf_sgptr >= host->mrq->data->sg_len);
+
+	sg = &host->mrq->data->sg[host->buf_sgptr];
+
+	host->buf_bytes = sg->length;
+	host->buf_ptr = host->dodma ? (u32 *)sg->dma_address : sg_virt(sg);
+	host->buf_sgptr++;
+}
+
+static inline u32 cal_blksz(unsigned int blksz)
+{
+	u32 blksztwo = 0;
+
+	while (blksz >>= 1)
+		blksztwo++;
+
+	return blksztwo;
+}
+
+/**
+ * ftsdc_enable_irq - enable IRQ, after having disabled it.
+ * @host: The device state.
+ * @more: True if more IRQs are expected from transfer.
+ *
+ * Enable the main IRQ if needed after it has been disabled.
+ *
+ * The IRQ can be one of the following states:
+ *	- enable after data read/write
+ *	- disable when handle data read/write
+ */
+static void ftsdc_enable_irq(struct ftsdc_host *host, bool enable)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+
+	host->irq_enabled = enable;
+
+	if (enable)
+		enable_irq(host->irq);
+	else
+		disable_irq(host->irq);
+
+	local_irq_restore(flags);
+}
+
+static void do_pio_read(struct ftsdc_host *host)
+{
+	u32 fifo;
+	u32 fifo_words;
+	u32 *ptr;
+	u32 status;
+	u32 retry = 0;
+
+	BUG_ON(host->buf_bytes != 0);
+
+	while (host->buf_sgptr < host->mrq->data->sg_len) {
+		get_data_buffer(host);
+
+		dbg(host, dbg_pio,
+		    "pio_read(): new target: [%i]@[%p]\n",
+		    host->buf_bytes, host->buf_ptr);
+
+		while (host->buf_bytes) {
+			status = REG_READ(SDC_STATUS_REG);
+			if (status & SDC_STATUS_REG_FIFO_OVERRUN) {
+				fifo = host->fifo_len > host->buf_bytes ?
+					host->buf_bytes : host->fifo_len;
+				dbg(host, dbg_pio,
+				    "pio_read(): fifo:[%02i] buffer:[%03i] dcnt:[%08X]\n",
+				    fifo, host->buf_bytes,
+				    REG_READ(SDC_DATA_LEN_REG));
+				host->buf_bytes -= fifo;
+				host->buf_count += fifo;
+				fifo_words = fifo >> 2;
+				ptr = host->buf_ptr;
+				while (fifo_words--)
+					*ptr++ = REG_READ(SDC_DATA_WINDOW_REG);
+				host->buf_ptr = ptr;
+				if (fifo & 3) {
+					u32 n = fifo & 3;
+					u32 data = REG_READ(SDC_DATA_WINDOW_REG);
+					u8 *p = (u8 *)host->buf_ptr;
+
+					while (n--) {
+						*p++ = data;
+						data >>= 8;
+					}
+				}
+			} else {
+				udelay(1);
+				if (++retry >= SDC_PIO_RETRY) {
+					host->mrq->data->error = -EIO;
+					goto err;
+				}
+			}
+		}
+	}
+err:
+
+	host->buf_active = XFER_NONE;
+	host->complete_what = COMPLETION_FINALIZE;
+}
+
+static void do_pio_write(struct ftsdc_host *host)
+{
+	u32 fifo;
+	u32 *ptr;
+	u32 status;
+	u32 retry = 0;
+
+	BUG_ON(host->buf_bytes != 0);
+
+	while (host->buf_sgptr < host->mrq->data->sg_len) {
+		get_data_buffer(host);
+
+		dbg(host, dbg_pio,
+		    "pio_write(): new source: [%i]@[%p]\n",
+		    host->buf_bytes, host->buf_ptr);
+
+		while (host->buf_bytes) {
+			status = REG_READ(SDC_STATUS_REG);
+			if (status & SDC_STATUS_REG_FIFO_UNDERRUN) {
+				fifo = host->fifo_len > host->buf_bytes ?
+					host->buf_bytes : host->fifo_len;
+
+				dbg(host, dbg_pio,
+				    "pio_write(): fifo:[%02i] buffer:[%03i] dcnt:[%08X]\n",
+				    fifo, host->buf_bytes,
+				    REG_READ(SDC_DATA_LEN_REG));
+
+				host->buf_bytes -= fifo;
+				host->buf_count += fifo;
+
+				fifo = (fifo + 3) >> 2;
+				ptr = host->buf_ptr;
+				while (fifo--) {
+					REG_WRITE(*ptr, SDC_DATA_WINDOW_REG);
+					ptr++;
+				}
+				host->buf_ptr = ptr;
+			} else {
+				udelay(1);
+				if (++retry >= SDC_PIO_RETRY) {
+					host->mrq->data->error = -EIO;
+					goto err;
+				}
+			}
+		}
+	}
+
+err:
+	host->buf_active = XFER_NONE;
+	host->complete_what = COMPLETION_FINALIZE;
+}
+
+static void do_dma_access(struct ftsdc_host *host)
+{
+	int res;
+	unsigned long timeout;
+	dmad_chreq *req = host->dma_req;
+	dmad_drb *drb = 0;
+
+	while (host->buf_sgptr < host->mrq->data->sg_len) {
+
+		reinit_completion(&host->dma_complete);
+		get_data_buffer(host);
+
+		dbg(host, dbg_dma,
+		    "dma_%s(): new target: [%i]@[%p]\n",
+		    host->buf_active == XFER_READ ? "read" : "write",
+		    host->buf_bytes, host->buf_ptr);
+
+		res = dmad_alloc_drb(req, &drb);
+
+		if (res != 0 || (drb == 0)) {
+			dbg(host, dbg_err, "%s() Failed to allocate dma request block!\n", __func__);
+			host->mrq->data->error = -ENODEV;
+			goto err;
+		}
+		drb->addr0 = host->mem->start + SDC_DATA_WINDOW_REG;
+		drb->addr1 = (dma_addr_t)host->buf_ptr;
+		drb->req_cycle = dmad_bytes_to_cycles(req, host->buf_bytes);
+		drb->sync = &host->dma_complete;
+		timeout = SDC_TIMEOUT_BASE*((host->buf_bytes+511)>>9);
+		res =  dmad_submit_request(req, drb, 1);
+		if (res != 0) {
+			dbg(host, dbg_err, "%s() Failed to submit dma request block!\n", __func__);
+			host->mrq->data->error = -ENODEV;
+			goto err;
+		}
+		dbg(host, dbg_err, "reach here!\n");
+		if (wait_for_completion_timeout(&host->dma_complete, timeout) == 0) {
+			dbg(host, dbg_err, "%s: read timeout\n", __func__);
+			host->mrq->data->error = -ETIMEDOUT;
+			goto err;
+		}
+	}
+
+	host->dma_finish = true;
+err:
+	host->buf_active = XFER_NONE;
+	host->complete_what = COMPLETION_FINALIZE;
+}
+
+static void ftsdc_work(struct work_struct *work)
+{
+	struct ftsdc_host *host =
+		container_of(work, struct ftsdc_host, work);
+
+	ftsdc_enable_irq(host, false);
+	if (host->dodma) {
+		do_dma_access(host);
+	} else {
+		if (host->buf_active == XFER_WRITE)
+			do_pio_write(host);
+
+		if (host->buf_active == XFER_READ)
+			do_pio_read(host);
+	}
+
+	tasklet_schedule(&host->pio_tasklet);
+	ftsdc_enable_irq(host, true);
+}
+
+static void pio_tasklet(unsigned long data)
+{
+	struct ftsdc_host *host = (struct ftsdc_host *) data;
+
+	if (host->complete_what == COMPLETION_XFER_PROGRESS) {
+		queue_work(mywq, (struct work_struct *)&host->work);
+		return;
+	}
+
+	if (host->complete_what == COMPLETION_FINALIZE) {
+		clear_imask(host);
+		if (host->buf_active != XFER_NONE) {
+			dbg(host, dbg_err, "unfinished %s "
+			    "- buf_count:[%u] buf_bytes:[%u]\n",
+			    (host->buf_active == XFER_READ) ? "read" : "write",
+			    host->buf_count, host->buf_bytes);
+
+			if (host->mrq->data)
+				host->mrq->data->error = -EINVAL;
+		}
+
+		finalize_request(host);
+	}
+}
+
+static void finalize_request(struct ftsdc_host *host)
+{
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_command *cmd;
+	u32 con;
+	int debug_as_failure = 0;
+	if (host->complete_what != COMPLETION_FINALIZE)
+		return;
+
+	if (!mrq)
+		return;
+
+	cmd = host->cmd_is_stop ? mrq->stop : mrq->cmd;
+
+	if (cmd->data && (cmd->error == 0) &&
+	    (cmd->data->error == 0)) {
+		if (host->dodma && (!host->dma_finish)) {
+			dbg(host, dbg_dma, "DMA Missing (%d)!\n",
+			    host->dma_finish);
+			return;
+		}
+		host->dodma = false;
+	}
+
+	/* Read response from controller. */
+	if (cmd->flags & MMC_RSP_136) {
+		cmd->resp[3] = REG_READ(SDC_RESPONSE0_REG);
+		cmd->resp[2] = REG_READ(SDC_RESPONSE1_REG);
+		cmd->resp[1] = REG_READ(SDC_RESPONSE2_REG);
+		cmd->resp[0] = REG_READ(SDC_RESPONSE3_REG);
+	} else if (cmd->flags & MMC_RSP_PRESENT) {
+		cmd->resp[0] = REG_READ(SDC_RESPONSE0_REG);
+	}
+
+	if (cmd->error)
+		debug_as_failure = 1;
+
+	if (cmd->data && cmd->data->error)
+		debug_as_failure = 1;
+
+	dbg_dumpcmd(host, cmd, debug_as_failure);
+
+	clear_imask(host);
+	con = REG_READ(SDC_STATUS_REG);
+	con &= ~SDC_CLEAR_REG_SDIO_INTR;
+	REG_WRITE(con, SDC_CLEAR_REG);
+
+	if (cmd->data && cmd->error)
+		cmd->data->error = cmd->error;
+
+	if (cmd->data && cmd->data->stop && (!host->cmd_is_stop)) {
+		host->cmd_is_stop = 1;
+		ftsdc_send_request(host->mmc);
+		return;
+	}
+
+	/* If we have no data transfer we are finished here */
+	if (!mrq->data)
+		goto request_done;
+
+	/* Calulate the amout of bytes transfer if there was no error */
+	if (mrq->data->error == 0) {
+		mrq->data->bytes_xfered =
+			(mrq->data->blocks * mrq->data->blksz);
+	} else {
+		mrq->data->bytes_xfered = 0;
+	}
+
+request_done:
+	host->complete_what = COMPLETION_NONE;
+	host->mrq = NULL;
+
+	host->last_opcode = mrq->cmd->opcode;
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void ftsdc_send_command(struct ftsdc_host *host,
+					struct mmc_command *cmd)
+{
+	u32 ccon = 0;
+	u32 newmask = 0;
+	u32 scon;
+
+	if (cmd->data) {
+		host->complete_what = COMPLETION_XFER_PROGRESS;
+		newmask |= SDC_INT_MASK_REG_RSP_TIMEOUT;
+	} else if (cmd->flags & MMC_RSP_PRESENT) {
+		host->complete_what = COMPLETION_RSPFIN;
+		newmask |= SDC_INT_MASK_REG_RSP_TIMEOUT;
+	} else {
+		host->complete_what = COMPLETION_CMDSENT;
+		newmask |= SDC_INT_MASK_REG_CMD_SEND;
+	}
+
+	ccon |= cmd->opcode & SDC_CMD_REG_INDEX;
+	ccon |= SDC_CMD_REG_CMD_EN;
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		ccon |= SDC_CMD_REG_NEED_RSP;
+		newmask |= SDC_INT_MASK_REG_RSP_CRC_OK |
+			SDC_INT_MASK_REG_RSP_CRC_FAIL;
+	}
+
+	if (cmd->flags & MMC_RSP_136)
+		ccon |= SDC_CMD_REG_LONG_RSP;
+
+	/* applicatiion specific cmd must follow an MMC_APP_CMD. The
+	 * value will be updated in finalize_request function */
+	if (host->last_opcode == MMC_APP_CMD)
+		ccon |= SDC_CMD_REG_APP_CMD;
+
+	enable_imask(host, newmask);
+	REG_WRITE(cmd->arg, SDC_ARGU_REG);
+
+	scon = REG_READ(SDC_SDIO_CTRL1_REG);
+	if (host->mmc->card != NULL && mmc_card_sdio(host->mmc->card))
+		scon |= SDC_SDIO_CTRL1_REG_SDIO_ENABLE;
+	else
+		scon &= ~SDC_SDIO_CTRL1_REG_SDIO_ENABLE;
+	REG_WRITE(scon, SDC_SDIO_CTRL1_REG);
+
+	dbg_dumpregs(host, "");
+	dbg(host, dbg_debug, "CON[%x]\n", ccon);
+
+	REG_WRITE(ccon, SDC_CMD_REG);
+}
+
+static int ftsdc_setup_data(struct ftsdc_host *host, struct mmc_data *data)
+{
+	u32 dcon, newmask = 0;
+
+	/* configure data transfer paramter */
+	if (!data)
+		return 0;
+	if(host->mmc->card && host->mmc->card->type==(unsigned int)MMC_TYPE_SD){
+		if (((data->blksz - 1) & data->blksz) != 0) {
+			pr_warning("%s: can't do non-power-of 2 sized block transfers (blksz %d)\n", __func__, data->blksz);
+			return -EINVAL;
+		}
+	}
+
+	if (data->blksz <= 2) {
+		/* We cannot deal with unaligned blocks with more than
+		 * one block being transfered. */
+
+		if (data->blocks > 1) {
+			pr_warning("%s: can't do non-word sized block transfers (blksz %d)\n", __func__, data->blksz);
+			return -EINVAL;
+		}
+	}
+
+	/* data length */
+	dcon = data->blksz * data->blocks;
+	REG_WRITE(dcon, SDC_DATA_LEN_REG);
+
+	/* write data control */
+	dcon = 0;
+	dcon = cal_blksz(data->blksz);
+
+	/* enable UNDERFUN will trigger interrupt immediatedly
+	 * So setup it when rsp is received successfully
+	 */
+	if (data->flags & MMC_DATA_WRITE) {
+		dcon |= SDC_DATA_CTRL_REG_DATA_WRITE;
+	} else {
+		dcon &= ~SDC_DATA_CTRL_REG_DATA_WRITE;
+		newmask |= SDC_INT_MASK_REG_FIFO_OVERRUN;
+	}
+
+	/* always reset fifo since last transfer may fail */
+	dcon |= SDC_DATA_CTRL_REG_FIFO_RST;
+
+	/* enable data transfer which will be pended until cmd is send */
+	dcon |= SDC_DATA_CTRL_REG_DATA_EN;
+	if (ftsdc_dmaexist(host) &&
+			((data->blksz * data->blocks) & 0xf) == 0) {
+		newmask &= ~SDC_INT_MASK_REG_FIFO_OVERRUN;
+		dcon |= SDC_DATA_CTRL_REG_DMA_EN;
+		dcon |= SDC_DMA_TYPE_4;
+		host->dodma = true;
+
+	}
+	REG_WRITE(dcon, SDC_DATA_CTRL_REG);
+	/* add to IMASK register */
+	newmask |= SDC_INT_MASK_REG_DATA_CRC_FAIL |
+			SDC_INT_MASK_REG_DATA_TIMEOUT;
+
+	enable_imask(host, newmask);
+	/* handle sdio */
+	dcon = SDC_SDIO_CTRL1_REG_READ_WAIT_ENABLE & REG_READ(SDC_SDIO_CTRL1_REG);
+	dcon |= data->blksz | data->blocks << 15;
+	if (1 < data->blocks)
+		dcon |= SDC_SDIO_CTRL1_REG_SDIO_BLK_MODE;
+	REG_WRITE(dcon, SDC_SDIO_CTRL1_REG);
+
+	return 0;
+}
+
+#define BOTH_DIR (MMC_DATA_WRITE | MMC_DATA_READ)
+
+static int ftsdc_prepare_buffer(struct ftsdc_host *host, struct mmc_data *data)
+{
+	int rw = (data->flags & MMC_DATA_WRITE) ? 1 : 0;
+
+	if ((!host->mrq) || (!host->mrq->data))
+		return -EINVAL;
+
+	BUG_ON((data->flags & BOTH_DIR) == BOTH_DIR);
+	host->buf_sgptr = 0;
+	host->buf_bytes = 0;
+	host->buf_count = 0;
+	host->buf_active = rw ? XFER_WRITE : XFER_READ;
+	if (host->dodma) {
+		u32 dma_len;
+		u32 drb_size;
+		dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
+				     rw ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+		if (dma_len == 0)
+			return -ENOMEM;
+
+		dmad_config_channel_dir(host->dma_req,
+				rw ? DMAD_DIR_A1_TO_A0 : DMAD_DIR_A0_TO_A1);
+		drb_size = dmad_max_size_per_drb(host->dma_req);
+		if (drb_size < (data->blksz & data->blocks))
+			return -ENODEV;
+
+		host->dma_finish = false;
+	}
+	return 0;
+}
+
+static irqreturn_t ftsdc_irq(int irq, void *dev_id)
+{
+	struct ftsdc_host *host = dev_id;
+	struct mmc_command *cmd;
+	u32 mci_status;
+	u32 mci_clear;
+	u32 mci_imsk;
+	unsigned long iflags;
+
+	mci_status = REG_READ(SDC_STATUS_REG);
+	mci_imsk = REG_READ(SDC_INT_MASK_REG);
+
+	dbg(host, dbg_debug, "irq: status:0x%08x, mask : %08x\n", mci_status, mci_imsk);
+
+	if (mci_status & SDC_STATUS_REG_SDIO_INTR) {
+		if (mci_imsk & SDC_INT_MASK_REG_SDIO_INTR) {
+			mci_clear = SDC_CLEAR_REG_SDIO_INTR;
+			REG_WRITE(mci_clear, SDC_CLEAR_REG);
+
+			mmc_signal_sdio_irq(host->mmc);
+			return IRQ_HANDLED;
+		}
+	}
+
+	spin_lock_irqsave(&host->complete_lock, iflags);
+
+	mci_status = REG_READ(SDC_STATUS_REG);
+	mci_clear = 0;
+
+	if (mci_status & SDC_STATUS_REG_CARD_CHANGE) {
+		if ((mci_status & SDC_STATUS_REG_CARD_DETECT)
+			== SDC_CARD_INSERT) {
+			host->status = "card insert";
+			mmc_detect_change(host->mmc, msecs_to_jiffies(500));
+		} else {
+			host->status = "card remove";
+		}
+		mci_clear |= SDC_CLEAR_REG_CARD_CHANGE;
+		dbg(host, dbg_irq, "%s\n", host->status);
+
+		if (host->complete_what != COMPLETION_NONE) {
+			host->mrq->cmd->error = -EIO;
+			goto close_transfer;
+		}
+
+		goto irq_out;
+	}
+
+	if ((host->complete_what == COMPLETION_NONE) ||
+	    (host->complete_what == COMPLETION_FINALIZE)) {
+		host->status = "nothing to complete";
+		mci_clear = -1u;
+		goto irq_out;
+	}
+
+	if (!host->mrq) {
+		host->status = "no active mrq";
+		clear_imask(host);
+		goto irq_out;
+	}
+
+	cmd = host->cmd_is_stop ? host->mrq->stop : host->mrq->cmd;
+
+	if (!cmd) {
+		host->status = "no active cmd";
+		clear_imask(host);
+		goto irq_out;
+	}
+
+	if (mci_status & SDC_STATUS_REG_CMD_SEND) {
+		mci_clear |= SDC_CLEAR_REG_CMD_SEND;
+
+		if (host->complete_what == COMPLETION_CMDSENT) {
+			host->status = "ok: command sent";
+			goto close_transfer;
+		} else {
+			host->status = "error: command sent(status not match)";
+			cmd->error = -EINVAL;
+			goto fail_transfer;
+		}
+	}
+
+	/* handle error status */
+	if (mci_status & SDC_STATUS_REG_RSP_TIMEOUT) {
+		dbg(host, dbg_err, "CMDSTAT: error RSP TIMEOUT\n");
+		mci_clear |= SDC_CLEAR_REG_RSP_TIMEOUT;
+		cmd->error = -ETIMEDOUT;
+		host->status = "error: response timeout";
+		goto fail_transfer;
+	}
+
+	if (mci_status & SDC_STATUS_REG_RSP_CRC_FAIL) {
+		mci_clear |= SDC_CLEAR_REG_RSP_CRC_FAIL;
+		/* This is wierd hack */
+		if (cmd->flags & MMC_RSP_CRC) {
+			dbg(host, dbg_err, "CMDSTAT: error RSP CRC\n");
+			cmd->error = -EILSEQ;
+			host->status = "error: RSP CRC failed";
+			goto fail_transfer;
+		} else {
+			host->status = "R3 or R4 type command";
+			goto close_transfer;
+		}
+	}
+
+	if (mci_status & SDC_STATUS_REG_RSP_CRC_OK) {
+		mci_clear |= SDC_CLEAR_REG_RSP_CRC_OK;
+
+		if (host->complete_what == COMPLETION_XFER_PROGRESS) {
+			REG_WRITE(mci_clear, SDC_CLEAR_REG);
+
+			host->status = "RSP recv OK";
+			if (!cmd->data)
+				goto close_transfer;
+
+			if (host->dodma) {
+				tasklet_schedule(&host->pio_tasklet);
+				host->status = "dma access";
+				goto irq_out;
+			}
+
+			if (host->buf_active == XFER_WRITE)
+				enable_imask(host, SDC_INT_MASK_REG_FIFO_UNDERRUN);
+		} else if (host->complete_what == COMPLETION_RSPFIN) {
+			goto close_transfer;
+		}
+	}
+
+	/* handler data transfer */
+	if (mci_status & SDC_STATUS_REG_DATA_TIMEOUT) {
+		dbg(host, dbg_err, "CMDSTAT: error DATA TIMEOUT\n");
+		mci_clear |= SDC_CLEAR_REG_DATA_TIMEOUT;
+		cmd->error = -ETIMEDOUT;
+		host->status = "error: data timeout";
+		goto fail_transfer;
+	}
+
+	if (mci_status & SDC_STATUS_REG_DATA_CRC_FAIL) {
+		dbg(host, dbg_err, "CMDSTAT: error DATA CRC\n");
+		mci_clear |= SDC_CLEAR_REG_DATA_CRC_FAIL;
+		cmd->error = -EILSEQ;
+		host->status = "error: data CRC fail";
+		goto fail_transfer;
+	}
+
+	if ((mci_status & SDC_STATUS_REG_FIFO_UNDERRUN) ||
+		mci_status & SDC_STATUS_REG_FIFO_OVERRUN) {
+
+		disable_imask(host, SDC_INT_MASK_REG_FIFO_OVERRUN |
+				SDC_INT_MASK_REG_FIFO_UNDERRUN);
+
+		if (!host->dodma) {
+			if (host->buf_active == XFER_WRITE) {
+				tasklet_schedule(&host->pio_tasklet);
+				host->status = "pio tx";
+			} else if (host->buf_active == XFER_READ) {
+
+				tasklet_schedule(&host->pio_tasklet);
+				host->status = "pio rx";
+			}
+		}
+	}
+
+	goto irq_out;
+
+fail_transfer:
+	host->buf_active = XFER_NONE;
+
+close_transfer:
+	host->complete_what = COMPLETION_FINALIZE;
+
+	clear_imask(host);
+	tasklet_schedule(&host->pio_tasklet);
+
+irq_out:
+	REG_WRITE(mci_clear, SDC_CLEAR_REG);
+
+	dbg(host, dbg_debug, "irq: %s\n", host->status);
+	spin_unlock_irqrestore(&host->complete_lock, iflags);
+	return IRQ_HANDLED;
+}
+
+static void ftsdc_send_request(struct mmc_host *mmc)
+{
+	struct ftsdc_host *host = mmc_priv(mmc);
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_command *cmd = host->cmd_is_stop ? mrq->stop : mrq->cmd;
+
+	host->ccnt++;
+	prepare_dbgmsg(host, cmd, host->cmd_is_stop);
+	dbg(host, dbg_debug, "%s\n", host->dbgmsg_cmd);
+
+	if (cmd->data) {
+		int res = ftsdc_setup_data(host, cmd->data);
+
+		host->dcnt++;
+
+		if (res) {
+			dbg(host, dbg_err, "setup data error %d\n", res);
+			cmd->error = res;
+			cmd->data->error = res;
+
+			mmc_request_done(mmc, mrq);
+			return;
+		}
+
+		res = ftsdc_prepare_buffer(host, cmd->data);
+
+		if (res) {
+			dbg(host, dbg_err, "data prepare error %d\n", res);
+			cmd->error = res;
+			cmd->data->error = res;
+
+			mmc_request_done(mmc, mrq);
+			return;
+		}
+	}
+
+	/* Send command */
+	ftsdc_send_command(host, cmd);
+}
+
+static int ftsdc_get_cd(struct mmc_host *mmc)
+{
+	struct ftsdc_host *host = mmc_priv(mmc);
+
+	u32 con = REG_READ(SDC_STATUS_REG);
+		dbg(host, dbg_debug, "get_cd status:%.8x\n\n", con);
+
+	return (con & SDC_STATUS_REG_CARD_DETECT) ? 0 : 1;
+}
+
+static void ftsdc_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct ftsdc_host *host = mmc_priv(mmc);
+	host->status = "mmc request";
+	host->cmd_is_stop = 0;
+	host->mrq = mrq;
+	if (ftsdc_get_cd(mmc) == 0) {
+		dbg(host, dbg_err, "%s: no medium present\n", __func__);
+		host->mrq->cmd->error = -ENOMEDIUM;
+		mmc_request_done(mmc, mrq);
+	} else {
+		ftsdc_send_request(mmc);
+	}
+	dbg(host, dbg_debug, "send request \n");
+}
+
+static void ftsdc_set_clk(struct ftsdc_host *host, struct mmc_ios *ios)
+{
+	u32 clk_div = 0;
+	u32 con;
+	struct ftsdc_mmc_config *pdata = host->pdev->dev.platform_data;
+	u32 freq = pdata->max_freq;
+
+	dbg(host, dbg_debug, "request clk : %u \n", ios->clock);
+	con = REG_READ(SDC_CLOCK_CTRL_REG);
+	if (ios->clock == 0) {
+		host->real_rate = 0;
+		con |= SDC_CLOCK_CTRL_REG_CLK_DIS;
+	} else {
+		clk_div = (freq / (ios->clock << 1)) - 1;
+		host->real_rate = freq / ((clk_div+1)<<1);
+		if (host->real_rate > ios->clock) {
+			++clk_div;
+			host->real_rate = freq / ((clk_div+1)<<1);
+		}
+		if (clk_div > 127)
+			dbg(host, dbg_err, "%s: no match clock rate, %u\n", __func__, ios->clock);
+
+		con = (con & ~SDC_CLOCK_CTRL_REG_CLK_DIV) | (clk_div & SDC_CLOCK_CTRL_REG_CLK_DIV);
+		con &= ~SDC_CLOCK_CTRL_REG_CLK_DIS;
+	}
+
+	REG_WRITE(con, SDC_CLOCK_CTRL_REG);
+}
+
+static void ftsdc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct ftsdc_host *host = mmc_priv(mmc);
+	u32 con;
+
+	con = REG_READ(SDC_POWER_CTRL_REG);
+	switch (ios->power_mode) {
+	case MMC_POWER_ON:
+	case MMC_POWER_UP:
+		con |= SDC_POWER_CTRL_REG_POWER_ON;
+		break;
+	case MMC_POWER_OFF:
+	default:
+		con &= ~SDC_POWER_CTRL_REG_POWER_ON;
+		break;
+	}
+
+	REG_WRITE(con, SDC_POWER_CTRL_REG);
+
+	ftsdc_set_clk(host, ios);
+
+	if ((ios->power_mode == MMC_POWER_ON) ||
+	    (ios->power_mode == MMC_POWER_UP)) {
+		dbg(host, dbg_debug, "running at %ukHz (requested: %ukHz).\n",
+			host->real_rate/1000, ios->clock/1000);
+	} else {
+		dbg(host, dbg_debug, "powered down.\n");
+	}
+
+	host->bus_width = ios->bus_width;
+	/* write bus configure */
+	con = REG_READ(SDC_BUS_WIDTH_REG);
+
+	con &= ~(SDC_BUS_WIDTH_REG_SINGLE_BUS |
+			SDC_BUS_WIDTH_REG_WIDE_4_BUS |
+			SDC_BUS_WIDTH_REG_WIDE_8_BUS);
+	if (host->bus_width == MMC_BUS_WIDTH_1)
+		con |= SDC_BUS_WIDTH_REG_SINGLE_BUS;
+	else if (host->bus_width == MMC_BUS_WIDTH_4)
+		con |= SDC_BUS_WIDTH_REG_WIDE_4_BUS;
+	else if (host->bus_width == MMC_BUS_WIDTH_8)
+		con |= SDC_BUS_WIDTH_REG_WIDE_8_BUS;
+	else {
+		dbg(host, dbg_err, "set_ios: can't support bus mode");
+	}
+	REG_WRITE(con, SDC_BUS_WIDTH_REG);
+
+	/*set rsp and data timeout */
+	con = -1;
+	REG_WRITE(con, SDC_DATA_TIMER_REG);
+	if (ios->power_mode == MMC_POWER_UP)
+		mmc_delay(250);
+}
+
+static int ftsdc_get_ro(struct mmc_host *mmc)
+{
+	struct ftsdc_host *host = mmc_priv(mmc);
+	u32 con = REG_READ(SDC_STATUS_REG);
+	dbg(host, dbg_debug, "get_ro status:%.8x\n", con);
+
+	return (con & SDC_STATUS_REG_CARD_LOCK) ? 1 : 0;
+}
+
+
+static void ftsdc_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct ftsdc_host *host = mmc_priv(mmc);
+	unsigned long flags;
+	u32 con;
+#ifdef CONFIG_MMC_DEBUG
+	u32 ena;
+#endif
+
+	local_irq_save(flags);
+
+	con = REG_READ(SDC_INT_MASK_REG);
+#ifdef CONFIG_MMC_DEBUG
+	ena = (con & SDC_STATUS_REG_SDIO_INTR) ? 1:0;
+	if (ena == enable)
+		printk("\n*** XXX ***\n");
+#endif
+
+	con = enable ? (con | SDC_STATUS_REG_SDIO_INTR) : (con & ~SDC_STATUS_REG_SDIO_INTR);
+	REG_WRITE(con, SDC_INT_MASK_REG);
+
+#ifdef CONFIG_MMC_DEBUG
+	//check and ensure data out to SD host controller
+	ena = (REG_READ(SDC_INT_MASK_REG) & SDC_STATUS_REG_SDIO_INTR) ? 1:0;
+	if (ena != enable) {
+		printk("\n*** YYY ***\n");
+	}
+#endif
+
+	local_irq_restore(flags);
+}
+
+static struct mmc_host_ops ftsdc_ops = {
+	.request	= ftsdc_request,
+	.set_ios	= ftsdc_set_ios,
+	.get_ro		= ftsdc_get_ro,
+	.get_cd		= ftsdc_get_cd,
+	.enable_sdio_irq = ftsdc_enable_sdio_irq,
+};
+
+#ifdef CONFIG_DEBUG_FS
+
+static int ftsdc_state_show(struct seq_file *seq, void *v)
+{
+	struct ftsdc_host *host = seq->private;
+
+	seq_printf(seq, "Register base = 0x%08x\n", (u32)host->base);
+	seq_printf(seq, "Clock rate = %u\n", host->real_rate);
+	seq_printf(seq, "host status = %s\n", host->status);
+	seq_printf(seq, "IRQ = %d\n", host->irq);
+	seq_printf(seq, "IRQ enabled = %d\n", host->irq_enabled);
+	seq_printf(seq, "complete what = %d\n", host->complete_what);
+	seq_printf(seq, "dma support = %d\n", ftsdc_dmaexist(host));
+	seq_printf(seq, "use dma = %d\n", host->dodma);
+
+	return 0;
+}
+
+static int ftsdc_state_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ftsdc_state_show, inode->i_private);
+}
+
+static const struct file_operations ftsdc_fops_state = {
+	.owner		= THIS_MODULE,
+	.open		= ftsdc_state_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+#define DBG_REG(_r) { .addr = SDC_## _r ## _REG, .name = #_r }
+
+struct ftsdc_reg {
+	unsigned short	addr;
+	unsigned char	*name;
+} debug_regs[] = {
+	DBG_REG(CMD),
+	DBG_REG(ARGU),
+	DBG_REG(RESPONSE0),
+	DBG_REG(RESPONSE1),
+	DBG_REG(RESPONSE2),
+	DBG_REG(RESPONSE3),
+	DBG_REG(RSP_CMD),
+	DBG_REG(DATA_CTRL),
+	DBG_REG(DATA_TIMER),
+	DBG_REG(DATA_LEN),
+	DBG_REG(STATUS),
+	DBG_REG(CLEAR),
+	DBG_REG(INT_MASK),
+	DBG_REG(POWER_CTRL),
+	DBG_REG(CLOCK_CTRL),
+	DBG_REG(BUS_WIDTH),
+	DBG_REG(SDIO_CTRL1),
+	DBG_REG(SDIO_CTRL2),
+	DBG_REG(SDIO_STATUS),
+	DBG_REG(FEATURE),
+	DBG_REG(REVISION),
+	{}
+};
+
+static int ftsdc_regs_show(struct seq_file *seq, void *v)
+{
+	struct ftsdc_host *host = seq->private;
+	struct ftsdc_reg *rptr = debug_regs;
+
+	for (; rptr->name; rptr++)
+		seq_printf(seq, "SDI%s\t=0x%08x\n", rptr->name,
+			   REG_READ(rptr->addr));
+
+	return 0;
+}
+
+static int ftsdc_regs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ftsdc_regs_show, inode->i_private);
+}
+
+static const struct file_operations ftsdc_fops_regs = {
+	.owner		= THIS_MODULE,
+	.open		= ftsdc_regs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void ftsdc_debugfs_attach(struct ftsdc_host *host)
+{
+	struct device *dev = &host->pdev->dev;
+
+	host->debug_root = debugfs_create_dir(dev_name(dev), NULL);
+	if (IS_ERR(host->debug_root)) {
+		dev_err(dev, "failed to create debugfs root\n");
+		return;
+	}
+
+	host->debug_state = debugfs_create_file("state", 0444,
+						host->debug_root, host,
+						&ftsdc_fops_state);
+
+	if (IS_ERR(host->debug_state))
+		dev_err(dev, "failed to create debug state file\n");
+
+	host->debug_regs = debugfs_create_file("regs", 0444,
+					       host->debug_root, host,
+					       &ftsdc_fops_regs);
+
+	if (IS_ERR(host->debug_regs))
+		dev_err(dev, "failed to create debug regs file\n");
+}
+
+static void ftsdc_debugfs_remove(struct ftsdc_host *host)
+{
+	debugfs_remove(host->debug_regs);
+	debugfs_remove(host->debug_state);
+	debugfs_remove(host->debug_root);
+}
+
+#else
+static inline void ftsdc_debugfs_attach(struct ftsdc_host *host) { }
+static inline void ftsdc_debugfs_remove(struct ftsdc_host *host) { }
+
+#endif /* CONFIG_DEBUG_FS */
+
+#if (defined(CONFIG_PLATFORM_AHBDMA) || defined(CONFIG_PLATFORM_APBDMA))
+static int ftsdc_alloc_dma(struct ftsdc_host *host)
+{
+	dmad_chreq *req = host->dma_req;
+	req = kzalloc(sizeof(dmad_chreq), GFP_KERNEL);
+#ifdef CONFIG_PLATFORM_APBDMA
+	req->apb_req.addr0_ctrl  = APBBR_ADDRINC_FIXED;  /* (in)  APBBR_ADDRINC_xxx */
+/* for amerald */
+#if !defined(CONFIG_PLAT_AE3XX)
+	if((inl(pmu_base) & AMERALD_MASK) == AMERALD_PRODUCT_ID){
+		req->apb_req.addr0_reqn	= APBBR_REQN_SDC_AMERALD;
+	}else
+#endif
+	{
+		req->apb_req.addr0_reqn  = APBBR_REQN_SDC;       /* (in)  APBBR_REQN_xxx (also used to help determine bus selection) */
+	}
+	req->apb_req.addr1_ctrl  = APBBR_ADDRINC_I4X;    /* (in)  APBBR_ADDRINC_xxx */
+	req->apb_req.addr1_reqn  = APBBR_REQN_NONE;      /* (in)  APBBR_REQN_xxx (also used to help determine bus selection) */
+	req->apb_req.burst_mode  = 1;                    /* (in)  Burst mode (0: no burst 1-, 1: burst 4- data cycles per dma cycle) */
+	req->apb_req.data_width  = APBBR_DATAWIDTH_4;    /* (in)  APBBR_DATAWIDTH_4(word), APBBR_DATAWIDTH_2(half-word), APBBR_DATAWIDTH_1(byte) */
+	req->apb_req.tx_dir      = DMAD_DIR_A0_TO_A1;    /* (in)  DMAD_DIR_A0_TO_A1, DMAD_DIR_A1_TO_A0 */
+	req->controller          = DMAD_DMAC_APB_CORE;   /* (in)  DMAD_DMAC_AHB_CORE, DMAD_DMAC_APB_CORE */
+	req->flags               = DMAD_FLAGS_SLEEP_BLOCK | DMAD_FLAGS_BIDIRECTION;
+
+	if (dmad_channel_alloc(req) == 0) {
+		dbg(host, dbg_debug, "%s: APB dma channel allocated (ch: %d)\n", __func__, req->channel);
+		host->dma_req = req;
+		return 0;
+	}
+
+	memset(req, 0, sizeof(dmad_chreq));
+	dbg(host, dbg_info, "%s: APB dma channel allocation failed\n", __func__);
+#endif /* CONFIG_PLATFORM_APBDMA */
+
+#ifdef CONFIG_PLATFORM_AHBDMA
+	req->ahb_req.sync         = 1;                    /* (in)  non-zero if src and dst have different clock domain */
+	req->ahb_req.priority     = DMAC_CSR_CHPRI_1;     /* (in)  DMAC_CSR_CHPRI_0 (lowest) ~ DMAC_CSR_CHPRI_3 (highest) */
+	req->ahb_req.hw_handshake = 1;                    /* (in)  non-zero to enable hardware handshake mode */
+	req->ahb_req.burst_size   = DMAC_CSR_SIZE_4;      /* (in)  DMAC_CSR_SIZE_1 ~ DMAC_CSR_SIZE_256 */
+	req->ahb_req.addr0_width  = DMAC_CSR_WIDTH_32;    /* (in)  DMAC_CSR_WIDTH_8, DMAC_CSR_WIDTH_16, or DMAC_CSR_WIDTH_32 */
+	req->ahb_req.addr0_ctrl   = DMAC_CSR_AD_FIX;      /* (in)  DMAC_CSR_AD_INC, DMAC_CSR_AD_DEC, or DMAC_CSR_AD_FIX */
+	req->ahb_req.addr0_reqn   = DMAC_REQN_SDC;        /* (in)  DMAC_REQN_xxx (also used to help determine channel number) */
+	req->ahb_req.addr1_width  = DMAC_CSR_WIDTH_32;    /* (in)  DMAC_CSR_WIDTH_8, DMAC_CSR_WIDTH_16, or DMAC_CSR_WIDTH_32 */
+	req->ahb_req.addr1_ctrl   = DMAC_CSR_AD_INC;      /* (in)  DMAC_CSR_AD_INC, DMAC_CSR_AD_DEC, or DMAC_CSR_AD_FIX */
+	req->ahb_req.addr1_reqn   = DMAC_REQN_NONE;       /* (in)  DMAC_REQN_xxx (also used to help determine channel number) */
+	req->ahb_req.tx_dir       = DMAD_DIR_A0_TO_A1;    /* (in)  DMAD_DIR_A0_TO_A1, DMAD_DIR_A1_TO_A0 */
+
+	req->controller           = DMAD_DMAC_AHB_CORE;   /* (in)  DMAD_DMAC_AHB_CORE, DMAD_DMAC_APB_CORE */
+	req->flags                = DMAD_FLAGS_SLEEP_BLOCK | DMAD_FLAGS_BIDIRECTION;
+
+	if (dmad_channel_alloc(req) == 0) {
+		dbg(host, dbg_debug, "%s: AHB dma channel allocated (ch: %d)\n", __func__, req->channel);
+		host->dma_req = req;
+		return 0;
+	}
+	dbg(host, dbg_info, "%s: AHB dma channel allocation failed\n", __func__);
+#endif
+
+	kfree(req);
+	return -ENODEV;
+
+}
+#endif
+
+enum {
+	MMC_CTLR_VERSION_1 = 0,
+	MMC_CTLR_VERSION_2,
+};
+
+
+static struct platform_device_id ftsdc_mmc_devtype[] = {
+	{
+		.name	= "ag101p",
+		.driver_data = MMC_CTLR_VERSION_1,
+	}, {
+		.name	= "ae3xx",
+		.driver_data = MMC_CTLR_VERSION_2,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(platform, ftsdc_mmc_devtype);
+
+static const struct of_device_id ftsdc_mmc_dt_ids[] = {
+	{
+		.compatible = "andestech,atfsdc010",
+		.data = &ftsdc_mmc_devtype[MMC_CTLR_VERSION_1],
+	},
+	{
+		.compatible = "andestech,atfsdc010",
+		.data = &ftsdc_mmc_devtype[MMC_CTLR_VERSION_2],
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, ftsdc_mmc_dt_ids);
+
+
+static struct ftsdc_mmc_config
+	*mmc_parse_pdata(struct platform_device *pdev)
+{
+	struct device_node *np;
+	struct ftsdc_mmc_config *pdata = pdev->dev.platform_data;
+	const struct of_device_id *match =
+		of_match_device(of_match_ptr(ftsdc_mmc_dt_ids), &pdev->dev);
+	u32 data;
+
+	np = pdev->dev.of_node;
+	if (!np)
+		return pdata;
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	pdev->dev.platform_data = (void *)pdata;
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "Failed to allocate memory for struct ftsdc_mmc_config\n");
+		goto nodata;
+	}
+
+	if (match)
+		pdev->id_entry = match->data;
+
+	if (of_property_read_u32(np, "max-frequency", &pdata->max_freq))
+		dev_info(&pdev->dev, "'max-frequency' property not specified, defaulting to 25MHz\n");
+
+	of_property_read_u32(np, "bus-width", &data);
+	switch (data) {
+	case 1:
+	case 4:
+	case 8:
+		pdata->wires = data;
+		break;
+	default:
+		pdata->wires = 1;
+/*
+		dev_info(&pdev->dev, "Unsupported buswidth, defaulting to 1 bit\n");
+*/
+	}
+nodata:
+	return pdata;
+}
+
+static int __init ftsdc_probe(struct platform_device *pdev)
+{
+	struct ftsdc_host *host;
+	struct mmc_host	*mmc;
+	struct ftsdc_mmc_config *pdata = NULL;
+	struct resource *r, *mem = NULL;
+	int ret = -ENOMEM;
+	u32 con;
+	int irq = 0;
+	size_t mem_size;
+
+	pdata = mmc_parse_pdata(pdev);
+	if (pdata == NULL) {
+		dev_err(&pdev->dev, "Couldn't get platform data\n");
+		return -ENOENT;
+	}
+	ret = -ENODEV;
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+
+	if (!r || irq == NO_IRQ)
+		goto probe_out;
+
+	ret = -EBUSY;
+	mem_size = resource_size(r);
+	mem = request_mem_region(r->start, mem_size, pdev->name);
+
+	if (!mem){
+		dev_err(&pdev->dev,
+			"failed to get io memory region resouce.\n");
+		goto probe_out;
+	}
+	ret = -ENOMEM;
+	mmc = mmc_alloc_host(sizeof(struct ftsdc_host), &pdev->dev);
+	if (!mmc) {
+		goto probe_out;
+	}
+
+	host = mmc_priv(mmc);
+	host->mmc 	= mmc;
+	host->pdev	= pdev;
+	mywq = create_workqueue("atcsdc_queue");
+	if (NULL == mywq)
+		goto probe_free_host;
+
+	spin_lock_init(&host->complete_lock);
+	tasklet_init(&host->pio_tasklet, pio_tasklet, (unsigned long) host);
+	init_completion(&host->dma_complete);
+	INIT_WORK(&host->work, ftsdc_work);
+
+	host->complete_what 	= COMPLETION_NONE;
+	host->buf_active 	= XFER_NONE;
+
+#if (defined(CONFIG_PLATFORM_AHBDMA) || defined(CONFIG_PLATFORM_APBDMA))
+	ftsdc_alloc_dma(host);
+#endif
+	host->mem = mem;
+	host->base = (void __iomem *) ioremap(mem->start, mem_size);
+	if (IS_ERR(host->base)){
+		ret = PTR_ERR(host->base);
+		goto probe_free_mem_region;
+	}
+	host->irq = irq;
+
+	ret = request_irq(host->irq, ftsdc_irq, 0, DRIVER_NAME, host);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to request mci interrupt.\n");
+		ret = -ENOENT;
+		goto probe_free_mem_region;
+	}
+	host->irq_enabled = true;
+	/* enable card change interruption */
+	con = REG_READ(SDC_INT_MASK_REG);
+	con |= SDC_INT_MASK_REG_CARD_CHANGE;
+	REG_WRITE(con, SDC_INT_MASK_REG);
+
+	con = REG_READ(SDC_BUS_WIDTH_REG);
+	mmc->ops 	= &ftsdc_ops;
+	mmc->ocr_avail	= MMC_VDD_32_33 | MMC_VDD_33_34;
+
+	if (con & SDC_WIDE_4_BUS_SUPPORT)
+		mmc->caps |= MMC_CAP_4_BIT_DATA;
+	else if (con & SDC_WIDE_8_BUS_SUPPORT)
+		mmc->caps |= MMC_CAP_8_BIT_DATA;
+
+#ifndef A320D_BUILDIN_SDC
+	mmc->caps |= MMC_CAP_SDIO_IRQ;
+#endif
+	mmc->f_min 	= pdata->max_freq / (2 * 128);
+	mmc->f_max 	= pdata->max_freq / 2;
+	/* limit SDIO mode max size */
+	mmc->max_req_size	= 128 * 1024 * 1024 - 1;
+	mmc->max_blk_size	= 2047;
+	mmc->max_req_size	= (mmc->max_req_size + 1) / (mmc->max_blk_size + 1);
+	mmc->max_seg_size	= mmc->max_req_size;
+	mmc->max_blk_count = (1<<17)-1;
+
+	/* kernel default value. see Doc/block/biodocs.txt */
+	/*
+	 'struct mmc_host' has no member named 'max_phys_segs'
+	 'struct mmc_host' has no member named 'max_hw_segs'
+	*/
+//	mmc->max_phys_segs	= 128;
+//	mmc->max_hw_segs	= 128;
+
+	/* set fifo lenght and default threshold half */
+	con = REG_READ(SDC_FEATURE_REG);
+	host->fifo_len = (con & SDC_FEATURE_REG_FIFO_DEPTH) * sizeof(u32);
+
+	dbg(host, dbg_debug,
+	    "probe: mapped mci_base:%p irq:%u.\n",
+	    host->base, host->irq);
+
+	dbg_dumpregs(host, "");
+	ret = mmc_add_host(mmc);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add mmc host.\n");
+		goto probe_free_irq;
+	}
+	ftsdc_debugfs_attach(host);
+	platform_set_drvdata(pdev, mmc);
+	dev_info(&pdev->dev, "%s - using %s SDIO IRQ\n", mmc_hostname(mmc),
+		 mmc->caps & MMC_CAP_SDIO_IRQ ? "hw" : "sw");
+	return 0;
+
+ probe_free_irq:
+	free_irq(host->irq, host);
+
+ probe_free_mem_region:
+	release_mem_region(host->mem->start, resource_size(host->mem));
+	destroy_workqueue(mywq);
+
+ probe_free_host:
+	mmc_free_host(mmc);
+
+ probe_out:
+	return ret;
+}
+
+static void ftsdc_shutdown(struct platform_device *pdev)
+{
+	struct mmc_host	*mmc = platform_get_drvdata(pdev);
+	struct ftsdc_host *host = mmc_priv(mmc);
+
+	flush_workqueue(mywq);
+	destroy_workqueue(mywq);
+
+	ftsdc_debugfs_remove(host);
+	mmc_remove_host(mmc);
+}
+
+static int __exit ftsdc_remove(struct platform_device *pdev)
+{
+	struct mmc_host		*mmc  = platform_get_drvdata(pdev);
+	struct ftsdc_host	*host = mmc_priv(mmc);
+
+	ftsdc_shutdown(pdev);
+
+	tasklet_disable(&host->pio_tasklet);
+
+	if (ftsdc_dmaexist(host))
+		kfree(host->dma_req);
+
+	free_irq(host->irq, host);
+
+	iounmap(host->base);
+	release_mem_region(host->mem->start, resource_size(host->mem));
+
+	mmc_free_host(mmc);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ftsdc_free_dma(struct ftsdc_host *host)
+{
+	dmad_channel_free(host->dma_req);
+	return 0;
+}
+
+static int ftsdc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	struct ftsdc_host *host = mmc_priv(mmc);
+	int ret = 0;
+	if (mmc) {
+		ftsdc_free_dma(host);
+	}
+	return ret;
+
+}
+
+static int ftsdc_resume(struct platform_device *pdev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	int ret = 0;
+	struct ftsdc_host *host = mmc_priv(mmc);
+	if (mmc) {
+#if (defined(CONFIG_PLATFORM_AHBDMA) || defined(CONFIG_PLATFORM_APBDMA))
+		ftsdc_alloc_dma(host);
+#endif
+	}
+	return ret;
+}
+
+#else
+#define ftsdc_suspend NULL
+#define ftsdc_resume NULL
+#endif
+
+static struct platform_driver ftsdc_driver = {
+	.driver	= {
+		.name	= "ftsdc010",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(ftsdc_mmc_dt_ids),
+	},
+	.remove		= __exit_p(ftsdc_remove),
+	.shutdown	= ftsdc_shutdown,
+	.suspend	= ftsdc_suspend,
+	.resume		= ftsdc_resume,
+};
+
+module_platform_driver_probe(ftsdc_driver, ftsdc_probe);
+MODULE_DESCRIPTION("Andestech Leopard MMC/SD Card Interface driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/ftsdc010.h b/drivers/mmc/host/ftsdc010.h
new file mode 100644
index 00000000..d8cbe57f
--- /dev/null
+++ b/drivers/mmc/host/ftsdc010.h
@@ -0,0 +1,257 @@
+/*
+ *  linux/driver/mmc/ftsdc010.h - Andestech MMC/SD driver
+ *  Andestech FTSDC010 Device Driver
+ *
+ *  Andestech (C) 2005 Faraday Corp. (http://www.Andestech.com)
+ *
+ *  All Rights Reserved
+ */
+#ifndef _FTSDC010_H_
+#define _FTSDC010_H_
+
+#define DELAY_FOR_DMA_READ
+
+#ifdef SD_DEBUG
+	#define P_DEBUG(fmt, args...) printk(KERN_ALERT "SD: " fmt, ## args)
+#else
+	#define P_DEBUG(a...)
+#endif
+#define P_DEBUGG(a...)
+
+/* used for dma timeout */
+#define SDC_TIMEOUT_BASE			(HZ/2)	// Unit is 500 ms
+
+/* used for pio retry times */
+#define SDC_PIO_RETRY				0x300000
+
+/* sd controller register */
+#define SDC_CMD_REG				0x00000000
+#define SDC_ARGU_REG				0x00000004
+#define SDC_RESPONSE0_REG			0x00000008
+#define SDC_RESPONSE1_REG			0x0000000C
+#define SDC_RESPONSE2_REG			0x00000010
+#define SDC_RESPONSE3_REG			0x00000014
+#define SDC_RSP_CMD_REG				0x00000018
+#define SDC_DATA_CTRL_REG			0x0000001C
+#define SDC_DATA_TIMER_REG			0x00000020
+#define SDC_DATA_LEN_REG			0x00000024
+#define SDC_STATUS_REG				0x00000028
+#define SDC_CLEAR_REG				0x0000002C
+#define SDC_INT_MASK_REG			0x00000030
+#define SDC_POWER_CTRL_REG			0x00000034
+#define SDC_CLOCK_CTRL_REG			0x00000038
+#define SDC_BUS_WIDTH_REG			0x0000003C
+#define SDC_DATA_WINDOW_REG			0x00000040
+
+#ifdef A320D_BUILDIN_SDC
+#define SDC_FEATURE_REG				0x00000044
+#define SDC_REVISION_REG			0x00000048
+#else
+#define SDC_MMC_INT_RSP_REG			0x00000044
+#define SDC_GP_OUTPUT_REG			0x00000048
+#define SDC_FEATURE_REG				0x0000009C
+#define SDC_REVISION_REG			0x000000A0
+#endif
+
+#define SDC_SDIO_CTRL1_REG			0x0000006C
+#define SDC_SDIO_CTRL2_REG			0x00000070
+#define SDC_SDIO_STATUS_REG			0x00000074
+
+/* bit mapping of command register */
+#define SDC_CMD_REG_INDEX			0x0000003F
+#define SDC_CMD_REG_NEED_RSP			0x00000040
+#define SDC_CMD_REG_LONG_RSP			0x00000080
+#define SDC_CMD_REG_APP_CMD			0x00000100
+#define SDC_CMD_REG_CMD_EN			0x00000200
+#define SDC_CMD_REG_SDC_RST			0x00000400
+#define SDC_CMD_MMC_INT_STOP			0x00000800
+
+/* bit mapping of response command register */
+#define SDC_RSP_CMD_REG_INDEX			0x0000003F
+#define SDC_RSP_CMD_REG_APP			0x00000040
+
+/* bit mapping of data control register */
+#define SDC_DATA_CTRL_REG_BLK_SIZE		0x0000000F
+#define SDC_DATA_CTRL_REG_DATA_WRITE		0x00000010
+#define SDC_DATA_CTRL_REG_DMA_EN		0x00000020
+#define SDC_DATA_CTRL_REG_DATA_EN		0x00000040
+#define SDC_DATA_CTRL_REG_FIFOTH		0x00000080
+#define SDC_DATA_CTRL_REG_DMA_TYPE		0x00000300
+#define SDC_DATA_CTRL_REG_FIFO_RST		0x00000400
+#define SDC_CPRM_DATA_CHANGE_ENDIAN_EN		0x00000800
+#define SDC_CPRM_DATA_SWAP_HL_EN		0x00001000
+
+#define SDC_DMA_TYPE_1				0x00000000
+#define SDC_DMA_TYPE_4				0x00000100
+#define SDC_DMA_TYPE_8				0x00000200
+
+/* bit mapping of status register */
+#define SDC_STATUS_REG_RSP_CRC_FAIL		0x00000001
+#define SDC_STATUS_REG_DATA_CRC_FAIL		0x00000002
+#define SDC_STATUS_REG_RSP_TIMEOUT		0x00000004
+#define SDC_STATUS_REG_DATA_TIMEOUT		0x00000008
+#define SDC_STATUS_REG_RSP_CRC_OK		0x00000010
+#define SDC_STATUS_REG_DATA_CRC_OK		0x00000020
+#define SDC_STATUS_REG_CMD_SEND			0x00000040
+#define SDC_STATUS_REG_DATA_END			0x00000080
+#define SDC_STATUS_REG_FIFO_UNDERRUN		0x00000100
+#define SDC_STATUS_REG_FIFO_OVERRUN		0x00000200
+#define SDC_STATUS_REG_CARD_CHANGE		0x00000400
+#define SDC_STATUS_REG_CARD_DETECT		0x00000800
+#define SDC_STATUS_REG_CARD_LOCK		0x00001000
+#define SDC_STATUS_REG_CP_READY			0x00002000
+#define SDC_STATUS_REG_CP_BUF_READY		0x00004000
+#define SDC_STATUS_REG_PLAIN_TEXT_READY		0x00008000
+#define SDC_STATUS_REG_SDIO_INTR	    	0x00010000
+
+/* bit mapping of clear register */
+#define SDC_CLEAR_REG_RSP_CRC_FAIL		0x00000001
+#define SDC_CLEAR_REG_DATA_CRC_FAIL		0x00000002
+#define SDC_CLEAR_REG_RSP_TIMEOUT		0x00000004
+#define SDC_CLEAR_REG_DATA_TIMEOUT		0x00000008
+#define SDC_CLEAR_REG_RSP_CRC_OK		0x00000010
+#define SDC_CLEAR_REG_DATA_CRC_OK		0x00000020
+#define SDC_CLEAR_REG_CMD_SEND			0x00000040
+#define SDC_CLEAR_REG_DATA_END			0x00000080
+#define SDC_CLEAR_REG_CARD_CHANGE		0x00000400
+#define SDC_CLEAR_REG_SDIO_INTR			0x00010000
+
+/* bit mapping of int_mask register */
+#define SDC_INT_MASK_REG_RSP_CRC_FAIL		0x00000001
+#define SDC_INT_MASK_REG_DATA_CRC_FAIL		0x00000002
+#define SDC_INT_MASK_REG_RSP_TIMEOUT		0x00000004
+#define SDC_INT_MASK_REG_DATA_TIMEOUT		0x00000008
+#define SDC_INT_MASK_REG_RSP_CRC_OK		0x00000010
+#define SDC_INT_MASK_REG_DATA_CRC_OK		0x00000020
+#define SDC_INT_MASK_REG_CMD_SEND		0x00000040
+#define SDC_INT_MASK_REG_DATA_END		0x00000080
+#define SDC_INT_MASK_REG_FIFO_UNDERRUN		0x00000100
+#define SDC_INT_MASK_REG_FIFO_OVERRUN		0x00000200
+#define SDC_INT_MASK_REG_CARD_CHANGE		0x00000400
+#define SDC_INT_MASK_REG_CARD_LOCK		0x00001000
+#define SDC_INT_MASK_REG_CP_READY		0x00002000
+#define SDC_INT_MASK_REG_CP_BUF_READY		0x00004000
+#define SDC_INT_MASK_REG_PLAIN_TEXT_READY	0x00008000
+#define SDC_INT_MASK_REG_SDIO_INTR	    	0x00010000
+
+
+#define SDC_CARD_INSERT				0x0
+#define SDC_CARD_REMOVE				SDC_STATUS_REG_CARD_DETECT
+
+/* bit mapping of power control register */
+#define SDC_POWER_CTRL_REG_POWER_ON		0x00000010
+#define SDC_POWER_CTRL_REG_POWER_BITS		0x0000000F
+
+/* bit mapping of clock control register */
+#define SDC_CLOCK_CTRL_REG_CLK_DIV		0x0000007F
+#define SDC_CLOCK_CTRL_REG_CARD_TYPE		0x00000080
+#define SDC_CLOCK_CTRL_REG_CLK_DIS		0x00000100
+
+/* card type */
+#define SDC_CARD_TYPE_SD			SDC_CLOCK_REG_CARD_TYPE
+#define SDC_CARD_TYPE_MMC			0x0
+
+/* bit mapping of bus width register */
+#define SDC_BUS_WIDTH_REG_SINGLE_BUS		0x00000001
+#define SDC_BUS_WIDTH_REG_WIDE_8_BUS		0x00000002
+#define SDC_BUS_WIDTH_REG_WIDE_4_BUS		0x00000004
+#define SDC_BUS_WIDTH_REG_WIDE_BUS_SUPPORT	0x00000018
+#define SDC_BUS_WIDTH_REG_CARD_DETECT		0x00000020
+
+#define SDC_WIDE_4_BUS_SUPPORT			0x00000008
+#define SDC_WIDE_8_BUS_SUPPORT			0x00000010
+
+/* bit mapping of feature register */
+#define SDC_FEATURE_REG_FIFO_DEPTH		0x000000FF
+#define SDC_FEATURE_REG_CPRM_FUNCTION		0x00000100
+
+/* bit mapping of sdio control register */
+#define SDC_SDIO_CTRL1_REG_SDIO_BLK_NO		0xFFFF8000
+#define SDC_SDIO_CTRL1_REG_SDIO_ENABLE		0x00004000
+#define SDC_SDIO_CTRL1_REG_READ_WAIT_ENABLE	0x00002000
+#define SDC_SDIO_CTRL1_REG_SDIO_BLK_MODE	0x00001000
+#define SDC_SDIO_CTRL1_REG_SDIO_BLK_SIZE	0x00000FFF
+
+/* bit mapping of sdio status register */
+#define SDC_SDIO_SDIO_STATUS_REG_FIFO_REMAIN_NO	0x00FE0000
+#define SDC_SDIO_SDIO_STATUS_REG_SDIO_BLK_CNT	0x0001FFFF
+
+enum ftsdc_waitfor {
+	COMPLETION_NONE,
+	COMPLETION_FINALIZE,
+	COMPLETION_CMDSENT,
+	COMPLETION_RSPFIN,
+	COMPLETION_XFER_PROGRESS,
+};
+
+struct ftsdc_host {
+	struct platform_device	*pdev;
+	struct mmc_host		*mmc;
+	struct resource		*mem;
+	struct clk		*clk;
+	void __iomem		*base;
+	int			irq;
+
+	unsigned int		real_rate;
+	bool			irq_enabled;
+	unsigned int		fifo_len;	/* bytes */
+	unsigned int		last_opcode;	/* keep last successful cmd to judge application specific command */
+
+	struct mmc_request	*mrq;
+	int			cmd_is_stop;
+
+	spinlock_t		complete_lock;
+	enum ftsdc_waitfor	complete_what;
+
+	struct completion	dma_complete;
+	dmad_chreq		*dma_req;
+	bool			dodma;
+	bool			dma_finish;
+
+
+	u32			buf_sgptr;	/* keep next scallterlist buffer index */
+	u32			buf_bytes;	/* keep current total scallterlist buffer length */
+	u32			buf_count;	/* keep real data size rw from sd */
+	u32			*buf_ptr;	/* keep current scallterlist buffer address */
+#define XFER_NONE 0
+#define XFER_READ 1
+#define XFER_WRITE 2
+	u32			buf_active;	/* keep current transfer mode */
+
+	int			bus_width;
+
+	char 			dbgmsg_cmd[301];
+	char 			dbgmsg_dat[301];
+	char			*status;
+
+	unsigned int		ccnt, dcnt;
+	struct tasklet_struct	pio_tasklet;
+	struct work_struct work;
+
+#ifdef CONFIG_DEBUG_FS
+	struct dentry		*debug_root;
+	struct dentry		*debug_state;
+	struct dentry		*debug_regs;
+#endif
+};
+
+struct ftsdc_mmc_config {
+	/* get_cd()/get_wp() may sleep */
+	int	(*get_cd)(int module);
+	int	(*get_ro)(int module);
+
+	void	(*set_power)(int module, bool on);
+
+	/* wires == 0 is equivalent to wires == 4 (4-bit parallel) */
+	u8	wires;
+
+	u32     max_freq;
+
+	/* any additional host capabilities: OR'd in to mmc->f_caps */
+	u32     caps;
+
+	/* Number of sg segments */
+	u8	nr_sg;
+};
+
+#endif
diff --git a/drivers/mtd/spi-nor/spi-nor.c b/drivers/mtd/spi-nor/spi-nor.c
index 5bfa36e9..0155c78d 100644
--- a/drivers/mtd/spi-nor/spi-nor.c
+++ b/drivers/mtd/spi-nor/spi-nor.c
@@ -1049,6 +1049,22 @@ static const struct flash_info spi_nor_ids[] = {
 			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ "is25lp128",  INFO(0x9d6018, 0, 64 * 1024, 256,
 			SECT_4K | SPI_NOR_DUAL_READ) },
+	{ "is25wp032",  INFO(0x9d7016, 0, 32 * 1024,  128,
+	                SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)
+	                .quad_enable = macronix_quad_enable,
+	},
+	{ "is25wp064",  INFO(0x9d7017, 0, 32 * 1024,  256,
+	                SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)
+	                .quad_enable = macronix_quad_enable,
+	},
+	{ "is25wp128",  INFO(0x9d7018, 0, 32 * 1024,  512,
+	                SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)
+	                .quad_enable = macronix_quad_enable,
+	},
+	{ "is25wp256d", INFO(0x9d7019, 0, 32 * 1024, 1024,
+	                SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES)
+			.quad_enable = macronix_quad_enable,
+	},
 
 	/* Macronix */
 	{ "mx25l512e",   INFO(0xc22010, 0, 64 * 1024,   1, SECT_4K) },
@@ -1066,6 +1082,7 @@ static const struct flash_info spi_nor_ids[] = {
 	{ "mx25l12805d", INFO(0xc22018, 0, 64 * 1024, 256, 0) },
 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+	{ "mx25u1635e",  INFO(0xc22535, 0, 64 * 1024,  32, SECT_4K) },
 	{ "mx25u25635f", INFO(0xc22539, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_4B_OPCODES) },
 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
 	{ "mx66l51235l", INFO(0xc2201a, 0, 64 * 1024, 1024, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES) },
@@ -1482,6 +1499,45 @@ static int macronix_quad_enable(struct spi_nor *nor)
 	return 0;
 }
 
+/**
+ * issi_unlock() - clear BP[0123] write-protection.
+ * @nor:	pointer to a 'struct spi_nor'
+ *
+ * Bits [2345] of the Status Register are BP[0123].
+ * ISSI chips use a different block protection scheme than other chips.
+ * Just disable the write-protect unilaterally.
+ *
+ * Return: 0 on success, -errno otherwise.
+ */
+static int issi_unlock(struct spi_nor *nor)
+{
+	int ret, val;
+	u8 mask = SR_BP0 | SR_BP1 | SR_BP2 | SR_BP3;
+
+	val = read_sr(nor);
+	if (val < 0)
+		return val;
+	if (!(val & mask))
+		return 0;
+
+	write_enable(nor);
+
+	write_sr(nor, val & ~mask);
+
+	ret = spi_nor_wait_till_ready(nor);
+	if (ret)
+		return ret;
+
+	ret = read_sr(nor);
+	if (ret > 0 && !(ret & mask)) {
+		dev_info(nor->dev, "ISSI Block Protection Bits cleared\n");
+		return 0;
+	} else {
+		dev_err(nor->dev, "ISSI Block Protection Bits not cleared\n");
+		return -EINVAL;
+	}
+}
+
 /*
  * Write status Register and configuration register with 2 bytes
  * The first byte will be written to the status register, while the
@@ -2714,6 +2770,9 @@ static int spi_nor_init(struct spi_nor *nor)
 		spi_nor_wait_till_ready(nor);
 	}
 
+	if (JEDEC_MFR(nor->info) == SNOR_MFR_ISSI)
+		issi_unlock(nor);
+
 	if (nor->quad_enable) {
 		err = nor->quad_enable(nor);
 		if (err) {
@@ -2893,7 +2952,7 @@ int spi_nor_scan(struct spi_nor *nor, const char *name,
 	if (ret)
 		return ret;
 
-	if (nor->addr_width) {
+	if (nor->addr_width && JEDEC_MFR(info) != SNOR_MFR_ISSI) {
 		/* already configured from SFDP */
 	} else if (info->addr_width) {
 		nor->addr_width = info->addr_width;
diff --git a/drivers/net/ethernet/faraday/Kconfig b/drivers/net/ethernet/faraday/Kconfig
index 0fb8df65..d6ea3d1a 100644
--- a/drivers/net/ethernet/faraday/Kconfig
+++ b/drivers/net/ethernet/faraday/Kconfig
@@ -5,7 +5,7 @@
 config NET_VENDOR_FARADAY
 	bool "Faraday devices"
 	default y
-	depends on ARM || NDS32 || COMPILE_TEST
+	depends on ARM || NDS32 || RISCV || COMPILE_TEST
 	---help---
 	  If you have a network (Ethernet) card belonging to this class, say Y.
 
@@ -18,8 +18,7 @@ if NET_VENDOR_FARADAY
 
 config FTMAC100
 	tristate "Faraday FTMAC100 10/100 Ethernet support"
-	depends on ARM || NDS32 || COMPILE_TEST
-	depends on !64BIT || BROKEN
+	depends on ARM || NDS32 || RISCV || COMPILE_TEST
 	select MII
 	---help---
 	  This driver supports the FTMAC100 10/100 Ethernet controller
@@ -28,7 +27,7 @@ config FTMAC100
 
 config FTGMAC100
 	tristate "Faraday FTGMAC100 Gigabit Ethernet support"
-	depends on ARM || NDS32 || COMPILE_TEST
+	depends on ARM || NDS32 || RISCV || COMPILE_TEST
 	depends on !64BIT || BROKEN
 	select PHYLIB
 	---help---
diff --git a/drivers/net/ethernet/faraday/ftmac100.c b/drivers/net/ethernet/faraday/ftmac100.c
index aecc7650..6575a88e 100644
--- a/drivers/net/ethernet/faraday/ftmac100.c
+++ b/drivers/net/ethernet/faraday/ftmac100.c
@@ -51,12 +51,25 @@
 #error invalid RX_BUF_SIZE
 #endif
 
+#define xprintk(...)
+
+#define FTMAC100_RX_DESC(priv, index)     (&priv->descs->rxdes[index])
+#define FTMAC100_RX_DESC_EXT(priv, index) (&priv->descs->rxdes_ext[index])
+#define FTMAC100_TX_DESC(priv, index)     (&priv->descs->txdes[index])
+#define FTMAC100_TX_DESC_EXT(priv, index) (&priv->descs->txdes_ext[index])
+
+#define FTMAC100_CURRENT_RX_DESC_INDEX(priv) (priv->rx_pointer)
+#define FTMAC100_CURRENT_TX_DESC_INDEX(priv) (priv->tx_pointer);
+#define FTMAC100_CURRENT_CLEAN_TX_DESC_INDEX(priv) (priv->tx_clean_pointer);
+
 /******************************************************************************
  * private data
  *****************************************************************************/
 struct ftmac100_descs {
 	struct ftmac100_rxdes rxdes[RX_QUEUE_ENTRIES];
 	struct ftmac100_txdes txdes[TX_QUEUE_ENTRIES];
+	struct ftmac100_rxdes_ext rxdes_ext[RX_QUEUE_ENTRIES];
+	struct ftmac100_txdes_ext txdes_ext[TX_QUEUE_ENTRIES];
 };
 
 struct ftmac100 {
@@ -81,8 +94,7 @@ struct ftmac100 {
 	struct mii_if_info mii;
 };
 
-static int ftmac100_alloc_rx_page(struct ftmac100 *priv,
-				  struct ftmac100_rxdes *rxdes, gfp_t gfp);
+static int ftmac100_alloc_rx_page(struct ftmac100 *priv, int index, gfp_t gfp);
 
 /******************************************************************************
  * internal functions (hardware register access)
@@ -109,11 +121,13 @@ static void ftmac100_disable_all_int(struct ftmac100 *priv)
 
 static void ftmac100_set_rx_ring_base(struct ftmac100 *priv, dma_addr_t addr)
 {
+xprintk("%s: addr %p\n", __func__, (void*)addr);
 	iowrite32(addr, priv->base + FTMAC100_OFFSET_RXR_BADR);
 }
 
 static void ftmac100_set_tx_ring_base(struct ftmac100 *priv, dma_addr_t addr)
 {
+xprintk("%s: addr %p\n", __func__, (void*)addr);
 	iowrite32(addr, priv->base + FTMAC100_OFFSET_TXR_BADR);
 }
 
@@ -186,6 +200,18 @@ static int ftmac100_start_hw(struct ftmac100 *priv)
 
 	iowrite32(FTMAC100_APTC_RXPOLL_CNT(1), priv->base + FTMAC100_OFFSET_APTC);
 
+	// Enable DMA Burst & RXFIFO threshold
+	iowrite32(FTMAC100_DBLAC_RX_THR_EN 	|  /* Enable fifo threshold arb */
+			  FTMAC100_DBLAC_INCR16_EN 	|  /* Enable INCR[4/8/16] DMA Burst, this option solve RX RPKT_LOST issue*/
+		  FTMAC100_DBLAC_RXFIFO_HTHR(6) |  /* 6/8 of FIFO high threshold */
+		  FTMAC100_DBLAC_RXFIFO_LTHR(2),   /* 2/8 of FIFO low threshold */
+		  priv->base + FTMAC100_OFFSET_DBLAC);
+
+	// Pending interrupt until receive packets reach threshold
+	iowrite32(FTMAC100_ITC_RXINT_THR(1) |
+		  FTMAC100_ITC_TXINT_THR(1),
+		  priv->base + FTMAC100_OFFSET_ITC);
+
 	ftmac100_set_mac(priv, netdev->dev_addr);
 
 	iowrite32(MACCR_ENABLE_ALL, priv->base + FTMAC100_OFFSET_MACCR);
@@ -272,25 +298,22 @@ static void ftmac100_rxdes_set_dma_addr(struct ftmac100_rxdes *rxdes,
 					dma_addr_t addr)
 {
 	rxdes->rxdes2 = cpu_to_le32(addr);
+	rxdes->rxdes3 = cpu_to_le32(addr >> 32);
 }
 
 static dma_addr_t ftmac100_rxdes_get_dma_addr(struct ftmac100_rxdes *rxdes)
 {
-	return le32_to_cpu(rxdes->rxdes2);
+	return le32_to_cpu(rxdes->rxdes2) | (dma_addr_t)le32_to_cpu(rxdes->rxdes3) << 32;
 }
 
-/*
- * rxdes3 is not used by hardware. We use it to keep track of page.
- * Since hardware does not touch it, we can skip cpu_to_le32()/le32_to_cpu().
- */
-static void ftmac100_rxdes_set_page(struct ftmac100_rxdes *rxdes, struct page *page)
+static void ftmac100_rxdes_set_page(struct ftmac100 *priv, int index, struct page *page)
 {
-	rxdes->rxdes3 = (unsigned int)page;
+	FTMAC100_RX_DESC_EXT(priv, index)->page = page;
 }
 
-static struct page *ftmac100_rxdes_get_page(struct ftmac100_rxdes *rxdes)
+static struct page *ftmac100_rxdes_get_page(struct ftmac100 *priv, int index)
 {
-	return (struct page *)rxdes->rxdes3;
+	return (struct page *)FTMAC100_RX_DESC_EXT(priv, index)->page;
 }
 
 /******************************************************************************
@@ -306,26 +329,23 @@ static void ftmac100_rx_pointer_advance(struct ftmac100 *priv)
 	priv->rx_pointer = ftmac100_next_rx_pointer(priv->rx_pointer);
 }
 
-static struct ftmac100_rxdes *ftmac100_current_rxdes(struct ftmac100 *priv)
-{
-	return &priv->descs->rxdes[priv->rx_pointer];
-}
-
-static struct ftmac100_rxdes *
+static int
 ftmac100_rx_locate_first_segment(struct ftmac100 *priv)
 {
-	struct ftmac100_rxdes *rxdes = ftmac100_current_rxdes(priv);
+	int index = FTMAC100_CURRENT_RX_DESC_INDEX(priv);
+	struct ftmac100_rxdes *rxdes = FTMAC100_RX_DESC(priv, index);
 
 	while (!ftmac100_rxdes_owned_by_dma(rxdes)) {
 		if (ftmac100_rxdes_first_segment(rxdes))
-			return rxdes;
+			return index;
 
 		ftmac100_rxdes_set_dma_own(rxdes);
 		ftmac100_rx_pointer_advance(priv);
-		rxdes = ftmac100_current_rxdes(priv);
+		index = FTMAC100_CURRENT_RX_DESC_INDEX(priv);
+		rxdes = FTMAC100_RX_DESC(priv, index);
 	}
 
-	return NULL;
+	return -1;
 }
 
 static bool ftmac100_rx_packet_error(struct ftmac100 *priv,
@@ -376,9 +396,13 @@ static bool ftmac100_rx_packet_error(struct ftmac100 *priv,
 static void ftmac100_rx_drop_packet(struct ftmac100 *priv)
 {
 	struct net_device *netdev = priv->netdev;
-	struct ftmac100_rxdes *rxdes = ftmac100_current_rxdes(priv);
+	struct ftmac100_rxdes *rxdes;
+	int index;
 	bool done = false;
 
+	index = FTMAC100_CURRENT_RX_DESC_INDEX(priv);
+	rxdes = FTMAC100_RX_DESC(priv, index);
+
 	if (net_ratelimit())
 		netdev_dbg(netdev, "drop packet %p\n", rxdes);
 
@@ -388,7 +412,8 @@ static void ftmac100_rx_drop_packet(struct ftmac100 *priv)
 
 		ftmac100_rxdes_set_dma_own(rxdes);
 		ftmac100_rx_pointer_advance(priv);
-		rxdes = ftmac100_current_rxdes(priv);
+		index = FTMAC100_CURRENT_RX_DESC_INDEX(priv);
+		rxdes = FTMAC100_RX_DESC(priv, index);
 	} while (!done && !ftmac100_rxdes_owned_by_dma(rxdes));
 
 	netdev->stats.rx_dropped++;
@@ -402,11 +427,12 @@ static bool ftmac100_rx_packet(struct ftmac100 *priv, int *processed)
 	struct page *page;
 	dma_addr_t map;
 	int length;
-	bool ret;
+	int index;
 
-	rxdes = ftmac100_rx_locate_first_segment(priv);
-	if (!rxdes)
+	index = ftmac100_rx_locate_first_segment(priv);
+	if (index < 0)
 		return false;
+	rxdes = FTMAC100_RX_DESC(priv, index);;
 
 	if (unlikely(ftmac100_rx_packet_error(priv, rxdes))) {
 		ftmac100_rx_drop_packet(priv);
@@ -417,8 +443,8 @@ static bool ftmac100_rx_packet(struct ftmac100 *priv, int *processed)
 	 * It is impossible to get multi-segment packets
 	 * because we always provide big enough receive buffers.
 	 */
-	ret = ftmac100_rxdes_last_segment(rxdes);
-	BUG_ON(!ret);
+	if (unlikely(!ftmac100_rxdes_last_segment(rxdes)))
+		BUG();
 
 	/* start processing */
 	skb = netdev_alloc_skb_ip_align(netdev, 128);
@@ -437,7 +463,7 @@ static bool ftmac100_rx_packet(struct ftmac100 *priv, int *processed)
 	dma_unmap_page(priv->dev, map, RX_BUF_SIZE, DMA_FROM_DEVICE);
 
 	length = ftmac100_rxdes_frame_length(rxdes);
-	page = ftmac100_rxdes_get_page(rxdes);
+	page = ftmac100_rxdes_get_page(priv, index);
 	skb_fill_page_desc(skb, 0, page, 0, length);
 	skb->len += length;
 	skb->data_len += length;
@@ -450,7 +476,7 @@ static bool ftmac100_rx_packet(struct ftmac100 *priv, int *processed)
 		/* Small frames are copied into linear part to free one page */
 		__pskb_pull_tail(skb, length);
 	}
-	ftmac100_alloc_rx_page(priv, rxdes, GFP_ATOMIC);
+	ftmac100_alloc_rx_page(priv, index, GFP_ATOMIC);
 
 	ftmac100_rx_pointer_advance(priv);
 
@@ -533,25 +559,27 @@ static void ftmac100_txdes_set_dma_addr(struct ftmac100_txdes *txdes,
 					dma_addr_t addr)
 {
 	txdes->txdes2 = cpu_to_le32(addr);
+	txdes->txdes3 = cpu_to_le32(addr >> 32);
 }
 
 static dma_addr_t ftmac100_txdes_get_dma_addr(struct ftmac100_txdes *txdes)
 {
-	return le32_to_cpu(txdes->txdes2);
+	return le32_to_cpu(txdes->txdes2) | (dma_addr_t)le32_to_cpu(txdes->txdes3) << 32;
 }
 
-/*
- * txdes3 is not used by hardware. We use it to keep track of socket buffer.
- * Since hardware does not touch it, we can skip cpu_to_le32()/le32_to_cpu().
- */
-static void ftmac100_txdes_set_skb(struct ftmac100_txdes *txdes, struct sk_buff *skb)
+static void ftmac100_txdes_skb_reset(struct ftmac100 *priv, int index)
 {
-	txdes->txdes3 = (unsigned int)skb;
+	FTMAC100_TX_DESC_EXT(priv, index)->skb = NULL;
 }
 
-static struct sk_buff *ftmac100_txdes_get_skb(struct ftmac100_txdes *txdes)
+static void ftmac100_txdes_set_skb(struct ftmac100 *priv, int index, struct sk_buff *skb)
 {
-	return (struct sk_buff *)txdes->txdes3;
+	FTMAC100_TX_DESC_EXT(priv, index)->skb = skb;
+}
+
+static struct sk_buff *ftmac100_txdes_get_skb(struct ftmac100 *priv, int index)
+{
+	return (struct sk_buff *)FTMAC100_TX_DESC_EXT(priv, index)->skb;
 }
 
 /******************************************************************************
@@ -572,32 +600,24 @@ static void ftmac100_tx_clean_pointer_advance(struct ftmac100 *priv)
 	priv->tx_clean_pointer = ftmac100_next_tx_pointer(priv->tx_clean_pointer);
 }
 
-static struct ftmac100_txdes *ftmac100_current_txdes(struct ftmac100 *priv)
-{
-	return &priv->descs->txdes[priv->tx_pointer];
-}
-
-static struct ftmac100_txdes *ftmac100_current_clean_txdes(struct ftmac100 *priv)
-{
-	return &priv->descs->txdes[priv->tx_clean_pointer];
-}
-
 static bool ftmac100_tx_complete_packet(struct ftmac100 *priv)
 {
 	struct net_device *netdev = priv->netdev;
 	struct ftmac100_txdes *txdes;
 	struct sk_buff *skb;
 	dma_addr_t map;
+	int index;
 
 	if (priv->tx_pending == 0)
 		return false;
 
-	txdes = ftmac100_current_clean_txdes(priv);
+	index = FTMAC100_CURRENT_CLEAN_TX_DESC_INDEX(priv);
+	txdes = FTMAC100_TX_DESC(priv, index);
 
 	if (ftmac100_txdes_owned_by_dma(txdes))
 		return false;
 
-	skb = ftmac100_txdes_get_skb(txdes);
+	skb = ftmac100_txdes_get_skb(priv, index);
 	map = ftmac100_txdes_get_dma_addr(txdes);
 
 	if (unlikely(ftmac100_txdes_excessive_collision(txdes) ||
@@ -616,6 +636,7 @@ static bool ftmac100_tx_complete_packet(struct ftmac100 *priv)
 	dev_kfree_skb(skb);
 
 	ftmac100_txdes_reset(txdes);
+	ftmac100_txdes_skb_reset(priv, index);
 
 	ftmac100_tx_clean_pointer_advance(priv);
 
@@ -639,12 +660,14 @@ static int ftmac100_xmit(struct ftmac100 *priv, struct sk_buff *skb,
 	struct net_device *netdev = priv->netdev;
 	struct ftmac100_txdes *txdes;
 	unsigned int len = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;
+	int index;
 
-	txdes = ftmac100_current_txdes(priv);
+	index = FTMAC100_CURRENT_TX_DESC_INDEX(priv);
+	txdes = FTMAC100_TX_DESC(priv, index);
 	ftmac100_tx_pointer_advance(priv);
 
 	/* setup TX descriptor */
-	ftmac100_txdes_set_skb(txdes, skb);
+	ftmac100_txdes_set_skb(priv, index, skb);
 	ftmac100_txdes_set_dma_addr(txdes, map);
 
 	ftmac100_txdes_set_first_segment(txdes);
@@ -668,10 +691,10 @@ static int ftmac100_xmit(struct ftmac100 *priv, struct sk_buff *skb,
 /******************************************************************************
  * internal functions (buffer)
  *****************************************************************************/
-static int ftmac100_alloc_rx_page(struct ftmac100 *priv,
-				  struct ftmac100_rxdes *rxdes, gfp_t gfp)
+static int ftmac100_alloc_rx_page(struct ftmac100 *priv, int index, gfp_t gfp)
 {
 	struct net_device *netdev = priv->netdev;
+	struct ftmac100_rxdes *rxdes = FTMAC100_RX_DESC(priv, index);
 	struct page *page;
 	dma_addr_t map;
 
@@ -690,7 +713,7 @@ static int ftmac100_alloc_rx_page(struct ftmac100 *priv,
 		return -ENOMEM;
 	}
 
-	ftmac100_rxdes_set_page(rxdes, page);
+	ftmac100_rxdes_set_page(priv, index, page);
 	ftmac100_rxdes_set_dma_addr(rxdes, map);
 	ftmac100_rxdes_set_buffer_size(rxdes, RX_BUF_SIZE);
 	ftmac100_rxdes_set_dma_own(rxdes);
@@ -702,8 +725,8 @@ static void ftmac100_free_buffers(struct ftmac100 *priv)
 	int i;
 
 	for (i = 0; i < RX_QUEUE_ENTRIES; i++) {
-		struct ftmac100_rxdes *rxdes = &priv->descs->rxdes[i];
-		struct page *page = ftmac100_rxdes_get_page(rxdes);
+		struct ftmac100_rxdes *rxdes = FTMAC100_RX_DESC(priv, i);
+		struct page *page = ftmac100_rxdes_get_page(priv, i);
 		dma_addr_t map = ftmac100_rxdes_get_dma_addr(rxdes);
 
 		if (!page)
@@ -714,8 +737,8 @@ static void ftmac100_free_buffers(struct ftmac100 *priv)
 	}
 
 	for (i = 0; i < TX_QUEUE_ENTRIES; i++) {
-		struct ftmac100_txdes *txdes = &priv->descs->txdes[i];
-		struct sk_buff *skb = ftmac100_txdes_get_skb(txdes);
+		struct ftmac100_txdes *txdes = FTMAC100_TX_DESC(priv, i);
+		struct sk_buff *skb = ftmac100_txdes_get_skb(priv, i);
 		dma_addr_t map = ftmac100_txdes_get_dma_addr(txdes);
 
 		if (!skb)
@@ -744,9 +767,7 @@ static int ftmac100_alloc_buffers(struct ftmac100 *priv)
 	ftmac100_rxdes_set_end_of_ring(&priv->descs->rxdes[RX_QUEUE_ENTRIES - 1]);
 
 	for (i = 0; i < RX_QUEUE_ENTRIES; i++) {
-		struct ftmac100_rxdes *rxdes = &priv->descs->rxdes[i];
-
-		if (ftmac100_alloc_rx_page(priv, rxdes, GFP_KERNEL))
+		if (ftmac100_alloc_rx_page(priv, i, GFP_KERNEL))
 			goto err;
 	}
 
@@ -871,11 +892,10 @@ static irqreturn_t ftmac100_interrupt(int irq, void *dev_id)
 	struct net_device *netdev = dev_id;
 	struct ftmac100 *priv = netdev_priv(netdev);
 
-	if (likely(netif_running(netdev))) {
-		/* Disable interrupts for polling */
-		ftmac100_disable_all_int(priv);
+	/* Disable interrupts for polling */
+	ftmac100_disable_all_int(priv);
+	if (likely(netif_running(netdev)))
 		napi_schedule(&priv->napi);
-	}
 
 	return IRQ_HANDLED;
 }
@@ -923,7 +943,7 @@ static int ftmac100_poll(struct napi_struct *napi, int budget)
 		ftmac100_tx_complete(priv);
 	}
 
-	if (status & (FTMAC100_INT_NORXBUF | FTMAC100_INT_RPKT_LOST |
+	if (status & (FTMAC100_INT_NORXBUF |
 		      FTMAC100_INT_AHB_ERR | FTMAC100_INT_PHYSTS_CHG)) {
 		if (net_ratelimit())
 			netdev_info(netdev, "[ISR] = 0x%x: %s%s%s%s\n", status,
@@ -977,6 +997,14 @@ static int ftmac100_open(struct net_device *netdev)
 		goto err_irq;
 	}
 
+	// set sysctl ip fragmentation parameters.
+	// sysctl -w net.ipv4.ipfrag_time
+	// sysctl -w net.ipv4.ipfrag_high_thresh
+	struct net *net;
+	net = dev_net(netdev);
+	net->ipv4.frags.timeout= (5* HZ);              /* Decrease fragment timeout, 30 -> 5 */
+	net->ipv4.frags.high_thresh= 8 * 1024 * 1024;  /* Increase fragment buffer size, 4M -> 8M */
+
 	priv->rx_pointer = 0;
 	priv->tx_clean_pointer = 0;
 	priv->tx_pointer = 0;
diff --git a/drivers/net/ethernet/faraday/ftmac100.h b/drivers/net/ethernet/faraday/ftmac100.h
index 46a0c47b..8ec8c0ff 100644
--- a/drivers/net/ethernet/faraday/ftmac100.h
+++ b/drivers/net/ethernet/faraday/ftmac100.h
@@ -35,6 +35,8 @@
 #define	FTMAC100_OFFSET_ITC		0x28
 #define	FTMAC100_OFFSET_APTC		0x2c
 #define	FTMAC100_OFFSET_DBLAC		0x30
+#define	FTMAC100_OFFSET_TXR_BADR_H	0x40
+#define	FTMAC100_OFFSET_RXR_BADR_H	0x44
 #define	FTMAC100_OFFSET_MACCR		0x88
 #define	FTMAC100_OFFSET_MACSR		0x8c
 #define	FTMAC100_OFFSET_PHYCR		0x90
@@ -138,7 +140,7 @@ struct ftmac100_txdes {
 	unsigned int	txdes0;
 	unsigned int	txdes1;
 	unsigned int	txdes2;	/* TXBUF_BADR */
-	unsigned int	txdes3;	/* not used by HW */
+	unsigned int	txdes3;	/* TXBUF_BADR_H */
 } __attribute__ ((aligned(16)));
 
 #define	FTMAC100_TXDES0_TXPKT_LATECOL	(1 << 0)
@@ -159,7 +161,7 @@ struct ftmac100_rxdes {
 	unsigned int	rxdes0;
 	unsigned int	rxdes1;
 	unsigned int	rxdes2;	/* RXBUF_BADR */
-	unsigned int	rxdes3;	/* not used by HW */
+	unsigned int	rxdes3;	/* RXBUF_BADR_H */
 } __attribute__ ((aligned(16)));
 
 #define	FTMAC100_RXDES0_RFL		0x7ff
@@ -177,4 +179,12 @@ struct ftmac100_rxdes {
 #define	FTMAC100_RXDES1_RXBUF_SIZE(x)	((x) & 0x7ff)
 #define	FTMAC100_RXDES1_EDORR		(1 << 31)
 
+struct ftmac100_txdes_ext {
+	void *skb;
+};
+
+struct ftmac100_rxdes_ext {
+	void *page;
+};
+
 #endif /* __FTMAC100_H */
diff --git a/drivers/net/wan/.gitignore b/drivers/net/wan/.gitignore
deleted file mode 100644
index dae3ea6b..00000000
--- a/drivers/net/wan/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-wanxlfw.inc
diff --git a/drivers/of/device.c b/drivers/of/device.c
index 064c8181..33d85511 100644
--- a/drivers/of/device.c
+++ b/drivers/of/device.c
@@ -76,6 +76,8 @@ int of_device_add(struct platform_device *ofdev)
  * of_dma_configure - Setup DMA configuration
  * @dev:	Device to apply DMA configuration
  * @np:		Pointer to OF node having DMA configuration
+ * @force_dma:  Whether device is to be set up by of_dma_configure() even if
+ *		DMA capability is not explicitly described by firmware.
  *
  * Try to get devices's DMA configuration from DT and update it
  * accordingly.
@@ -84,7 +86,7 @@ int of_device_add(struct platform_device *ofdev)
  * can use a platform bus notifier and handle BUS_NOTIFY_ADD_DEVICE events
  * to fix up DMA configuration.
  */
-int of_dma_configure(struct device *dev, struct device_node *np)
+int of_dma_configure(struct device *dev, struct device_node *np, bool force_dma)
 {
 	u64 dma_addr, paddr, size = 0;
 	int ret;
@@ -100,7 +102,7 @@ int of_dma_configure(struct device *dev, struct device_node *np)
 		 * DMA configuration regardless of whether "dma-ranges" is
 		 * correctly specified or not.
 		 */
-		if (!dev->bus->force_dma)
+		if (!force_dma)
 			return ret == -ENODEV ? 0 : ret;
 
 		dma_addr = offset = 0;
diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 9a4f4246..895c83e0 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -353,7 +353,7 @@ int of_reserved_mem_device_init_by_idx(struct device *dev,
 		/* ensure that dma_ops is set for virtual devices
 		 * using reserved memory
 		 */
-		of_dma_configure(dev, np);
+		of_dma_configure(dev, np, true);
 
 		dev_info(dev, "assigned reserved memory node %s\n", rmem->name);
 	} else {
diff --git a/drivers/parisc/Kconfig b/drivers/parisc/Kconfig
index 3a102a84..5a48b560 100644
--- a/drivers/parisc/Kconfig
+++ b/drivers/parisc/Kconfig
@@ -103,11 +103,6 @@ config IOMMU_SBA
 	depends on PCI_LBA
 	default PCI_LBA
 
-config IOMMU_HELPER
-	bool
-	depends on IOMMU_SBA || IOMMU_CCIO
-	default y
-
 source "drivers/pcmcia/Kconfig"
 
 endmenu
diff --git a/drivers/pci/host/Kconfig b/drivers/pci/host/Kconfig
index 0d0177ce..0dfcb16e 100644
--- a/drivers/pci/host/Kconfig
+++ b/drivers/pci/host/Kconfig
@@ -74,7 +74,7 @@ config PCI_HOST_GENERIC
 
 config PCIE_XILINX
 	bool "Xilinx AXI PCIe host bridge support"
-	depends on ARCH_ZYNQ || MICROBLAZE || (MIPS && PCI_DRIVERS_GENERIC)
+	depends on OF_PCI
 	help
 	  Say 'Y' here if you want kernel to support the Xilinx AXI PCIe
 	  Host Bridge driver.
diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index b9a13113..f8269a72 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -16,6 +16,8 @@
 #include <linux/pm_runtime.h>
 #include <linux/suspend.h>
 #include <linux/kexec.h>
+#include <linux/of_device.h>
+#include <linux/acpi.h>
 #include "pci.h"
 #include "pcie/portdrv.h"
 
@@ -1577,6 +1579,35 @@ static int pci_bus_num_vf(struct device *dev)
 	return pci_num_vf(to_pci_dev(dev));
 }
 
+/**
+ * pci_dma_configure - Setup DMA configuration
+ * @dev: ptr to dev structure
+ *
+ * Function to update PCI devices's DMA configuration using the same
+ * info from the OF node or ACPI node of host bridge's parent (if any).
+ */
+static int pci_dma_configure(struct device *dev)
+{
+	struct device *bridge;
+	int ret = 0;
+
+	bridge = pci_get_host_bridge_device(to_pci_dev(dev));
+
+	if (IS_ENABLED(CONFIG_OF) && bridge->parent &&
+	    bridge->parent->of_node) {
+		ret = of_dma_configure(dev, bridge->parent->of_node, true);
+	} else if (has_acpi_companion(bridge)) {
+		struct acpi_device *adev = to_acpi_device_node(bridge->fwnode);
+		enum dev_dma_attr attr = acpi_get_dma_attr(adev);
+
+		if (attr != DEV_DMA_NOT_SUPPORTED)
+			ret = acpi_dma_configure(dev, attr);
+	}
+
+	pci_put_host_bridge_device(bridge);
+	return ret;
+}
+
 struct bus_type pci_bus_type = {
 	.name		= "pci",
 	.match		= pci_bus_match,
@@ -1589,7 +1620,7 @@ struct bus_type pci_bus_type = {
 	.drv_groups	= pci_drv_groups,
 	.pm		= PCI_PM_OPS_PTR,
 	.num_vf		= pci_bus_num_vf,
-	.force_dma	= true,
+	.dma_configure	= pci_dma_configure,
 };
 EXPORT_SYMBOL(pci_bus_type);
 
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index 4635cb35..3aea72a5 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -41,6 +41,15 @@ config PWM_AB8500
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-ab8500.
 
+config PWM_ATCPIT100
+	tristate "AE350 PWM support"
+	depends on PLAT_AE350
+	help
+	  Generic PWM framework driver for AE350 SoC.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-atcpwm.
+
 config PWM_ATMEL
 	tristate "Atmel PWM support"
 	depends on ARCH_AT91
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index 9c676a0d..09c1ead1 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -2,6 +2,7 @@
 obj-$(CONFIG_PWM)		+= core.o
 obj-$(CONFIG_PWM_SYSFS)		+= sysfs.o
 obj-$(CONFIG_PWM_AB8500)	+= pwm-ab8500.o
+obj-$(CONFIG_PWM_ATCPIT100)	+= pwm-atcpit100.o
 obj-$(CONFIG_PWM_ATMEL)		+= pwm-atmel.o
 obj-$(CONFIG_PWM_ATMEL_HLCDC_PWM)	+= pwm-atmel-hlcdc.o
 obj-$(CONFIG_PWM_ATMEL_TCB)	+= pwm-atmel-tcb.o
diff --git a/drivers/pwm/pwm-atcpit100.c b/drivers/pwm/pwm-atcpit100.c
new file mode 100644
index 00000000..de4e8eda
--- /dev/null
+++ b/drivers/pwm/pwm-atcpit100.c
@@ -0,0 +1,246 @@
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/math64.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#define CLK_EXTERNAL				32768
+#define CLK_INTERNAL				60000000
+#define PRESCALE_MIN				0
+#define CHANNEL_ENABLE				(0x1c)
+#define CHPWMEN(ch)				((1<<3)<<(4*ch))
+#define CHANNEL_CONTROL(n)			(0x20 + (n*0x10))
+#define CHCLK_APB				(1<<3)
+#define CHMODE_PWM				(0x4)
+#define RELOAD(n)				(0x24 + (n*0x10))
+#define DUTY_CYCLE_HIGH_MIN			(0x00000000)
+#define DUTY_CYCLE_HIGH_MAX			(0x0000ffff)
+#define PERIOD_COUNT_MIN			(0x00000000)
+#define PERIOD_COUNT_MAX			(0x0000ffff)
+
+#define PWM_READL(offset)		\
+	readl(ap->base + (offset))
+
+#define PWM_WRITEL(val, offset)	\
+	writel((val), ap->base + (offset))
+
+struct atcpit_pwmc {
+	struct pwm_chip chip;
+	void __iomem *base;
+	struct clk *clk;
+	u64 rate[2];
+	u32 val;
+	bool en[2];
+	enum pwm_polarity polarity;	/* PWM polarity */
+};
+
+static inline struct atcpit_pwmc *to_atcpit_pwmc(struct pwm_chip *_chip)
+{
+	return container_of(_chip, struct atcpit_pwmc, chip);
+}
+
+static void atcpit_pwmc_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct atcpit_pwmc *ap = to_atcpit_pwmc(chip);
+	unsigned int chan = pwm->hwpwm;
+	unsigned int value;
+
+	value = PWM_READL(CHANNEL_ENABLE);
+	value &= ~(CHPWMEN(pwm->hwpwm));
+	PWM_WRITEL(value, CHANNEL_ENABLE);
+	ap->en[chan] = 0;
+	pwm->state.enabled = 0;
+}
+
+static int atcpit_pwmc_config(struct pwm_chip *chip, struct pwm_device *pwm,
+			    unsigned int duty_ns, unsigned int period_ns)
+{
+	struct atcpit_pwmc *ap = to_atcpit_pwmc(chip);
+	u64 val, div, rate;
+	unsigned long prescale = PRESCALE_MIN, pc, dc;
+	unsigned int value, chan = pwm->hwpwm;
+
+	/*
+	 * Find period count, duty count and prescale to suit duty_ns and
+	 * period_ns. This is done according to formulas described below:
+	 *
+	 * period_ns = 10^9 * (PRESCALE + 1) * PC / PWM_CLK_RATE
+	 * duty_ns = 10^9  * (PRESCALE + 1) * DC / PWM_CLK_RATE
+	 *
+	 * PC = (PWM_CLK_RATE * period_ns) / (10^9 * (PRESCALE + 1))
+	 * DC = (PWM_CLK_RATE * duty_ns) / (10^9 * (PRESCALE + 1))
+	 */
+
+	if (period_ns <= duty_ns)
+		return -EINVAL;
+
+	if (ap->en[chan]) {
+		while (1) {
+			rate = ap->rate[pwm->hwpwm];
+			div = 1000000000;
+			div *= 1 + prescale;
+			val = rate * period_ns;
+			pc = div64_u64(val, div);
+			val = rate * duty_ns;
+			dc = div64_u64(val, div);
+			pc -= dc;
+
+			/* If duty_ns or period_ns are not achievable then return */
+			if (pc < PERIOD_COUNT_MIN || dc < DUTY_CYCLE_HIGH_MIN) {
+				atcpit_pwmc_disable(chip, pwm);
+				return -EINVAL;
+			}
+
+			/* If pc and dc are in bounds, the calculation is done */
+			if (pc <= PERIOD_COUNT_MAX && dc <= DUTY_CYCLE_HIGH_MAX) {
+				if(pc > 0)
+					pc--;
+
+				if (ap->polarity == PWM_POLARITY_NORMAL) {
+					value = pc;
+					value |= ((dc) << 16);
+					ap->val = value;
+				} else {
+					value = dc;
+					value |= ((pc) << 16);
+				}
+				PWM_WRITEL(value, RELOAD(pwm->hwpwm));
+				break;
+			}
+
+			/* Otherwise recalculate pc and dc */
+			if (pc > PERIOD_COUNT_MAX || dc > DUTY_CYCLE_HIGH_MAX) {
+				atcpit_pwmc_disable(chip, pwm);
+				return -EINVAL;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int atcpit_pwmc_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct atcpit_pwmc *ap = to_atcpit_pwmc(chip);
+	int ret;
+	unsigned int chan = pwm->hwpwm;
+	unsigned int value;
+
+	value = PWM_READL(CHANNEL_CONTROL(chan));
+	value |= (CHMODE_PWM);
+
+	if(pwm->hwpwm)
+		value |= (CHCLK_APB);
+
+	PWM_WRITEL(value, CHANNEL_CONTROL(chan));
+	value = PWM_READL(CHANNEL_ENABLE);
+	value |= CHPWMEN(pwm->hwpwm);
+	PWM_WRITEL(value, CHANNEL_ENABLE);
+	ap->en[chan] = 1;
+	pwm->state.enabled = 1;
+	ret = atcpit_pwmc_config(chip, pwm, pwm_get_duty_cycle(pwm),
+			       pwm_get_period(pwm));
+
+	if (ret < 0) {
+		clk_disable_unprepare(ap->clk);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int atcpit_pwmc_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm,
+				  enum pwm_polarity polarity)
+{
+	struct atcpit_pwmc *ap = to_atcpit_pwmc(chip);
+	ap->polarity = polarity;
+
+	return 0;
+}
+
+static const struct pwm_ops atcpit_pwm_ops = {
+	.config = atcpit_pwmc_config,
+	.set_polarity = atcpit_pwmc_set_polarity,
+	.enable = atcpit_pwmc_enable,
+	.disable = atcpit_pwmc_disable,
+	.owner = THIS_MODULE,
+};
+
+static int atcpit_pwmc_probe(struct platform_device *pdev)
+{
+	struct atcpit_pwmc *ap;
+	struct resource *res;
+	int ret = 0;
+
+	ap = devm_kzalloc(&pdev->dev, sizeof(*ap), GFP_KERNEL);
+
+	if (ap == NULL)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, ap);
+	ap->chip.dev = &pdev->dev;
+	ap->chip.ops = &atcpit_pwm_ops;
+	ap->chip.base = -1;
+	ap->chip.npwm = 2;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ap->base = devm_ioremap_resource(&pdev->dev, res);
+
+	if (IS_ERR(ap->base))
+		return PTR_ERR(ap->base);
+
+	ap->rate[0] = CLK_EXTERNAL;
+	ap->rate[1] = CLK_INTERNAL;
+
+	if (IS_ERR(ap->clk)) {
+		dev_err(&pdev->dev, "failed to get clock: %ld\n",
+			PTR_ERR(ap->clk));
+		return PTR_ERR(ap->clk);
+	}
+
+	ret = pwmchip_add_with_polarity(&ap->chip, PWM_POLARITY_NORMAL);
+	if (ret < 0)
+		dev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);
+
+	return ret;
+}
+
+static int atcpit_pwmc_remove(struct platform_device *pdev)
+{
+	struct atcpit_pwmc *ap = platform_get_drvdata(pdev);
+	int err;
+
+	err = pwmchip_remove(&ap->chip);
+	if (err < 0)
+		return err;
+
+	dev_dbg(&pdev->dev, "pwm-atcpit100 driver removed\n");
+
+	return 0;
+
+}
+
+static const struct of_device_id atcpit_pwmc_dt[] = {
+	{ .compatible = "andestech,atcpit100-pwm" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, atcpit_pwmc_dt);
+
+static struct platform_driver atcpit_pwmc_driver = {
+	.driver = {
+		.name = "atcpit100-pwm",
+		.of_match_table = atcpit_pwmc_dt,
+	},
+	.probe = atcpit_pwmc_probe,
+	.remove = atcpit_pwmc_remove,
+};
+module_platform_driver(atcpit_pwmc_driver);
+MODULE_AUTHOR("Andestech Corporation <rick@andestech.com>");
+MODULE_DESCRIPTION("Andes atcpit100 PWM driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c
index 7c71cdb8..4726d43a 100644
--- a/drivers/pwm/sysfs.c
+++ b/drivers/pwm/sysfs.c
@@ -263,7 +263,6 @@ static int pwm_export_child(struct device *parent, struct pwm_device *pwm)
 	export->pwm = pwm;
 	mutex_init(&export->lock);
 
-	export->child.class = parent->class;
 	export->child.release = pwm_export_release;
 	export->child.parent = parent;
 	export->child.devt = MKDEV(0, 0);
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 59e6dede..36b1ad13 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1352,6 +1352,16 @@ config RTC_DRV_S3C
 	  This driver can also be build as a module. If so, the module
 	  will be called rtc-s3c.
 
+config RTC_DRV_ATCRTC100
+	tristate "AE3XX Real Time Clock"
+	depends on RISCV
+	help
+	  If you say Y here you will get access to the real time clock
+	  built into your AE3XX.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called rtc-atcrtc100.
+
 config RTC_DRV_EP93XX
 	tristate "Cirrus Logic EP93XX"
 	depends on ARCH_EP93XX || COMPILE_TEST
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 5ff2fc0c..c1df8c79 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -33,6 +33,7 @@ obj-$(CONFIG_RTC_DRV_AC100)	+= rtc-ac100.o
 obj-$(CONFIG_RTC_DRV_ARMADA38X)	+= rtc-armada38x.o
 obj-$(CONFIG_RTC_DRV_AS3722)	+= rtc-as3722.o
 obj-$(CONFIG_RTC_DRV_ASM9260)	+= rtc-asm9260.o
+obj-$(CONFIG_RTC_DRV_ATCRTC100) += rtc-atcrtc100.o
 obj-$(CONFIG_RTC_DRV_AT91RM9200)+= rtc-at91rm9200.o
 obj-$(CONFIG_RTC_DRV_AT91SAM9)	+= rtc-at91sam9.o
 obj-$(CONFIG_RTC_DRV_AU1XXX)	+= rtc-au1xxx.o
diff --git a/drivers/rtc/rtc-atcrtc100.c b/drivers/rtc/rtc-atcrtc100.c
new file mode 100644
index 00000000..08c9a464
--- /dev/null
+++ b/drivers/rtc/rtc-atcrtc100.c
@@ -0,0 +1,379 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2008-2017 Andes Technology Corporation
+
+/*
+ * Andes RTC Support
+ *
+ * Copyright (C) 2006, 2007, 2008  Paul Mundt
+ * Copyright (C) 2006  Jamie Lenehan
+ * Copyright (C) 2008  Angelo Castello
+ * Copyright (C) 2008  Roy Lee
+ *
+ * Based on the old arch/sh/kernel/cpu/rtc.c by:
+ *
+ *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
+ *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/rtc.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/of.h>
+
+#define DRV_NAME		"atcrtc100"
+#define RTC_REG(off)		\
+		(*(volatile unsigned int *)(rtc->regbase + (off)))
+#define RTC_ID			RTC_REG(0x00)	/* ID and Revision */
+#define ID_OFF			12
+#define ID_MSK			(0xfffff << ID_OFF)
+#define ATCRTC100ID		(0x03011 << ID_OFF)
+#define RTC_RSV			RTC_REG(0x4)	/* Reserve */
+
+#define RTC_CNT			RTC_REG(0x10)	/* Counter */
+#define RTC_ALM			RTC_REG(0x14)	/* Alarm */
+#define DAY_OFF			17
+#define DAY_MSK			(0x7fff)
+#define HOR_OFF			12
+#define HOR_MSK			(0x1f)
+#define MIN_OFF			6
+#define MIN_MSK			(0x3f)
+#define SEC_OFF			0
+#define SEC_MSK			(0x3f)
+#define RTC_SECOND		\
+			((RTC_CNT >> SEC_OFF) & SEC_MSK) /* RTC sec */
+#define RTC_MINUTE		\
+			((RTC_CNT >> MIN_OFF) & MIN_MSK) /* RTC min */
+#define RTC_HOUR		\
+			((RTC_CNT >> HOR_OFF) & HOR_MSK) /* RTC hour */
+#define RTC_DAYS		\
+			((RTC_CNT >> DAY_OFF) & DAY_MSK) /* RTC day */
+#define RTC_ALM_SECOND		\
+			((RTC_ALM >> SEC_OFF) & SEC_MSK) /* RTC alarm sec */
+#define RTC_ALM_MINUTE		\
+			((RTC_ALM >> MIN_OFF) & MIN_MSK) /* RTC alarm min */
+#define RTC_ALM_HOUR		\
+			((RTC_ALM >> HOR_OFF) & HOR_MSK) /* RTC alarm hour */
+#define RTC_CR			RTC_REG(0x18)	/* Control */
+#define RTC_EN			(0x1UL << 0)
+#define ALARM_WAKEUP		(0x1UL << 1)
+#define ALARM_INT		(0x1UL << 2)
+#define DAY_INT			(0x1UL << 3)
+#define HOR_INT			(0x1UL << 4)
+#define MIN_INT			(0x1UL << 5)
+#define SEC_INT			(0x1UL << 6)
+#define HSEC_INT		(0x1UL << 7)
+#define RTC_STA			RTC_REG(0x1c)	/* Status */
+#define WD			(0x1UL << 16)
+
+/* CHeck if day is configured as  15 */
+#define CHECK_DAY_15	0
+
+struct atc_rtc {
+	void __iomem *regbase;
+	struct resource *res;
+	unsigned int alarm_irq;
+	unsigned int interrupt_irq;
+	struct rtc_device *rtc_dev;
+	spinlock_t		lock;		/* Protects this structure */
+};
+
+struct atc_rtc rtc_platform_data;
+
+static irqreturn_t rtc_interrupt(int irq, void *dev_id)
+{
+	struct atc_rtc *rtc = dev_id;
+
+	if (RTC_STA & SEC_INT) {
+		RTC_STA |= SEC_INT;
+		rtc_update_irq(rtc->rtc_dev, 1, RTC_UF | RTC_IRQF);
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+static irqreturn_t rtc_alarm(int irq, void *dev_id)
+{
+	struct atc_rtc *rtc = dev_id;
+
+	if (RTC_STA & ALARM_INT) {
+		RTC_CR &= ~ALARM_INT;
+		RTC_STA |= ALARM_INT;
+		rtc_update_irq(rtc->rtc_dev, 1, RTC_AF | RTC_IRQF);
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+static int atc_alarm_irq_enable(struct device *dev, unsigned int enabled)
+{
+	struct atc_rtc *rtc = dev_get_drvdata(dev);
+
+	spin_lock_irq(&rtc->lock);
+	if (enabled)
+		RTC_CR |= ALARM_INT;
+	else
+		RTC_CR &= ~ALARM_INT;
+	spin_unlock_irq(&rtc->lock);
+	return 0;
+}
+
+static int atc_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct atc_rtc *rtc = dev_get_drvdata(dev);
+	unsigned long time = RTC_DAYS * 86400 + RTC_HOUR * 3600
+				+ RTC_MINUTE * 60 + RTC_SECOND;
+
+	rtc_time_to_tm(time, tm);
+	if (rtc_valid_tm(tm) < 0) {
+		dev_err(dev, "invalid date\n");
+		rtc_time_to_tm(0, tm);
+	}
+	return 0;
+}
+
+static int atc_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct atc_rtc *rtc = dev_get_drvdata(dev);
+	unsigned long time = 0;
+	u32 cnt = 0;
+
+	rtc_tm_to_time(tm, &time);
+	cnt |= (((time / 86400) & DAY_MSK) << DAY_OFF);
+	time %= 86400;
+	cnt |= (((time / 3600) & HOR_MSK) << HOR_OFF);
+	time %= 3600;
+	cnt |= (((time / 60) & MIN_MSK) << MIN_OFF);
+	time %= 60;
+	cnt |= ((time & SEC_MSK) << SEC_OFF);
+
+	spin_lock_irq(&rtc->lock);
+	RTC_CNT = cnt;
+	spin_unlock_irq(&rtc->lock);
+
+	/* synchronization progress of RTC register updates */
+	while ((RTC_STA & WD) != WD)
+		continue;
+
+	return 0;
+}
+
+static int atc_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)
+{
+	struct atc_rtc *rtc = dev_get_drvdata(dev);
+	struct rtc_time *tm = &wkalrm->time;
+
+	tm->tm_sec	= RTC_ALM_SECOND;
+	tm->tm_min	= RTC_ALM_MINUTE;
+	tm->tm_hour	= RTC_ALM_HOUR;
+	wkalrm->enabled = (RTC_CR & ALARM_INT) ? 1 : 0;
+	return 0;
+}
+
+static int atc_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)
+{
+	u32 alm = 0;
+	struct atc_rtc *rtc = dev_get_drvdata(dev);
+	struct rtc_time *tm = &wkalrm->time;
+	int err = rtc_valid_tm(tm);
+
+	if (err < 0) {
+		dev_err(dev, "invalid alarm value\n");
+		return err;
+	}
+	/* disable alarm interrupt and clear the alarm flag */
+	RTC_CR &= ~ALARM_INT;
+	/* set alarm time */
+	alm |= ((tm->tm_sec & SEC_MSK) << SEC_OFF);
+	alm |= ((tm->tm_min & MIN_MSK) << MIN_OFF);
+	alm |= ((tm->tm_hour & HOR_MSK) << HOR_OFF);
+
+	spin_lock_irq(&rtc->lock);
+	RTC_ALM = alm;
+
+	while ((RTC_STA & WD) != WD)
+		continue;
+
+	if (wkalrm->enabled)
+		RTC_CR |= ALARM_INT;
+	spin_unlock_irq(&rtc->lock);
+
+	return 0;
+}
+
+const static struct rtc_class_ops rtc_ops = {
+	.alarm_irq_enable = atc_alarm_irq_enable,
+	.read_time	= atc_rtc_read_time,
+	.set_time	= atc_rtc_set_time,
+	.read_alarm	= atc_rtc_read_alarm,
+	.set_alarm	= atc_rtc_set_alarm,
+};
+
+static int atc_rtc_probe(struct platform_device *pdev)
+{
+	struct atc_rtc *rtc = &rtc_platform_data;
+	int ret = -ENOENT;
+
+	spin_lock_init(&rtc->lock);
+
+	rtc->alarm_irq = platform_get_irq(pdev, 1);
+	if (rtc->alarm_irq < 0)
+		goto err_exit;
+
+	rtc->interrupt_irq = platform_get_irq(pdev, 0);
+	if (rtc->interrupt_irq < 0)
+		goto err_exit;
+
+	rtc->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!rtc->res)
+		goto err_exit;
+
+	ret = request_irq(rtc->alarm_irq, rtc_alarm, 0,
+			  "RTC Alarm : atcrtc100", rtc);
+	if (ret)
+		goto err_exit;
+
+	ret = request_irq(rtc->interrupt_irq, rtc_interrupt,
+			  0, "RTC Interrupt : atcrtc100", rtc);
+	if (ret)
+		goto err_interrupt_irq;
+
+	ret = -EBUSY;
+
+	rtc->res = request_mem_region(rtc->res->start,
+				      rtc->res->end - rtc->res->start + 1,
+				      pdev->name);
+	if (!rtc->res)
+		goto err_request_region;
+
+	ret = -EINVAL;
+
+	rtc->regbase = ioremap_nocache(rtc->res->start,
+				       rtc->res->end - rtc->res->start + 1);
+	if (!rtc->regbase)
+		goto err_ioremap1;
+
+	if ((RTC_ID & ID_MSK) != ATCRTC100ID)
+		return -ENOENT;
+
+#if CHECK_DAY_15
+	RTC_CNT = DAY_MSK << DAY_OFF;
+	while ((RTC_STA & WD) != WD)
+		continue;
+
+	if (DAY_MSK << DAY_OFF != RTC_CNT) {
+		pr_err("rtc initialize fail\n");
+		return -ENOENT;
+	}
+#endif
+	RTC_CR |= RTC_EN;
+	platform_set_drvdata(pdev, rtc);
+
+	if (of_property_read_bool(pdev->dev.of_node, "wakeup-source"))
+		device_init_wakeup(&pdev->dev, true);
+
+	rtc->rtc_dev =
+		rtc_device_register(DRV_NAME, &pdev->dev,
+				    &rtc_ops, THIS_MODULE);
+
+	if (IS_ERR(rtc->rtc_dev)) {
+		ret = PTR_ERR(rtc->rtc_dev);
+		goto err_unmap;
+	}
+
+	rtc->rtc_dev->max_user_freq = 256;
+	rtc->rtc_dev->irq_freq = 1;
+	return 0;
+
+err_unmap:
+	iounmap(rtc->regbase);
+err_ioremap1:
+	release_resource(rtc->res);
+err_request_region:
+	free_irq(rtc->interrupt_irq, rtc);
+err_interrupt_irq:
+	free_irq(rtc->alarm_irq, rtc);
+err_exit:
+	return ret;
+}
+
+static int atc_rtc_remove(struct platform_device *pdev)
+{
+	struct atc_rtc *rtc = platform_get_drvdata(pdev);
+
+	rtc_device_unregister(rtc->rtc_dev);
+	/*
+	 * Because generic rtc will not execute rtc_device_release()
+	 * when call rtc_device_unregister(),
+	 * rtc id will increase when unloading a rtc driver.
+	 * This can work around to recycle rtc id.
+	 * But if kernel fix this issue, it shell be removed away.
+	 */
+	rtc->rtc_dev->dev.release(&rtc->rtc_dev->dev);
+	RTC_CR &= ~(RTC_EN | SEC_INT | ALARM_INT);
+	free_irq(rtc->alarm_irq, rtc);
+	free_irq(rtc->interrupt_irq, rtc);
+	iounmap(rtc->regbase);
+	release_resource(rtc->res);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int atc_rtc_resume(struct device *dev)
+{
+	struct atc_rtc *rtc_dd = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev))
+		disable_irq_wake(rtc_dd->alarm_irq);
+
+	return 0;
+}
+
+static int atc_rtc_suspend(struct device *dev)
+{
+	struct atc_rtc *rtc_dd = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev))
+		enable_irq_wake(rtc_dd->alarm_irq);
+
+	return 0;
+}
+#endif
+static SIMPLE_DEV_PM_OPS(atc_rtc_pm_ops, atc_rtc_suspend, atc_rtc_resume);
+
+#ifdef CONFIG_OF
+static const struct of_device_id atc_rtc_dt_match[] = {
+	{.compatible = "andestech,atcrtc100" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, atc_rtc_dt_match);
+#endif
+
+static struct platform_driver atc_rtc_platform_driver = {
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table	= of_match_ptr(atc_rtc_dt_match),
+		.pm = &atc_rtc_pm_ops,
+	},
+	.probe		= atc_rtc_probe,
+	.remove		= atc_rtc_remove,
+};
+
+module_platform_driver(atc_rtc_platform_driver);
+MODULE_DESCRIPTION("SuperH on-chip RTC driver");
+MODULE_AUTHOR("Paul Mundt <lethal@linux-sh.org>, "
+	      "Jamie Lenehan <lenehan@twibble.org>, "
+	      "Angelo Castello <angelo.castello@st.com>, "
+	      "Nick Hu <nickhu@andestech.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/drivers/scsi/.gitignore b/drivers/scsi/.gitignore
deleted file mode 100644
index e2956741..00000000
--- a/drivers/scsi/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-53c700_d.h
-scsi_devinfo_tbl.c
diff --git a/drivers/scsi/aic7xxx/.gitignore b/drivers/scsi/aic7xxx/.gitignore
deleted file mode 100644
index b8ee24d5..00000000
--- a/drivers/scsi/aic7xxx/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-aic79xx_reg.h
-aic79xx_reg_print.c
-aic79xx_seq.h
-aic7xxx_reg.h
-aic7xxx_reg_print.c
-aic7xxx_seq.h
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 2d4146ce..9ff5322b 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -743,6 +743,18 @@ config SPI_ZYNQMP_GQSPI
 	help
 	  Enables Xilinx GQSPI controller driver for Zynq UltraScale+ MPSoC.
 
+config SPI_SIFIVE
+        tristate "SiFive SPI controller"
+        depends on HAS_IOMEM
+	select SPI_BITBANG
+        help
+          This exposes the SPI controller IP from SiFive.
+
+config SPI_ATCSPI200
+        tristate "ANDES TECH SPI controller"
+        depends on HAS_IOMEM
+        help
+          This exposes the SPI controller IP from Andes.
 #
 # Add new SPI master controllers in alphabetical order above this line
 #
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index b935f10e..d3e1e564 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_SPI_LOOPBACK_TEST)		+= spi-loopback-test.o
 obj-$(CONFIG_SPI_ALTERA)		+= spi-altera.o
 obj-$(CONFIG_SPI_ARMADA_3700)		+= spi-armada-3700.o
 obj-$(CONFIG_SPI_ATMEL)			+= spi-atmel.o
+obj-$(CONFIG_SPI_ATCSPI200)		+= spi-atcspi200.o
 obj-$(CONFIG_SPI_ATH79)			+= spi-ath79.o
 obj-$(CONFIG_SPI_AU1550)		+= spi-au1550.o
 obj-$(CONFIG_SPI_AXI_SPI_ENGINE)	+= spi-axi-spi-engine.o
@@ -106,6 +107,7 @@ obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
 obj-$(CONFIG_SPI_XLP)			+= spi-xlp.o
 obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
 obj-$(CONFIG_SPI_ZYNQMP_GQSPI)		+= spi-zynqmp-gqspi.o
+obj-$(CONFIG_SPI_SIFIVE)		+= spi-sifive.o
 
 # SPI slave protocol handlers
 obj-$(CONFIG_SPI_SLAVE_TIME)		+= spi-slave-time.o
diff --git a/drivers/spi/spi-atcspi200.c b/drivers/spi/spi-atcspi200.c
new file mode 100644
index 00000000..a4ec76a4
--- /dev/null
+++ b/drivers/spi/spi-atcspi200.c
@@ -0,0 +1,426 @@
+/*
+ * Andestech SPI controller driver
+ *
+ * Author: Nylon Chen
+ *	nylon7@andestech.com
+ *
+ * 2020 (c) Andes Technology Corporation
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/spinlock.h>
+
+#define SPI_XFER_BEGIN		(1 << 0)
+#define SPI_XFER_END		(1 << 1)
+#define SPI_XFER_ONCE		(SPI_XFER_BEGIN | SPI_XFER_END)
+
+#define SPI_NAME		"atcspi200"
+#define SPI_MAX_HZ		50000000
+#define MAX_TRANSFER_LEN	512
+#define CHUNK_SIZE		1
+#define SPI_TIMEOUT		0x100000
+#define NSPI_MAX_CS_NUM		1
+#define DATA_LENGTH(x)		((x-1)<<8)
+
+/* SPI Transfer Control Register  */
+#define ATCSPI200_TRANSFMT_OFFSET 		24
+#define ATCSPI200_TRANSFMT_MASK			(0x0F<<ATCSPI200_TRANSFMT_OFFSET)
+#define ATCSPI200_TRANSMODE_WR_SYNC 		(0<<ATCSPI200_TRANSFMT_OFFSET)
+#define ATCSPI200_TRANSMODE_W_ONLY      	(1<<ATCSPI200_TRANSFMT_OFFSET)
+#define ATCSPI200_TRANSMODE_R_ONLY      	(2<<ATCSPI200_TRANSFMT_OFFSET)
+#define ATCSPI200_TRANSMODE_WR      		(3<<ATCSPI200_TRANSFMT_OFFSET)
+#define ATCSPI200_TRANSCTRL_WRTRANCNT_OFFSET	12
+#define ATCSPI200_TRANSCTRL_WRTRANCNT_MASK	(0x1FF<<ATCSPI200_TRANSCTRL_WRTRANCNT_OFFSET)
+#define ATCSPI200_TRANSCTRL_RDTRANCNT_OFFSET	0
+#define ATCSPI200_TRANSCTRL_RDTRANCNT_MASK	(0x1FF<<ATCSPI200_TRANSCTRL_RDTRANCNT_OFFSET)
+
+/* SPI Control Register */
+#define ATCSPI200_CTRL_TXFIFORST_MASK		(1<<2)
+#define ATCSPI200_CTRL_RXFIFORST_MASK		(1<<1)
+#define ATCSPI200_CTRL_SPIRST_MASK		(1<<0)
+
+/* SPI Transfer Format Register */
+#define ATCSPI200_TRANSFMT_CPHA_MASK		(1UL << 0)
+#define ATCSPI200_TRANSFMT_CPOL_MASK		(1UL << 1)
+
+/* SPI Status Register */
+#define ATCSPI200_STATUS_TXEMPTY_OFFSET		(1<<22)
+#define ATCSPI200_STATUS_RXEMPTY_OFFSET		(1<<14)
+#define ATCSPI200_STATUS_TXNUM_LOWER_OFFSET	(16)
+#define ATCSPI200_STATUS_TXNUM_LOWER_MASK	(0x1F<<ATCSPI200_STATUS_TXNUM_LOWER_OFFSET)
+#define ATCSPI200_STATUS_RXNUM_LOWER_OFFSET	(8)
+#define ATCSPI200_STATUS_RXNUM_LOWER_MASK	(0x1F<<ATCSPI200_STATUS_RXNUM_LOWER_OFFSET)
+#define ATCSPI200_STATUS_SPIACTIVE_MASK		(1<<0)
+
+/* SPI Interface timing Setting */
+#define ATCSPI200_TIMING_SCLK_DIV_MASK		0xFF
+
+/* ATCSPI200 registers  */
+#define IDRev		0x00	// ID and Revision Register
+#define TransFmt  	0x10    // SPI Transfer Format Register
+#define DirectIO	0x14	// SPI Direct IO Control Register
+#define TransCtrl	0x20	// SPI Transfer Control Register
+#define Cmd		0x24	// SPI Command Register
+#define Addr		0x28	// SPI Address Register
+#define Data		0x2C	// SPI Data Register
+#define Ctrl		0x30	// SPI Control Register
+#define Status		0x34	// SPI Status Register
+#define IntrEn		0x38	// SPI Interrupt Enable Register
+#define IntrSt		0x3C	// SPI Interrupt Status Registe
+#define Timing		0x40	// SPI Interface timing Register
+
+struct atcspi200_spi {
+	void __iomem	*regs;
+	struct clk	*clk;
+	size_t		trans_len;
+	size_t		data_len;
+	size_t		cmd_len;
+	u32		clk_rate;
+	u8		cmd_buf[16];
+	u8		*din;
+	u8		*dout;
+	unsigned int	max_transfer_length;
+	unsigned int	freq;
+	unsigned int	mode;
+	unsigned int	mtiming;
+	int		timeout;
+	spinlock_t	lock;
+};
+
+static void atcspi200_spi_write(struct atcspi200_spi *spi, int offset, u32 value)
+{
+	iowrite32(value, spi->regs + offset);
+}
+
+static u32 atcspi200_spi_read(struct atcspi200_spi *spi, int offset)
+{
+	return ioread32(spi->regs + offset);
+}
+
+static int atcspi200_spi_setup(struct atcspi200_spi *spi)
+{
+	unsigned int	format_val;
+	u32	timing;
+	u8	div;
+	int ctrl_val = atcspi200_spi_read(spi,Ctrl);
+	ctrl_val |= (ATCSPI200_CTRL_TXFIFORST_MASK|ATCSPI200_CTRL_RXFIFORST_MASK|ATCSPI200_CTRL_SPIRST_MASK);
+	atcspi200_spi_write(spi,Ctrl,ctrl_val);
+	while (((atcspi200_spi_read(spi,Ctrl))&(ATCSPI200_CTRL_TXFIFORST_MASK|ATCSPI200_CTRL_RXFIFORST_MASK|ATCSPI200_CTRL_SPIRST_MASK))&&(spi->timeout--))
+		if (!spi->timeout)
+			return -EINVAL;
+
+	spi->cmd_len = 0;
+	format_val = spi->mode|DATA_LENGTH(8);
+	format_val |= ATCSPI200_TRANSFMT_CPHA_MASK;
+	format_val |= ATCSPI200_TRANSFMT_CPOL_MASK;
+	atcspi200_spi_write(spi,TransFmt,format_val);
+
+	timing = atcspi200_spi_read(spi,Timing);
+	timing &= ~ATCSPI200_TIMING_SCLK_DIV_MASK;
+
+	if (spi->freq >= spi->clk_rate)
+		div = ATCSPI200_TIMING_SCLK_DIV_MASK;
+	else {
+		for (div=0; div <ATCSPI200_TIMING_SCLK_DIV_MASK; div++) {
+			if(spi->freq >= spi->clk_rate / (2 * (div + 1)))
+				break;
+		}
+	}
+	timing |= div;
+	atcspi200_spi_write(spi,Timing,timing);
+	return 0;
+}
+
+static int atcspi200_spi_stop(struct atcspi200_spi *spi)
+{
+	atcspi200_spi_write(spi,Timing,spi->mtiming);
+	while ((atcspi200_spi_read(spi,Status) & ATCSPI200_STATUS_SPIACTIVE_MASK)&&(spi->timeout--))
+		if (!spi->timeout)
+			return -EINVAL;
+	return 0;
+}
+
+static int atcspi200_spi_start(struct atcspi200_spi *spi,struct spi_transfer *t)
+{
+	int i,trans_len=0;
+	int tc = atcspi200_spi_read(spi,TransCtrl);
+
+	tc &= ~(ATCSPI200_TRANSCTRL_WRTRANCNT_MASK|ATCSPI200_TRANSCTRL_RDTRANCNT_MASK|ATCSPI200_TRANSFMT_MASK);
+	if ((spi->dout)&&(spi->cmd_len))
+		tc |= ATCSPI200_TRANSMODE_WR;
+	else if (spi->dout)
+		tc |= ATCSPI200_TRANSMODE_R_ONLY;
+	else
+		tc |= ATCSPI200_TRANSMODE_W_ONLY;
+
+	if (spi->din)
+		trans_len = spi->trans_len;
+	tc |= (spi->cmd_len+trans_len-1) << ATCSPI200_TRANSCTRL_WRTRANCNT_OFFSET;
+
+	if (spi->dout)
+		tc |= (spi->trans_len-1) << ATCSPI200_TRANSCTRL_RDTRANCNT_OFFSET;
+
+	atcspi200_spi_write(spi,TransCtrl,tc);
+	atcspi200_spi_write(spi,Cmd,1);
+
+	for (i=0;i<spi->cmd_len;i++)
+		atcspi200_spi_write(spi,Data,spi->cmd_buf[i]);
+
+	return 0;
+}
+
+static void atcspi200_spi_tx(struct atcspi200_spi *spi, const u8 *dout)
+{
+	atcspi200_spi_write(spi,Data,*dout);
+}
+
+static int atcspi200_spi_rx(struct atcspi200_spi *spi, u8 *din, unsigned int bytes)
+{
+	u32 tmp_data = atcspi200_spi_read(spi,Data);
+	*din = tmp_data;
+	return bytes;
+}
+static int atcspi200_spi_transfer(struct spi_device *atcspi200_spi, struct spi_transfer *t, unsigned long flags)
+{
+	struct atcspi200_spi *spi = spi_master_get_devdata(atcspi200_spi->master);
+
+	unsigned int event, rx_bytes;
+	const u8* dout = NULL;
+        u8 *din = NULL;
+        int num_blks, num_chunks, max_trans_len, trans_len;
+        int num_bytes;
+        u8 *cmd_buf = spi->cmd_buf;
+        size_t cmd_len = spi->cmd_len;
+        unsigned long data_len = t->len;
+        int rf_cnt;
+        int ret = 0;
+
+        max_trans_len = spi->max_transfer_length;
+	switch (flags) {
+	case SPI_XFER_BEGIN:
+		cmd_len = spi->cmd_len = data_len;
+		memcpy(cmd_buf,t->tx_buf,cmd_len);
+		return 0;
+	case SPI_XFER_END:
+		if(data_len ==0) {
+			return 0;
+		}
+		spi->data_len =data_len;
+		spi->din =(u8 *)t->tx_buf;
+		spi->dout =(u8 *)t->rx_buf;
+		break;
+
+	case SPI_XFER_BEGIN | SPI_XFER_END:
+		spi->data_len = 0;
+		spi->din = 0;
+		spi->dout=0;
+		cmd_len = spi->cmd_len = data_len;
+		memcpy(cmd_buf,t->tx_buf,cmd_len);
+		t->tx_buf = 0;
+		data_len = 0;
+		atcspi200_spi_start(spi,t);
+		break;
+	}
+	num_chunks = DIV_ROUND_UP(data_len, max_trans_len);
+	din = t->rx_buf;
+	dout = t->tx_buf;
+	while(num_chunks--) {
+		trans_len = min((size_t)data_len,(size_t)max_trans_len);
+		spi->trans_len = trans_len;
+		num_blks = DIV_ROUND_UP(trans_len , CHUNK_SIZE);
+		num_bytes = (trans_len) % CHUNK_SIZE;
+		if(num_bytes == 0)
+			num_bytes = CHUNK_SIZE;
+		atcspi200_spi_start(spi,t);
+		while (num_blks) {
+			event = atcspi200_spi_read(spi,Status);
+			if ((event & ATCSPI200_STATUS_TXEMPTY_OFFSET ) && (t->tx_buf)) {
+				atcspi200_spi_tx(spi,dout);
+				num_blks -= CHUNK_SIZE;
+				dout += CHUNK_SIZE;
+			}
+			if ((event&ATCSPI200_STATUS_RXNUM_LOWER_MASK)&&(t->rx_buf)) {
+				rf_cnt = ((event & ATCSPI200_STATUS_RXNUM_LOWER_MASK)>> ATCSPI200_STATUS_RXNUM_LOWER_OFFSET);
+				if (rf_cnt >= CHUNK_SIZE)
+					rx_bytes = CHUNK_SIZE;
+				else if(num_blks == 1 && rf_cnt == num_bytes)
+					rx_bytes = num_bytes;
+				else
+					continue;
+
+				if(atcspi200_spi_rx(spi,din,rx_bytes) == rx_bytes)
+				{
+					num_blks -= CHUNK_SIZE;
+					din = (unsigned char*)din + rx_bytes;
+				}
+			}
+		}
+		data_len -= trans_len;
+		if(data_len) {
+			spi->cmd_buf[1] += ((trans_len>>16)&0xff);
+			spi->cmd_buf[2] += ((trans_len>>8)&0xff);
+			spi->cmd_buf[3] += ((trans_len)&0xff);
+			spi->data_len = data_len;
+		}
+		ret = atcspi200_spi_stop(spi);
+	}
+	ret = atcspi200_spi_stop(spi);
+	return ret;
+}
+static int atcspi200_spi_transfer_one_message(struct spi_master *master,struct spi_message *m)
+{
+	struct atcspi200_spi *spi = spi_master_get_devdata(master);
+	struct spi_transfer *t;
+	unsigned long spi_flags;
+	unsigned long flags;
+	int ret=0;
+
+	m->actual_length = 0;
+
+	spi_flags = SPI_XFER_BEGIN;
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		if (!t->tx_buf && !t->rx_buf)
+			spi_flags |= SPI_XFER_ONCE;
+
+		if (list_is_last(&t->transfer_list, &m->transfers))
+			spi_flags |= SPI_XFER_END;
+
+		spin_lock_irqsave(&spi->lock, flags);
+		ret = atcspi200_spi_transfer(m->spi, t, spi_flags);
+		spin_unlock_irqrestore(&spi->lock, flags);
+		if (ret)
+			break;
+		m->actual_length += t->len;
+		spi_flags = 0;
+	}
+	m->status = ret;
+	spi_finalize_current_message(master);
+
+	return 0;
+}
+static int atcspi200_spi_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct spi_master *master;
+	struct atcspi200_spi *spi;
+	int ret;
+	u32 num_cs = NSPI_MAX_CS_NUM;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct atcspi200_spi));
+	if (!master) {
+		dev_err(&pdev->dev, "spi_allooc_master error\n");
+		return -ENOMEM;
+	}
+
+	spi = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, master);
+
+	/* get base addr  */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	spi->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(spi->regs)) {
+		dev_err(&pdev->dev, "Unable to map IO resources\n");
+		ret = PTR_ERR(spi->regs);
+		goto put_master;
+	}
+
+	spi->timeout = SPI_TIMEOUT;
+	spi->max_transfer_length = MAX_TRANSFER_LEN;
+	spi->mtiming = atcspi200_spi_read(spi,Timing);
+
+	/* get clock */
+	spi->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(spi->clk)) {
+		dev_err(&pdev->dev, "Unable to find bus clock\n");
+		ret = PTR_ERR(spi->clk);
+		goto put_master;
+	}
+
+	/* Optional parameters */
+	ret = of_property_read_u32(pdev->dev.of_node, "spi-max-frequency",&master->max_speed_hz);
+	if(ret) {
+		master->max_speed_hz = SPI_MAX_HZ; /* 50MHz */
+		spi->freq = SPI_MAX_HZ;
+	}
+
+	/* Spin up the bus clock before hitting registers */
+	ret = clk_prepare_enable(spi->clk);
+	if(ret) {
+		dev_err(&pdev->dev, "Unable to enable bus clock\n");
+		goto put_master;
+	}
+	spi->clk_rate = clk_get_rate(spi->clk);
+	if (!spi->clk_rate) {
+		dev_err(&pdev->dev, "clk rate = 0\n");
+		ret = -EINVAL;
+		goto put_master;
+	}
+	/* probe the number of CS lines */
+	ret = of_property_read_u32(pdev->dev.of_node, "num-cs",&num_cs);
+	if (ret) {
+		dev_err(&pdev->dev, "could not find num-cs\n");
+		ret = -ENXIO;
+		goto put_master;
+	}
+	if (num_cs > NSPI_MAX_CS_NUM) {
+		dev_warn(&pdev->dev, "unsupported number of cs (%i), reducing to 1\n",num_cs);
+		num_cs = NSPI_MAX_CS_NUM;
+	}
+
+	/* Define our master */
+	master->bus_num = pdev->id;
+	master->mode_bits = SPI_CPOL | SPI_CPHA;
+	master->dev.of_node = pdev->dev.of_node;
+	master->num_chipselect = num_cs;
+	master->transfer_one_message = atcspi200_spi_transfer_one_message;
+
+	/* Configure the SPI master hardware */
+	atcspi200_spi_setup(spi);
+
+	ret = devm_spi_register_master(&pdev->dev, master);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "spi_register_master failed\n");
+		goto put_master;
+	}
+	dev_info(&pdev->dev, "Andes SPI driver.\n");
+
+	return 0;
+
+put_master:
+	spi_master_put(master);
+
+	return ret;
+}
+
+static const struct of_device_id atcspi200_spi_of_match[] = {
+	{ .compatible = "andestech,atcspi200", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, atcspi200_spi_of_match);
+
+static struct platform_driver atcspi200_spi_driver = {
+	.probe = atcspi200_spi_probe,
+	.driver = {
+		.name = SPI_NAME,
+		.of_match_table = atcspi200_spi_of_match,
+	},
+};
+module_platform_driver(atcspi200_spi_driver);
+
+MODULE_AUTHOR("Nylon Chen. <nylon7@andestech.com>");
+MODULE_DESCRIPTION("Andes SPI driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/spi-atcspi200_cb.c b/drivers/spi/spi-atcspi200_cb.c
new file mode 100644
index 00000000..76080740
--- /dev/null
+++ b/drivers/spi/spi-atcspi200_cb.c
@@ -0,0 +1,475 @@
+/*
+ * Andestech SPI controller driver
+ *
+ * Author: Nylon Chen
+ *	nylon7@andestech.com
+ *
+ * 2020 (c) Andes Technology Corporation
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+
+#define ANDES_SPI_NAME "atcspi200-spi"
+#define ANDES_MAX_HZ	50000000
+#define MAX_TRANSFER_LEN        512
+#define CHUNK_SIZE              1
+#define SPI_TIMEOUT             0x100000
+#define SPI_BUS                	0
+#define SPI_BASE               	0xf0b00000
+#define NSPI_MAX_CS_NUM         1
+
+/* SPI transfer format register */
+#define SPI_CPHA                      (1UL << 0)
+#define SPI_CPOL                      (1UL << 1)
+#define SPI_SLAVE                     (1UL << 2)
+#define SPI_LSB                       (1UL << 3)
+#define SPI_MERGE                     (1UL << 7)
+#define DATA_BITS(data_bits)          ((data_bits - 1) << 8)
+
+/* SPI transfer control register */
+#define SPI_TRANSCTRL_SLV_DATA_ONLY   (0x1 << 31)
+
+// RD/WR transfer count
+#define RD_TRANCNT(num)               ((num - 1) << 0)
+#define WR_TRANCNT(num)               ((num - 1) << 12)
+
+// SPI transfer mode
+#define SPI_TRANSMODE_WRnRD           (0x0 << 24)
+#define SPI_TRANSMODE_WRONLY          (0x1 << 24)
+#define SPI_TRANSMODE_RDONLY          (0x2 << 24)
+#define SPI_TRANSMODE_WR_RD           (0x3 << 24)
+#define SPI_TRANSMODE_RD_WR           (0x4 << 24)
+#define SPI_TRANSMODE_WR_DMY_RD       (0x5 << 24)
+#define SPI_TRANSMODE_RD_DMY_WR       (0x6 << 24)
+#define SPI_TRANSMODE_NONEDATA        (0x7 << 24)
+#define SPI_TRANSMODE_DMY_WR          (0x8 << 24)
+#define SPI_TRANSMODE_DMY_RD          (0x9 << 24)
+
+/* SPI control register */
+#define SPIRST                        (1UL << 0)
+#define RXFIFORST                     (1UL << 1)
+#define TXFIFORST                     (1UL << 2)
+#define RXDMAEN                       (1UL << 3)
+#define TXDMAEN                       (1UL << 4)
+#define RXTHRES(num)                  (num << 8)
+#define TXTHRES(num)                  (num << 16)
+
+#define THRES_MASK_FIFO_16            (0x1f)
+#define THRES_MASK_FIFO_128           (0xff)
+#define RXTHRES_OFFSET                (8)
+#define TXTHRES_OFFSET                (16)
+
+/* SPI interrupt enable register */
+#define SPI_RXFIFOOORINT              (1UL << 0)
+#define SPI_TXFIFOOURINT              (1UL << 1)
+#define SPI_RXFIFOINT                 (1UL << 2)
+#define SPI_TXFIFOINT                 (1UL << 3)
+#define SPI_ENDINT                    (1UL << 4)
+#define SPI_SLVCMD                    (1UL << 5)
+
+// SPI flags
+#define SPI_FLAG_INITIALIZED          (1UL << 0)     // SPI initialized
+#define SPI_FLAG_POWERED              (1UL << 1)     // SPI powered on
+#define SPI_FLAG_CONFIGURED           (1UL << 2)     // SPI configured
+#define SPI_FLAG_DATA_LOST            (1UL << 3)     // SPI data lost occurred
+#define SPI_FLAG_MODE_FAULT           (1UL << 4)     // SPI mode fault occurred
+
+#define IDREV		0x00	/* 0x00 ID and revision register */
+#define TRANSFMT	0x10	/* 0x10 SPI transfer format register */
+#define DIRECTIO	0x14	/* 0x14 SPI direct IO control register */
+#define TRANSCTRL	0x20	/* 0x20 SPI transfer control register */
+#define CMD		0x24	/* 0x24 SPI command register */
+#define ADDR		0x28	/* 0x28 SPI address register */
+#define DATA		0x2C	/* 0x2c SPI data register */
+#define CTRL		0x30	/* 0x30 SPI conrtol register */
+#define STATUS		0x34	/* 0x34 SPI status register */
+#define INTREN		0x38	/* 0x38 SPI interrupt enable register */
+#define INTRST		0x3C	/* 0x3c SPI interrupt status register */
+#define TIMING		0x40	/* 0x40 SPI interface timing register */
+#define MEMCTRL		0x50	/* 0x50 SPI memory access control register */
+#define SLVST		0x60	/* 0x60 SPI slave status register */
+#define SLVDATACNT	0x64	/* 0x64 SPI slave data count register */
+#define CONFIG		0x7C	/* 0x7c Configuration register */
+
+typedef struct _SPI_STATUS {
+	uint8_t        	busy;         // transmitter/receiver busy flag
+	uint8_t		data_lost;    // data lost: receiver overflow/transmit underflow (cleared on start of transfer operation)
+	uint8_t		mode_fault;   // Mode fault detected; optional (cleared on start of transfer operation)
+} SPI_STATUS
+
+typedef struct _SPI_TRANSFER_INFO {
+        uint8_t                 transfer_op;   // transfer operation: send/recv/transfer
+        uint8_t                 *rx_buf;       // pointer to in data buffer
+        uint8_t                 *tx_buf;       // pointer to out data buffer
+        uint8_t                 *tx_buf_limit; // pointer to the end of in data buffer
+        uint32_t                rx_cnt;        // number of data received
+        uint32_t                tx_cnt;        // number of data sent
+        uint8_t                 txfifo_refill; // The size of data SPI TX ISR refills one time.
+} SPI_TRANSFER_INFO;
+
+
+// SPI information (Run-time)
+typedef struct _SPI_INFO {
+        uint32_t   cb_event;      // event callback
+        SPI_STATUS              status;        // SPI status flags
+        SPI_TRANSFER_INFO       xfer;          // SPI transfer information
+        uint8_t                 flags;         // SPI driver flags
+        uint32_t                mode;          // SPI mode
+        uint8_t                 txfifo_size;   // SPI HW TXFIFO size
+        uint8_t                 data_bits;     // the size of one unit SPI data (1 ~ 32, defaults: 8 bits)
+        uint32_t                data_num;      // num of the transfer data(use in auto-size)
+        uint32_t                block_num;     // num of the transfer block(use in auto-size)
+} SPI_INFO;
+
+
+struct andes_spi {
+	void __iomem    *regs;
+	struct clk      *clk;
+	SPI_INFO	*info
+	struct completion done;         /* Wake-up from interrupt */ 
+};
+
+
+static void andes_spi_tx(struct andes_spi *spi, const void *data_out)
+{
+}
+
+static int andes_spi_rx(struct andes_spi *spi,void *din, unsigned int bytes)
+{
+}
+
+static void andes_spi_write(struct andes_spi *spi, int offset, u32 value)
+{
+	iowrite32(value, spi->regs + offset);
+}
+
+static u32 andes_spi_read(struct andes_spi *spi, int offset)
+{
+	return ioread32(spi->regs + offset);
+}
+
+static void spi_polling_spiactive(struct andes_spi *spi) {
+	poll = andes_spi_read(spi,STATUS)
+        while ((poll) & 0x1);
+}
+
+static uint32_t spi_get_txfifo_size(SPI_RESOURCES *spi) {
+		int cfg = andes_spi_read(spi,CONFIG);
+                return 2 << ((cfg >> 4) & 0x3);
+        }
+}
+
+static void andes_spi_init(struct andes_spi *spi)
+{
+	spi->info->status.busy	= 0U;
+	spi->info->status.data_lost  = 0U;
+        spi->info->status.mode_fault = 0U;
+
+	spi->info->xfer.rx_buf       = 0U;
+        spi->info->xfer.tx_buf       = 0U;
+        spi->info->xfer.tx_buf_limit = 0U;
+        spi->info->xfer.rx_cnt       = 0U;
+        spi->info->xfer.tx_cnt       = 0U;
+
+        spi->info->mode              = 0U;
+	spi->info->txfifo_size = spi_get_txfifo_size(spi);
+
+	spi->info->flags = SPI_FLAG_INITIALIZED;
+
+	return 0;
+}
+
+static void spi_irq_handler(struct andes_spi *spi) {
+	uint32_t i, j, status, interen;
+        uint32_t data = 0;
+        uint32_t rx_num = 0;
+        uint32_t event = 0;
+        uint32_t have_clear_state = 0;
+
+	// read status register
+	status = andes_spi_read(spi,INTRST);
+
+	if((status & SPI_RXFIFOOORINT) || (status & SPI_TXFIFOOURINT))
+	{
+		// TX FIFO underrun or RX FIFO overrun interrupt status
+		spi->info->status.data_lost = 1U;
+		event |= NDS_SPI_EVENT_DATA_LOST;
+	}
+	if(status & SPI_TXFIFOINT)
+	{
+		for(i=0; i<spi->info->xfer.txfifo_refill; i++) {
+			data = 0;
+			if(spi->info->xfer.tx_buf < spi->info->xfer.rx_buf_limit) {
+			// handle the data frame format
+				if (spi->info->data_bits <= 8) {
+					data = *spi->info->xfer.tx_buf;
+					spi->info->xfer.tx_buf++;
+				} else if (spi->info->data_bits <= 16) {
+					for (j = 0; j < 2; j++) {
+						data |= *spi->info->xfer.tx_buf << j * 8;
+						spi->info->xfer.tx_buf++;
+                                        }
+				} else {
+					for (j = 0; j < 4; j++) {
+                                                data |= *spi->info->xfer.tx_buf << j * 8;
+                                                spi->info->xfer.tx_buf++;
+					}
+				}
+			}
+				andes_spi_write(spi,DATA,data);
+				spi->info->xfer.tx_cnt++;
+			else {
+				andes_spi_write(spi,INTREN);
+			}
+		}
+
+}
+
+static irqreturn_t andes_andes_irq(int irq, void *dev_id)
+{
+	struct andes_spi *spi = dev_id;
+	u32 interrupt_enable = andes_spi_read(spi, SPI_TXFIFOINT|SPI_ENDINT);
+
+	if(interrupts &(SPI_RXFIFOINT|SPI_TXFIFOINT)) {
+		andes_spi_write(spi,ATCSPI200_INTEREN,0);
+		complete(&spi->done);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static int
+andes_spi_prep_transfer(struct andes_spi *spi, struct spi_device *device,struct spi_transfer *t)
+{
+	u32 tm;
+	u8 div;
+	tm = andes_spi_read(spi,ATCSPI200_TIMING);
+	tm &= ~ATCSPI200_TIMING_SCLK_DIV_MASK;
+
+	if(ANDES_MAX_HZ >= spi->clk)
+		div = 0xff;
+	else{
+		for (div=0; div <0xff; div++){
+			if(ANDES_MAX_HZ >=spi->clk / (2*(div+1)))
+				break;
+		}
+	}
+
+	tm |= div;
+	andes_spi_write(spi,ATCSPI200_TIMING,tm);
+
+
+}
+
+static int andes_spi_start(struct andes_spi *spi,const u8* tx_ptr, u8* rx_ptr)
+{
+	int i,olen=0;
+	int tc = andes_spi_read(spi,ATCSPI200_TRANSCTRL);
+
+	tc &= (ATCSPI200_TRANSCTRL_WRTRANCNT_MASK|ATCSPI200_TRANSCTRL_RDTRANCNT_MASK|ATCSPI200_TRANSCTRL_TRANSMODE_MASK);
+	if((*tx_ptr)&&spi->cmd_len)
+		tc |= ATCSPI200_TRANSCTRL_TRANSMODE_WR;
+	else if((tx_ptr))
+		tc |= ATCSPI200_TRANSCTRL_TRANSMODE_R_ONLY;
+	else
+		tc |= ATCSPI200_TRANSCTRL_TRANSMODE_W_ONLY;
+
+	if(rx_ptr)
+		olen = spi->tran_len;
+
+	andes_spi_write(spi,ATCSPI200_TRANSCTRL,tc);
+	andes_spi_write(spi,ATCSPI200_CMD,1);
+
+	for(i=0;i<spi->cmd_len;i++)
+		andes_spi_write(spi,ATCSPI200_DATA,spi->cmd_buf[i]);
+
+	return 0;
+}
+
+//static int andes_spi_transfer_one(struct spi_master *master,struct spi_device *spi,struct spi_transfer *t)
+static int andes_spi_transfer_one(struct spi_master *master,struct spi_device *spi, struct spi_transfer *t)
+{
+	struct andes_spi *spi = spi_master_get_devdata(master);
+	int poll = andes_spi_prep_transfer(spi, device, t);
+
+	unsigned int event, rx_bytes;
+	int num_bytes;
+	int num_blks, num_chunks, max_tran_len, tran_len;
+	u8 *cmd_buf = spi->cmd_buf;
+	size_t cmd_len = spi->cmd_len;
+	unsigned long data_len = t->len;
+	int rf_cnt;
+	int ret = 0;
+
+	max_transfer_length = spi->max_transfer_length;
+
+	const u8 *tx_ptr = NULL;
+	u8 *rx_ptr = NULL;
+	//flags = begin
+	cmd_len = spi->cmd_len = data_len;
+	memcpy(cmd_buf,data_out,cmd_len);
+	//flags = end
+	//flags = once
+	data_out = 0;
+	data_len = 0;
+
+	
+
+
+}
+
+static int andes_spi_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct spi_master *master;
+	struct andes_spi *spi;
+	int ret;
+	u32 num_cs = NSPI_MAX_CS_NUM;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct andes_spi));
+	if (!master) {
+		dev_err(&pdev->dev, "spi_allooc_master error\n");
+		return -ENOMEM;
+	}
+
+	spi = spi_master_get_devdata(master);
+	init_completion(&spi->done);
+	platform_set_drvdata(pdev, master);
+
+	/* get base addr  */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	spi->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(spi->regs)) {
+		dev_err(&pdev->dev, "Unable to map IO resources\n");
+		ret = PTR_ERR(spi->regs);
+		goto put_master;
+	}
+
+	spi->to = SPI_TIMEOUT;
+	spi->max_transfer_length = MAX_TRANSFER_LEN;
+	spi->mtiming = andes_spi_read(spi,ATCSPI200_TIMING);
+
+	/* get clock */
+	spi->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(spi->clk)) {
+		dev_err(&pdev->dev, "Unable to find bus clock\n");
+		ret = PTR_ERR(spi->clk);
+		goto put_master;
+	}
+
+	/* get interrupt */
+	spi->irq = platform_get_irq(pdev, 0);
+	if (spi->irq < 0) {
+		dev_err(&pdev->dev, "Unable to find interrupt\n");
+		ret = PTR_ERR(spi->irq);
+		goto put_master;
+	}
+
+	/* Optional parameters */
+	ret = of_property_read_u32(tsd->dev->of_node, "spi-max-frequency",&master->max_speed_hz)
+	if(ret) {
+		master->max_speed_hz = ANDES_MAX_HZ; /* 50MHz */
+	}
+
+	/* Spin up the bus clock before hitting registers */
+	ret = clk_prepare_enable(spi->clk);
+	if(ret) {
+		dev_err(&pdev->dev, "Unable to enable bus clock\n");
+		goto put_master;
+	}
+	/* probe the number of CS lines */
+	ret = of_property_read_u32(of_node, "num-cs", &num_cs)
+	if (ret) {
+		dev_err(dev, "could not find num-cs\n");
+		ret = -ENXIO;
+		goto put_master;
+	}
+	if (num_cs > NSPI_MAX_CS_NUM) {
+		dev_warn(dev, "unsupported number of cs (%i), reducing to 1\n",num_cs);
+		num_cs = NSPI_MAX_CS_NUM;
+	}
+
+
+	/* Define our master */
+	master->bus_num = pdev->id;
+	master->mode_bits = SPI_CPOL | SPI_CPHA;
+	master->dev.of_node = pdev->dev.of_node;
+	master->num_chipselect = num_cs;
+	master->transfer_one = andes_spi_transfer_one;
+
+	/* Configure the SPI master hardware */
+	andes_spi_init(spi);
+
+	/* Register for SPI InterruptRegister for SPI Interrupt */
+	ret = devm_request_irq(&pdev->dev, irq, andes_spi_irq, 0,
+				dev_name(&pdev->dev), spi);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to bind to interrupt\n");
+		goto put_master;
+	}
+
+	dev_info(&pdev->dev, "mapped; irq=%d, cs=%d\n",
+		irq, master->num_chipselect);
+
+	ret = devm_spi_register_master(&pdev->dev, master);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "spi_register_master failed\n");
+		goto put_master;
+	}
+
+	dev_info(&pdev->dev, "Andes SPI driver.\n");
+
+	return 0;
+
+put_master:
+	spi_master_put(master);
+
+	return ret;
+}
+
+static int andes_spi_remove(struct platform_device *pdev)
+{
+	struct andes_spi *spi = platform_get_drvdata(pdev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	clk_put(spi->clk);
+
+	return 0;
+}
+
+static const struct of_device_id andes_spi_of_match[] = {
+	{ .compatible = "andestech,atcspi200", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, andes_spi_of_match);
+
+static struct platform_driver andes_spi_driver = {
+	.probe = andes_spi_probe,
+	.remove = andes_spi_remove,
+	.driver = {
+		.name = ANDES_SPI_NAME,
+		.of_match_table = andes_spi_of_match,
+	},
+};
+module_platform_driver(andes_spi_driver);
+
+MODULE_AUTHOR("Nylon Chen. <nylon7@andestech.com>");
+MODULE_DESCRIPTION("Andes SPI driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/spi-sifive.c b/drivers/spi/spi-sifive.c
new file mode 100644
index 00000000..208566a9
--- /dev/null
+++ b/drivers/spi/spi-sifive.c
@@ -0,0 +1,423 @@
+/*
+ * SiFive SPI controller driver (master mode only)
+ *
+ * Author: SiFive, Inc.
+ *	sifive@sifive.com
+ *
+ * 2018 (c) SiFive Software, Inc.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/io.h>
+#include <linux/log2.h>
+
+#define SIFIVE_SPI_MAX_CS	32
+
+#define SIFIVE_SPI_NAME "sifive_spi"
+
+#define SIFIVE_SPI_DEFAULT_DEPTH 8
+#define SIFIVE_SPI_DEFAULT_BITS	8
+
+#define XSPI_SCDR_OFFSET	0x000	/* Serial Clock Divisor Register */
+#define XSPI_SCD_SCALE_MASK	0xFFF
+
+#define XSPI_SCMR_OFFSET        0x004   /* Serial Clock Mode Register */
+#define XSPI_SCM_CPHA		1
+#define XSPI_SCM_CPOL		2
+#define XSPI_SCM_MODE_MASK     (XSPI_SCM_CPHA | XSPI_SCM_CPOL)
+
+#define XSPI_CSIDR_OFFSET       0x010
+#define XSPI_CSDR_OFFSET        0x014
+#define XSPI_CSMR_OFFSET        0x018
+#define XSPI_CSM_MODE_AUTO      0
+#define XSPI_CSM_MODE_HOLD      2
+#define XSPI_CSM_MODE_OFF       3
+
+#define XSPI_DC0R_OFFSET        0x028
+#define XSPI_CS_TO_SCK_MASK     0xFF
+#define XSPI_SCK_TO_CS_MASK     (0xFF << 16)
+#define XSPI_DC1R_OFFSET        0x02C
+#define XSPI_MIN_CS_IATIME_MASK 0xFF
+#define XSPI_MAX_IF_DELAY_MASK  (0xFF << 16)
+
+#define XSPI_FFR_OFFSET         0x040
+#define XSPI_FF_SINGLE          0
+#define XSPI_FF_DUAL            1
+#define XSPI_FF_QUAD            2
+#define XSPI_FF_SPI_MASK        0x3
+#define XSPI_FF_LSB_FIRST       4
+#define XSPI_FF_TX_DIR          8
+#define XSPI_FF_BPF_MASK        (0xFF << 16)
+
+#define XSPI_TXDR_OFFSET	0x048	/* Data Transmit Register */
+#define XSPI_TXD_FIFO_FULL      (8U << 28)
+#define XSPI_RXDR_OFFSET	0x04C	/* Data Receive Register */
+#define XSPI_RXD_FIFO_EMPTY     (8U << 28)
+#define XSPI_DATA_MASK          0xFF
+#define XSPI_DATA_SHIFT         8
+
+#define XSPI_TXWMR_OFFSET       0x050   /* TX FIFO Watermark Register */
+#define XSPI_RXWMR_OFFSET       0x054   /* RX FIFO Watermark Register */
+
+#define XSPI_FCTRL_OFFSET	0x60
+
+#define XSPI_IPR_OFFSET		0x074	/* Interrupt Pendings Register */
+#define XSPI_IER_OFFSET		0x070	/* Interrupt Enable Register */
+#define XSPI_TXWM_INTR          0x1
+#define XSPI_RXWM_INTR          0x2
+
+struct sifive_spi {
+	void __iomem	*regs;		/* virt. address of the control registers */
+	struct clk	*clk;		/* bus clock */
+	int		irq;		/* watermark irq */
+	int 		buffer_size;	/* buffer size in words */
+	u32		cs_inactive;	/* Level of the CS pins when inactive*/
+	struct completion done;		/* Wake-up from interrupt */
+};
+
+static void sifive_spi_write(struct sifive_spi *spi, int offset, u32 value)
+{
+	iowrite32(value, spi->regs + offset);
+}
+
+static u32 sifive_spi_read(struct sifive_spi *spi, int offset)
+{
+	return ioread32(spi->regs + offset);
+}
+
+static void sifive_spi_init(struct sifive_spi *spi)
+{
+	/* Watermark interrupts are disabled by default */
+	sifive_spi_write(spi, XSPI_IER_OFFSET, 0);
+
+	/* Default watermark FIFO threshold values */
+	sifive_spi_write(spi, XSPI_TXWMR_OFFSET, 1);
+	sifive_spi_write(spi, XSPI_RXWMR_OFFSET, 0);
+
+	/* Set CS/SCK Delays and Inactive Time to defaults */
+
+	/* Exit specialized memory-mapped SPI flash mode */
+	sifive_spi_write(spi, XSPI_FCTRL_OFFSET, 0);
+}
+
+static void sifive_spi_prep_device(struct sifive_spi *spi, struct spi_device *device)
+{
+	u32 cr;
+
+	/* Update the chip select polarity */
+	if (device->mode & SPI_CS_HIGH)
+		spi->cs_inactive &= ~BIT(device->chip_select);
+	else
+		spi->cs_inactive |= BIT(device->chip_select);
+	sifive_spi_write(spi, XSPI_CSDR_OFFSET, spi->cs_inactive);
+
+	/* Select the correct device */
+	sifive_spi_write(spi, XSPI_CSIDR_OFFSET, device->chip_select);
+
+	/* Switch clock mode bits */
+	cr = sifive_spi_read(spi, XSPI_SCMR_OFFSET) & ~XSPI_SCM_MODE_MASK;
+	if (device->mode & SPI_CPHA)
+		cr |= XSPI_SCM_CPHA;
+	if (device->mode & SPI_CPOL)
+		cr |= XSPI_SCM_CPOL;
+	sifive_spi_write(spi, XSPI_SCMR_OFFSET, cr);
+}
+
+static int sifive_spi_prep_transfer(struct sifive_spi *spi, struct spi_device *device, struct spi_transfer *t)
+{
+	u32 hz, scale, cr;
+	int mode;
+
+	/* Calculate and program the clock rate */
+	hz = t->speed_hz ? t->speed_hz : device->max_speed_hz;
+	scale = (DIV_ROUND_UP(clk_get_rate(spi->clk) >> 1, hz) - 1) & XSPI_SCD_SCALE_MASK;
+	sifive_spi_write(spi, XSPI_SCDR_OFFSET, scale);
+
+	/* Modify the SPI protocol mode */
+	cr = sifive_spi_read(spi, XSPI_FFR_OFFSET);
+
+	/* LSB first? */
+	cr &= ~XSPI_FF_LSB_FIRST;
+	if (device->mode & SPI_LSB_FIRST)
+		cr |= XSPI_FF_LSB_FIRST;
+
+	/* SINGLE/DUAL/QUAD? */
+	mode = max((int)t->rx_nbits, (int)t->tx_nbits);
+	cr &= ~XSPI_FF_SPI_MASK;
+	switch (mode) {
+		case SPI_NBITS_QUAD: cr |= XSPI_FF_QUAD;   break;
+		case SPI_NBITS_DUAL: cr |= XSPI_FF_DUAL;   break;
+		default:             cr |= XSPI_FF_SINGLE; break;
+	}
+
+	/* SPI direction */
+	cr &= ~XSPI_FF_TX_DIR;
+	if (!t->rx_buf)
+		cr |= XSPI_FF_TX_DIR;
+
+	sifive_spi_write(spi, XSPI_FFR_OFFSET, cr);
+
+	/* We will want to poll if the time we need to wait is less than the context switching time.
+	 * Let's call that threshold 5us. The operation will take:
+	 *    (8/mode) * buffer_size / hz <= 5 * 10^-6
+	 *    1600000 * buffer_size <= hz * mode
+	 */
+	return 1600000 * spi->buffer_size <= hz * mode;
+}
+
+static void sifive_spi_tx(struct sifive_spi *spi, const u8* tx_ptr)
+{
+	BUG_ON((sifive_spi_read(spi, XSPI_TXDR_OFFSET) & XSPI_TXD_FIFO_FULL) != 0);
+	sifive_spi_write(spi, XSPI_TXDR_OFFSET, *tx_ptr & XSPI_DATA_MASK);
+}
+
+static void sifive_spi_rx(struct sifive_spi *spi, u8* rx_ptr)
+{
+        u32 data = sifive_spi_read(spi, XSPI_RXDR_OFFSET);
+        BUG_ON((data & XSPI_RXD_FIFO_EMPTY) != 0);
+        *rx_ptr = data & XSPI_DATA_MASK;
+}
+
+static void sifive_spi_wait(struct sifive_spi *spi, int bit, int poll)
+{
+	if (poll) {
+		u32 cr;
+		do cr = sifive_spi_read(spi, XSPI_IPR_OFFSET);
+		while (!(cr & bit));
+	} else {
+		reinit_completion(&spi->done);
+		sifive_spi_write(spi, XSPI_IER_OFFSET, bit);
+		wait_for_completion(&spi->done);
+	}
+}
+
+static void sifive_spi_execute(struct sifive_spi *spi, struct spi_transfer *t, int poll)
+{
+	int remaining_words = t->len;
+	const u8* tx_ptr = t->tx_buf;
+	u8* rx_ptr = t->rx_buf;
+
+	while (remaining_words) {
+		int n_words, tx_words, rx_words;
+		n_words = min(remaining_words, spi->buffer_size);
+
+		/* Enqueue n_words for transmission */
+		for (tx_words = 0; tx_words < n_words; ++tx_words)
+			sifive_spi_tx(spi, tx_ptr++);
+
+		if (rx_ptr) {
+			/* Wait for transmission + reception to complete */
+			sifive_spi_write(spi, XSPI_RXWMR_OFFSET, n_words-1);
+			sifive_spi_wait(spi, XSPI_RXWM_INTR, poll);
+
+			/* Read out all the data from the RX FIFO */
+			for (rx_words = 0; rx_words < n_words; ++rx_words)
+				sifive_spi_rx(spi, rx_ptr++);
+		} else {
+			/* Wait for transmission to complete */
+			sifive_spi_wait(spi, XSPI_TXWM_INTR, poll);
+		}
+
+		remaining_words -= n_words;
+	}
+}
+
+static int sifive_spi_transfer_one(struct spi_master *master, struct spi_device *device, struct spi_transfer *t)
+{
+	struct sifive_spi *spi = spi_master_get_devdata(master);
+	int poll;
+
+	sifive_spi_prep_device(spi, device);
+	poll = sifive_spi_prep_transfer(spi, device, t);
+	sifive_spi_execute(spi, t, poll);
+
+	return 0;
+}
+
+static void sifive_spi_set_cs(struct spi_device *device, bool is_high)
+{
+	struct sifive_spi *spi = spi_master_get_devdata(device->master);
+
+	/* Reverse polarity is handled by SCMR/CPOL. Not inverted CS. */
+	if (device->mode & SPI_CS_HIGH)
+		is_high = !is_high;
+
+	sifive_spi_write(spi, XSPI_CSMR_OFFSET, is_high ? XSPI_CSM_MODE_AUTO : XSPI_CSM_MODE_HOLD);
+}
+
+static irqreturn_t sifive_spi_irq(int irq, void *dev_id)
+{
+	struct sifive_spi *spi = dev_id;
+	u32 ip;
+
+	ip = sifive_spi_read(spi, XSPI_IPR_OFFSET) & (XSPI_TXWM_INTR | XSPI_RXWM_INTR);
+	if (ip != 0) {
+		/* Disable interrupts until next transfer */
+		sifive_spi_write(spi, XSPI_IER_OFFSET, 0);
+		complete(&spi->done);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static int sifive_spi_probe(struct platform_device *pdev)
+{
+	struct sifive_spi *spi;
+	struct resource *res;
+	int ret, num_cs;
+	u32 cs_bits, buffer_size, bits_per_word;
+	struct spi_master *master;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct sifive_spi));
+	if (!master) {
+		dev_err(&pdev->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	spi = spi_master_get_devdata(master);
+	init_completion(&spi->done);
+	platform_set_drvdata(pdev, master);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	spi->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(spi->regs)) {
+		dev_err(&pdev->dev, "Unable to map IO resources\n");
+		ret = PTR_ERR(spi->regs);
+		goto put_master;
+	}
+
+	spi->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(spi->clk)) {
+		dev_err(&pdev->dev, "Unable to find bus clock\n");
+		ret = PTR_ERR(spi->clk);
+		goto put_master;
+	}
+
+	spi->irq = platform_get_irq(pdev, 0);
+	if (spi->irq < 0) {
+		dev_err(&pdev->dev, "Unable to find interrupt\n");
+		ret = spi->irq;
+		goto put_master;
+	}
+
+	/* Optional parameters */
+	ret = of_property_read_u32(pdev->dev.of_node, "sifive,buffer-size", &buffer_size);
+	if (ret < 0)
+		spi->buffer_size = SIFIVE_SPI_DEFAULT_DEPTH;
+	else
+		spi->buffer_size = buffer_size;
+
+	ret = of_property_read_u32(pdev->dev.of_node, "sifive,bits-per-word", &bits_per_word);
+	if (ret < 0)
+		bits_per_word = SIFIVE_SPI_DEFAULT_BITS;
+
+	/* Spin up the bus clock before hitting registers */
+	ret = clk_prepare_enable(spi->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to enable bus clock\n");
+		goto put_master;
+	}
+
+	/* probe the number of CS lines */
+	spi->cs_inactive = sifive_spi_read(spi, XSPI_CSDR_OFFSET);
+	sifive_spi_write(spi, XSPI_CSDR_OFFSET, 0xffffffffU);
+	cs_bits = sifive_spi_read(spi, XSPI_CSDR_OFFSET);
+	sifive_spi_write(spi, XSPI_CSDR_OFFSET, spi->cs_inactive);
+	if (!cs_bits) {
+		dev_err(&pdev->dev, "Could not auto probe CS lines\n");
+		ret = -EINVAL;
+		goto put_master;
+	}
+
+	num_cs = ilog2(cs_bits) + 1;
+	if (num_cs > SIFIVE_SPI_MAX_CS) {
+		dev_err(&pdev->dev, "Invalid number of spi slaves\n");
+		ret = -EINVAL;
+		goto put_master;
+	}
+
+	/* Define our master */
+	master->bus_num = pdev->id;
+	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST | SPI_CS_HIGH |
+	                    SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD;
+	master->flags = SPI_CONTROLLER_MUST_TX | SPI_MASTER_GPIO_SS;
+	master->dev.of_node = pdev->dev.of_node;
+	master->bits_per_word_mask = SPI_BPW_MASK(bits_per_word);
+	master->num_chipselect = num_cs;
+	master->transfer_one = sifive_spi_transfer_one;
+	master->set_cs = sifive_spi_set_cs;
+
+	/* If mmc_spi sees a dma_mask, it starts using dma mapped buffers.
+	 * Probably it should rely on the SPI core auto mapping instead.
+	 */
+	pdev->dev.dma_mask = 0;
+
+	/* Configure the SPI master hardware */
+	sifive_spi_init(spi);
+
+	/* Register for SPI Interrupt */
+	ret = devm_request_irq(&pdev->dev, spi->irq, sifive_spi_irq, 0,
+				dev_name(&pdev->dev), spi);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to bind to interrupt\n");
+		goto put_master;
+	}
+
+	dev_info(&pdev->dev, "mapped; irq=%d, cs=%d\n",
+		spi->irq, master->num_chipselect);
+
+	ret = devm_spi_register_master(&pdev->dev, master);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "spi_register_master failed\n");
+		goto put_master;
+	}
+
+	return 0;
+
+put_master:
+	spi_master_put(master);
+
+	return ret;
+}
+
+static int sifive_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct sifive_spi *spi = spi_master_get_devdata(master);
+
+	/* Disable all the interrupts just in case */
+	sifive_spi_write(spi, XSPI_IER_OFFSET, 0);
+	spi_master_put(master);
+
+	return 0;
+}
+
+static const struct of_device_id sifive_spi_of_match[] = {
+	{ .compatible = "sifive,spi0", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sifive_spi_of_match);
+
+static struct platform_driver sifive_spi_driver = {
+	.probe = sifive_spi_probe,
+	.remove = sifive_spi_remove,
+	.driver = {
+		.name = SIFIVE_SPI_NAME,
+		.of_match_table = sifive_spi_of_match,
+	},
+};
+module_platform_driver(sifive_spi_driver);
+
+MODULE_AUTHOR("SiFive, Inc. <sifive@sifive.com>");
+MODULE_DESCRIPTION("SiFive SPI driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/greybus/tools/.gitignore b/drivers/staging/greybus/tools/.gitignore
deleted file mode 100644
index 023654c8..00000000
--- a/drivers/staging/greybus/tools/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-loopback_test
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 0f058df0..d6300859 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1060,6 +1060,29 @@ config SERIAL_OMAP_CONSOLE
 	  your boot loader about how to pass options to the kernel at
 	  boot time.)
 
+config SERIAL_SIFIVE
+	tristate "SiFive UART support"
+	depends on OF
+	select SERIAL_CORE
+	help
+	  If you have a SiFive Freedom U500 or similar SoC, enable this to
+	  support the SiFive UART.
+
+config SERIAL_SIFIVE_CONSOLE
+	bool "Console on SiFive UART"
+	depends on SERIAL_SIFIVE=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  Select this option if you would like to use a SiFive UART as the
+	  system console.
+
+	  Even if you say Y here, the currently visible virtual console
+	  (/dev/tty0) will still be used as the system console by default, but
+	  you can alter that using a kernel command line option such as
+	  "console=ttySIx". (Try "man bootparam" or see the documentation of
+	  your boot loader about how to pass options to the kernel at
+	  boot time.)
+
 config SERIAL_LANTIQ
 	bool "Lantiq serial driver"
 	depends on LANTIQ
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index daac6756..7e906d3c 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -89,6 +89,7 @@ obj-$(CONFIG_SERIAL_MVEBU_UART)	+= mvebu-uart.o
 obj-$(CONFIG_SERIAL_PIC32)	+= pic32_uart.o
 obj-$(CONFIG_SERIAL_MPS2_UART)	+= mps2-uart.o
 obj-$(CONFIG_SERIAL_OWL)	+= owl-uart.o
+obj-$(CONFIG_SERIAL_SIFIVE)	+= sifive.o
 
 # GPIOLIB helpers for modem control lines
 obj-$(CONFIG_SERIAL_MCTRL_GPIO)	+= serial_mctrl_gpio.o
diff --git a/drivers/tty/serial/sifive.c b/drivers/tty/serial/sifive.c
new file mode 100644
index 00000000..588fb31c
--- /dev/null
+++ b/drivers/tty/serial/sifive.c
@@ -0,0 +1,1051 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * SiFive UART driver
+ * Copyright (C) 2018 Paul Walmsley <paul@pwsan.com>
+ *
+ * Based partially on drivers/tty/serial/pxa.c, drivers/pwm/pwm-sifive.c,
+ * and drivers/tty/serial/omap-serial.c
+ *
+ * See Chapter 19 "Universal Asynchronous Receiver/Transmitter (UART)" of
+ * SiFive FE310-G000 v2p3.
+ *
+ * The SiFive UART design is not 8250-compatible.  The following common
+ * features are not supported:
+ * - Word lengths other than 8 bits
+ * - Break handling
+ * - Parity
+ * - Flow control
+ * - Modem signals (DSR, RI, etc.)
+ * On the other hand, the design is free from the baggage of the classical 8250
+ * programming model.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/* XXX Magic SYSRQ support - is it possible to implement? */
+/* XXX ignore_status_mask */
+/* XXX Ensure operations are spinlocked that need to be spinlocked */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/serial_reg.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/serial_core.h>
+#include <linux/irq.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+
+/*
+ * Register offsets
+ */
+
+/* TXDATA */
+#define SIFIVE_SERIAL_TXDATA_OFFS		0x0
+#define SIFIVE_SERIAL_TXDATA_FULL_SHIFT		31
+#define SIFIVE_SERIAL_TXDATA_FULL_MASK		(1 << SIFIVE_SERIAL_TXDATA_FULL_SHIFT)
+#define SIFIVE_SERIAL_TXDATA_DATA_SHIFT		0
+#define SIFIVE_SERIAL_TXDATA_DATA_MASK		(0xff << SIFIVE_SERIAL_TXDATA_DATA_SHIFT)
+
+/* RXDATA */
+#define SIFIVE_SERIAL_RXDATA_OFFS		0x4
+#define SIFIVE_SERIAL_RXDATA_EMPTY_SHIFT	31
+#define SIFIVE_SERIAL_RXDATA_EMPTY_MASK		(1 << SIFIVE_SERIAL_RXDATA_EMPTY_SHIFT)
+#define SIFIVE_SERIAL_RXDATA_DATA_SHIFT		0
+#define SIFIVE_SERIAL_RXDATA_DATA_MASK		(0xff << SIFIVE_SERIAL_RXDATA_DATA_SHIFT)
+
+/* TXCTRL */
+#define SIFIVE_SERIAL_TXCTRL_OFFS		0x8
+#define SIFIVE_SERIAL_TXCTRL_TXCNT_SHIFT	16
+#define SIFIVE_SERIAL_TXCTRL_TXCNT_MASK		(0x7 << SIFIVE_SERIAL_TXCTRL_TXCNT_SHIFT)
+#define SIFIVE_SERIAL_TXCTRL_NSTOP_SHIFT	1
+#define SIFIVE_SERIAL_TXCTRL_NSTOP_MASK		(1 << SIFIVE_SERIAL_TXCTRL_NSTOP_SHIFT)
+#define SIFIVE_SERIAL_TXCTRL_TXEN_SHIFT		0
+#define SIFIVE_SERIAL_TXCTRL_TXEN_MASK		(1 << SIFIVE_SERIAL_TXCTRL_TXEN_SHIFT)
+
+/* RXCTRL */
+#define SIFIVE_SERIAL_RXCTRL_OFFS		0xC
+#define SIFIVE_SERIAL_RXCTRL_RXCNT_SHIFT	16
+#define SIFIVE_SERIAL_RXCTRL_RXCNT_MASK		(0x7 << SIFIVE_SERIAL_TXCTRL_TXCNT_SHIFT)
+#define SIFIVE_SERIAL_RXCTRL_RXEN_SHIFT		0
+#define SIFIVE_SERIAL_RXCTRL_RXEN_MASK		(1 << SIFIVE_SERIAL_RXCTRL_RXEN_SHIFT)
+
+/* IE */
+#define SIFIVE_SERIAL_IE_OFFS			0x10
+#define SIFIVE_SERIAL_IE_RXWM_SHIFT		1
+#define SIFIVE_SERIAL_IE_RXWM_MASK		(1 << SIFIVE_SERIAL_IE_RXWM_SHIFT)
+#define SIFIVE_SERIAL_IE_TXWM_SHIFT		0
+#define SIFIVE_SERIAL_IE_TXWM_MASK		(1 << SIFIVE_SERIAL_IE_TXWM_SHIFT)
+
+/* IP */
+#define SIFIVE_SERIAL_IP_OFFS			0x14
+#define SIFIVE_SERIAL_IP_RXWM_SHIFT		1
+#define SIFIVE_SERIAL_IP_RXWM_MASK		(1 << SIFIVE_SERIAL_IP_RXWM_SHIFT)
+#define SIFIVE_SERIAL_IP_TXWM_SHIFT		0
+#define SIFIVE_SERIAL_IP_TXWM_MASK		(1 << SIFIVE_SERIAL_IP_TXWM_SHIFT)
+
+/* DIV */
+#define SIFIVE_SERIAL_DIV_OFFS			0x18
+#define SIFIVE_SERIAL_DIV_DIV_SHIFT		0
+#define SIFIVE_SERIAL_DIV_DIV_MASK		(0xffff << SIFIVE_SERIAL_IP_DIV_SHIFT)
+
+/*
+ * Config macros
+ */
+
+/* SIFIVE_SERIAL_MAX_PORTS: maximum number of UARTs possible on a device */
+/* XXX Move to Kconfig? */
+#define SIFIVE_SERIAL_MAX_PORTS			10
+
+/* SIFIVE_SERIAL_NAME: our driver's name that we pass to the operating system */
+#define SIFIVE_SERIAL_NAME			"sifive-serial"
+
+/* SIFIVE_TTY_PREFIX: tty name prefix for SiFive serial ports */
+#define SIFIVE_TTY_PREFIX			"ttySI"
+
+/*
+ *
+ */
+
+/**
+ * sifive_serial_port - driver-specific data extension to struct uart_port
+ * @port: struct uart_port embedded in this struct
+ * @dev: struct device *
+ * @ier: shadowed copy of the interrupt enable register
+ * @clkin_rate: input clock to the UART IP block.
+ * @bit_rate: UART serial line rate (e.g., 115200 bps)
+ * @clk_notifier: clock rate change notifier for upstream clock changes
+ */
+struct sifive_serial_port {
+	struct uart_port	port;
+	struct device		*dev;
+	unsigned char		ier;
+	unsigned long		clkin_rate;
+	unsigned long		bit_rate;
+	struct clk		*clk;
+	struct notifier_block	clk_notifier;
+};
+
+/*
+ * Structure container-of macros
+ */
+
+#define port_to_sifive_serial_port(p) (container_of((p), \
+						    struct sifive_serial_port, \
+						    port))
+
+#define notifier_to_sifive_serial_port(nb) (container_of((nb), \
+							 struct sifive_serial_port, \
+							 clk_notifier))
+
+/*
+ * Forward declarations
+ */
+static void sifive_serial_stop_tx(struct uart_port *port);
+
+/*
+ * Internal functions
+ */
+
+/**
+ * sifive_serial_early_write() - write to a UART register (early)
+ * @port: pointer to a struct uart_port record
+ * @offs: register address offset from the IP block base address
+ * @v: value to write to the register
+ *
+ * Given a pointer @port to a struct uart_port record, write the value @v to the
+ * IP block register address offset @offs.  This function is intended for early
+ * console use.
+ */
+static void sifive_serial_early_write(struct uart_port *port, u16 offs, u32 v)
+{
+	writel(v, port->membase + offs);
+}
+
+/**
+ * sifive_serial_early_read() - read from a UART register (early)
+ * @port: pointer to a struct uart_port record
+ * @offs: register address offset from the IP block base address
+ *
+ * Given a pointer @port to a struct uart_port record, read the contents of the
+ * IP block register located at offset @offs from the IP block base and return
+ * it.  This function is intended for early console use.
+ *
+ * Returns: the register value read from the UART.
+ */
+static u32 sifive_serial_early_read(struct uart_port *port, u16 offs)
+{
+	return readl(port->membase + offs);
+}
+
+/**
+ * sifive_serial_write() - write to a UART register
+ * @ssp: pointer to a struct sifive_serial_port record
+ * @offs: register address offset from the IP block base address
+ * @v: value to write to the register
+ *
+ * Write the value @v to the IP block register located at offset @offs from the
+ * IP block base, given a pointer @ssp to a struct sifive_serial_port record.
+ */
+static void sifive_serial_write(struct sifive_serial_port *ssp, u16 offs, u32 v)
+{
+	sifive_serial_early_write(&ssp->port, offs, v);
+}
+
+/**
+ * sifive_serial_read() - read from a UART register
+ * @ssp: pointer to a struct sifive_serial_port record
+ * @offs: register address offset from the IP block base address
+ *
+ * Read the contents of the IP block register located at offset @offs from the
+ * IP block base, given a pointer @ssp to a struct sifive_serial_port record.
+ *
+ * Returns: the value of the UART register
+ */
+static u32 sifive_serial_read(struct sifive_serial_port *ssp, u16 offs)
+{
+	return sifive_serial_early_read(&ssp->port, offs);
+}
+
+/**
+ * sifive_serial_is_txfifo_full() - is the TXFIFO full?
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Read the transmit FIFO "full" bit, returning a non-zero value if the
+ * TX FIFO is full, or zero if space remains.  Intended to be used to prevent
+ * writes to the TX FIFO when it's full.
+ *
+ * Returns: SIFIVE_SERIAL_TXDATA_FULL_MASK (non-zero) if the transmit FIFO
+ * is full, or 0 if space remains.
+ */
+static int sifive_serial_is_txfifo_full(struct sifive_serial_port *ssp)
+{
+	return sifive_serial_read(ssp, SIFIVE_SERIAL_TXDATA_OFFS) &
+		SIFIVE_SERIAL_TXDATA_FULL_MASK;
+}
+
+/**
+ * sifive_serial_transmit_char() - enqueue a byte to transmit onto the TX FIFO
+ * @ssp: pointer to a struct sifive_serial_port
+ * @ch: character to transmit
+ *
+ * Enqueue a byte @ch onto the transmit FIFO, given a pointer @ssp to the
+ * struct sifive_serial_port * to transmit on.  Caller should first check to
+ * ensure that the TXFIFO has space; see sifive_serial_is_txfifo_full().
+ */
+static void sifive_serial_transmit_char(struct sifive_serial_port *ssp, int ch)
+{
+	sifive_serial_write(ssp, SIFIVE_SERIAL_TXDATA_OFFS, ch);
+}
+
+/**
+ * sifive_serial_transmit_chars() - enqueue multiple bytes onto the TX FIFO
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Transfer up to a TX FIFO size's worth of characters from the Linux serial
+ * transmit buffer to the SiFive UART TX FIFO.
+ */
+static void sifive_serial_transmit_chars(struct sifive_serial_port *ssp)
+{
+	struct circ_buf *xmit = &ssp->port.state->xmit;
+	int count;
+
+	if (ssp->port.x_char) {
+		sifive_serial_transmit_char(ssp, ssp->port.x_char);
+		ssp->port.icount.tx++;
+		ssp->port.x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&ssp->port)) {
+		sifive_serial_stop_tx(&ssp->port);
+		return;
+	}
+	count = ssp->port.fifosize;
+	do {
+		sifive_serial_transmit_char(ssp, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		ssp->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&ssp->port);
+
+	if (uart_circ_empty(xmit))
+		sifive_serial_stop_tx(&ssp->port);
+}
+
+/**
+ * sifive_serial_enable_txwm() - enable transmit watermark interrupts
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Enable interrupt generation when the transmit FIFO watermark is reached
+ * on the UART referred to by @ssp.
+ */
+static void sifive_serial_enable_txwm(struct sifive_serial_port *ssp)
+{
+	if (ssp->ier & SIFIVE_SERIAL_IE_TXWM_MASK)
+		return;
+
+	ssp->ier |= SIFIVE_SERIAL_IE_TXWM_MASK;
+	sifive_serial_write(ssp, SIFIVE_SERIAL_IE_OFFS, ssp->ier);
+}
+
+/**
+ * sifive_serial_enable_rxwm() - enable receive watermark interrupts
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Enable interrupt generation when the receive FIFO watermark is reached
+ * on the UART referred to by @ssp.
+ */
+static void sifive_serial_enable_rxwm(struct sifive_serial_port *ssp)
+{
+	if (ssp->ier & SIFIVE_SERIAL_IE_RXWM_MASK)
+		return;
+
+	ssp->ier |= SIFIVE_SERIAL_IE_RXWM_MASK;
+	sifive_serial_write(ssp, SIFIVE_SERIAL_IE_OFFS, ssp->ier);
+}
+
+/**
+ * sifive_serial_disable_txwm() - disable transmit watermark interrupts
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Disable interrupt generation when the transmit FIFO watermark is reached
+ * on the UART referred to by @ssp.
+ */
+static void sifive_serial_disable_txwm(struct sifive_serial_port *ssp)
+{
+	if (!(ssp->ier & SIFIVE_SERIAL_IE_TXWM_MASK))
+		return;
+
+	ssp->ier &= ~SIFIVE_SERIAL_IE_TXWM_MASK;
+	sifive_serial_write(ssp, SIFIVE_SERIAL_IE_OFFS, ssp->ier);
+}
+
+/**
+ * sifive_serial_disable_rxwm() - disable receive watermark interrupts
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Disable interrupt generation when the receive FIFO watermark is reached
+ * on the UART referred to by @ssp.
+ */
+static void sifive_serial_disable_rxwm(struct sifive_serial_port *ssp)
+{
+	if (!(ssp->ier & SIFIVE_SERIAL_IE_RXWM_MASK))
+		return;
+
+	ssp->ier &= ~SIFIVE_SERIAL_IE_RXWM_MASK;
+	sifive_serial_write(ssp, SIFIVE_SERIAL_IE_OFFS, ssp->ier);
+}
+
+/**
+ * sifive_serial_receive_char() - receive a byte from the UART
+ * @ssp: pointer to a struct sifive_serial_port
+ * @is_empty: char pointer to return whether the RX FIFO is empty
+ *
+ * Try to read a byte from the SiFive UART RX FIFO, referenced by
+ * @ssp, and to return it.  Also returns the RX FIFO empty bit in
+ * the char pointed to by @ch.  The caller must pass the byte back to the
+ * Linux serial layer if needed.
+ *
+ * Returns: the byte read from the UART RX FIFO.
+ */
+static char sifive_serial_receive_char(struct sifive_serial_port *ssp,
+				       char *is_empty)
+{
+	u32 v;
+	u8 ch;
+
+	v = sifive_serial_read(ssp, SIFIVE_SERIAL_RXDATA_OFFS);
+
+	if (!is_empty)
+		WARN_ON(1);
+	else
+		*is_empty = (v & SIFIVE_SERIAL_RXDATA_EMPTY_MASK) >>
+			SIFIVE_SERIAL_RXDATA_EMPTY_SHIFT;
+
+	ch = (v & SIFIVE_SERIAL_RXDATA_DATA_MASK) >>
+		SIFIVE_SERIAL_RXDATA_DATA_SHIFT;
+
+	return ch;
+}
+
+/**
+ * sifive_serial_receive_chars() - receive multiple bytes from the UART
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Receive up to an RX FIFO's worth of bytes from the SiFive UART referred
+ * to by @ssp and pass them up to the Linux serial layer.
+ */
+static void sifive_serial_receive_chars(struct sifive_serial_port *ssp)
+{
+	unsigned char ch;
+	char is_empty;
+	int c;
+
+	for (c = ssp->port.fifosize; c > 0; --c) {
+		ch = sifive_serial_receive_char(ssp, &is_empty);
+		if (is_empty) break;
+
+		ssp->port.icount.rx++;
+		uart_insert_char(&ssp->port, 0, 0, ch, TTY_NORMAL);
+	}
+}
+
+/**
+ * sifive_serial_update_div() - calculate the divisor setting by the line rate
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Calculate the appropriate value of the clock divisor for the UART
+ * referred to by @ssp and the target line rate referred to by @bps, and
+ * return it.
+ */
+static void sifive_serial_update_div(struct sifive_serial_port *ssp)
+{
+	u16 div = DIV_ROUND_UP(ssp->clkin_rate, ssp->bit_rate) - 1;
+	/* XXX check for div out of spec */
+	sifive_serial_write(ssp, SIFIVE_SERIAL_DIV_OFFS, div);
+}
+
+/**
+ * sifive_serial_update_bit_rate() - set the UART "baud rate"
+ * @ssp: pointer to a struct sifive_serial_port
+ * @rate: new target bit rate
+ *
+ * Calculate the UART divisor value for the target bit rate @rate for the
+ * SiFive UART described by @ssp and program it into the UART.  There may
+ * be some error between the target bit rate and the actual bit rate implemented
+ * by the UART due to clock ratio granularity.
+ */
+static void sifive_serial_update_bit_rate(struct sifive_serial_port *ssp,
+					  unsigned int rate)
+{
+	if (ssp->bit_rate == rate)
+		return;
+
+	ssp->bit_rate = rate;
+	sifive_serial_update_div(ssp);
+}
+
+/**
+ * sifive_serial_set_stop_bits() - set the number of stop bits
+ * @ssp: pointer to a struct sifive_serial_port
+ * @nstop: 1 or 2 (stop bits)
+ *
+ * Program the SiFive UART referred to by @ssp to use @nstop stop bits.
+ */
+static void sifive_serial_set_stop_bits(struct sifive_serial_port *ssp,
+					char nstop)
+{
+	u32 v;
+
+	if (nstop < 1 || nstop > 2) {
+		WARN_ON(1);
+		return;
+	}
+
+	v = sifive_serial_read(ssp, SIFIVE_SERIAL_TXCTRL_OFFS);
+	v &= ~SIFIVE_SERIAL_TXCTRL_NSTOP_MASK;
+	v |= (nstop-1) << SIFIVE_SERIAL_TXCTRL_NSTOP_SHIFT;
+	sifive_serial_write(ssp, SIFIVE_SERIAL_TXCTRL_OFFS, v);
+}
+
+/**
+ * sifive_serial_wait_for_xmitr() - wait for an empty slot on the TX FIFO
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Delay while the UART TX FIFO referred to by @ssp is marked as full.
+ *
+ * XXX Probably should use a timeout/bailout.
+ */
+static inline void sifive_serial_wait_for_xmitr(struct sifive_serial_port *ssp)
+{
+	while (sifive_serial_is_txfifo_full(ssp))
+		udelay(1); /* XXX Should vary by bps rate */
+}
+
+/*
+ * Linux serial API functions
+ */
+
+static void sifive_serial_stop_tx(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_disable_txwm(ssp);
+}
+
+static void sifive_serial_stop_rx(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_disable_rxwm(ssp);
+}
+
+static void sifive_serial_start_tx(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_enable_txwm(ssp);
+}
+
+static irqreturn_t sifive_serial_irq(int irq, void *dev_id)
+{
+	struct sifive_serial_port *ssp = dev_id;
+	irqreturn_t r = IRQ_NONE;
+	int c = ssp->port.fifosize;
+	u32 ip;
+
+	spin_lock(&ssp->port.lock);
+
+	do {
+		ip = sifive_serial_read(ssp, SIFIVE_SERIAL_IP_OFFS);
+		if (!ip)
+			break;
+
+		r = IRQ_HANDLED;
+
+		if (ip & SIFIVE_SERIAL_IP_RXWM_MASK)
+			sifive_serial_receive_chars(ssp);
+		if (ip & SIFIVE_SERIAL_IP_TXWM_MASK)
+			sifive_serial_transmit_chars(ssp);
+	} while (c--);
+
+	spin_unlock(&ssp->port.lock);
+
+	tty_flip_buffer_push(&ssp->port.state->port);
+
+	return r;
+}
+
+static unsigned int sifive_serial_tx_empty(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	return !sifive_serial_is_txfifo_full(ssp);
+}
+
+static unsigned int sifive_serial_get_mctrl(struct uart_port *port)
+{
+	return 0; /* XXX -EINVAL? */
+}
+
+static void sifive_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	// dev_err(port->dev, "set_mctrl not supported\n");
+}
+
+static void sifive_serial_break_ctl(struct uart_port *port, int break_state)
+{
+	dev_err(port->dev, "sending break not supported\n");
+}
+
+static int sifive_serial_startup(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_enable_rxwm(ssp);
+
+	return 0;
+}
+
+static void sifive_serial_shutdown(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_disable_rxwm(ssp);
+	sifive_serial_disable_txwm(ssp);
+}
+
+/**
+ * sifive_serial_clk_notifier() - clock post-rate-change notifier
+ * @nb: pointer to the struct notifier_block, from the notifier code
+ * @event: event mask from the notifier code
+ * @data: pointer to the struct clk_notifier_data from the notifier code
+ *
+ * On the H5U SoC, the UART IP block is derived from the CPU clock source
+ * after a synchronous divide-by-two divider, so any CPU clock rate change
+ * requires the UART baud rate to be updated.  This presumably could corrupt any
+ * serial word currently being transmitted or received.  It would probably
+ * be better to stop receives and transmits, then complete the baud rate
+ * change, then re-enable them.
+ */
+static int sifive_serial_clk_notifier(struct notifier_block *nb,
+				      unsigned long event, void *data)
+{
+	struct clk_notifier_data *cnd = data;
+	struct sifive_serial_port *ssp = notifier_to_sifive_serial_port(nb);
+
+	if (event == POST_RATE_CHANGE && ssp->clkin_rate != cnd->new_rate) {
+		ssp->clkin_rate = cnd->new_rate;
+		sifive_serial_update_div(ssp);
+	}
+
+	return NOTIFY_OK;
+}
+
+static void sifive_serial_set_termios(struct uart_port *port,
+				      struct ktermios *termios,
+				      struct ktermios *old)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+	int rate;
+	char nstop;
+
+	if ((termios->c_cflag & CSIZE) != CS8) {
+		dev_err(ssp->port.dev, "only 8-bit words supported\n");
+		return;
+	}
+
+	/* Set number of stop bits */
+	nstop = (termios->c_cflag & CSTOPB) ? 2 : 1;
+	sifive_serial_set_stop_bits(ssp, nstop);
+
+	/* Set line rate */
+	rate = uart_get_baud_rate(port, termios, old, 0, ssp->clkin_rate / 16);
+	sifive_serial_update_bit_rate(ssp, rate);
+
+	/* XXX Enable FIFOs with watermark 1 */
+
+#if 0
+	spin_lock_irqsave(&ssp->port.lock, flags);
+#endif
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, rate);
+
+	/* XXX */
+	ssp->port.read_status_mask = 0;
+	if (termios->c_iflag & INPCK) {
+		dev_err(ssp->port.dev, "INPCK flag not supported\n");
+		return;
+	}
+	if (termios->c_iflag & (BRKINT | PARMRK)) {
+		dev_err(ssp->port.dev, "BRKINT/PARMRK flag not supported\n");
+		return;
+	}
+
+#if 0
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		ssp->port.ignore_status_mask |= UART_LSR_DR;
+#endif
+
+	/* XXX enable interrupts */
+}
+
+static void sifive_serial_release_port(struct uart_port *port)
+{
+}
+
+static int sifive_serial_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static void sifive_serial_config_port(struct uart_port *port, int flags)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	ssp->port.type = PORT_SIFIVE_H5U;
+}
+
+static int sifive_serial_verify_port(struct uart_port *port,
+				     struct serial_struct *ser)
+{
+	return -EINVAL;
+}
+
+static const char *sifive_serial_type(struct uart_port *port)
+{
+	return port->type == PORT_SIFIVE_H5U ? SIFIVE_SERIAL_NAME : NULL;
+}
+
+/*
+ * Polling support
+ */
+
+#ifdef CONFIG_CONSOLE_POLL
+
+static void sifive_serial_poll_put_char(struct uart_port *port,
+					unsigned char ch)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_wait_for_xmitr(ssp);
+	sifive_serial_write(ssp, SIFIVE_SERIAL_TXDATA_OFFS, ch);
+}
+
+static int sifive_serial_poll_get_char(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+	char is_empty, ch;
+
+	ch = sifive_serial_receive_char(ssp, &is_empty);
+	if (is_empty)
+		return NO_POLL_CHAR;
+
+	return ch;
+}
+
+#endif /* CONFIG_CONSOLE_POLL */
+
+/*
+ * Earlyconsole support
+ */
+
+#ifdef CONFIG_SERIAL_EARLYCON
+static void early_sifive_serial_putc(struct uart_port *port, int c)
+{
+	while (sifive_serial_early_read(port, SIFIVE_SERIAL_TXDATA_OFFS) &
+	       SIFIVE_SERIAL_TXDATA_FULL_MASK)
+		cpu_relax();
+
+	sifive_serial_early_write(port, SIFIVE_SERIAL_TXDATA_OFFS, c);
+}
+
+void early_sifive_serial_write(struct console *console, const char *s,
+			       unsigned int count)
+{
+	struct earlycon_device *device = console->data;
+	struct uart_port *port = &device->port;
+
+	uart_console_write(port, s, count, early_sifive_serial_putc);
+}
+
+static int __init early_sifive_serial_setup(struct earlycon_device *device,
+					    const char *options)
+{
+	struct uart_port *port = &device->port;
+
+	if (!(port->membase || port->iobase))
+		return -ENODEV;
+
+	device->con->write = early_sifive_serial_write;
+	return 0;
+}
+
+OF_EARLYCON_DECLARE(sifive, "sifive,freedom-uart", early_sifive_serial_setup);
+#endif /* CONFIG_SERIAL_EARLYCON */
+
+/*
+ * Linux console interface
+ */
+
+#ifdef CONFIG_SERIAL_SIFIVE_CONSOLE
+
+static struct sifive_serial_port *sifive_serial_console_ports[SIFIVE_SERIAL_MAX_PORTS];
+
+static void sifive_serial_console_putchar(struct uart_port *port, int ch)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_wait_for_xmitr(ssp);
+	sifive_serial_transmit_char(ssp, ch);
+}
+
+static void sifive_serial_console_write(struct console *co, const char *s,
+					unsigned int count)
+{
+	struct sifive_serial_port *ssp = sifive_serial_console_ports[co->index];
+	unsigned long flags;
+	unsigned int ier;
+	int locked = 1;
+
+	if (!ssp) return;
+
+	local_irq_save(flags);
+	if (ssp->port.sysrq)
+		locked = 0;
+	else if (oops_in_progress)
+		locked = spin_trylock(&ssp->port.lock);
+	else
+		spin_lock(&ssp->port.lock);
+
+	ier = sifive_serial_read(ssp, SIFIVE_SERIAL_IE_OFFS);
+	sifive_serial_write(ssp, SIFIVE_SERIAL_IE_OFFS, 0);
+
+	uart_console_write(&ssp->port, s, count, sifive_serial_console_putchar);
+
+	sifive_serial_write(ssp, SIFIVE_SERIAL_IE_OFFS, ier);
+
+	if (locked)
+		spin_unlock(&ssp->port.lock);
+	local_irq_restore(flags);
+}
+
+static int __init sifive_serial_console_setup(struct console *co, char *options)
+{
+	struct sifive_serial_port *ssp;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	ssp = sifive_serial_console_ports[co->index];
+	if (!ssp)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(&ssp->port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver sifive_serial_uart_driver;
+
+static struct console sifive_serial_console = {
+	.name		= SIFIVE_TTY_PREFIX,
+	.write		= sifive_serial_console_write,
+	.device		= uart_console_device,
+	.setup		= sifive_serial_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &sifive_serial_uart_driver,
+};
+
+static void sifive_serial_add_console_port(struct sifive_serial_port *ssp)
+{
+	sifive_serial_console_ports[ssp->port.line] = ssp;
+}
+
+static void sifive_serial_remove_console_port(struct sifive_serial_port *ssp)
+{
+	sifive_serial_console_ports[ssp->port.line] = 0;
+}
+
+#define SIFIVE_SERIAL_CONSOLE	(&sifive_serial_console)
+
+#else
+
+#define SIFIVE_SERIAL_CONSOLE	NULL
+
+static inline void sifive_serial_add_console_port(struct sifive_serial_port *ssp)
+{}
+static void sifive_serial_remove_console_port(struct sifive_serial_port *ssp)
+{}
+
+#endif
+
+static const struct uart_ops sifive_serial_uops = {
+	.tx_empty	= sifive_serial_tx_empty,
+	.set_mctrl	= sifive_serial_set_mctrl,
+	.get_mctrl	= sifive_serial_get_mctrl,
+	.stop_tx	= sifive_serial_stop_tx,
+	.start_tx	= sifive_serial_start_tx,
+	.stop_rx	= sifive_serial_stop_rx,
+	.break_ctl	= sifive_serial_break_ctl,
+	.startup	= sifive_serial_startup,
+	.shutdown	= sifive_serial_shutdown,
+	.set_termios	= sifive_serial_set_termios,
+	.type		= sifive_serial_type,
+	.release_port	= sifive_serial_release_port,
+	.request_port	= sifive_serial_request_port,
+	.config_port	= sifive_serial_config_port,
+	.verify_port	= sifive_serial_verify_port,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_put_char  = sifive_serial_poll_put_char,
+	.poll_get_char  = sifive_serial_poll_get_char,
+#endif
+};
+
+static struct uart_driver sifive_serial_uart_driver = {
+	.owner		= THIS_MODULE,
+	.driver_name	= SIFIVE_SERIAL_NAME,
+	.dev_name	= "ttySI",
+	.nr		= SIFIVE_SERIAL_MAX_PORTS,
+	.cons		= SIFIVE_SERIAL_CONSOLE,
+};
+
+static int sifive_serial_probe(struct platform_device *pdev)
+{
+	struct sifive_serial_port *ssp;
+	struct resource *mem;
+	struct clk *clk;
+	void __iomem *base;
+	int irq, id, r;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "could not acquire interrupt\n");
+		return -EPROBE_DEFER;
+	}
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(base)) {
+		dev_err(&pdev->dev, "could not acquire device memory\n");
+		return PTR_ERR(base);
+	}
+
+	clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "unable to find controller clock\n");
+		return PTR_ERR(clk);
+	}
+
+	id = of_alias_get_id(pdev->dev.of_node, "serial");
+	if (id < 0) {
+		dev_err(&pdev->dev, "missing aliases entry\n");
+		return id;
+	}
+
+#ifdef CONFIG_SERIAL_SIFIVE_CONSOLE
+	if (id > SIFIVE_SERIAL_MAX_PORTS) {
+		dev_err(&pdev->dev, "too many UARTs (%d)\n", id);
+		return -EINVAL;
+	}
+#endif
+
+	ssp = devm_kzalloc(&pdev->dev, sizeof(*ssp), GFP_KERNEL);
+	if (!ssp)
+		return -ENOMEM;
+
+	ssp->port.dev = &pdev->dev;
+	ssp->port.type = PORT_SIFIVE_H5U;
+	ssp->port.iotype = UPIO_MEM;
+	ssp->port.irq = irq;
+	ssp->port.fifosize = 8;
+	ssp->port.ops = &sifive_serial_uops;
+	ssp->port.line = id;
+	ssp->port.mapbase = mem->start;
+	ssp->port.membase = base;
+	ssp->dev = &pdev->dev;
+	ssp->clk = clk;
+	ssp->clk_notifier.notifier_call = sifive_serial_clk_notifier;
+
+	r = clk_notifier_register(ssp->clk, &ssp->clk_notifier);
+	if (r) {
+		dev_err(&pdev->dev, "could not register clock notifier: %d\n",
+			r);
+		goto probe_out1;
+	}
+
+	/* Setup clock divider */
+	ssp->clkin_rate = clk_get_rate(ssp->clk);
+	ssp->bit_rate = 115200;
+	sifive_serial_update_div(ssp);
+
+	platform_set_drvdata(pdev, ssp);
+
+	/* Enable transmits and set the watermark level to 1 */
+	sifive_serial_write(ssp, SIFIVE_SERIAL_TXCTRL_OFFS,
+			    (1 << SIFIVE_SERIAL_TXCTRL_TXCNT_SHIFT) |
+			    SIFIVE_SERIAL_TXCTRL_TXEN_MASK);
+
+	/* Enable receives and set the watermark level to 0 */
+	sifive_serial_write(ssp, SIFIVE_SERIAL_RXCTRL_OFFS,
+			    (0 << SIFIVE_SERIAL_RXCTRL_RXCNT_SHIFT) |
+			    SIFIVE_SERIAL_RXCTRL_RXEN_MASK);
+
+	r = request_irq(ssp->port.irq, sifive_serial_irq, ssp->port.irqflags,
+			dev_name(&pdev->dev), ssp);
+	if (r) {
+		dev_err(&pdev->dev, "could not attach interrupt: %d\n", r);
+		goto probe_out2;
+	}
+
+	r = uart_add_one_port(&sifive_serial_uart_driver, &ssp->port);
+	if (r != 0) {
+		dev_err(&pdev->dev, "could not add uart: %d\n", r);
+		goto probe_out3;
+	}
+
+	sifive_serial_add_console_port(ssp);
+
+	return 0;
+
+probe_out3:
+	free_irq(ssp->port.irq, ssp);
+probe_out2:
+	clk_notifier_unregister(ssp->clk, &ssp->clk_notifier);
+probe_out1:
+	return r;
+}
+
+static int sifive_serial_remove(struct platform_device *dev)
+{
+	struct sifive_serial_port *ssp = platform_get_drvdata(dev);
+
+	sifive_serial_remove_console_port(ssp);
+	uart_remove_one_port(&sifive_serial_uart_driver, &ssp->port);
+	free_irq(ssp->port.irq, ssp);
+	clk_notifier_unregister(ssp->clk, &ssp->clk_notifier);
+
+	return 0;
+}
+
+static const struct of_device_id sifive_serial_of_match[] = {
+	{ .compatible = "sifive,uart0" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sifive_serial_match);
+
+static struct platform_driver sifive_serial_platform_driver = {
+	.probe		= sifive_serial_probe,
+	.remove		= sifive_serial_remove,
+	.driver		= {
+		.name	= SIFIVE_SERIAL_NAME,
+		.of_match_table = of_match_ptr(sifive_serial_of_match),
+	},
+};
+
+static int __init sifive_serial_init(void)
+{
+	struct tty_driver *tty_drv;
+	int r;
+
+	r = uart_register_driver(&sifive_serial_uart_driver);
+	if (r) goto init_out1;
+
+	tty_drv = sifive_serial_uart_driver.tty_driver;
+	if (!tty_drv) goto init_out2;
+
+	/* change default terminal settings for SiFive uarts */
+	tty_drv->init_termios.c_cflag = B115200 | CS8 | CREAD | HUPCL | CLOCAL;
+	tty_drv->init_termios.c_ispeed = 115200;
+	tty_drv->init_termios.c_ospeed = 115200;
+
+	r = platform_driver_register(&sifive_serial_platform_driver);
+	if (r) goto init_out2;
+
+	return 0;
+
+init_out2:
+	uart_unregister_driver(&sifive_serial_uart_driver);
+init_out1:
+	return r;
+}
+
+static void __exit sifive_serial_exit(void)
+{
+	platform_driver_unregister(&sifive_serial_platform_driver);
+	uart_unregister_driver(&sifive_serial_uart_driver);
+}
+
+module_init(sifive_serial_init);
+module_exit(sifive_serial_exit);
+
+MODULE_DESCRIPTION("SiFive UART serial driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Paul Walmsley <paul@pwsan.com>");
diff --git a/drivers/tty/vt/.gitignore b/drivers/tty/vt/.gitignore
deleted file mode 100644
index 83683a2d..00000000
--- a/drivers/tty/vt/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-consolemap_deftbl.c
-defkeymap.c
diff --git a/drivers/video/fbdev/FTLCDC100/Kconfig b/drivers/video/fbdev/FTLCDC100/Kconfig
new file mode 100644
index 00000000..1393d530
--- /dev/null
+++ b/drivers/video/fbdev/FTLCDC100/Kconfig
@@ -0,0 +1,74 @@
+config FB_FTLCDC100
+        tristate "Faraday FTLCDC100 driver"
+        depends on FB
+        select FB_CFB_FILLRECT
+        select FB_CFB_COPYAREA
+        select FB_CFB_IMAGEBLIT
+
+	choice
+		prompt "Default LCD Panel"
+		depends on FB_FTLCDC100
+		default PANEL_AUA036QN01
+		help
+		  This option select a default panel setting for the LCD controller
+
+		config PANEL_AUA036QN01
+			bool "AU 3.5 inch LCD Panel"
+
+		config PANEL_CH7013A
+			bool "Chrontel Digital PC to TV Encoder"
+			select I2C
+			select I2C_FARADAY
+			select CH7013A
+
+		config PANEL_AUA070VW04
+			bool "AU 7.0 inch LCD Panel"
+
+		config PANEL_LW500AC9601
+			bool "CHIMEI 5.0 inch LCD panel"
+
+	endchoice
+
+	# config FTLCD_OSD
+	# 	bool "Enable OSD (On Screen Display)"
+	# 	depends on FB_FTLCDC100
+	# 	default n
+	# 	---help---
+	# 	This enables access to the OSD (On Screen Display) for Faraday
+	# 	FTLCDC100 LCD control.  Disabling OSD will reduce the size of
+	# 	the kernel by approximately 6kb.
+	#
+
+	choice
+	        prompt "Default Color Mode"
+	        depends on FB_FTLCDC100
+	        default FFB_MODE_RGB
+	        help
+	          This option select default color mode
+
+		config FFB_MODE_RGB
+			bool "RGB Mode"
+		config FFB_MODE_YUV422
+			bool "YUV422 Mode"
+		config FFB_MODE_YUV420
+			bool "YUV420 Mode"
+	endchoice
+
+	choice
+	        prompt "Default BPP"
+	        depends on FB_FTLCDC100
+	        default FFB_MODE_16BPP
+	        help
+	          This option select default BPP (bits-per-pixel)
+
+		config FFB_MODE_8BPP
+			depends on FFB_MODE_RGB || FFB_MODE_YUV420
+			bool "8 bits-per-pixel"
+		config FFB_MODE_16BPP
+			depends on FFB_MODE_RGB || FFB_MODE_YUV422
+			bool "16 bits-per-pixel"
+		config FFB_MODE_24BPP
+			depends on FFB_MODE_RGB
+			bool "24 bits-per-pixel"
+	endchoice
+
diff --git a/drivers/video/fbdev/FTLCDC100/Makefile b/drivers/video/fbdev/FTLCDC100/Makefile
new file mode 100644
index 00000000..3f206f6d
--- /dev/null
+++ b/drivers/video/fbdev/FTLCDC100/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_FB_FTLCDC100) += faradayfb-main.o
diff --git a/drivers/video/fbdev/FTLCDC100/faradayfb-main.c b/drivers/video/fbdev/FTLCDC100/faradayfb-main.c
new file mode 100644
index 00000000..f4841c00
--- /dev/null
+++ b/drivers/video/fbdev/FTLCDC100/faradayfb-main.c
@@ -0,0 +1,833 @@
+#include <linux/module.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+#include "faradayfb.h"
+#include "lcd-info.c"
+#include "pingpong-module.c"
+
+
+#define REG32(a)        (*(volatile unsigned int *)(a))
+static resource_size_t	lcd_base;
+
+static u32 faradayfb_pseudo_palette[32];
+static inline void faradayfb_lcd_power(struct fb_info *info, int on)
+{
+	struct faradayfb_info *fbi = info->par;
+	volatile LCD_Register *plcd = (LCD_Register *)fbi->io_base;
+
+	if (on)
+		fbi->control |= (1UL << 11);
+	else
+		fbi->control &= ~(1UL << 11);
+
+	plcd->Control = fbi->control;
+}
+
+static void faradayfb_setup_gpio(struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+	volatile LCD_Register *plcd = (LCD_Register *)fbi->io_base;
+
+	plcd->GPIO = 0x010000;
+}
+
+static void faradayfb_enable_controller(struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+	volatile LCD_Register *plcd = (LCD_Register *)fbi->io_base;
+
+	plcd->Timing0 = fbi->time0;
+	plcd->Timing1 = fbi->time1;
+	plcd->Timing2 = fbi->time2;
+	plcd->Control = fbi->control & ~0x01;
+	plcd->UPBase  = fbi->screen_dma | fbi->frame420_size;
+	plcd->Control |= 0x01;
+	DEBUG(0, 1, "Time0   = 0x%08x\n", plcd->Timing0);
+	DEBUG(0, 1, "Time1   = 0x%08x\n", plcd->Timing1);
+	DEBUG(0, 1, "Time2   = 0x%08x\n", plcd->Timing2);
+	DEBUG(0, 1, "Control = 0x%08x\n", plcd->Control);
+	DEBUG(0, 1, "UPBase  = 0x%08x\n", plcd->UPBase);
+}
+
+static void faradayfb_disable_controller(struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+	volatile LCD_Register *plcd = (LCD_Register *)fbi->io_base;
+
+	DECLARE_WAITQUEUE(wait, current);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	add_wait_queue(&fbi->ctrlr_wait, &wait);
+	fbi->control &= ~0x0001;
+	plcd->Control = fbi->control;
+	schedule_timeout(20 * HZ / 1000);
+	remove_wait_queue(&fbi->ctrlr_wait, &wait);
+}
+
+static void faradayfb_enable_int(struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+	volatile LCD_Register *plcd = (LCD_Register *)fbi->io_base;
+
+	plcd->INTREnable = fbi->int_mask;
+}
+
+static void faradayfb_disable_int(struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+	volatile LCD_Register *plcd = (LCD_Register *)fbi->io_base;
+
+	fbi->int_mask    = plcd->INTREnable;
+	plcd->INTREnable = 0;
+	plcd->Status     = 0x1e;
+}
+
+static struct faradayfb_rgb def_rgb_8 = {
+
+	.red    = { .offset = 0, .length = 4 },
+	.green  = { .offset = 0, .length = 4 },
+	.blue   = { .offset = 0, .length = 4 },
+	.transp = { .offset = 0, .length = 0 },
+};
+
+static struct faradayfb_rgb def_rgb_16 = {
+
+	.red    = { .offset = 11, .length = 5, .msb_right = 0 },
+	.green  = { .offset = 5,  .length = 6, .msb_right = 0 },
+	.blue   = { .offset = 0,  .length = 5, .msb_right = 0 },
+	.transp = { .offset = 15, .length = 0, .msb_right = 0 },
+};
+
+static struct faradayfb_rgb def_rgb_24 = {
+
+	.red    = { .offset = 16, .length = 8, .msb_right = 0 },
+	.green  = { .offset = 8,  .length = 8, .msb_right = 0 },
+	.blue   = { .offset = 0,  .length = 8, .msb_right = 0 },
+	.transp = { .offset = 0,  .length = 0, .msb_right = 0 },
+};
+
+static inline void faradayfb_schedule_work(struct fb_info *info, unsigned int state)
+{
+	struct faradayfb_info *fbi = info->par;
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	/*
+	 * We need to handle two requests being made at the same time.
+	 * There are two important cases:
+	 *  1. When we are changing VT (C_REENABLE) while unblanking (C_ENABLE)
+	 *     We must perform the unblanking, which will do our REENABLE for us.
+	 *  2. When we are blanking, but immediately unblank before we have
+	 *     blanked.  We do the "REENABLE" thing here as well, just to be sure.
+	 */
+	if (fbi->task_state == C_ENABLE && state == C_REENABLE)
+		state = (unsigned int) - 1;
+
+	if (fbi->task_state == C_DISABLE && state == C_ENABLE)
+		state = C_REENABLE;
+
+	if (state != (unsigned int) - 1) {
+
+		fbi->task_state = state;
+		schedule_work(&fbi->task);
+	}
+
+	local_irq_restore(flags);
+}
+
+static int faradayfb_setpalettereg(unsigned int regno, unsigned int red,
+		unsigned int green, unsigned int blue, unsigned int trans,
+		struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+
+	if (regno < fbi->palette_size) {
+
+		fbi->palette_cpu[regno] = ((red >> 0) & (0x1fUL << 11)) |
+			((green >> 5) & (0x3F << 5)) |
+			((blue >> 11) & (0x1f << 0));
+
+		return 0;
+	}
+
+	return 1;
+}
+
+static int faradayfb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,
+		unsigned int blue, unsigned int trans, struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+	int ret = 1;
+	/*
+	 * If inverse mode was selected, invert all the colours
+	 * rather than the register number.  The register number
+	 * is what you poke into the framebuffer to produce the
+	 * colour you requested.
+	 */
+	if (fbi->cmap_inverse) {
+
+		red   = 0xffff - red;
+		green = 0xffff - green;
+		blue  = 0xffff - blue;
+	}
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no mater what visual we are using.
+	 */
+	if (info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green + 7471 * blue) >> 16;
+
+	switch(info->fix.visual) {
+
+		case FB_VISUAL_TRUECOLOR:
+			/*
+			 * 12 or 16-bit True Colour.  We encode the RGB value
+			 * according to the RGB bitfield information.
+			 */
+			if (regno < 16) {
+
+				u32 col;
+				red	>>= (16 - info->var.red.length);
+				green	>>= (16 - info->var.green.length);
+				blue	>>= (16 - info->var.blue.length);
+				col = (red << info->var.red.offset) |
+					(green << info->var.green.offset) |
+					(blue << info->var.blue.offset) ;
+
+				switch(info->var.bits_per_pixel) {
+
+					/* is the following code correct?? */
+					case 16:
+					case 32:
+						((u32 *)(info->pseudo_palette))[regno] = col;
+						ret=0;
+						break;
+				}
+			}
+			break;
+
+		case FB_VISUAL_STATIC_PSEUDOCOLOR:
+		case FB_VISUAL_PSEUDOCOLOR:
+			if (fbi->smode == FFB_MODE_RGB)
+				ret = faradayfb_setpalettereg(regno, red, green, blue, trans, info);
+			break;
+	}
+
+	return ret;
+}
+
+/*
+ * Round up in the following order: bits_per_pixel, xres,
+ * yres, xres_virtual, yres_virtual, xoffset, yoffset, grayscale,
+ * bitfields, horizontal timing, vertical timing.
+ */
+static int faradayfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+	int rgbidx;
+
+	var->xres = min(var->xres, (unsigned int)MIN_XRES);
+	var->yres = min(var->yres, (unsigned int)MIN_YRES);
+	var->xres = max(var->xres, fbi->xres);
+	var->yres = max(var->yres, fbi->yres);
+	var->xres_virtual = max(var->xres_virtual, var->xres);
+	var->yres_virtual = max(var->yres_virtual, var->yres);
+
+	DEBUG(0, 1, "var->bits_per_pixel = %d\n", var->bits_per_pixel);
+
+	switch (var->bits_per_pixel) {
+
+		case 1: case 2: case 4: case 8:
+			rgbidx = RGB_8;
+			break;
+
+		case 16:
+			rgbidx = RGB_16;
+			break;
+
+		case 32:
+			rgbidx = RGB_24;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+
+	/*
+	 * Copy the RGB parameters for this display
+	 * from the machine specific parameters.
+	 */
+	var->red	= fbi->rgb[ rgbidx]->red;
+	var->green	= fbi->rgb[ rgbidx]->green;
+	var->blue	= fbi->rgb[ rgbidx]->blue;
+	var->transp	= fbi->rgb[ rgbidx]->transp;
+
+	DEBUG(0, 1, "RGBT length = %d:%d:%d:%d\n",
+			var->red.length, var->green.length, var->blue.length, var->transp.length);
+
+	DEBUG(0, 1, "RGBT offset = %d:%d:%d:%d\n",
+			var->red.offset, var->green.offset, var->blue.offset, var->transp.offset);
+
+	DEBUG(0, 1, "Leave\n");
+
+	return 0;
+}
+
+/*
+ * Configures LCD Controller based on entries in var parameter.  Settings are
+ * only written to the controller if changes were made.
+ */
+static int faradayfb_activate_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+	volatile LCD_Register *plcd = (LCD_Register *)fbi->io_base;
+
+	DEBUG(0, 1, "var: xres=%d hslen=%d lm=%d rm=%d\n", var->xres, var->hsync_len, var->left_margin, var->right_margin);
+	DEBUG(0, 1, "var: yres=%d vslen=%d um=%d bm=%d\n", var->yres, var->vsync_len, var->upper_margin, var->lower_margin);
+
+	fbi->time0 = FARADAY_LCDTIME0_HFP(var->left_margin)
+		| FARADAY_LCDTIME0_HBP(var->right_margin)
+		| FARADAY_LCDTIME0_HW(var->hsync_len)
+		| FARADAY_LCDTIME0_PL(var->xres);
+
+	fbi->time1 = FARADAY_LCDTIME1_VBP(var->upper_margin)
+		| FARADAY_LCDTIME1_VFP(var->lower_margin)
+		| FARADAY_LCDTIME1_VW(var->vsync_len)
+		| FARADAY_LCDTIME1_LF(var->yres);
+
+	if ((plcd->Timing0 != fbi->time0)
+			|| (plcd->Timing1 != fbi->time1)
+			|| (plcd->Timing2 != fbi->time2)
+			|| (plcd->Control != fbi->control)) {
+
+		faradayfb_schedule_work(info, C_REENABLE);
+	}
+
+	return 0;
+}
+
+/* Set the user defined part of the display for the specified console */
+static int faradayfb_set_par(struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	unsigned long palette_mem_size;
+
+	if (var->bits_per_pixel == 16 || var->bits_per_pixel == 32)
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+	else if (!fbi->cmap_static)
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	else {
+		/*
+		 * Some people have weird ideas about wanting static
+		 * pseudocolor maps.  I suspect their user space
+		 * applications are broken.
+		 */
+		info->fix.visual = FB_VISUAL_STATIC_PSEUDOCOLOR;
+	}
+
+	info->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
+
+	fbi->palette_size = var->bits_per_pixel == 8 ? 256 : 16;
+
+	palette_mem_size = fbi->palette_size * sizeof(u32);
+
+	DEBUG(0, 1, "info->fix.line_length = %d\n", info->fix.line_length);
+	DEBUG(0, 1, "palette_mem_size = 0x%08lx\n", (unsigned long) palette_mem_size);
+
+	fbi->palette_cpu = (u32 *)(fbi->map_cpu + PAGE_SIZE - palette_mem_size);
+
+	fbi->palette_dma = fbi->map_dma + PAGE_SIZE - palette_mem_size;
+
+	/* Set (any) board control register to handle new color depth */
+	faradayfb_activate_var(var, info);
+
+	DEBUG(0, 1, "Leave\n");
+
+	return 0;
+}
+
+static irqreturn_t faradayfb_handle_irq(int irq, void *dev_id)
+{
+	struct fb_info *info = (struct fb_info*)dev_id;
+	struct faradayfb_info *fbi = info->par;
+	volatile LCD_Register *plcd = (LCD_Register *)fbi->io_base;
+	u32 status = plcd->Interrupt;
+	printk("\n\n faradayfb_handle_irq , irq %d\n\n",irq);
+
+	DEBUG(0, 1, "status 0x%x\n", status);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * This function must be called from task context only, since it will
+ * sleep when disabling the LCD controller, or if we get two contending
+ * processes trying to alter state.
+ */
+static void set_ctrlr_state(struct fb_info *info, unsigned int state)
+{
+	struct faradayfb_info *fbi = info->par;
+	unsigned int old_state;
+
+	down(&fbi->ctrlr_sem);
+
+	old_state = fbi->state;
+
+	/* Hack around fbcon initialisation.  */
+	if (old_state == C_STARTUP && state == C_REENABLE)
+		state = C_ENABLE;
+
+	switch (state) {
+		case C_DISABLE_PM:
+		case C_DISABLE:
+
+			/* Disable controller */
+			if (old_state != C_DISABLE) {
+
+				fbi->state = state;
+				faradayfb_disable_int(info);
+				faradayfb_lcd_power(info, 0);
+				//				faradayfb_disable_controller(info);
+			}
+			break;
+
+		case C_REENABLE:
+			/*
+			 * Re-enable the controller only if it was already
+			 * enabled.  This is so we reprogram the control
+			 * registers.
+			 */
+			if (old_state == C_ENABLE) {
+
+				faradayfb_disable_int(info);
+				faradayfb_lcd_power(info, 0);
+				faradayfb_disable_controller(info);
+
+				faradayfb_setup_gpio(info);
+				faradayfb_lcd_power(info, 1);
+				faradayfb_enable_controller(info);
+				faradayfb_enable_int(info);
+			}
+			break;
+
+		case C_ENABLE_PM:
+			/*
+			 * Re-enable the controller after PM.  This is not
+			 * perfect - think about the case where we were doing
+			 * a clock change, and we suspended half-way through.
+			 */
+			if (old_state != C_DISABLE_PM)
+				break;
+			/* fall through */
+
+		case C_ENABLE:
+			/*
+			 * Power up the LCD screen, enable controller, and
+			 * turn on the backlight.
+			 */
+			if (old_state != C_ENABLE) {
+
+				fbi->state = C_ENABLE;
+				faradayfb_setup_gpio(info);
+				faradayfb_lcd_power(info, 1);
+				faradayfb_enable_controller(info);
+				faradayfb_enable_int(info);
+			}
+			break;
+	}
+	up(&fbi->ctrlr_sem);
+}
+
+/*
+ * Blank the display by setting all palette values to zero.  Note, the
+ * 12 and 16 bpp modes don't really use the palette, so this will not
+ * blank the display in all modes.
+ */
+static int faradayfb_blank(int blank, struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+	int i;
+
+	switch (blank) {
+		case FB_BLANK_POWERDOWN:
+		case FB_BLANK_VSYNC_SUSPEND:
+		case FB_BLANK_HSYNC_SUSPEND:
+		case FB_BLANK_NORMAL:
+
+			if (info->fix.visual == FB_VISUAL_PSEUDOCOLOR ||
+					info->fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR) {
+
+				for (i = 0; i < fbi->palette_size; i++)
+					faradayfb_setpalettereg(i, 0, 0, 0, 0, info);
+			}
+
+			faradayfb_schedule_work(info, C_DISABLE);
+
+			break;
+
+		case FB_BLANK_UNBLANK:
+
+			if (info->fix.visual == FB_VISUAL_PSEUDOCOLOR ||
+					info->fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR)
+				fb_set_cmap(&info->cmap, info);
+
+			faradayfb_schedule_work(info, C_ENABLE);
+
+			break;
+	}
+
+	return 0;
+}
+
+/*
+ * Our LCD controller task (which is called when we blank or unblank)
+ * via keventd.
+ */
+static void faradayfb_task(struct work_struct *dummy)
+{
+	struct faradayfb_info *fbi = container_of(dummy, struct faradayfb_info, task);
+	struct fb_info *info = fbi->info;
+	unsigned int state;
+
+	state = xchg(&fbi->task_state, -1);
+	set_ctrlr_state(info, state);
+}
+
+/* Fake monspecs to fill in fbinfo structure */
+static struct fb_monspecs monspecs = {
+
+	.hfmin	= 30000,
+	.hfmax	= 70000,
+	.vfmin	= 50,
+	.vfmax	= 65,
+};
+
+static int ffb_get_mach_param(struct faradayfb_mach_info *inf, struct fb_info *info, unsigned long smode)
+{
+	struct faradayfb_info *fbi = info->par;
+	struct lcd_param *tparam;
+	unsigned long bpp_mode;
+
+	if (!(tparam = get_lcd_time(inf->time0, inf->num_time0, smode)))
+		return -1;
+
+	fbi->time0 = tparam->value;
+
+	if (!(tparam = get_lcd_time(inf->time1, inf->num_time1, smode)))
+		return -1;
+
+	fbi->time1 = tparam->value;
+
+	if (!(tparam = get_lcd_time(inf->time2, inf->num_time2, smode)))
+		return -1;
+
+	fbi->time2 = tparam->value;
+
+	switch(info->var.bits_per_pixel) {
+
+		case 1: case 2: case 4: case 8:
+			bpp_mode = FFB_MODE_8BPP;
+			break;
+
+		case 16:
+			bpp_mode = FFB_MODE_16BPP;
+			break;
+
+		case 32:
+			bpp_mode = FFB_MODE_24BPP;
+			break;
+
+		default:
+			DEBUG(1, 1, "Unsupported BPP, set default BPP to 16\n");
+			bpp_mode = FFB_MODE_16BPP;
+			break;
+	}
+
+	if (!(tparam = get_lcd_ctrl(inf->control, inf->num_control, smode | bpp_mode)))
+		return -1;
+
+	fbi->control = tparam->value;
+
+	fbi->xres = inf->xres;
+	fbi->yres = inf->yres;
+
+	return 0;
+}
+
+static int faradayfb_set_var(struct fb_info *info, struct faradayfb_mach_info *inf, unsigned long type)
+{
+	struct faradayfb_info *fbi = info->par;
+	unsigned long t_smode = 0;
+
+	if (!type)
+		t_smode = fbi->smode;
+	else
+		t_smode = type;
+
+	if (ffb_get_mach_param(inf, info, t_smode)) {
+
+		DEBUG(1, 1, "Not support mode(%lx)\n", t_smode);
+		return -1;
+	}
+
+	info->var.xres		= fbi->xres;
+	info->var.xres_virtual	= fbi->xres;
+	info->var.yres		= fbi->yres;
+	info->var.yres_virtual	= fbi->yres;
+
+	info->var.upper_margin	= FARADAY_LCDTIME1_GET_VBP(fbi->time1);
+	info->var.lower_margin	= FARADAY_LCDTIME1_GET_VFP(fbi->time1);
+	info->var.vsync_len	= FARADAY_LCDTIME1_GET_VW(fbi->time1);
+	info->var.left_margin	= FARADAY_LCDTIME0_GET_HFP(fbi->time0);
+	info->var.right_margin	= FARADAY_LCDTIME0_GET_HBP(fbi->time0);
+	info->var.hsync_len	= FARADAY_LCDTIME0_GET_HW(fbi->time0);
+
+	fbi->int_mask = 0;
+
+	if (t_smode & FFB_MODE_YUV420)
+		fbi->frame420_size	= (((info->var.xres * info->var.yres + 0xffff) & 0xffff0000) >> 16) << 2;
+	else
+		fbi->frame420_size	= 0;
+
+	return 0;
+}
+
+static struct fb_ops faradayfb_ops = {
+
+	.owner		= THIS_MODULE,
+	.fb_check_var	= faradayfb_check_var,
+	.fb_set_par	= faradayfb_set_par,
+	.fb_setcolreg	= faradayfb_setcolreg,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_blank	= faradayfb_blank,
+	.fb_mmap	= faradayfb_mmap,
+	.fb_ioctl	= faradayfb_ioctl,
+};
+
+static struct fb_info * faradayfb_init_fbinfo(struct device *dev)
+{
+	struct faradayfb_mach_info *inf;
+	struct fb_info *info;
+	struct faradayfb_info *fbi;
+
+	if (!(info = framebuffer_alloc(sizeof(struct faradayfb_info), dev)))
+		return NULL;
+
+	fbi = info->par;
+	fbi->info = info;
+	fbi->io_base		= lcd_base;
+	strcpy(info->fix.id, FARADAYFB_MODULE_NAME);
+
+	info->fix.type		= FB_TYPE_PACKED_PIXELS;
+	info->fix.type_aux	= 0;
+	info->fix.xpanstep	= 0;
+	info->fix.ypanstep	= 0;
+	info->fix.ywrapstep	= 0;
+	info->fix.accel		= FB_ACCEL_NONE;
+
+	info->var.nonstd	= 0;
+	info->var.activate	= FB_ACTIVATE_NOW;
+	info->var.height	= -1;
+	info->var.width		= -1;
+	info->var.accel_flags	= 0;
+	info->var.vmode		= FB_VMODE_NONINTERLACED;
+
+	info->fbops		= &faradayfb_ops;
+	info->flags		= FBINFO_DEFAULT;
+	info->monspecs		= monspecs;
+	info->pseudo_palette	= &faradayfb_pseudo_palette;
+
+	fbi->rgb[RGB_8]		= &def_rgb_8;
+	fbi->rgb[RGB_16]	= &def_rgb_16;
+	fbi->rgb[RGB_24]	= &def_rgb_24;
+
+	inf = (struct faradayfb_mach_info*)dev->platform_data;
+
+	/*
+	 * People just don't seem to get this.  We don't support
+	 * anything but correct entries now, so panic if someone
+	 * does something stupid.
+	 */
+
+	fbi->xres			= inf->xres;
+	fbi->yres			= inf->yres;
+	fbi->max_bpp			= 32;
+#if defined(CONFIG_FFB_MODE_8BPP)
+	info->var.bits_per_pixel	= min((u32)8, inf->max_bpp);
+#elif defined(CONFIG_FFB_MODE_16BPP)
+	info->var.bits_per_pixel	= min((u32)16, inf->max_bpp);
+#elif defined(CONFIG_FFB_MODE_24BPP)
+	info->var.bits_per_pixel	= min((u32)32, inf->max_bpp);
+	info->var.bits_per_pixel	= 32;
+#endif
+
+	info->var.pixclock		= inf->pixclock;
+	info->var.sync			= inf->sync;
+	info->var.grayscale		= inf->cmap_greyscale;
+	fbi->cmap_inverse		= inf->cmap_inverse;
+	fbi->cmap_static		= inf->cmap_static;
+	fbi->smode			= FFB_DEFAULT_MODE;
+	if (faradayfb_set_var(info, inf, 0))
+		goto err;
+	fbi->state			= C_STARTUP;
+	fbi->task_state			= (unsigned char) - 1;
+	info->fix.smem_len		= faradayfb_cal_frame_buf_size(fbi);
+	init_waitqueue_head(&fbi->ctrlr_wait);
+	INIT_WORK(&fbi->task, faradayfb_task);
+	sema_init(&fbi->ctrlr_sem, 1);
+	return info;
+err:
+	kfree(fbi);
+	kfree(info);
+
+	return NULL;
+}
+
+static int faradayfb_probe(struct platform_device *pdev)
+{
+	struct fb_info *info = NULL;
+	struct faradayfb_info *fbi;
+	int irq = -EINVAL;
+	int ret = -ENODEV;
+	struct resource	*io;
+
+	if ((io = platform_get_resource(pdev, IORESOURCE_MEM, 0)) == NULL ) {
+		dev_err(&pdev->dev, "Failed to get memory resource\n");
+		goto err_exit;
+	}
+
+	if ((irq = platform_get_irq(pdev, 0)) <= 0) {
+		dev_err(&pdev->dev, "Failed to get irq\n");
+		goto err_exit;
+	}
+
+	lcd_base = (resource_size_t)devm_ioremap_resource(&pdev->dev, io);
+	pdev->dev.platform_data	= &ffb_mach_info,
+
+	info = faradayfb_init_fbinfo(&pdev->dev);
+	if (info == NULL) {
+		dev_err(&pdev->dev,"Failed to init info\n");
+		goto err_exit;
+	}
+
+	fbi = info->par;
+
+	/* Initialize video memory */
+	if ((ret = faradayfb_map_video_memory(info)) < 0) {
+		dev_err(&pdev->dev,"Failed to map video memory\n");
+		goto err_free_mem;
+	}
+
+	ret = -EINVAL;
+	if (request_irq(irq, faradayfb_handle_irq, 0, "LCD", info)) {
+		dev_err(&pdev->dev,"Failed to request irq\n");
+		goto err_free_map;
+	}
+
+	/*
+	 * This makes sure that our colour bitfield
+	 * descriptors are correctly initialised.
+	 */
+	faradayfb_check_var(&info->var, info);
+	faradayfb_set_par(info);
+	dev_set_drvdata(&pdev->dev, info);
+	if ((ret = register_framebuffer(info)) < 0) {
+		dev_err(&pdev->dev,"Failed to register framebuffer\n");
+		goto err_free_irq;
+	}
+	faradayfb_clean_screen(info);
+
+	return 0;
+
+err_free_irq:
+	dev_set_drvdata(&pdev->dev, NULL);
+	free_irq(irq, info);
+err_free_map:
+	faradayfb_unmap_video_memory(info);
+err_free_mem:
+	kfree(info->par);
+	kfree(info);
+err_exit:
+
+	return ret;
+}
+
+/* Called when the device is being detached from the driver */
+static int faradayfb_remove(struct platform_device *pdev)
+{
+	struct fb_info  *info = platform_get_drvdata(pdev);
+	int irq;
+
+	set_ctrlr_state(info, C_DISABLE);
+
+	irq = platform_get_irq(pdev, 0);
+	free_irq(irq, info);
+
+	unregister_framebuffer(info);
+	faradayfb_unmap_video_memory(info);
+	dev_set_drvdata(&pdev->dev, NULL);
+	kfree(info->par);
+	kfree(info);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/* suspend and resume support for the lcd controller */
+static int faradayfb_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	struct fb_info *info = platform_get_drvdata(pdev);
+
+	//    if (level == SUSPEND_DISABLE || level == SUSPEND_POWER_DOWN)
+	if (mesg.event == PM_EVENT_PRETHAW || mesg.event & PM_EVENT_SLEEP)
+		set_ctrlr_state(info, C_DISABLE_PM);
+
+	return 0;
+}
+
+static int faradayfb_resume(struct platform_device *pdev)
+{
+	struct fb_info *info = platform_get_drvdata(pdev);
+
+	//    need modify
+	//    if (level == RESUME_ENABLE)
+	set_ctrlr_state(info, C_ENABLE_PM);
+
+	return 0;
+}
+
+#else
+#define faradayfb_suspend NULL
+#define faradayfb_resume  NULL
+#endif
+
+static struct of_device_id atflcd_of_match[] = {
+	{ .compatible = "andestech,atflcdc100", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, atflcd_of_match);
+static struct platform_driver atflcd_of_driver = {
+	.probe = faradayfb_probe,
+	.remove = faradayfb_remove,
+	.driver = {
+		.name = "faraday-lcd",
+		.owner = THIS_MODULE,
+		.of_match_table = atflcd_of_match,
+	},
+};
+
+module_platform_driver(atflcd_of_driver);
+MODULE_DESCRIPTION("Faraday LCD driver");
+MODULE_AUTHOR("Francis Huang <francish@faraday-tech.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/FTLCDC100/faradayfb.h b/drivers/video/fbdev/FTLCDC100/faradayfb.h
new file mode 100644
index 00000000..3bc41754
--- /dev/null
+++ b/drivers/video/fbdev/FTLCDC100/faradayfb.h
@@ -0,0 +1,215 @@
+#ifndef __FARADAYFB_H
+#define __FARADAYFB_H
+
+#define FARADAYFB_MODULE_NAME  "faradayfb"
+#define DEBUG(enabled, tagged, ...)				\
+	do {							\
+		if (enabled) {					\
+			if (tagged)				\
+			printk("[ %30s() ] ", __func__);	\
+			printk(__VA_ARGS__);			\
+		}						\
+	} while (0)
+
+#if defined(CONFIG_FFB_MODE_RGB)
+#  define DEFAULT_COLOR  FFB_MODE_RGB
+#elif defined(CONFIG_FFB_MODE_YUV422)
+#  define DEFAULT_COLOR  FFB_MODE_YUV422
+#elif defined(CONFIG_FFB_MODE_YUV420)
+#  define DEFAULT_COLOR  FFB_MODE_YUV420
+#endif
+
+#if defined(CONFIG_FFB_MODE_8BPP)
+#  define DEFAULT_BPP  FFB_MODE_8BPP
+#elif defined(CONFIG_FFB_MODE_16BPP)
+#  define DEFAULT_BPP  FFB_MODE_16BPP
+#elif defined(CONFIG_FFB_MODE_24BPP)
+#  define DEFAULT_BPP  FFB_MODE_24BPP
+#endif
+
+#define FFB_DEFAULT_MODE        (DEFAULT_COLOR | DEFAULT_BPP)
+
+struct lcd_param {
+
+	unsigned long value;
+	unsigned long flags;
+};
+
+inline struct lcd_param* get_lcd_time(struct lcd_param* array, unsigned long num_array, unsigned long type)
+{
+	int i;
+
+	for (i = 0; i < num_array; i++) {
+
+		struct lcd_param *r = &array[i];
+
+		if (r->flags & type & 0xff)
+			return r;
+	}
+
+	return NULL;
+}
+
+inline struct lcd_param* get_lcd_ctrl(struct lcd_param* array, unsigned long num_array, unsigned long type)
+{
+	int i;
+
+	for (i = 0; i < num_array; i++) {
+
+		struct lcd_param *r = &array[i];
+
+		if ((r->flags & type & 0xff) && (r->flags & type & 0xff00))
+			return r;
+	}
+
+	return NULL;
+}
+
+enum { RGB_8, RGB_16, RGB_24, NR_RGB};
+
+struct faradayfb_rgb {
+
+	struct fb_bitfield	red;
+	struct fb_bitfield	green;
+	struct fb_bitfield	blue;
+	struct fb_bitfield	transp;
+};
+
+/* This structure describes the machine which we are running on.  */
+struct faradayfb_mach_info {
+
+	unsigned long		num_time0;
+	struct lcd_param *	time0;
+
+	unsigned long		num_time1;
+	struct lcd_param *	time1;
+
+	unsigned long		num_time2;
+	struct lcd_param *	time2;
+
+	unsigned long		num_control;
+	struct lcd_param *	control;
+
+	unsigned long		pixclock;
+
+	unsigned long		xres;
+	unsigned long		yres;
+
+	unsigned int		max_bpp;
+	unsigned int		sync;
+
+	unsigned int		cmap_greyscale:1,
+				cmap_inverse:1,
+				cmap_static:1,
+				unused:29;
+};
+
+struct faradayfb_info {
+
+	struct fb_info		*info;
+	struct faradayfb_rgb	*rgb[NR_RGB];
+
+	unsigned int		xres;
+	unsigned int		yres;
+	unsigned int		max_bpp;
+
+	/*
+	 * These are the addresses we mapped
+	 * the framebuffer memory region to.
+	 */
+	dma_addr_t		map_dma;
+	unsigned char *		map_cpu;
+	unsigned int		map_size;
+
+	unsigned char *		screen_cpu;
+	dma_addr_t		screen_dma;
+	u32 *			palette_cpu;
+	dma_addr_t		palette_dma;
+	unsigned int		palette_size;
+
+	unsigned int		cmap_inverse:1,
+				cmap_static:1,
+				unused:30;
+
+	unsigned long		time0;
+	unsigned long		time1;
+	unsigned long		time2;
+	unsigned long		control;
+	unsigned long		int_mask;
+	unsigned long		io_base;
+
+	unsigned int		state;
+	unsigned int		task_state;
+	struct semaphore	ctrlr_sem;
+	wait_queue_head_t	ctrlr_wait;
+	struct work_struct	task;
+
+	unsigned long		smode;
+	unsigned long		frame420_size;
+};
+
+/*
+ * These are the actions for set_ctrlr_state
+ */
+#define C_DISABLE		0
+#define C_ENABLE		1
+#define C_DISABLE_CLKCHANGE	2
+#define C_ENABLE_CLKCHANGE	3
+#define C_REENABLE		4
+#define C_DISABLE_PM		5
+#define C_ENABLE_PM		6
+#define C_STARTUP		7
+
+#define FARADAY_LCDTIME0_GET_HBP(x) ((((x) >> 24) & 0xFF) + 1)
+#define FARADAY_LCDTIME0_GET_HFP(x) ((((x) >> 16) & 0xFF) + 1)
+#define FARADAY_LCDTIME0_GET_HW(x)  ((((x) >>  8) & 0xFF) + 1)
+#define FARADAY_LCDTIME1_GET_VBP(x) ((((x) >> 24) & 0xFF)    )
+#define FARADAY_LCDTIME1_GET_VFP(x) ((((x) >> 16) & 0xFF)    )
+#define FARADAY_LCDTIME1_GET_VW(x)  ((((x) >>  8) & 0xFF) + 1)
+
+#define FARADAY_LCDTIME0_HBP(x)     ((((x) - 1) & 0xFF) << 24)
+#define FARADAY_LCDTIME0_HFP(x)     ((((x) - 1) & 0xFF) << 16)
+#define FARADAY_LCDTIME0_HW(x)      ((((x) - 1) & 0xFF) <<  8)
+#define FARADAY_LCDTIME0_PL(x)      (((((x) >> 4) - 1) & 0x3F) <<  2)
+#define FARADAY_LCDTIME1_VBP(x)     ((((x)    ) & 0xFF) << 24)
+#define FARADAY_LCDTIME1_VFP(x)     ((((x)    ) & 0xFF) << 16)
+#define FARADAY_LCDTIME1_VW(x)      ((((x) - 1) & 0xFF) <<  8)
+#define FARADAY_LCDTIME1_LF(x)      ((((x) - 1) & 0x3FF)     )
+
+#define FFB_MODE_RGB	0x00000001
+#define FFB_MODE_YUV420	0x00000002
+#define FFB_MODE_YUV422	0x00000004
+
+#define FFB_MODE_8BPP	0x00000100
+#define FFB_MODE_16BPP	0x00000200
+#define FFB_MODE_24BPP	0x00000400
+
+/* Minimum X and Y resolutions */
+#define MIN_XRES	64
+#define MIN_YRES	64
+
+typedef struct LCDTag {
+
+	u32 Timing0;			/* 0x00        */
+	u32 Timing1;			/* 0x04        */
+	u32 Timing2;			/* 0x08        */
+	u32 Timing3;			/* 0x0C        */
+	u32 UPBase;			/* 0x10        */
+	u32 LPBase;			/* 0x14        */
+	u32 INTREnable;			/* 0x18        */
+	u32 Control;			/* 0x1C        */
+	u32 Status;			/* 0x20        */
+	u32 Interrupt;			/* 0x24        */
+	u32 UPCurr;			/* 0x28        */
+	u32 LPCurr;			/* 0x2C        */
+	u32 Reserved1[5];		/* 0x30~0x40   */
+	u32 GPIO;			/* 0x44        */
+	u32 Reserved2[0x74 - 6];	/* 0x48~0x1FC  */
+
+	u32 Palette[0x80];		/* 0x200~0x3FC */
+	u32 TestReg[0x100];		/* 0x400~0x7FC */
+
+} LCD_Register;
+
+#endif /* __FARADAYFB_H */
+
diff --git a/drivers/video/fbdev/FTLCDC100/lcd-info.c b/drivers/video/fbdev/FTLCDC100/lcd-info.c
new file mode 100644
index 00000000..501bdbc1
--- /dev/null
+++ b/drivers/video/fbdev/FTLCDC100/lcd-info.c
@@ -0,0 +1,264 @@
+/*
+ * HBP : Horizontal Back Porch
+ * HFP : Horizontal Front Porch
+ * HSPW: Horizontal Sync. Pulse Width
+ * PPL : Pixels-per-line = 16(PPL+1)
+ */
+#define ENC_PARAM_TIME0(HBP, HFP, HSPW, PPL)	\
+	((((HBP)         - 1) << 24) |		\
+	 (((HFP)         - 1) << 16) |		\
+	 (((HSPW)        - 1) << 8 ) |		\
+	 ((((PPL) >> 4) - 1) << 2 ))
+
+/*
+ * HBP : Vertical Back Porch
+ * HFP : Vertical Front Porch
+ * HSPW: Vertical Sync. Pulse Width
+ * LPP : Lines-per-panel = LPP + 1
+ */
+#define ENC_PARAM_TIME1(VBP, VFP, VSPW, LPP)	\
+	((((VBP)     ) << 24) |			\
+	 (((VFP)     ) << 16) |			\
+	 (((VSPW) - 1) << 10) |			\
+	 (((LPP)  - 1) ))
+
+/*
+ * PRA : Pixel Rate Adaptive
+ * IOE : Invert Panel Output Enable
+ * IPC : Invert Panel Clock (Test Chip Testing)
+ * IHS : Invert Horisontal Sync.
+ * IVS : Invert Versical Sync.
+ * PCD : Panel Clock Divisor
+ */
+#define ENC_PARAM_TIME2(PRA, IOE, IPC, IHS, IVS, PCD)	\
+	(((PRA)     << 15) |				\
+	 ((IOE)     << 14) |				\
+	 ((IPC)     << 13) |				\
+	 ((IHS)     << 12) |				\
+	 ((IVS)     << 11) |				\
+	 (((PCD) - 1) ))
+
+/*
+ * Enable YCbCr
+ * Enable YCbCr420
+ * FIFO threadhold
+ * Panel type, 0-6bit, 1-8bit
+ * LcdVComp, when to generate interrupt, 1: start of back_porch
+ * Power Enable
+ * Big Endian Pixel/Byte Ordering
+ * BGR
+ * TFT
+ * LCD bits per pixel
+ * Controller Enable
+ */
+
+#define ENC_PARAM_CTRL(ENYUV, ENYUV420, FIFOTH, PTYPE, VCOMP, LCD_ON, ENDIAN, BGR, TFT, BPP, LCD_EN) \
+	((ENYUV        << 18) |			\
+	 (ENYUV420     << 17) |			\
+	 (FIFOTH       << 16) |			\
+	 (PTYPE        << 15) |			\
+	 (VCOMP        << 12) |			\
+	 (LCD_ON       << 11) |			\
+	 (ENDIAN       <<  9) |			\
+	 (BGR          <<  8) |			\
+	 (TFT          <<  5) |			\
+	 (BPP          <<  1) |			\
+	 (LCD_EN))
+
+static struct lcd_param control[] = {
+
+	{
+		.value = ENC_PARAM_CTRL(0, 0, 1, 1, 0x3, 1, 0x0, 1, 1, 0x3, 1),
+		.flags = FFB_MODE_RGB | FFB_MODE_8BPP,
+	},
+	{
+		.value = ENC_PARAM_CTRL(1, 1, 1, 1, 0x3, 1, 0x0, 0, 1, 0x3, 1),
+		.flags = FFB_MODE_YUV420 | FFB_MODE_8BPP,
+	},
+	{
+		.value = ENC_PARAM_CTRL(1, 0, 1, 1, 0x3, 1, 0x0, 0, 1, 0x4, 1),
+		.flags = FFB_MODE_YUV422 | FFB_MODE_16BPP,
+	},
+	{
+		.value = ENC_PARAM_CTRL(0, 0, 1, 1, 0x3, 1, 0x0, 1, 1, 0x4, 1),
+		.flags = FFB_MODE_RGB | FFB_MODE_16BPP,
+	},
+	{
+		.value = ENC_PARAM_CTRL(0, 0, 1, 1, 0x3, 1, 0x0, 1, 1, 0x5, 1),
+		.flags = FFB_MODE_RGB | FFB_MODE_24BPP,
+	},
+};
+
+#ifdef CONFIG_PANEL_AUA036QN01
+
+static struct lcd_param time0[] = {
+
+	{
+		.value = ENC_PARAM_TIME0(7, 6, 1, 320),
+		.flags = FFB_MODE_RGB | FFB_MODE_YUV420 | FFB_MODE_YUV422,
+	},
+};
+
+static struct lcd_param time1[] = {
+
+	{
+		.value = ENC_PARAM_TIME1(1, 1, 1, 240),
+		.flags = FFB_MODE_RGB | FFB_MODE_YUV420 | FFB_MODE_YUV422,
+	},
+};
+
+static struct lcd_param time2[] = {
+
+	{
+		.value = ENC_PARAM_TIME2(0, 0, 1, 1, 1, 0x7),
+		.flags = FFB_MODE_RGB | FFB_MODE_YUV420 | FFB_MODE_YUV422,
+	},
+};
+
+static struct faradayfb_mach_info ffb_mach_info = {
+
+	.pixclock      = 171521,
+	.xres          = 320,
+	.yres          = 240,
+	.max_bpp       = 24,
+	.sync          = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	.num_time0     = ARRAY_SIZE(time0),
+	.time0         = time0,
+	.num_time1     = ARRAY_SIZE(time1),
+	.time1         = time1,
+	.num_time2     = ARRAY_SIZE(time2),
+	.time2         = time2,
+	.num_control   = ARRAY_SIZE(control),
+	.control       = control,
+};
+#endif
+
+#ifdef CONFIG_PANEL_AUA070VW04
+static struct lcd_param time0[] = {
+
+	{
+		.value = ENC_PARAM_TIME0(88, 40, 128, 800),
+		.flags = FFB_MODE_RGB | FFB_MODE_YUV420 | FFB_MODE_YUV422,
+	},
+};
+
+static struct lcd_param time1[] = {
+
+	{
+		.value = ENC_PARAM_TIME1(21, 1, 3, 480),
+		.flags = FFB_MODE_RGB | FFB_MODE_YUV420 | FFB_MODE_YUV422,
+	},
+};
+
+static struct lcd_param time2[] = {
+
+	{
+		.value = ENC_PARAM_TIME2(0, 1, 1, 1, 1, 0x5),
+		.flags = FFB_MODE_RGB | FFB_MODE_YUV420 | FFB_MODE_YUV422,
+	},
+};
+
+static struct faradayfb_mach_info ffb_mach_info = {
+
+	.pixclock      = 171521,
+	.xres          = 800,
+	.yres          = 480,
+	.max_bpp       = 24,
+	.sync          = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	.num_time0     = ARRAY_SIZE(time0),
+	.time0         = time0,
+	.num_time1     = ARRAY_SIZE(time1),
+	.time1         = time1,
+	.num_time2     = ARRAY_SIZE(time2),
+	.time2         = time2,
+	.num_control   = ARRAY_SIZE(control),
+	.control       = control,
+};
+
+#endif
+
+#ifdef CONFIG_PANEL_LW500AC9601
+static struct lcd_param time0[] = {
+
+        {
+                .value = ENC_PARAM_TIME0(88, 40, 128, 800),
+                .flags = FFB_MODE_RGB | FFB_MODE_YUV420 | FFB_MODE_YUV422,
+        },
+};
+
+static struct lcd_param time1[] = {
+
+        {
+                .value = ENC_PARAM_TIME1(21, 1, 3, 480),
+                .flags = FFB_MODE_RGB | FFB_MODE_YUV420 | FFB_MODE_YUV422,
+        },
+};
+
+static struct lcd_param time2[] = {
+
+        {
+                .value = ENC_PARAM_TIME2( 0, 0, 1, 1, 1, 0x3),
+                .flags = FFB_MODE_RGB | FFB_MODE_YUV420 | FFB_MODE_YUV422,
+        },
+};
+
+static struct faradayfb_mach_info ffb_mach_info = {
+
+        .pixclock      = 171521,
+        .xres          = 800,
+        .yres          = 480,
+        .max_bpp       = 24,
+        .sync          = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+        .num_time0     = ARRAY_SIZE(time0),
+        .time0         = time0,
+        .num_time1     = ARRAY_SIZE(time1),
+        .time1         = time1,
+        .num_time2     = ARRAY_SIZE(time2),
+        .time2         = time2,
+        .num_control   = ARRAY_SIZE(control),
+        .control       = control,
+};
+#endif
+
+#ifdef CONFIG_CH7013A
+static struct lcd_param time0[] = {
+
+	{
+		.value = ENC_PARAM_TIME0(42, 10, 96, 640),
+		.flags = FFB_MODE_RGB,
+	},
+};
+
+static struct lcd_param time1[] = {
+
+	{
+		.value = ENC_PARAM_TIME1(28, 5, 2, 480),
+		.flags = FFB_MODE_RGB,
+	},
+};
+static struct lcd_param time2[] = {
+
+	{
+		.value = ENC_PARAM_TIME2(0, 1, 1, 0, 0, 0x3),
+		.flags = FFB_MODE_RGB,
+	},
+};
+
+static struct faradayfb_mach_info ffb_mach_info = {
+
+	.pixclock      = 37910,
+	.xres          = 640,
+	.yres          = 480,
+	.max_bpp       = 24,
+	.sync          = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	.num_time0     = ARRAY_SIZE(time0),
+	.time0         = time0,
+	.num_time1     = ARRAY_SIZE(time1),
+	.time1         = time1,
+	.num_time2     = ARRAY_SIZE(time2),
+	.time2         = time2,
+	.num_control   = ARRAY_SIZE(control),
+	.control       = control,
+};
+
+#endif /* CONFIG_CH7013A */
diff --git a/drivers/video/fbdev/FTLCDC100/pingpong-module.c b/drivers/video/fbdev/FTLCDC100/pingpong-module.c
new file mode 100644
index 00000000..8314f47f
--- /dev/null
+++ b/drivers/video/fbdev/FTLCDC100/pingpong-module.c
@@ -0,0 +1,603 @@
+#include <linux/io.h>
+
+void *fmem_alloc(size_t size, dma_addr_t *dma_handle, bool has_dma_coherent)
+{
+	struct page *page;
+	void *cpu_addr = NULL;
+	size = PAGE_ALIGN(size);
+
+	if (!(page = alloc_pages(GFP_DMA, get_order(size)))) {
+		goto no_page;
+	}
+	*dma_handle = page_to_phys(page);
+
+	if(!has_dma_coherent){
+		cpu_addr = ioremap_nocache(*dma_handle, size);
+	}else{
+		cpu_addr = ioremap(*dma_handle, size);
+	}
+
+	if (cpu_addr) {
+		do {
+			SetPageReserved(page);
+			page++;
+		} while (size -= PAGE_SIZE);
+	}
+	else {
+		__free_pages(page, get_order(size));
+	}
+no_page:
+	return cpu_addr;
+}
+
+void fmem_free(size_t size, void *cpu_addr, dma_addr_t handle)
+{
+	struct page *page = pfn_to_page(handle >> PAGE_SHIFT);
+
+	iounmap(cpu_addr);
+	size = PAGE_ALIGN(size);
+
+	do {
+		ClearPageReserved(page);
+		__free_page(page);
+		page++;
+
+	} while (size -= PAGE_SIZE);
+}
+
+static int faradayfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	struct faradayfb_info *fbi = info->par;
+	unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
+	int ret = -EINVAL;
+
+	DEBUG(0, 1, "Enter\n");
+
+	if (off < info->fix.smem_len) {
+
+		off += fbi->screen_dma & PAGE_MASK;
+		vma->vm_pgoff = off >> PAGE_SHIFT;
+		if(!info->device->archdata.dma_coherent){
+			vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+		}
+		ret = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+				vma->vm_end - vma->vm_start, vma->vm_page_prot);
+	}
+	else {
+		DEBUG(1, 1, "buffer mapping error !!\n");
+	}
+
+	DEBUG(0, 1, "Leave\n");
+
+	return ret;
+}
+
+/*
+ * Allocates the DRAM memory for the frame buffer.  This buffer is
+ * remapped into a non-cached, non-buffered, memory region to
+ * allow palette and pixel writes to occur without flushing the
+ * cache.  Once this area is remapped, all virtual memory
+ * access to the video memory should occur at the new region.
+ */
+static int __init faradayfb_map_video_memory(struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+
+	bool dma_coherent = info->device->archdata.dma_coherent;
+
+	fbi->map_size = PAGE_ALIGN(info->fix.smem_len);
+	fbi->map_cpu = fmem_alloc(fbi->map_size, &fbi->map_dma, dma_coherent);
+
+	if (fbi->map_cpu) {
+
+		memset(fbi->map_cpu, 0x1d, fbi->map_size);
+		info->screen_base = fbi->map_cpu + PAGE_SIZE;
+		fbi->screen_dma = fbi->map_dma + PAGE_SIZE;
+		info->fix.smem_start = fbi->screen_dma;
+	}
+
+	return fbi->map_cpu ? 0 : -ENOMEM;
+}
+
+static inline void faradayfb_clean_screen(struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+	int size = info->var.xres * info->var.yres;
+
+	if (fbi->smode & FFB_MODE_YUV422) {
+
+		memset(fbi->map_cpu, 16, size * info->var.bits_per_pixel / 8);
+	}
+	else if (fbi->smode & FFB_MODE_YUV420) {
+
+		memset(fbi->map_cpu, 16, size);
+		memset(fbi->map_cpu + PAGE_SIZE + ((size + 0xffff) & 0xffff0000), 128, size / 4);
+		memset(fbi->map_cpu + PAGE_SIZE + ((size + 0xffff) & 0xffff0000) * 5 / 4, 128, size / 4);
+	}
+}
+
+static inline void faradayfb_unmap_video_memory(struct fb_info *info)
+{
+	struct faradayfb_info *fbi = info->par;
+	fmem_free(fbi->map_size, fbi->map_cpu, fbi->map_dma);
+}
+
+#define FRAME_SIZE_RGB(xres, yres, mbpp)	((xres) * (yres) * (mbpp) / 8)
+#define FRAME_SIZE_YUV422(xres, yres, mbpp)	(((xres) * (yres) * (mbpp) / 8) * 2)
+#define FRAME_SIZE_YUV420(xres, yres, mbpp)	(((((xres) * (yres) * (mbpp) / 8) + 0xffff) & 0xffff0000) * 3 / 2)
+
+unsigned int nextPowerOf2(unsigned int n)
+{
+    n--;
+    n |= n >> 1;
+    n |= n >> 2;
+    n |= n >> 4;
+    n |= n >> 8;
+    n |= n >> 16;
+    n++;
+    return n;
+}
+
+static inline u32 faradayfb_cal_frame_buf_size(struct faradayfb_info *fbi)
+{
+	u32 size_rgb	= FRAME_SIZE_RGB(fbi->xres, fbi->yres, fbi->max_bpp);
+	u32 size_yuv422	= FRAME_SIZE_YUV422(fbi->xres, fbi->yres, 8);
+	u32 size_yuv420	= FRAME_SIZE_YUV420(fbi->xres, fbi->yres, 8);
+
+	// PMA needs to allocate power of 2 memory size
+	return nextPowerOf2(max(size_rgb, max(size_yuv422, size_yuv420)));
+}
+
+#ifdef CONFIG_FTLCD_OSD
+/************************************
+ *	OSD
+ ***********************************/
+#define FOSD_SETPOS		0x46e1
+#define FOSD_SETDIM		0x46e2
+#define FOSD_SETSCAL		0x46e3
+#define FLCD_SET_TRANSPARENT	0x46e4
+#define FLCD_SET_STRING		0x46e5
+#define FOSD_ON			0x46e6
+#define FOSD_OFF		0x46e7
+#define FRREG			0x46e8
+#define FWREG			0x46e9
+
+#define dig_alpha	(16 * 10) + (16 * 26) + (16 * 3)
+
+struct fosd_string {
+
+	unsigned int Str_row;
+	unsigned int display_mode;
+	unsigned int fg_color;
+	unsigned int bg_color;
+	unsigned char Str_OSD[30];
+};
+
+struct fosd_data {
+
+	unsigned int HPos;
+	unsigned int VPos;
+	unsigned int HDim;
+	unsigned int VDim;
+	unsigned int transparent_level;
+	unsigned int HScal;
+	unsigned int VScal;
+	struct fosd_string Str_Data[10];
+};
+
+unsigned int OSD_Font[] = {
+
+	/*	0	*/
+	0x00, 0x00, 0x00, 0x3e, 0x63, 0x67, 0x6f, 0x7b,
+	0x73, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00, 0x00,
+
+	/*	1	*/
+	0x00, 0x00, 0x00, 0x0c, 0x1c, 0x3c, 0x0c, 0x0c,
+	0x0c, 0x0c, 0x0c, 0x3f, 0x00, 0x00, 0x00, 0x00,
+
+	/*	2	*/
+	0x00, 0x00, 0x00, 0x3e, 0x63, 0x03, 0x06, 0x0c,
+	0x18, 0x30, 0x63, 0x7f, 0x00, 0x00, 0x00, 0x00,
+
+	/*	3	*/
+	0x00, 0x00, 0x00, 0x3E, 0x63, 0x03, 0x03, 0x1e,
+	0x03, 0x03, 0x63, 0x3E, 0x00, 0x00, 0x00, 0x00,
+
+	/*	4	*/
+	0x00, 0x00, 0x00, 0x06, 0x0e, 0x1e, 0x36, 0x66,
+	0x7f, 0x06, 0x06, 0x0f, 0x00, 0x00, 0x00, 0x00,
+
+	/*	5	*/
+	0x00, 0x00, 0x00, 0x7f, 0x60, 0x60, 0x60, 0x7e,
+	0x03, 0x03, 0x63, 0x3e, 0x00, 0x00, 0x00, 0x00,
+
+	/*	6	*/
+	0x00, 0x00, 0x00, 0x1c, 0x30, 0x60, 0x60, 0x7e,
+	0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00, 0x00,
+
+	/*	7	*/
+	0x00, 0x00, 0x00, 0x7f, 0x63, 0x03, 0x06, 0x0c,
+	0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
+
+	/*	8	*/
+	0x00, 0x00, 0x00, 0x3e, 0x63, 0x63, 0x63, 0x3e,
+	0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00, 0x00,
+
+	/*	9	*/
+	0x00, 0x00, 0x00, 0x3e, 0x63, 0x63, 0x63, 0x3f,
+	0x03, 0x03, 0x06, 0x3c, 0x00, 0x00, 0x00, 0x00,
+
+	/*	A	*/
+	0x00, 0x00, 0x00, 0x08, 0x1c, 0x36, 0x63, 0x63,
+	0x7f, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00,
+
+	/*	B	*/
+	0x00, 0x00, 0x00, 0x7E, 0x33, 0x33, 0x33, 0x3E,
+	0x33, 0x33, 0x33, 0x7E, 0x00, 0x00, 0x00, 0x00,
+
+	/*	C	*/
+	0x00, 0x00, 0x00, 0x1E, 0x33, 0x61, 0x60, 0x60,
+	0x60, 0x61, 0x33, 0x1E, 0x00, 0x00, 0x00, 0x00,
+
+	/*	D	*/
+	0x00, 0x00, 0x00, 0x7c, 0x36, 0x33, 0x33, 0x33,
+	0x33, 0x33, 0x36, 0x7C, 0x00, 0x00, 0x00, 0x00,
+
+	/*	E	*/
+	0x00, 0x00, 0x00, 0x7f, 0x33, 0x31, 0x34, 0x3c,
+	0x34, 0x31, 0x33, 0x7f, 0x00, 0x00, 0x00, 0x00,
+
+	/*	F	*/
+	0x00, 0x00, 0x00, 0x7f, 0x33, 0x31, 0x34, 0x3c,
+	0x34, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00,
+
+	/*	G	*/
+	0x00, 0x00, 0x00, 0x1E, 0x33, 0x61, 0x60, 0x60,
+	0x6F, 0x63, 0x36, 0x7C, 0x00, 0x00, 0x00, 0x00,
+
+	/*	H	*/
+	0x00, 0x00, 0x00, 0x63, 0x63, 0x63, 0x64, 0x7f,
+	0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00,
+
+	/*	I	*/
+	0x00, 0x00, 0x00, 0x3c, 0x18, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
+
+	/*	J	*/
+	0x00, 0x00, 0x00, 0x0f, 0x06, 0x06, 0x06, 0x06,
+	0x06, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00,
+
+	/*	K	*/
+	0x00, 0x00, 0x00, 0x73, 0x33, 0x36, 0x36, 0x3c,
+	0x36, 0x36, 0x33, 0x73, 0x00, 0x00, 0x00, 0x00,
+
+	/*	L	*/
+	0x00, 0x00, 0x00, 0x78, 0x30, 0x30, 0x30, 0x30,
+	0x30, 0x31, 0x33, 0x7f, 0x00, 0x00, 0x00, 0x00,
+
+	/*	M	*/
+	0x00, 0x00, 0x00, 0x63, 0x77, 0x7f, 0x6b, 0x63,
+	0x63, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00,
+
+	/*	N	*/
+	0x00, 0x00, 0x00, 0x63, 0x73, 0x7b, 0x7f, 0x6f,
+	0x67, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00,
+
+	/*	O	*/
+	0x00, 0x00, 0x00, 0x1c, 0x36, 0x63, 0x63, 0x63,
+	0x63, 0x63, 0x36, 0x1c, 0x00, 0x00, 0x00, 0x00,
+
+	/*	P	*/
+	0x00, 0x00, 0x00, 0x7e, 0x33, 0x33, 0x33, 0x3e,
+	0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00,
+
+	/*	Q	*/
+	0x00, 0x00, 0x00, 0x3e, 0x63, 0x63, 0x63, 0x63,
+	0x6b, 0x6f, 0x3e, 0x06, 0x07, 0x00, 0x00, 0x00,
+
+	/*	R	*/
+	0x00, 0x00, 0x00, 0x7e, 0x33, 0x33, 0x33, 0x3e,
+	0x36, 0x33, 0x33, 0x73, 0x00, 0x00, 0x00, 0x00,
+
+	/*	S	*/
+	0x00, 0x00, 0x00, 0x3e, 0x63, 0x63, 0x30, 0x1c,
+	0x06, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00, 0x00,
+
+	/*	T	*/
+	0x00, 0x00, 0x00, 0xFF, 0x99, 0x18, 0x18, 0x18,
+	0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
+
+	/*	U	*/
+	0x00, 0x00, 0x00, 0x63, 0x63, 0x63, 0x63, 0x63,
+	0x63, 0x63, 0x63, 0x3e, 0x00, 0x00, 0x00, 0x00,
+
+	/*	V	*/
+	0x00, 0x00, 0x00, 0x63, 0x63, 0x63, 0x63, 0x63,
+	0x63, 0x36, 0x1c, 0x08, 0x00, 0x00, 0x00, 0x00,
+
+	/*	W	*/
+	0x00, 0x00, 0x00, 0x63, 0x63, 0x63, 0x63, 0x63,
+	0x6b, 0x7f, 0x77, 0x63, 0x00, 0x00, 0x00, 0x00,
+
+	/*	X	*/
+	0x00, 0x00, 0x00, 0x63, 0x63, 0x63, 0x36, 0x1c,
+	0x36, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00,
+
+	/*	Y	*/
+	0x00, 0x00, 0x00, 0x63, 0x63, 0x63, 0x36, 0x1c,
+	0x1c, 0x1c, 0x1c, 0x3e, 0x00, 0x00, 0x00, 0x00,
+
+	/*	Z	*/
+	0x00, 0x00, 0x00, 0x7f, 0x63, 0x46, 0x0c, 0x18,
+	0x30, 0x61, 0x63, 0x7f, 0x00, 0x00, 0x00, 0x00,
+
+	/*	space	*/
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	/*	 = 	*/
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00,
+	0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+	/*	 , 	*/
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
+};
+
+void OSD_On(struct faradayfb_info *fbi)
+{
+	REG32(fbi->io_base + 0x34) &= 0xfffffffe;
+	REG32(fbi->io_base + 0x34) |= 1;
+}
+
+void OSD_Off(struct faradayfb_info *fbi)
+{
+	REG32(fbi->io_base + 0x34) &= 0xfffffffe;
+}
+
+void OSD_Pos(struct faradayfb_info *fbi, int HPos, int VPos)
+{
+	REG32(fbi->io_base + 0x38) = (HPos << 10) | VPos;
+}
+
+void OSD_Dim(struct faradayfb_info *fbi, int HDim, int VDim)
+{
+	REG32(fbi->io_base + 0x34) &= 0x0000001f;
+	REG32(fbi->io_base + 0x34) |= ((HDim << 10) | (VDim << 5));
+}
+
+void OSD_transparent(struct faradayfb_info *fbi, int level)
+{
+	REG32(fbi->io_base + 0x40) &= 0xffffff00;
+	REG32(fbi->io_base + 0x40) |= (level << 6);
+}
+
+void OSD_fg_color(struct faradayfb_info *fbi, int pal0, int pal1, int pal2, int pal3)
+{
+	REG32(fbi->io_base + 0x3c) = (pal0) | (pal1 << 8) | (pal2 << 16) | (pal3<< 24);
+}
+
+void OSD_bg_color(struct faradayfb_info *fbi, int pal1, int pal2, int pal3)
+{
+	REG32(fbi->io_base + 0x40) &= 0x000000ff;
+	REG32(fbi->io_base + 0x40) |= (pal1 << 8) | (pal2 << 16) | (pal3 << 24);
+}
+
+void OSD_Scal(struct faradayfb_info *fbi, int HScal, int VScal)
+{
+	REG32(fbi->io_base + 0x34) &= 0xffffffe1;
+	REG32(fbi->io_base + 0x34) |= (HScal << 3) | (VScal << 1);
+}
+
+void OSD_putc(struct faradayfb_info *fbi, char c, int position, unsigned int value)
+{
+	if (c >= '0' && c <= '9')
+		REG32(fbi->io_base + 0xc000 + position * 4) = ((c -'0') << 4) | value;
+
+	else if (c>= 'A' && c <= 'Z')
+		REG32(fbi->io_base + 0xc000 + position * 4) = ((c - 'A' + 10) << 4) | value;
+
+	if (c == ' ')
+		REG32(fbi->io_base + 0xc000 + position * 4) = (('Z' - 'A' + 10 + 1) << 4) | value;
+
+	if (c == '=')
+		REG32(fbi->io_base + 0xc000 + position * 4) = (('Z' - 'A' + 10 + 2) << 4) | value;
+
+	if (c == ',')
+		REG32(fbi->io_base + 0xc000 + position * 4) = (('Z' - 'A' + 10 + 3) << 4) | value;
+}
+
+void OSD_puts(struct faradayfb_info *fbi, char *str, int position, unsigned int value)
+{
+	int i;
+
+	for (i = 0; i < strlen(str); i++)
+		OSD_putc(fbi, *(str + i), position + i, value);
+}
+
+void OSD_String(struct faradayfb_info *fbi, int row, int mode, char *str, int fg_color, int bg_color)
+{
+	int i, j, x, y;
+	unsigned int value = fg_color | bg_color;
+
+	/* 10 digit & 26 alphabet & ' ' & '=' & ',' */
+	for (i = 0; i < dig_alpha; i++) {
+
+		x = 0;
+		y = OSD_Font[i];
+
+		for (j = 0; j < 12; j ++) { /* reorder */
+			if (y & 1)
+				x |= 1;
+			y >>= 1;
+			x <<= 1;
+		}
+
+		x >>= 1;
+		REG32(fbi->io_base + 0x8000 + i * 4) = x;
+	}
+
+	OSD_puts(fbi, str, row, value);
+
+	if (mode == 2) { /* YCbCr */
+
+		OSD_fg_color(fbi, 0x57, 0x88, 0x3B, 0xFF);
+		OSD_bg_color(fbi, 0x57, 0x88, 0x3B);
+	}
+	else {
+		OSD_fg_color(fbi, 0x07, 0x38, 0xC0, 0xFF);
+		OSD_bg_color(fbi, 0x07, 0x38, 0xc0);
+	}
+}
+#endif	/* CONFIG_FTLCD_OSD */
+
+struct andesIO {
+
+	unsigned long Regaddr;
+	unsigned long Regoffset;
+	unsigned long Regvalue;
+};
+
+static int faradayfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+#ifdef CONFIG_FTLCD_OSD
+	struct faradayfb_info	*fbi = info->par;
+	int			i;
+	struct fosd_data	fosd;
+
+	struct andesIO		IOAccess;
+	unsigned long			*Regaccess;
+#endif
+
+	DEBUG(0, 1, "Enter\n");
+
+	switch (cmd) {
+#ifdef CONFIG_FTLCD_OSD
+		case FRREG:
+
+			if (copy_from_user(&IOAccess, (struct andesIO *)arg, sizeof(struct andesIO))) {
+
+				ret = -EFAULT;
+				break;
+			}
+
+			Regaccess = (unsigned long *)(((IOAccess.Regaddr >> 4) | (unsigned long)0xF0000000) + IOAccess.Regoffset);
+
+			IOAccess.Regvalue = *(Regaccess);
+
+			if (copy_to_user((struct andesIO *)arg, &IOAccess, sizeof(struct andesIO))) {
+				ret = -EFAULT;
+				break;
+			}
+
+			break;
+
+		case FWREG:
+
+			if (copy_from_user(&IOAccess, (struct andesIO *)arg, sizeof(struct andesIO))) {
+				ret = -EFAULT;
+				break;
+			}
+
+			Regaccess = (unsigned long *)(((IOAccess.Regaddr >> 4) | (unsigned long)0xF0000000) + IOAccess.Regoffset);
+			*(Regaccess) = IOAccess.Regvalue;
+
+			break;
+
+		case FOSD_ON:
+
+			DEBUG(1, 1, "FOSD_ON:\n");
+			OSD_On(fbi);
+			break;
+
+		case FOSD_OFF:
+
+			DEBUG(1, 1, "FOSD_OFF:\n");
+			OSD_Off(fbi);
+			break;
+
+		case FOSD_SETPOS:
+
+			DEBUG(1, 1, "FOSD_SETPOS:\n");
+
+			if (copy_from_user(&fosd, (unsigned int *)arg, 2 * sizeof(unsigned int))) {
+
+				ret = -EFAULT;
+				break;
+			}
+
+			OSD_Pos(fbi, fosd.HPos, fosd.VPos);
+			DEBUG(1, 1, "OSD_Pos = %d %d\n", fosd.HPos, fosd.VPos);
+			break;
+
+		case FOSD_SETDIM:
+
+			DEBUG(1, 1, "FOSD_SETDIM:\n");
+
+			if (copy_from_user(&fosd, (unsigned int *)arg, 4 * sizeof(unsigned int))) {
+
+				ret = -EFAULT;
+				break;
+			}
+
+			OSD_Dim(fbi, fosd.HDim, fosd.VDim);
+			DEBUG(1, 1, "OSD_Dim = %d %d\n", fosd.HDim, fosd.VDim);
+			break;
+
+		case FOSD_SETSCAL:
+
+			DEBUG(1, 1, "FOSD_SETSCAL:\n");
+
+			if (copy_from_user(&fosd, (unsigned int *)arg, 7 * sizeof(unsigned int))) {
+				ret = -EFAULT;
+				break;
+			}
+
+			OSD_Scal(fbi, fosd.HScal, fosd.VScal);
+			break;
+
+		case FLCD_SET_TRANSPARENT:
+
+			DEBUG(1, 1, "FLCD_SET_TRANSPARENT:\n");
+
+			if (copy_from_user(&fosd, (unsigned int *)arg, 5 * sizeof(unsigned int))) {
+
+				ret = -EFAULT;
+				break;
+			}
+
+			OSD_transparent(fbi, fosd.transparent_level);
+			DEBUG(1, 1, "OSD_transparent = %d\n", fosd.transparent_level);
+			break;
+
+		case FLCD_SET_STRING:
+
+			DEBUG(1, 1, "FLCD_SET_STRING:\n");
+
+			if (copy_from_user(&fosd, (unsigned int *)arg, sizeof(struct fosd_data))) {
+
+				ret = -EFAULT;
+				break;
+			}
+
+			for (i = 0; i < fosd.VDim; i++)
+
+				OSD_String(fbi, fosd.Str_Data[i].Str_row,
+						fosd.Str_Data[i].display_mode,
+						fosd.Str_Data[i].Str_OSD,
+						fosd.Str_Data[i].fg_color,
+						fosd.Str_Data[i].bg_color);
+			break;
+#endif 	/* CONFIG_FTLCD_OSD */
+
+		default:
+
+			DEBUG(1, 1, "IOCTL CMD(0x%08u) no define!\n", cmd);
+			ret = -EFAULT;
+			break;
+	}
+
+	DEBUG(0, 1, "Leave\n");
+	return ret;
+}
diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index d9425426..c2ae4d94 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -2029,6 +2029,8 @@ config FB_UDL
 	  mplayer -vo fbdev. Supports all USB 2.0 era DisplayLink devices.
 	  To compile as a module, choose M here: the module name is udlfb.
 
+source "drivers/video/fbdev/FTLCDC100/Kconfig"
+
 config FB_IBM_GXT4500
 	tristate "Framebuffer support for IBM GXT4000P/4500P/6000P/6500P adaptors"
 	depends on FB
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index 55282a21..2aa13bfd 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -123,6 +123,7 @@ obj-y                             += omap2/
 obj-$(CONFIG_XEN_FBDEV_FRONTEND)  += xen-fbfront.o
 obj-$(CONFIG_FB_CARMINE)          += carminefb.o
 obj-$(CONFIG_FB_MB862XX)	  += mb862xx/
+obj-$(CONFIG_FB_FTLCDC100)        += FTLCDC100/
 obj-$(CONFIG_FB_NUC900)           += nuc900fb.o
 obj-$(CONFIG_FB_JZ4740)		  += jz4740_fb.o
 obj-$(CONFIG_FB_PUV3_UNIGFX)      += fb-puv3.o
diff --git a/drivers/video/logo/.gitignore b/drivers/video/logo/.gitignore
deleted file mode 100644
index e48355f5..00000000
--- a/drivers/video/logo/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-#
-# Generated files
-#
-*_mono.c
-*_vga16.c
-*_clut224.c
-*_gray256.c
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 9af07fd9..b3cedb88 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -46,6 +46,12 @@ config WATCHDOG_NOWAYOUT
 	  get killed. If you say Y here, the watchdog cannot be stopped once
 	  it has been started.
 
+config WATCHDOG_DEBUG
+	bool "Hang in watch dog interrupt handler"
+	help
+	  When system failed, it will hang in watch dog interrupt handler for
+	  debugging.
+
 config WATCHDOG_HANDLE_BOOT_ENABLED
 	bool "Update boot-enabled watchdog until userspace takes over"
 	default y
@@ -342,6 +348,13 @@ config FTWDT010_WATCHDOG
 	  To compile this driver as a module, choose M here: the
 	  module will be called ftwdt010_wdt.
 
+config ATCWDT200_WATCHDOG
+	tristate "ATCWDT200_WATCHDOG"
+	depends on RISCV && PLAT_AE350
+	help
+	  Support for Andes aycwdt200 watchdog. When the watchdog triigers the
+	  system will be reset.
+
 config IXP4XX_WATCHDOG
 	tristate "IXP4xx Watchdog"
 	depends on ARCH_IXP4XX
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 1d3c6b09..48960262 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -47,6 +47,7 @@ obj-$(CONFIG_TWL4030_WATCHDOG) += twl4030_wdt.o
 obj-$(CONFIG_21285_WATCHDOG) += wdt285.o
 obj-$(CONFIG_977_WATCHDOG) += wdt977.o
 obj-$(CONFIG_FTWDT010_WATCHDOG) += ftwdt010_wdt.o
+obj-$(CONFIG_ATCWDT200_WATCHDOG) += atcwdt200_wdt.o
 obj-$(CONFIG_IXP4XX_WATCHDOG) += ixp4xx_wdt.o
 obj-$(CONFIG_KS8695_WATCHDOG) += ks8695_wdt.o
 obj-$(CONFIG_S3C2410_WATCHDOG) += s3c2410_wdt.o
diff --git a/drivers/watchdog/atcwdt200_wdt.c b/drivers/watchdog/atcwdt200_wdt.c
new file mode 100644
index 00000000..2064d96b
--- /dev/null
+++ b/drivers/watchdog/atcwdt200_wdt.c
@@ -0,0 +1,310 @@
+/*
+ *  Watchdog driver for the ATCWDT200 Watch Dog Driver
+ *
+ *      (c) Copyright 2016 Andes Technology Corp. (www.andestech.com)
+ *      Based on sa1100_wdt.c by Oleg Drokin <green@crimea.edu>
+ *      Based on SoftDog driver by Alan Cox <alan@redhat.com>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ *
+ *      11/07/2016 Initial release
+ */
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <linux/reboot.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/reboot.h>
+#include <linux/uaccess.h>
+#include <linux/cpumask.h>
+#include <asm/processor.h>
+#include <asm/sbi.h>
+#include <asm/andesv5/smu.h>
+
+#define DRIVER_NAME	"atcwdt200"
+#define DEBUG( str, ...)			\
+	do{					\
+		if( debug)			\
+		printk( str, ##__VA_ARGS__);	\
+	} while(0)
+/* ID and Revision Register */
+#define idrev		(*( volatile unsigned int *)( wdt_base + 0x00))
+#define ID_OFF		12
+#define ID_MSK		(0xfffff<<ID_OFF)
+#define ID		(0x03002<<ID_OFF)
+
+/* Control Register */
+#define ctrl		(*( volatile unsigned int *)( wdt_base + 0x10))
+#define RST_TIME_OFF	8
+#define RST_TIME_MSK	(0x3<<RST_TIME_OFF)
+#define RST_CLK_128	(0<<RST_TIME_OFF)
+#define RST_CLK_256	(1<<RST_TIME_OFF)
+#define RST_CLK_512	(2<<RST_TIME_OFF)
+#define RST_CLK_1024	(3<<RST_TIME_OFF)
+#define INT_TIME_OFF	4
+#define INT_TIME_MSK	(0xf<<INT_TIME_OFF)
+#define INT_CLK_64	(0<<INT_TIME_OFF)
+#define INT_CLK_256	(1<<INT_TIME_OFF)
+#define INT_CLK_1024	(2<<INT_TIME_OFF)
+#define INT_CLK_2048	(3<<INT_TIME_OFF)
+#define INT_CLK_4096	(4<<INT_TIME_OFF)
+#define INT_CLK_8192	(5<<INT_TIME_OFF)
+#define INT_CLK_16384	(6<<INT_TIME_OFF)
+#define INT_CLK_32768	(7<<INT_TIME_OFF)
+#define RST_EN		(1<<3)
+#define INT_EN		(1<<2)
+#define CLK_PCLK	(1<<1)
+#define WDT_EN		(1<<0)
+
+/* Restart Register */
+#define restart		(*( volatile unsigned int *)( wdt_base + 0x14))
+#define RESTART_MAGIC	0xcafe
+
+/* Write Enable Register */
+#define wren		(*( volatile unsigned int *)( wdt_base + 0x18))
+#define WP_MAGIC	0x5aa5
+
+/* Status Register */
+#define st		(*( volatile unsigned int *)( wdt_base + 0x1c))
+#define INT_EXPIRED	(1<<0)
+
+#define TIMER_MARGIN	60	/* (secs) Default is 1 minute */
+
+static int expect_close = 0;
+static int debug = 0;
+static int timeout = TIMER_MARGIN;  /* in seconds */
+static bool nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, bool, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started "
+	"(default=" __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+static int wdt_panic = 0;
+module_param(wdt_panic, int, 0);
+MODULE_PARM_DESC(wdt_panic,
+	"Watchdog action, set to 1 to panic, 0 to reboot (default=0)");
+
+module_param(debug, int, 0);
+module_param(timeout, int, 0);
+static u32 wdt_freq;
+static void __iomem *wdt_base;
+
+// enable the WDT
+void wdt_start(void)
+{
+#ifdef CONFIG_WATCHDOG_DEBUG
+	wren = WP_MAGIC;
+	ctrl = (INT_CLK_32768|INT_EN|WDT_EN);
+#else
+	wren = WP_MAGIC;
+	ctrl = (INT_CLK_32768|INT_EN|RST_CLK_128|RST_EN|WDT_EN);
+#endif
+}
+
+int wdt_get_timeout(void)
+{
+	int time = (ctrl & INT_TIME_MSK) >> INT_TIME_OFF;
+
+	if (time > 7)
+		return (time - 7) * 2;
+	else
+		return 1;
+}
+
+// set reset vector and enable WDT
+static int wdtdog_open(struct inode *inode, struct file *file){
+	int val = num_online_cpus();
+
+	sbi_set_reset_vec(val);
+	wdt_start();
+	DEBUG("Activating WDT..\n");
+	return 0;
+}
+
+// disable WDT, NOWAY_OUT MEANS NEED MAGIC NUMBER
+// OR just disable it if NOWAY_OUT not set
+static int wdtdog_release(struct inode *inode, struct file *file){
+#ifndef CONFIG_WATCHDOG_NOWAYOUT
+	/*
+	 *  Shut off the timer.
+	 *  Lock it in if it's a module and we defined ...NOWAYOUT
+	 */
+	if(expect_close) {
+		wren = WP_MAGIC;
+		ctrl = 0;
+		DEBUG( "Deactivating WDT..\n");
+	}
+#endif
+	expect_close = 0;
+	return 0;
+}
+// clean the WDT
+static ssize_t wdtdog_write(struct file *file, const char *data, size_t len, loff_t *ppos){
+	if (!len)
+		return 0;
+
+	if (!nowayout){
+		size_t i;
+		for (i = 0; i < len; i++){
+			char c;
+			if (get_user(c, data + i))
+				return -EFAULT;
+			if (c == 'V'){
+				expect_close = 42;
+				break;
+			}
+		}
+	}
+	wren = WP_MAGIC;
+	restart = RESTART_MAGIC;
+	st |= INT_EXPIRED;
+	return len;
+}
+
+static long wdtdog_ioctl(struct file *file, unsigned int cmd, unsigned long arg){
+	static struct watchdog_info ident = {
+		.identity = "FTWDT010 watchdog",
+	};
+
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+	int new_options, retval = -EINVAL;
+
+	switch( cmd){
+		case WDIOC_GETSUPPORT:
+			return copy_to_user(argp, &ident, sizeof( ident));
+
+		case WDIOC_GETSTATUS:
+		case WDIOC_GETBOOTSTATUS:
+			return put_user(0, p);
+
+		case WDIOC_SETOPTIONS:
+			if (get_user(new_options, p))
+				return -EFAULT;
+
+			if (new_options & WDIOS_DISABLECARD){
+				wren = WP_MAGIC;
+				ctrl &= ~WDT_EN;
+				retval = 0;
+			}
+
+			if (new_options & WDIOS_ENABLECARD){
+				wdt_start();
+				retval = 0;
+			}
+			return retval;
+
+		case WDIOC_GETTIMEOUT:
+			timeout = wdt_get_timeout();
+			return put_user(timeout, p);
+
+		case WDIOC_KEEPALIVE:
+			wren = WP_MAGIC;
+			restart = RESTART_MAGIC;
+			st |= INT_EXPIRED;
+			return 0;
+
+		default:
+			return -ENOIOCTLCMD;
+	}
+}
+
+extern struct atc_smu atcsmu;
+static int atcwdt200_restart_call(struct notifier_block *nb,
+                                  unsigned long action, void *data)
+{
+	int i;
+	int cpu_num = num_online_cpus();
+
+	if (atcsmu.base <= 0)
+		pr_err("Need to add smu node to dts!!\n");
+
+	for (i = 0; i < cpu_num; i++)
+		writel(FLASH_BASE ,atcsmu.base + RESET_VEC_OFF +
+			i * RESET_VEC_PER_CORE);
+
+	wren = WP_MAGIC;
+	ctrl = (INT_CLK_32768|INT_EN|RST_CLK_128|RST_EN|WDT_EN);
+        return 0;
+}
+
+static struct notifier_block atcwdt200_restart = {
+        .notifier_call = atcwdt200_restart_call,
+        .priority = 255,
+};
+
+static struct file_operations wdtdog_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.write		= wdtdog_write,
+	.unlocked_ioctl	= wdtdog_ioctl,
+	.open		= wdtdog_open,
+	.release	= wdtdog_release,
+};
+
+static struct miscdevice atcwdt200_dog_miscdev = {
+	WATCHDOG_MINOR,
+	"ATCWDT200 watchdog",
+	&wdtdog_fops
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id atcwdt200_dog_match[] = {
+	{ .compatible = "andestech,atcwdt200" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, atcwdt200_dog_match);
+#endif
+
+static int atcwdt200_dog_probe(struct platform_device *pdev){
+	int ret;
+	struct resource *res;
+	struct device_node *node;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	wdt_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(wdt_base))
+		return PTR_ERR(wdt_base);
+
+	if((idrev & ID_MSK)!=ID)
+		return -ENOENT;
+
+	node = of_find_matching_node(NULL, atcwdt200_dog_match);
+	if (of_property_read_u32(node, "clock-frequency", &wdt_freq))
+		panic("Can't read clock-frequency");
+
+	ret = misc_register(&atcwdt200_dog_miscdev);
+	if( ret)
+		return ret;
+
+	register_restart_handler(&atcwdt200_restart);
+
+	DEBUG("ATCWDT200 watchdog timer: timer timeout %d sec\n", timeout);
+	return 0;
+}
+
+static int atcwdt200_dog_remove(struct platform_device *pdev){
+	misc_deregister(&atcwdt200_dog_miscdev);
+	return 0;
+}
+
+static struct platform_driver atcwdt200_dog_driver = {
+	.probe		= atcwdt200_dog_probe,
+	.remove		= atcwdt200_dog_remove,
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(atcwdt200_dog_match),
+	},
+};
+
+module_platform_driver(atcwdt200_dog_driver);
+MODULE_AUTHOR("Andes Corp.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/zorro/.gitignore b/drivers/zorro/.gitignore
deleted file mode 100644
index 34f980bd..00000000
--- a/drivers/zorro/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-devlist.h
-gen-devlist
diff --git a/firmware/.gitignore b/firmware/.gitignore
deleted file mode 100644
index d9c69017..00000000
--- a/firmware/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-*.gen.S
-*.fw
-*.bin
-*.csp
-*.dsp
-ihex2fw
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index 4ad6f669..942a9241 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -414,7 +414,7 @@ static unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)
  * header pointed to by elf_ex, into a newly allocated array. The caller is
  * responsible for freeing the allocated data. Returns an ERR_PTR upon failure.
  */
-static struct elf_phdr *load_elf_phdrs(struct elfhdr *elf_ex,
+struct elf_phdr *load_elf_phdrs(struct elfhdr *elf_ex,
 				       struct file *elf_file)
 {
 	struct elf_phdr *elf_phdata = NULL;
diff --git a/include/asm-generic/dma-mapping.h b/include/asm-generic/dma-mapping.h
index 880a292d..ad286826 100644
--- a/include/asm-generic/dma-mapping.h
+++ b/include/asm-generic/dma-mapping.h
@@ -4,7 +4,16 @@
 
 static inline const struct dma_map_ops *get_arch_dma_ops(struct bus_type *bus)
 {
+	/*
+	 * Use the non-coherent ops if available.  If an architecture wants a
+	 * more fine-grained selection of operations it will have to implement
+	 * get_arch_dma_ops itself or use the per-device dma_ops.
+	 */
+#ifdef CONFIG_DMA_NONCOHERENT_OPS
+	return &dma_noncoherent_ops;
+#else
 	return &dma_direct_ops;
+#endif
 }
 
 #endif /* _ASM_GENERIC_DMA_MAPPING_H */
diff --git a/include/asm-generic/module.h b/include/asm-generic/module.h
index 98e1541b..d358f241 100644
--- a/include/asm-generic/module.h
+++ b/include/asm-generic/module.h
@@ -27,6 +27,7 @@ struct mod_arch_specific
 #endif
 #define ELF_R_TYPE(X)	ELF64_R_TYPE(X)
 #define ELF_R_SYM(X)	ELF64_R_SYM(X)
+#define ELF_ADDR_PREFIX "ll"
 
 #else /* CONFIG_64BIT */
 
@@ -44,6 +45,14 @@ struct mod_arch_specific
 #endif
 #define ELF_R_TYPE(X)	ELF32_R_TYPE(X)
 #define ELF_R_SYM(X)	ELF32_R_SYM(X)
+#define ELF_ADDR_PREFIX
 #endif
 
+#define PRIdEA	ELF_ADDR_PREFIX "d" /* signed decimal */
+#define PRIiEA	ELF_ADDR_PREFIX "i" /* signed decimal */
+#define PRIuEA	ELF_ADDR_PREFIX "u" /* unsigned decimal */
+#define PRIoEA	ELF_ADDR_PREFIX "o" /* unsigned octal */
+#define PRIxEA	ELF_ADDR_PREFIX "x" /* unsigned lowercase hexadecimal */
+#define PRIXEA	ELF_ADDR_PREFIX "X" /* unsigned uppercase hexadecimal */
+
 #endif /* __ASM_GENERIC_MODULE_H */
diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h
index 8796ba38..554c27f6 100644
--- a/include/linux/cpuhotplug.h
+++ b/include/linux/cpuhotplug.h
@@ -125,6 +125,7 @@ enum cpuhp_state {
 	CPUHP_AP_MARCO_TIMER_STARTING,
 	CPUHP_AP_MIPS_GIC_TIMER_STARTING,
 	CPUHP_AP_ARC_TIMER_STARTING,
+	CPUHP_AP_RISCV_TIMER_STARTING,
 	CPUHP_AP_KVM_STARTING,
 	CPUHP_AP_KVM_ARM_VGIC_INIT_STARTING,
 	CPUHP_AP_KVM_ARM_VGIC_STARTING,
diff --git a/include/linux/device.h b/include/linux/device.h
index 47795699..00b6c3b4 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -88,6 +88,8 @@ extern void bus_remove_file(struct bus_type *, struct bus_attribute *);
  * @resume:	Called to bring a device on this bus out of sleep mode.
  * @num_vf:	Called to find out how many virtual functions a device on this
  *		bus supports.
+ * @dma_configure:	Called to setup DMA configuration on a device on
+			this bus.
  * @pm:		Power management operations of this bus, callback the specific
  *		device driver's pm-ops.
  * @iommu_ops:  IOMMU specific operations for this bus, used to attach IOMMU
@@ -96,8 +98,6 @@ extern void bus_remove_file(struct bus_type *, struct bus_attribute *);
  * @p:		The private data of the driver core, only the driver core can
  *		touch this.
  * @lock_key:	Lock class key for use by the lock validator
- * @force_dma:	Assume devices on this bus should be set up by dma_configure()
- * 		even if DMA capability is not explicitly described by firmware.
  *
  * A bus is a channel between the processor and one or more devices. For the
  * purposes of the device model, all devices are connected via a bus, even if
@@ -130,14 +130,14 @@ struct bus_type {
 
 	int (*num_vf)(struct device *dev);
 
+	int (*dma_configure)(struct device *dev);
+
 	const struct dev_pm_ops *pm;
 
 	const struct iommu_ops *iommu_ops;
 
 	struct subsys_private *p;
 	struct lock_class_key lock_key;
-
-	bool force_dma;
 };
 
 extern int __must_check bus_register(struct bus_type *bus);
@@ -904,6 +904,8 @@ struct dev_links_info {
  * @offline:	Set after successful invocation of bus type's .offline().
  * @of_node_reused: Set if the device-tree node is shared with an ancestor
  *              device.
+ * @dma_32bit_limit: bridge limited to 32bit DMA even if the device itself
+ *		indicates support for a higher limit in the dma_mask field.
  *
  * At the lowest level, every device in a Linux system is represented by an
  * instance of struct device. The device structure contains the information
@@ -992,6 +994,7 @@ struct device {
 	bool			offline_disabled:1;
 	bool			offline:1;
 	bool			of_node_reused:1;
+	bool			dma_32bit_limit:1;
 };
 
 static inline struct device *kobj_to_dev(struct kobject *kobj)
diff --git a/include/linux/dma-contiguous.h b/include/linux/dma-contiguous.h
index b67bf6ac..3c5a4cb3 100644
--- a/include/linux/dma-contiguous.h
+++ b/include/linux/dma-contiguous.h
@@ -48,7 +48,7 @@
  *   CMA should not be used by the device drivers directly. It is
  *   only a helper framework for dma-mapping subsystem.
  *
- *   For more information, see kernel-docs in drivers/base/dma-contiguous.c
+ *   For more information, see kernel-docs in kernel/dma/contiguous.c
  */
 
 #ifdef __KERNEL__
diff --git a/include/linux/dma-debug.h b/include/linux/dma-debug.h
index c7d844f0..a785f250 100644
--- a/include/linux/dma-debug.h
+++ b/include/linux/dma-debug.h
@@ -30,8 +30,6 @@ struct bus_type;
 
 extern void dma_debug_add_bus(struct bus_type *bus);
 
-extern void dma_debug_init(u32 num_entries);
-
 extern int dma_debug_resize_entries(u32 num_entries);
 
 extern void debug_dma_map_page(struct device *dev, struct page *page,
@@ -100,10 +98,6 @@ static inline void dma_debug_add_bus(struct bus_type *bus)
 {
 }
 
-static inline void dma_debug_init(u32 num_entries)
-{
-}
-
 static inline int dma_debug_resize_entries(u32 num_entries)
 {
 	return 0;
diff --git a/include/linux/dma-direct.h b/include/linux/dma-direct.h
index 53ad6a47..8d9f33fe 100644
--- a/include/linux/dma-direct.h
+++ b/include/linux/dma-direct.h
@@ -59,6 +59,11 @@ void *dma_direct_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
 		gfp_t gfp, unsigned long attrs);
 void dma_direct_free(struct device *dev, size_t size, void *cpu_addr,
 		dma_addr_t dma_addr, unsigned long attrs);
+dma_addr_t dma_direct_map_page(struct device *dev, struct page *page,
+		unsigned long offset, size_t size, enum dma_data_direction dir,
+		unsigned long attrs);
+int dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,
+		enum dma_data_direction dir, unsigned long attrs);
 int dma_direct_supported(struct device *dev, u64 mask);
-
+int dma_direct_mapping_error(struct device *dev, dma_addr_t dma_addr);
 #endif /* _LINUX_DMA_DIRECT_H */
diff --git a/include/linux/dma-mapping.h b/include/linux/dma-mapping.h
index f8ab1c0f..0f152492 100644
--- a/include/linux/dma-mapping.h
+++ b/include/linux/dma-mapping.h
@@ -137,6 +137,7 @@ struct dma_map_ops {
 };
 
 extern const struct dma_map_ops dma_direct_ops;
+extern const struct dma_map_ops dma_noncoherent_ops;
 extern const struct dma_map_ops dma_virt_ops;
 
 #define DMA_BIT_MASK(n)	(((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
@@ -502,7 +503,7 @@ dma_get_sgtable_attrs(struct device *dev, struct sg_table *sgt, void *cpu_addr,
 #define dma_get_sgtable(d, t, v, h, s) dma_get_sgtable_attrs(d, t, v, h, s, 0)
 
 #ifndef arch_dma_alloc_attrs
-#define arch_dma_alloc_attrs(dev, flag)	(true)
+#define arch_dma_alloc_attrs(dev)	(true)
 #endif
 
 static inline void *dma_alloc_attrs(struct device *dev, size_t size,
@@ -521,7 +522,7 @@ static inline void *dma_alloc_attrs(struct device *dev, size_t size,
 	/* let the implementation decide on the zone to allocate from: */
 	flag &= ~(__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM);
 
-	if (!arch_dma_alloc_attrs(&dev, &flag))
+	if (!arch_dma_alloc_attrs(&dev))
 		return NULL;
 	if (!ops->alloc)
 		return NULL;
@@ -839,7 +840,7 @@ static inline int dma_mmap_wc(struct device *dev,
 #define dma_mmap_writecombine dma_mmap_wc
 #endif
 
-#if defined(CONFIG_NEED_DMA_MAP_STATE) || defined(CONFIG_DMA_API_DEBUG)
+#ifdef CONFIG_NEED_DMA_MAP_STATE
 #define DEFINE_DMA_UNMAP_ADDR(ADDR_NAME)        dma_addr_t ADDR_NAME
 #define DEFINE_DMA_UNMAP_LEN(LEN_NAME)          __u32 LEN_NAME
 #define dma_unmap_addr(PTR, ADDR_NAME)           ((PTR)->ADDR_NAME)
diff --git a/include/linux/dma-noncoherent.h b/include/linux/dma-noncoherent.h
new file mode 100644
index 00000000..10b2654d
--- /dev/null
+++ b/include/linux/dma-noncoherent.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _LINUX_DMA_NONCOHERENT_H
+#define _LINUX_DMA_NONCOHERENT_H 1
+
+#include <linux/dma-mapping.h>
+
+void *arch_dma_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
+		gfp_t gfp, unsigned long attrs);
+void arch_dma_free(struct device *dev, size_t size, void *cpu_addr,
+		dma_addr_t dma_addr, unsigned long attrs);
+
+#ifdef CONFIG_DMA_NONCOHERENT_MMAP
+int arch_dma_mmap(struct device *dev, struct vm_area_struct *vma,
+		void *cpu_addr, dma_addr_t dma_addr, size_t size,
+		unsigned long attrs);
+#else
+#define arch_dma_mmap NULL
+#endif /* CONFIG_DMA_NONCOHERENT_MMAP */
+
+#ifdef CONFIG_DMA_NONCOHERENT_CACHE_SYNC
+void arch_dma_cache_sync(struct device *dev, void *vaddr, size_t size,
+		enum dma_data_direction direction);
+#else
+#define arch_dma_cache_sync NULL
+#endif /* CONFIG_DMA_NONCOHERENT_CACHE_SYNC */
+
+#ifdef CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE
+void arch_sync_dma_for_device(struct device *dev, phys_addr_t paddr,
+		size_t size, enum dma_data_direction dir);
+#else
+static inline void arch_sync_dma_for_device(struct device *dev,
+		phys_addr_t paddr, size_t size, enum dma_data_direction dir)
+{
+}
+#endif /* ARCH_HAS_SYNC_DMA_FOR_DEVICE */
+
+#ifdef CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU
+void arch_sync_dma_for_cpu(struct device *dev, phys_addr_t paddr,
+		size_t size, enum dma_data_direction dir);
+#else
+static inline void arch_sync_dma_for_cpu(struct device *dev,
+		phys_addr_t paddr, size_t size, enum dma_data_direction dir)
+{
+}
+#endif /* ARCH_HAS_SYNC_DMA_FOR_CPU */
+
+#endif /* _LINUX_DMA_NONCOHERENT_H */
diff --git a/include/linux/elf.h b/include/linux/elf.h
index e3649b3e..9475e0f2 100644
--- a/include/linux/elf.h
+++ b/include/linux/elf.h
@@ -49,6 +49,8 @@ extern Elf64_Dyn _DYNAMIC [];
 struct file;
 struct coredump_params;
 
+extern struct elf_phdr *load_elf_phdrs(struct elfhdr *elf_ex,
+				       struct file *elf_file);
 #ifndef ARCH_HAVE_EXTRA_ELF_NOTES
 static inline int elf_coredump_extra_notes_size(void) { return 0; }
 static inline int elf_coredump_extra_notes_write(struct coredump_params *cprm) { return 0; }
diff --git a/include/linux/iommu-common.h b/include/linux/iommu-common.h
deleted file mode 100644
index 802c90c7..00000000
--- a/include/linux/iommu-common.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _LINUX_IOMMU_COMMON_H
-#define _LINUX_IOMMU_COMMON_H
-
-#include <linux/spinlock_types.h>
-#include <linux/device.h>
-#include <asm/page.h>
-
-#define IOMMU_POOL_HASHBITS     4
-#define IOMMU_NR_POOLS          (1 << IOMMU_POOL_HASHBITS)
-#define IOMMU_ERROR_CODE	(~(unsigned long) 0)
-
-struct iommu_pool {
-	unsigned long	start;
-	unsigned long	end;
-	unsigned long	hint;
-	spinlock_t	lock;
-};
-
-struct iommu_map_table {
-	unsigned long		table_map_base;
-	unsigned long		table_shift;
-	unsigned long		nr_pools;
-	void			(*lazy_flush)(struct iommu_map_table *);
-	unsigned long		poolsize;
-	struct iommu_pool	pools[IOMMU_NR_POOLS];
-	u32			flags;
-#define	IOMMU_HAS_LARGE_POOL	0x00000001
-#define	IOMMU_NO_SPAN_BOUND	0x00000002
-#define	IOMMU_NEED_FLUSH	0x00000004
-	struct iommu_pool	large_pool;
-	unsigned long		*map;
-};
-
-extern void iommu_tbl_pool_init(struct iommu_map_table *iommu,
-				unsigned long num_entries,
-				u32 table_shift,
-				void (*lazy_flush)(struct iommu_map_table *),
-				bool large_pool, u32 npools,
-				bool skip_span_boundary_check);
-
-extern unsigned long iommu_tbl_range_alloc(struct device *dev,
-					   struct iommu_map_table *iommu,
-					   unsigned long npages,
-					   unsigned long *handle,
-					   unsigned long mask,
-					   unsigned int align_order);
-
-extern void iommu_tbl_range_free(struct iommu_map_table *iommu,
-				 u64 dma_addr, unsigned long npages,
-				 unsigned long entry);
-
-#endif
diff --git a/include/linux/iommu-helper.h b/include/linux/iommu-helper.h
index cb9a9248..70d01edc 100644
--- a/include/linux/iommu-helper.h
+++ b/include/linux/iommu-helper.h
@@ -2,6 +2,7 @@
 #ifndef _LINUX_IOMMU_HELPER_H
 #define _LINUX_IOMMU_HELPER_H
 
+#include <linux/bug.h>
 #include <linux/kernel.h>
 
 static inline unsigned long iommu_device_max_index(unsigned long size,
@@ -14,9 +15,15 @@ static inline unsigned long iommu_device_max_index(unsigned long size,
 		return size;
 }
 
-extern int iommu_is_span_boundary(unsigned int index, unsigned int nr,
-				  unsigned long shift,
-				  unsigned long boundary_size);
+static inline int iommu_is_span_boundary(unsigned int index, unsigned int nr,
+		unsigned long shift, unsigned long boundary_size)
+{
+	BUG_ON(!is_power_of_2(boundary_size));
+
+	shift = (shift + index) & (boundary_size - 1);
+	return shift + nr > boundary_size;
+}
+
 extern unsigned long iommu_area_alloc(unsigned long *map, unsigned long size,
 				      unsigned long start, unsigned int nr,
 				      unsigned long shift,
diff --git a/include/linux/irqchip/irq-riscv-intc.h b/include/linux/irqchip/irq-riscv-intc.h
new file mode 100644
index 00000000..d939d184
--- /dev/null
+++ b/include/linux/irqchip/irq-riscv-intc.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2017 SiFive
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#ifndef IRQCHIP__IRQ_RISCV_INIT_H
+#define IRQCHIP__IRQ_RISCV_INIT_H
+
+void riscv_intc_irq(unsigned int cause, struct pt_regs *regs);
+
+#endif
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index de36969e..e7e20b8c 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -23,6 +23,7 @@
 #define SNOR_MFR_ATMEL		CFI_MFR_ATMEL
 #define SNOR_MFR_GIGADEVICE	0xc8
 #define SNOR_MFR_INTEL		CFI_MFR_INTEL
+#define SNOR_MFR_ISSI		0x9d
 #define SNOR_MFR_MICRON		CFI_MFR_ST /* ST Micro <--> Micron */
 #define SNOR_MFR_MACRONIX	CFI_MFR_MACRONIX
 #define SNOR_MFR_SPANSION	CFI_MFR_AMD
@@ -119,6 +120,7 @@
 #define SR_BP0			BIT(2)	/* Block protect 0 */
 #define SR_BP1			BIT(3)	/* Block protect 1 */
 #define SR_BP2			BIT(4)	/* Block protect 2 */
+#define SR_BP3			BIT(5)  /* Block protect 3 (on ISSI chips) */
 #define SR_TB			BIT(5)	/* Top/Bottom protect */
 #define SR_SRWD			BIT(7)	/* SR write protect */
 /* Spansion/Cypress specific status bits */
diff --git a/include/linux/of_device.h b/include/linux/of_device.h
index 8da5a1b3..165fd302 100644
--- a/include/linux/of_device.h
+++ b/include/linux/of_device.h
@@ -55,7 +55,9 @@ static inline struct device_node *of_cpu_device_node_get(int cpu)
 	return of_node_get(cpu_dev->of_node);
 }
 
-int of_dma_configure(struct device *dev, struct device_node *np);
+int of_dma_configure(struct device *dev,
+		     struct device_node *np,
+		     bool force_dma);
 void of_dma_deconfigure(struct device *dev);
 #else /* CONFIG_OF */
 
@@ -105,7 +107,9 @@ static inline struct device_node *of_cpu_device_node_get(int cpu)
 	return NULL;
 }
 
-static inline int of_dma_configure(struct device *dev, struct device_node *np)
+static inline int of_dma_configure(struct device *dev,
+				   struct device_node *np,
+				   bool force_dma)
 {
 	return 0;
 }
diff --git a/include/linux/platform_device.h b/include/linux/platform_device.h
index 49f634d9..3097c943 100644
--- a/include/linux/platform_device.h
+++ b/include/linux/platform_device.h
@@ -356,6 +356,8 @@ extern int platform_pm_restore(struct device *dev);
 #define platform_pm_restore		NULL
 #endif
 
+extern int platform_dma_configure(struct device *dev);
+
 #ifdef CONFIG_PM_SLEEP
 #define USE_PLATFORM_PM_SLEEP_OPS \
 	.suspend = platform_pm_suspend, \
diff --git a/include/linux/pwm.h b/include/linux/pwm.h
old mode 100644
new mode 100755
index 56518adc..6a591714
--- a/include/linux/pwm.h
+++ b/include/linux/pwm.h
@@ -261,7 +261,7 @@ struct pwm_ops {
 	int (*request)(struct pwm_chip *chip, struct pwm_device *pwm);
 	void (*free)(struct pwm_chip *chip, struct pwm_device *pwm);
 	int (*config)(struct pwm_chip *chip, struct pwm_device *pwm,
-		      int duty_ns, int period_ns);
+		      unsigned int duty_ns, unsigned int period_ns);
 	int (*set_polarity)(struct pwm_chip *chip, struct pwm_device *pwm,
 			    enum pwm_polarity polarity);
 	int (*capture)(struct pwm_chip *chip, struct pwm_device *pwm,
diff --git a/include/linux/timer_riscv.h b/include/linux/timer_riscv.h
new file mode 100644
index 00000000..59935817
--- /dev/null
+++ b/include/linux/timer_riscv.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2017 SiFive
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#ifndef _LINUX_TIMER_RISCV_H
+#define _LINUX_TIMER_RISCV_H
+
+/*
+ * All RISC-V systems have a timer attached to every hart.  These timers can be
+ * read by the 'rdcycle' pseudo instruction, and can use the SBI to setup
+ * events.  In order to abstract the architecture-specific timer reading and
+ * setting functions away from the clock event insertion code, we provide
+ * function pointers to the clockevent subsystem that perform two basic operations:
+ * rdtime() reads the timer on the current CPU, and next_event(delta) sets the
+ * next timer event to 'delta' cycles in the future.  As the timers are
+ * inherently a per-cpu resource, these callbacks perform operations on the
+ * current hart.  There is guaranteed to be exactly one timer per hart on all
+ * RISC-V systems.
+ */
+void timer_riscv_init(int cpu_id,
+		      unsigned long riscv_timebase,
+		      int (*next_event)(unsigned long, struct clock_event_device *));
+
+void clocksource_riscv_init(unsigned long long (*rdtime)(struct clocksource *));
+#endif
diff --git a/include/uapi/linux/audit.h b/include/uapi/linux/audit.h
index 4e61a9e0..f86a5fb3 100644
--- a/include/uapi/linux/audit.h
+++ b/include/uapi/linux/audit.h
@@ -396,6 +396,7 @@ enum {
 /* do not define AUDIT_ARCH_PPCLE since it is not supported by audit */
 #define AUDIT_ARCH_PPC64	(EM_PPC64|__AUDIT_ARCH_64BIT)
 #define AUDIT_ARCH_PPC64LE	(EM_PPC64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_RISCV	(EM_RISCV)
 #define AUDIT_ARCH_S390		(EM_S390)
 #define AUDIT_ARCH_S390X	(EM_S390|__AUDIT_ARCH_64BIT)
 #define AUDIT_ARCH_SH		(EM_SH)
diff --git a/include/uapi/linux/elf-em.h b/include/uapi/linux/elf-em.h
index 31aa1017..93722e60 100644
--- a/include/uapi/linux/elf-em.h
+++ b/include/uapi/linux/elf-em.h
@@ -41,6 +41,7 @@
 #define EM_TILEPRO	188	/* Tilera TILEPro */
 #define EM_MICROBLAZE	189	/* Xilinx MicroBlaze */
 #define EM_TILEGX	191	/* Tilera TILE-Gx */
+#define EM_RISCV	243	/* RISC-V */
 #define EM_BPF		247	/* Linux BPF - in-kernel virtual machine */
 #define EM_FRV		0x5441	/* Fujitsu FR-V */
 
diff --git a/include/uapi/linux/perf_event.h b/include/uapi/linux/perf_event.h
index b8e288a1..7533b905 100644
--- a/include/uapi/linux/perf_event.h
+++ b/include/uapi/linux/perf_event.h
@@ -337,6 +337,7 @@ struct perf_event_attr {
 				exclude_user   :  1, /* don't count user      */
 				exclude_kernel :  1, /* ditto kernel          */
 				exclude_hv     :  1, /* ditto hypervisor      */
+				exclude_machine :  1, /* ditto machine        */
 				exclude_idle   :  1, /* don't count when idle */
 				mmap           :  1, /* include mmap data     */
 				comm	       :  1, /* include comm data     */
@@ -370,7 +371,7 @@ struct perf_event_attr {
 				context_switch :  1, /* context switch data */
 				write_backward :  1, /* Write ring buffer from end to beginning */
 				namespaces     :  1, /* include namespaces data */
-				__reserved_1   : 35;
+				__reserved_1   : 34;
 
 	union {
 		__u32		wakeup_events;	  /* wakeup every n events */
diff --git a/include/uapi/linux/serial_core.h b/include/uapi/linux/serial_core.h
index dce5f9da..86973c38 100644
--- a/include/uapi/linux/serial_core.h
+++ b/include/uapi/linux/serial_core.h
@@ -281,4 +281,7 @@
 /* MediaTek BTIF */
 #define PORT_MTK_BTIF	117
 
+/* SiFive UART */
+#define PORT_SIFIVE_H5U	118
+
 #endif /* _UAPILINUX_SERIAL_CORE_H */
diff --git a/init/Kconfig b/init/Kconfig
index 18b151f0..07331ec4 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1670,10 +1670,6 @@ source "arch/Kconfig"
 
 endmenu		# General setup
 
-config HAVE_GENERIC_DMA_COHERENT
-	bool
-	default n
-
 config RT_MUTEXES
 	bool
 
diff --git a/kernel/.gitignore b/kernel/.gitignore
deleted file mode 100644
index b3097bde..00000000
--- a/kernel/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-#
-# Generated files
-#
-config_data.h
-config_data.gz
-timeconst.h
-hz.bc
diff --git a/kernel/Makefile b/kernel/Makefile
index f85ae5df..f790bdb0 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -41,6 +41,7 @@ obj-y += printk/
 obj-y += irq/
 obj-y += rcu/
 obj-y += livepatch/
+obj-y += dma/
 
 obj-$(CONFIG_CHECKPOINT_RESTORE) += kcmp.o
 obj-$(CONFIG_FREEZER) += freezer.o
diff --git a/kernel/debug/kdb/.gitignore b/kernel/debug/kdb/.gitignore
deleted file mode 100644
index 396d12ed..00000000
--- a/kernel/debug/kdb/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-gen-kdb_cmds.c
diff --git a/kernel/dma/Kconfig b/kernel/dma/Kconfig
new file mode 100644
index 00000000..9bd54304
--- /dev/null
+++ b/kernel/dma/Kconfig
@@ -0,0 +1,50 @@
+
+config HAS_DMA
+	bool
+	depends on !NO_DMA
+	default y
+
+config NEED_SG_DMA_LENGTH
+	bool
+
+config NEED_DMA_MAP_STATE
+	bool
+
+config ARCH_DMA_ADDR_T_64BIT
+	def_bool 64BIT || PHYS_ADDR_T_64BIT
+
+config HAVE_GENERIC_DMA_COHERENT
+	bool
+
+config ARCH_HAS_SYNC_DMA_FOR_DEVICE
+	bool
+
+config ARCH_HAS_SYNC_DMA_FOR_CPU
+	bool
+	select NEED_DMA_MAP_STATE
+
+config DMA_DIRECT_OPS
+	bool
+	depends on HAS_DMA
+
+config DMA_NONCOHERENT_OPS
+	bool
+	depends on HAS_DMA
+	select DMA_DIRECT_OPS
+
+config DMA_NONCOHERENT_MMAP
+	bool
+	depends on DMA_NONCOHERENT_OPS
+
+config DMA_NONCOHERENT_CACHE_SYNC
+	bool
+	depends on DMA_NONCOHERENT_OPS
+
+config DMA_VIRT_OPS
+	bool
+	depends on HAS_DMA
+
+config SWIOTLB
+	bool
+	select DMA_DIRECT_OPS
+	select NEED_DMA_MAP_STATE
diff --git a/kernel/dma/Makefile b/kernel/dma/Makefile
new file mode 100644
index 00000000..6de44e4e
--- /dev/null
+++ b/kernel/dma/Makefile
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0
+
+obj-$(CONFIG_HAS_DMA)			+= mapping.o
+obj-$(CONFIG_DMA_CMA)			+= contiguous.o
+obj-$(CONFIG_HAVE_GENERIC_DMA_COHERENT) += coherent.o
+obj-$(CONFIG_DMA_DIRECT_OPS)		+= direct.o
+obj-$(CONFIG_DMA_NONCOHERENT_OPS)	+= noncoherent.o
+obj-$(CONFIG_DMA_VIRT_OPS)		+= virt.o
+obj-$(CONFIG_DMA_API_DEBUG)		+= debug.o
+obj-$(CONFIG_SWIOTLB)			+= swiotlb.o
+
diff --git a/kernel/dma/coherent.c b/kernel/dma/coherent.c
new file mode 100644
index 00000000..597d4089
--- /dev/null
+++ b/kernel/dma/coherent.c
@@ -0,0 +1,434 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Coherent per-device memory handling.
+ * Borrowed from i386
+ */
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+
+struct dma_coherent_mem {
+	void		*virt_base;
+	dma_addr_t	device_base;
+	unsigned long	pfn_base;
+	int		size;
+	int		flags;
+	unsigned long	*bitmap;
+	spinlock_t	spinlock;
+	bool		use_dev_dma_pfn_offset;
+};
+
+static struct dma_coherent_mem *dma_coherent_default_memory __ro_after_init;
+
+static inline struct dma_coherent_mem *dev_get_coherent_memory(struct device *dev)
+{
+	if (dev && dev->dma_mem)
+		return dev->dma_mem;
+	return NULL;
+}
+
+static inline dma_addr_t dma_get_device_base(struct device *dev,
+					     struct dma_coherent_mem * mem)
+{
+	if (mem->use_dev_dma_pfn_offset)
+		return (mem->pfn_base - dev->dma_pfn_offset) << PAGE_SHIFT;
+	else
+		return mem->device_base;
+}
+
+static int dma_init_coherent_memory(
+	phys_addr_t phys_addr, dma_addr_t device_addr, size_t size, int flags,
+	struct dma_coherent_mem **mem)
+{
+	struct dma_coherent_mem *dma_mem = NULL;
+	void __iomem *mem_base = NULL;
+	int pages = size >> PAGE_SHIFT;
+	int bitmap_size = BITS_TO_LONGS(pages) * sizeof(long);
+	int ret;
+
+	if (!size) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	mem_base = memremap(phys_addr, size, MEMREMAP_WC);
+	if (!mem_base) {
+		ret = -EINVAL;
+		goto out;
+	}
+	dma_mem = kzalloc(sizeof(struct dma_coherent_mem), GFP_KERNEL);
+	if (!dma_mem) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	dma_mem->bitmap = kzalloc(bitmap_size, GFP_KERNEL);
+	if (!dma_mem->bitmap) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	dma_mem->virt_base = mem_base;
+	dma_mem->device_base = device_addr;
+	dma_mem->pfn_base = PFN_DOWN(phys_addr);
+	dma_mem->size = pages;
+	dma_mem->flags = flags;
+	spin_lock_init(&dma_mem->spinlock);
+
+	*mem = dma_mem;
+	return 0;
+
+out:
+	kfree(dma_mem);
+	if (mem_base)
+		memunmap(mem_base);
+	return ret;
+}
+
+static void dma_release_coherent_memory(struct dma_coherent_mem *mem)
+{
+	if (!mem)
+		return;
+
+	memunmap(mem->virt_base);
+	kfree(mem->bitmap);
+	kfree(mem);
+}
+
+static int dma_assign_coherent_memory(struct device *dev,
+				      struct dma_coherent_mem *mem)
+{
+	if (!dev)
+		return -ENODEV;
+
+	if (dev->dma_mem)
+		return -EBUSY;
+
+	dev->dma_mem = mem;
+	return 0;
+}
+
+int dma_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,
+				dma_addr_t device_addr, size_t size, int flags)
+{
+	struct dma_coherent_mem *mem;
+	int ret;
+
+	ret = dma_init_coherent_memory(phys_addr, device_addr, size, flags, &mem);
+	if (ret)
+		return ret;
+
+	ret = dma_assign_coherent_memory(dev, mem);
+	if (ret)
+		dma_release_coherent_memory(mem);
+	return ret;
+}
+EXPORT_SYMBOL(dma_declare_coherent_memory);
+
+void dma_release_declared_memory(struct device *dev)
+{
+	struct dma_coherent_mem *mem = dev->dma_mem;
+
+	if (!mem)
+		return;
+	dma_release_coherent_memory(mem);
+	dev->dma_mem = NULL;
+}
+EXPORT_SYMBOL(dma_release_declared_memory);
+
+void *dma_mark_declared_memory_occupied(struct device *dev,
+					dma_addr_t device_addr, size_t size)
+{
+	struct dma_coherent_mem *mem = dev->dma_mem;
+	unsigned long flags;
+	int pos, err;
+
+	size += device_addr & ~PAGE_MASK;
+
+	if (!mem)
+		return ERR_PTR(-EINVAL);
+
+	spin_lock_irqsave(&mem->spinlock, flags);
+	pos = PFN_DOWN(device_addr - dma_get_device_base(dev, mem));
+	err = bitmap_allocate_region(mem->bitmap, pos, get_order(size));
+	spin_unlock_irqrestore(&mem->spinlock, flags);
+
+	if (err != 0)
+		return ERR_PTR(err);
+	return mem->virt_base + (pos << PAGE_SHIFT);
+}
+EXPORT_SYMBOL(dma_mark_declared_memory_occupied);
+
+static void *__dma_alloc_from_coherent(struct dma_coherent_mem *mem,
+		ssize_t size, dma_addr_t *dma_handle)
+{
+	int order = get_order(size);
+	unsigned long flags;
+	int pageno;
+	void *ret;
+
+	spin_lock_irqsave(&mem->spinlock, flags);
+
+	if (unlikely(size > (mem->size << PAGE_SHIFT)))
+		goto err;
+
+	pageno = bitmap_find_free_region(mem->bitmap, mem->size, order);
+	if (unlikely(pageno < 0))
+		goto err;
+
+	/*
+	 * Memory was found in the coherent area.
+	 */
+	*dma_handle = mem->device_base + (pageno << PAGE_SHIFT);
+	ret = mem->virt_base + (pageno << PAGE_SHIFT);
+	spin_unlock_irqrestore(&mem->spinlock, flags);
+	memset(ret, 0, size);
+	return ret;
+err:
+	spin_unlock_irqrestore(&mem->spinlock, flags);
+	return NULL;
+}
+
+/**
+ * dma_alloc_from_dev_coherent() - allocate memory from device coherent pool
+ * @dev:	device from which we allocate memory
+ * @size:	size of requested memory area
+ * @dma_handle:	This will be filled with the correct dma handle
+ * @ret:	This pointer will be filled with the virtual address
+ *		to allocated area.
+ *
+ * This function should be only called from per-arch dma_alloc_coherent()
+ * to support allocation from per-device coherent memory pools.
+ *
+ * Returns 0 if dma_alloc_coherent should continue with allocating from
+ * generic memory areas, or !0 if dma_alloc_coherent should return @ret.
+ */
+int dma_alloc_from_dev_coherent(struct device *dev, ssize_t size,
+		dma_addr_t *dma_handle, void **ret)
+{
+	struct dma_coherent_mem *mem = dev_get_coherent_memory(dev);
+
+	if (!mem)
+		return 0;
+
+	*ret = __dma_alloc_from_coherent(mem, size, dma_handle);
+	if (*ret)
+		return 1;
+
+	/*
+	 * In the case where the allocation can not be satisfied from the
+	 * per-device area, try to fall back to generic memory if the
+	 * constraints allow it.
+	 */
+	return mem->flags & DMA_MEMORY_EXCLUSIVE;
+}
+EXPORT_SYMBOL(dma_alloc_from_dev_coherent);
+
+void *dma_alloc_from_global_coherent(ssize_t size, dma_addr_t *dma_handle)
+{
+	if (!dma_coherent_default_memory)
+		return NULL;
+
+	return __dma_alloc_from_coherent(dma_coherent_default_memory, size,
+			dma_handle);
+}
+
+static int __dma_release_from_coherent(struct dma_coherent_mem *mem,
+				       int order, void *vaddr)
+{
+	if (mem && vaddr >= mem->virt_base && vaddr <
+		   (mem->virt_base + (mem->size << PAGE_SHIFT))) {
+		int page = (vaddr - mem->virt_base) >> PAGE_SHIFT;
+		unsigned long flags;
+
+		spin_lock_irqsave(&mem->spinlock, flags);
+		bitmap_release_region(mem->bitmap, page, order);
+		spin_unlock_irqrestore(&mem->spinlock, flags);
+		return 1;
+	}
+	return 0;
+}
+
+/**
+ * dma_release_from_dev_coherent() - free memory to device coherent memory pool
+ * @dev:	device from which the memory was allocated
+ * @order:	the order of pages allocated
+ * @vaddr:	virtual address of allocated pages
+ *
+ * This checks whether the memory was allocated from the per-device
+ * coherent memory pool and if so, releases that memory.
+ *
+ * Returns 1 if we correctly released the memory, or 0 if the caller should
+ * proceed with releasing memory from generic pools.
+ */
+int dma_release_from_dev_coherent(struct device *dev, int order, void *vaddr)
+{
+	struct dma_coherent_mem *mem = dev_get_coherent_memory(dev);
+
+	return __dma_release_from_coherent(mem, order, vaddr);
+}
+EXPORT_SYMBOL(dma_release_from_dev_coherent);
+
+int dma_release_from_global_coherent(int order, void *vaddr)
+{
+	if (!dma_coherent_default_memory)
+		return 0;
+
+	return __dma_release_from_coherent(dma_coherent_default_memory, order,
+			vaddr);
+}
+
+static int __dma_mmap_from_coherent(struct dma_coherent_mem *mem,
+		struct vm_area_struct *vma, void *vaddr, size_t size, int *ret)
+{
+	if (mem && vaddr >= mem->virt_base && vaddr + size <=
+		   (mem->virt_base + (mem->size << PAGE_SHIFT))) {
+		unsigned long off = vma->vm_pgoff;
+		int start = (vaddr - mem->virt_base) >> PAGE_SHIFT;
+		int user_count = vma_pages(vma);
+		int count = PAGE_ALIGN(size) >> PAGE_SHIFT;
+
+		*ret = -ENXIO;
+		if (off < count && user_count <= count - off) {
+			unsigned long pfn = mem->pfn_base + start + off;
+			*ret = remap_pfn_range(vma, vma->vm_start, pfn,
+					       user_count << PAGE_SHIFT,
+					       vma->vm_page_prot);
+		}
+		return 1;
+	}
+	return 0;
+}
+
+/**
+ * dma_mmap_from_dev_coherent() - mmap memory from the device coherent pool
+ * @dev:	device from which the memory was allocated
+ * @vma:	vm_area for the userspace memory
+ * @vaddr:	cpu address returned by dma_alloc_from_dev_coherent
+ * @size:	size of the memory buffer allocated
+ * @ret:	result from remap_pfn_range()
+ *
+ * This checks whether the memory was allocated from the per-device
+ * coherent memory pool and if so, maps that memory to the provided vma.
+ *
+ * Returns 1 if @vaddr belongs to the device coherent pool and the caller
+ * should return @ret, or 0 if they should proceed with mapping memory from
+ * generic areas.
+ */
+int dma_mmap_from_dev_coherent(struct device *dev, struct vm_area_struct *vma,
+			   void *vaddr, size_t size, int *ret)
+{
+	struct dma_coherent_mem *mem = dev_get_coherent_memory(dev);
+
+	return __dma_mmap_from_coherent(mem, vma, vaddr, size, ret);
+}
+EXPORT_SYMBOL(dma_mmap_from_dev_coherent);
+
+int dma_mmap_from_global_coherent(struct vm_area_struct *vma, void *vaddr,
+				   size_t size, int *ret)
+{
+	if (!dma_coherent_default_memory)
+		return 0;
+
+	return __dma_mmap_from_coherent(dma_coherent_default_memory, vma,
+					vaddr, size, ret);
+}
+
+/*
+ * Support for reserved memory regions defined in device tree
+ */
+#ifdef CONFIG_OF_RESERVED_MEM
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/of_reserved_mem.h>
+
+static struct reserved_mem *dma_reserved_default_memory __initdata;
+
+static int rmem_dma_device_init(struct reserved_mem *rmem, struct device *dev)
+{
+	struct dma_coherent_mem *mem = rmem->priv;
+	int ret;
+
+	if (!mem) {
+		ret = dma_init_coherent_memory(rmem->base, rmem->base,
+					       rmem->size,
+					       DMA_MEMORY_EXCLUSIVE, &mem);
+		if (ret) {
+			pr_err("Reserved memory: failed to init DMA memory pool at %pa, size %ld MiB\n",
+				&rmem->base, (unsigned long)rmem->size / SZ_1M);
+			return ret;
+		}
+	}
+	mem->use_dev_dma_pfn_offset = true;
+	rmem->priv = mem;
+	dma_assign_coherent_memory(dev, mem);
+	return 0;
+}
+
+static void rmem_dma_device_release(struct reserved_mem *rmem,
+				    struct device *dev)
+{
+	if (dev)
+		dev->dma_mem = NULL;
+}
+
+static const struct reserved_mem_ops rmem_dma_ops = {
+	.device_init	= rmem_dma_device_init,
+	.device_release	= rmem_dma_device_release,
+};
+
+static int __init rmem_dma_setup(struct reserved_mem *rmem)
+{
+	unsigned long node = rmem->fdt_node;
+
+	if (of_get_flat_dt_prop(node, "reusable", NULL))
+		return -EINVAL;
+
+#ifdef CONFIG_ARM
+	if (!of_get_flat_dt_prop(node, "no-map", NULL)) {
+		pr_err("Reserved memory: regions without no-map are not yet supported\n");
+		return -EINVAL;
+	}
+
+	if (of_get_flat_dt_prop(node, "linux,dma-default", NULL)) {
+		WARN(dma_reserved_default_memory,
+		     "Reserved memory: region for default DMA coherent area is redefined\n");
+		dma_reserved_default_memory = rmem;
+	}
+#endif
+
+	rmem->ops = &rmem_dma_ops;
+	pr_info("Reserved memory: created DMA memory pool at %pa, size %ld MiB\n",
+		&rmem->base, (unsigned long)rmem->size / SZ_1M);
+	return 0;
+}
+
+static int __init dma_init_reserved_memory(void)
+{
+	const struct reserved_mem_ops *ops;
+	int ret;
+
+	if (!dma_reserved_default_memory)
+		return -ENOMEM;
+
+	ops = dma_reserved_default_memory->ops;
+
+	/*
+	 * We rely on rmem_dma_device_init() does not propagate error of
+	 * dma_assign_coherent_memory() for "NULL" device.
+	 */
+	ret = ops->device_init(dma_reserved_default_memory, NULL);
+
+	if (!ret) {
+		dma_coherent_default_memory = dma_reserved_default_memory->priv;
+		pr_info("DMA: default coherent area is set\n");
+	}
+
+	return ret;
+}
+
+core_initcall(dma_init_reserved_memory);
+
+RESERVEDMEM_OF_DECLARE(dma, "shared-dma-pool", rmem_dma_setup);
+#endif
diff --git a/kernel/dma/contiguous.c b/kernel/dma/contiguous.c
new file mode 100644
index 00000000..d987dcd1
--- /dev/null
+++ b/kernel/dma/contiguous.c
@@ -0,0 +1,278 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Contiguous Memory Allocator for DMA mapping framework
+ * Copyright (c) 2010-2011 by Samsung Electronics.
+ * Written by:
+ *	Marek Szyprowski <m.szyprowski@samsung.com>
+ *	Michal Nazarewicz <mina86@mina86.com>
+ */
+
+#define pr_fmt(fmt) "cma: " fmt
+
+#ifdef CONFIG_CMA_DEBUG
+#ifndef DEBUG
+#  define DEBUG
+#endif
+#endif
+
+#include <asm/page.h>
+#include <asm/dma-contiguous.h>
+
+#include <linux/memblock.h>
+#include <linux/err.h>
+#include <linux/sizes.h>
+#include <linux/dma-contiguous.h>
+#include <linux/cma.h>
+
+#ifdef CONFIG_CMA_SIZE_MBYTES
+#define CMA_SIZE_MBYTES CONFIG_CMA_SIZE_MBYTES
+#else
+#define CMA_SIZE_MBYTES 0
+#endif
+
+struct cma *dma_contiguous_default_area;
+
+/*
+ * Default global CMA area size can be defined in kernel's .config.
+ * This is useful mainly for distro maintainers to create a kernel
+ * that works correctly for most supported systems.
+ * The size can be set in bytes or as a percentage of the total memory
+ * in the system.
+ *
+ * Users, who want to set the size of global CMA area for their system
+ * should use cma= kernel parameter.
+ */
+static const phys_addr_t size_bytes = (phys_addr_t)CMA_SIZE_MBYTES * SZ_1M;
+static phys_addr_t size_cmdline = -1;
+static phys_addr_t base_cmdline;
+static phys_addr_t limit_cmdline;
+
+static int __init early_cma(char *p)
+{
+	pr_debug("%s(%s)\n", __func__, p);
+	size_cmdline = memparse(p, &p);
+	if (*p != '@')
+		return 0;
+	base_cmdline = memparse(p + 1, &p);
+	if (*p != '-') {
+		limit_cmdline = base_cmdline + size_cmdline;
+		return 0;
+	}
+	limit_cmdline = memparse(p + 1, &p);
+
+	return 0;
+}
+early_param("cma", early_cma);
+
+#ifdef CONFIG_CMA_SIZE_PERCENTAGE
+
+static phys_addr_t __init __maybe_unused cma_early_percent_memory(void)
+{
+	struct memblock_region *reg;
+	unsigned long total_pages = 0;
+
+	/*
+	 * We cannot use memblock_phys_mem_size() here, because
+	 * memblock_analyze() has not been called yet.
+	 */
+	for_each_memblock(memory, reg)
+		total_pages += memblock_region_memory_end_pfn(reg) -
+			       memblock_region_memory_base_pfn(reg);
+
+	return (total_pages * CONFIG_CMA_SIZE_PERCENTAGE / 100) << PAGE_SHIFT;
+}
+
+#else
+
+static inline __maybe_unused phys_addr_t cma_early_percent_memory(void)
+{
+	return 0;
+}
+
+#endif
+
+/**
+ * dma_contiguous_reserve() - reserve area(s) for contiguous memory handling
+ * @limit: End address of the reserved memory (optional, 0 for any).
+ *
+ * This function reserves memory from early allocator. It should be
+ * called by arch specific code once the early allocator (memblock or bootmem)
+ * has been activated and all other subsystems have already allocated/reserved
+ * memory.
+ */
+void __init dma_contiguous_reserve(phys_addr_t limit)
+{
+	phys_addr_t selected_size = 0;
+	phys_addr_t selected_base = 0;
+	phys_addr_t selected_limit = limit;
+	bool fixed = false;
+
+	pr_debug("%s(limit %08lx)\n", __func__, (unsigned long)limit);
+
+	if (size_cmdline != -1) {
+		selected_size = size_cmdline;
+		selected_base = base_cmdline;
+		selected_limit = min_not_zero(limit_cmdline, limit);
+		if (base_cmdline + size_cmdline == limit_cmdline)
+			fixed = true;
+	} else {
+#ifdef CONFIG_CMA_SIZE_SEL_MBYTES
+		selected_size = size_bytes;
+#elif defined(CONFIG_CMA_SIZE_SEL_PERCENTAGE)
+		selected_size = cma_early_percent_memory();
+#elif defined(CONFIG_CMA_SIZE_SEL_MIN)
+		selected_size = min(size_bytes, cma_early_percent_memory());
+#elif defined(CONFIG_CMA_SIZE_SEL_MAX)
+		selected_size = max(size_bytes, cma_early_percent_memory());
+#endif
+	}
+
+	if (selected_size && !dma_contiguous_default_area) {
+		pr_debug("%s: reserving %ld MiB for global area\n", __func__,
+			 (unsigned long)selected_size / SZ_1M);
+
+		dma_contiguous_reserve_area(selected_size, selected_base,
+					    selected_limit,
+					    &dma_contiguous_default_area,
+					    fixed);
+	}
+}
+
+/**
+ * dma_contiguous_reserve_area() - reserve custom contiguous area
+ * @size: Size of the reserved area (in bytes),
+ * @base: Base address of the reserved area optional, use 0 for any
+ * @limit: End address of the reserved memory (optional, 0 for any).
+ * @res_cma: Pointer to store the created cma region.
+ * @fixed: hint about where to place the reserved area
+ *
+ * This function reserves memory from early allocator. It should be
+ * called by arch specific code once the early allocator (memblock or bootmem)
+ * has been activated and all other subsystems have already allocated/reserved
+ * memory. This function allows to create custom reserved areas for specific
+ * devices.
+ *
+ * If @fixed is true, reserve contiguous area at exactly @base.  If false,
+ * reserve in range from @base to @limit.
+ */
+int __init dma_contiguous_reserve_area(phys_addr_t size, phys_addr_t base,
+				       phys_addr_t limit, struct cma **res_cma,
+				       bool fixed)
+{
+	int ret;
+
+	ret = cma_declare_contiguous(base, size, limit, 0, 0, fixed,
+					"reserved", res_cma);
+	if (ret)
+		return ret;
+
+	/* Architecture specific contiguous memory fixup. */
+	dma_contiguous_early_fixup(cma_get_base(*res_cma),
+				cma_get_size(*res_cma));
+
+	return 0;
+}
+
+/**
+ * dma_alloc_from_contiguous() - allocate pages from contiguous area
+ * @dev:   Pointer to device for which the allocation is performed.
+ * @count: Requested number of pages.
+ * @align: Requested alignment of pages (in PAGE_SIZE order).
+ * @gfp_mask: GFP flags to use for this allocation.
+ *
+ * This function allocates memory buffer for specified device. It uses
+ * device specific contiguous memory area if available or the default
+ * global one. Requires architecture specific dev_get_cma_area() helper
+ * function.
+ */
+struct page *dma_alloc_from_contiguous(struct device *dev, size_t count,
+				       unsigned int align, gfp_t gfp_mask)
+{
+	if (align > CONFIG_CMA_ALIGNMENT)
+		align = CONFIG_CMA_ALIGNMENT;
+
+	return cma_alloc(dev_get_cma_area(dev), count, align, gfp_mask);
+}
+
+/**
+ * dma_release_from_contiguous() - release allocated pages
+ * @dev:   Pointer to device for which the pages were allocated.
+ * @pages: Allocated pages.
+ * @count: Number of allocated pages.
+ *
+ * This function releases memory allocated by dma_alloc_from_contiguous().
+ * It returns false when provided pages do not belong to contiguous area and
+ * true otherwise.
+ */
+bool dma_release_from_contiguous(struct device *dev, struct page *pages,
+				 int count)
+{
+	return cma_release(dev_get_cma_area(dev), pages, count);
+}
+
+/*
+ * Support for reserved memory regions defined in device tree
+ */
+#ifdef CONFIG_OF_RESERVED_MEM
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/of_reserved_mem.h>
+
+#undef pr_fmt
+#define pr_fmt(fmt) fmt
+
+static int rmem_cma_device_init(struct reserved_mem *rmem, struct device *dev)
+{
+	dev_set_cma_area(dev, rmem->priv);
+	return 0;
+}
+
+static void rmem_cma_device_release(struct reserved_mem *rmem,
+				    struct device *dev)
+{
+	dev_set_cma_area(dev, NULL);
+}
+
+static const struct reserved_mem_ops rmem_cma_ops = {
+	.device_init	= rmem_cma_device_init,
+	.device_release = rmem_cma_device_release,
+};
+
+static int __init rmem_cma_setup(struct reserved_mem *rmem)
+{
+	phys_addr_t align = PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order);
+	phys_addr_t mask = align - 1;
+	unsigned long node = rmem->fdt_node;
+	struct cma *cma;
+	int err;
+
+	if (!of_get_flat_dt_prop(node, "reusable", NULL) ||
+	    of_get_flat_dt_prop(node, "no-map", NULL))
+		return -EINVAL;
+
+	if ((rmem->base & mask) || (rmem->size & mask)) {
+		pr_err("Reserved memory: incorrect alignment of CMA region\n");
+		return -EINVAL;
+	}
+
+	err = cma_init_reserved_mem(rmem->base, rmem->size, 0, rmem->name, &cma);
+	if (err) {
+		pr_err("Reserved memory: unable to setup CMA region\n");
+		return err;
+	}
+	/* Architecture specific contiguous memory fixup. */
+	dma_contiguous_early_fixup(rmem->base, rmem->size);
+
+	if (of_get_flat_dt_prop(node, "linux,cma-default", NULL))
+		dma_contiguous_set_default(cma);
+
+	rmem->ops = &rmem_cma_ops;
+	rmem->priv = cma;
+
+	pr_info("Reserved memory: created CMA memory pool at %pa, size %ld MiB\n",
+		&rmem->base, (unsigned long)rmem->size / SZ_1M);
+
+	return 0;
+}
+RESERVEDMEM_OF_DECLARE(cma, "shared-dma-pool", rmem_cma_setup);
+#endif
diff --git a/kernel/dma/debug.c b/kernel/dma/debug.c
new file mode 100644
index 00000000..6a1ebaa8
--- /dev/null
+++ b/kernel/dma/debug.c
@@ -0,0 +1,1745 @@
+/*
+ * Copyright (C) 2008 Advanced Micro Devices, Inc.
+ *
+ * Author: Joerg Roedel <joerg.roedel@amd.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/sched/task_stack.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched/task.h>
+#include <linux/stacktrace.h>
+#include <linux/dma-debug.h>
+#include <linux/spinlock.h>
+#include <linux/vmalloc.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/export.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/ctype.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+
+#include <asm/sections.h>
+
+#define HASH_SIZE       1024ULL
+#define HASH_FN_SHIFT   13
+#define HASH_FN_MASK    (HASH_SIZE - 1)
+
+/* allow architectures to override this if absolutely required */
+#ifndef PREALLOC_DMA_DEBUG_ENTRIES
+#define PREALLOC_DMA_DEBUG_ENTRIES (1 << 16)
+#endif
+
+enum {
+	dma_debug_single,
+	dma_debug_page,
+	dma_debug_sg,
+	dma_debug_coherent,
+	dma_debug_resource,
+};
+
+enum map_err_types {
+	MAP_ERR_CHECK_NOT_APPLICABLE,
+	MAP_ERR_NOT_CHECKED,
+	MAP_ERR_CHECKED,
+};
+
+#define DMA_DEBUG_STACKTRACE_ENTRIES 5
+
+/**
+ * struct dma_debug_entry - track a dma_map* or dma_alloc_coherent mapping
+ * @list: node on pre-allocated free_entries list
+ * @dev: 'dev' argument to dma_map_{page|single|sg} or dma_alloc_coherent
+ * @type: single, page, sg, coherent
+ * @pfn: page frame of the start address
+ * @offset: offset of mapping relative to pfn
+ * @size: length of the mapping
+ * @direction: enum dma_data_direction
+ * @sg_call_ents: 'nents' from dma_map_sg
+ * @sg_mapped_ents: 'mapped_ents' from dma_map_sg
+ * @map_err_type: track whether dma_mapping_error() was checked
+ * @stacktrace: support backtraces when a violation is detected
+ */
+struct dma_debug_entry {
+	struct list_head list;
+	struct device    *dev;
+	int              type;
+	unsigned long	 pfn;
+	size_t		 offset;
+	u64              dev_addr;
+	u64              size;
+	int              direction;
+	int		 sg_call_ents;
+	int		 sg_mapped_ents;
+	enum map_err_types  map_err_type;
+#ifdef CONFIG_STACKTRACE
+	struct		 stack_trace stacktrace;
+	unsigned long	 st_entries[DMA_DEBUG_STACKTRACE_ENTRIES];
+#endif
+};
+
+typedef bool (*match_fn)(struct dma_debug_entry *, struct dma_debug_entry *);
+
+struct hash_bucket {
+	struct list_head list;
+	spinlock_t lock;
+} ____cacheline_aligned_in_smp;
+
+/* Hash list to save the allocated dma addresses */
+static struct hash_bucket dma_entry_hash[HASH_SIZE];
+/* List of pre-allocated dma_debug_entry's */
+static LIST_HEAD(free_entries);
+/* Lock for the list above */
+static DEFINE_SPINLOCK(free_entries_lock);
+
+/* Global disable flag - will be set in case of an error */
+static bool global_disable __read_mostly;
+
+/* Early initialization disable flag, set at the end of dma_debug_init */
+static bool dma_debug_initialized __read_mostly;
+
+static inline bool dma_debug_disabled(void)
+{
+	return global_disable || !dma_debug_initialized;
+}
+
+/* Global error count */
+static u32 error_count;
+
+/* Global error show enable*/
+static u32 show_all_errors __read_mostly;
+/* Number of errors to show */
+static u32 show_num_errors = 1;
+
+static u32 num_free_entries;
+static u32 min_free_entries;
+static u32 nr_total_entries;
+
+/* number of preallocated entries requested by kernel cmdline */
+static u32 nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;
+
+/* debugfs dentry's for the stuff above */
+static struct dentry *dma_debug_dent        __read_mostly;
+static struct dentry *global_disable_dent   __read_mostly;
+static struct dentry *error_count_dent      __read_mostly;
+static struct dentry *show_all_errors_dent  __read_mostly;
+static struct dentry *show_num_errors_dent  __read_mostly;
+static struct dentry *num_free_entries_dent __read_mostly;
+static struct dentry *min_free_entries_dent __read_mostly;
+static struct dentry *filter_dent           __read_mostly;
+
+/* per-driver filter related state */
+
+#define NAME_MAX_LEN	64
+
+static char                  current_driver_name[NAME_MAX_LEN] __read_mostly;
+static struct device_driver *current_driver                    __read_mostly;
+
+static DEFINE_RWLOCK(driver_name_lock);
+
+static const char *const maperr2str[] = {
+	[MAP_ERR_CHECK_NOT_APPLICABLE] = "dma map error check not applicable",
+	[MAP_ERR_NOT_CHECKED] = "dma map error not checked",
+	[MAP_ERR_CHECKED] = "dma map error checked",
+};
+
+static const char *type2name[5] = { "single", "page",
+				    "scather-gather", "coherent",
+				    "resource" };
+
+static const char *dir2name[4] = { "DMA_BIDIRECTIONAL", "DMA_TO_DEVICE",
+				   "DMA_FROM_DEVICE", "DMA_NONE" };
+
+/*
+ * The access to some variables in this macro is racy. We can't use atomic_t
+ * here because all these variables are exported to debugfs. Some of them even
+ * writeable. This is also the reason why a lock won't help much. But anyway,
+ * the races are no big deal. Here is why:
+ *
+ *   error_count: the addition is racy, but the worst thing that can happen is
+ *                that we don't count some errors
+ *   show_num_errors: the subtraction is racy. Also no big deal because in
+ *                    worst case this will result in one warning more in the
+ *                    system log than the user configured. This variable is
+ *                    writeable via debugfs.
+ */
+static inline void dump_entry_trace(struct dma_debug_entry *entry)
+{
+#ifdef CONFIG_STACKTRACE
+	if (entry) {
+		pr_warning("Mapped at:\n");
+		print_stack_trace(&entry->stacktrace, 0);
+	}
+#endif
+}
+
+static bool driver_filter(struct device *dev)
+{
+	struct device_driver *drv;
+	unsigned long flags;
+	bool ret;
+
+	/* driver filter off */
+	if (likely(!current_driver_name[0]))
+		return true;
+
+	/* driver filter on and initialized */
+	if (current_driver && dev && dev->driver == current_driver)
+		return true;
+
+	/* driver filter on, but we can't filter on a NULL device... */
+	if (!dev)
+		return false;
+
+	if (current_driver || !current_driver_name[0])
+		return false;
+
+	/* driver filter on but not yet initialized */
+	drv = dev->driver;
+	if (!drv)
+		return false;
+
+	/* lock to protect against change of current_driver_name */
+	read_lock_irqsave(&driver_name_lock, flags);
+
+	ret = false;
+	if (drv->name &&
+	    strncmp(current_driver_name, drv->name, NAME_MAX_LEN - 1) == 0) {
+		current_driver = drv;
+		ret = true;
+	}
+
+	read_unlock_irqrestore(&driver_name_lock, flags);
+
+	return ret;
+}
+
+#define err_printk(dev, entry, format, arg...) do {			\
+		error_count += 1;					\
+		if (driver_filter(dev) &&				\
+		    (show_all_errors || show_num_errors > 0)) {		\
+			WARN(1, "%s %s: " format,			\
+			     dev ? dev_driver_string(dev) : "NULL",	\
+			     dev ? dev_name(dev) : "NULL", ## arg);	\
+			dump_entry_trace(entry);			\
+		}							\
+		if (!show_all_errors && show_num_errors > 0)		\
+			show_num_errors -= 1;				\
+	} while (0);
+
+/*
+ * Hash related functions
+ *
+ * Every DMA-API request is saved into a struct dma_debug_entry. To
+ * have quick access to these structs they are stored into a hash.
+ */
+static int hash_fn(struct dma_debug_entry *entry)
+{
+	/*
+	 * Hash function is based on the dma address.
+	 * We use bits 20-27 here as the index into the hash
+	 */
+	return (entry->dev_addr >> HASH_FN_SHIFT) & HASH_FN_MASK;
+}
+
+/*
+ * Request exclusive access to a hash bucket for a given dma_debug_entry.
+ */
+static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,
+					   unsigned long *flags)
+	__acquires(&dma_entry_hash[idx].lock)
+{
+	int idx = hash_fn(entry);
+	unsigned long __flags;
+
+	spin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);
+	*flags = __flags;
+	return &dma_entry_hash[idx];
+}
+
+/*
+ * Give up exclusive access to the hash bucket
+ */
+static void put_hash_bucket(struct hash_bucket *bucket,
+			    unsigned long *flags)
+	__releases(&bucket->lock)
+{
+	unsigned long __flags = *flags;
+
+	spin_unlock_irqrestore(&bucket->lock, __flags);
+}
+
+static bool exact_match(struct dma_debug_entry *a, struct dma_debug_entry *b)
+{
+	return ((a->dev_addr == b->dev_addr) &&
+		(a->dev == b->dev)) ? true : false;
+}
+
+static bool containing_match(struct dma_debug_entry *a,
+			     struct dma_debug_entry *b)
+{
+	if (a->dev != b->dev)
+		return false;
+
+	if ((b->dev_addr <= a->dev_addr) &&
+	    ((b->dev_addr + b->size) >= (a->dev_addr + a->size)))
+		return true;
+
+	return false;
+}
+
+/*
+ * Search a given entry in the hash bucket list
+ */
+static struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,
+						  struct dma_debug_entry *ref,
+						  match_fn match)
+{
+	struct dma_debug_entry *entry, *ret = NULL;
+	int matches = 0, match_lvl, last_lvl = -1;
+
+	list_for_each_entry(entry, &bucket->list, list) {
+		if (!match(ref, entry))
+			continue;
+
+		/*
+		 * Some drivers map the same physical address multiple
+		 * times. Without a hardware IOMMU this results in the
+		 * same device addresses being put into the dma-debug
+		 * hash multiple times too. This can result in false
+		 * positives being reported. Therefore we implement a
+		 * best-fit algorithm here which returns the entry from
+		 * the hash which fits best to the reference value
+		 * instead of the first-fit.
+		 */
+		matches += 1;
+		match_lvl = 0;
+		entry->size         == ref->size         ? ++match_lvl : 0;
+		entry->type         == ref->type         ? ++match_lvl : 0;
+		entry->direction    == ref->direction    ? ++match_lvl : 0;
+		entry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;
+
+		if (match_lvl == 4) {
+			/* perfect-fit - return the result */
+			return entry;
+		} else if (match_lvl > last_lvl) {
+			/*
+			 * We found an entry that fits better then the
+			 * previous one or it is the 1st match.
+			 */
+			last_lvl = match_lvl;
+			ret      = entry;
+		}
+	}
+
+	/*
+	 * If we have multiple matches but no perfect-fit, just return
+	 * NULL.
+	 */
+	ret = (matches == 1) ? ret : NULL;
+
+	return ret;
+}
+
+static struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,
+						 struct dma_debug_entry *ref)
+{
+	return __hash_bucket_find(bucket, ref, exact_match);
+}
+
+static struct dma_debug_entry *bucket_find_contain(struct hash_bucket **bucket,
+						   struct dma_debug_entry *ref,
+						   unsigned long *flags)
+{
+
+	unsigned int max_range = dma_get_max_seg_size(ref->dev);
+	struct dma_debug_entry *entry, index = *ref;
+	unsigned int range = 0;
+
+	while (range <= max_range) {
+		entry = __hash_bucket_find(*bucket, ref, containing_match);
+
+		if (entry)
+			return entry;
+
+		/*
+		 * Nothing found, go back a hash bucket
+		 */
+		put_hash_bucket(*bucket, flags);
+		range          += (1 << HASH_FN_SHIFT);
+		index.dev_addr -= (1 << HASH_FN_SHIFT);
+		*bucket = get_hash_bucket(&index, flags);
+	}
+
+	return NULL;
+}
+
+/*
+ * Add an entry to a hash bucket
+ */
+static void hash_bucket_add(struct hash_bucket *bucket,
+			    struct dma_debug_entry *entry)
+{
+	list_add_tail(&entry->list, &bucket->list);
+}
+
+/*
+ * Remove entry from a hash bucket list
+ */
+static void hash_bucket_del(struct dma_debug_entry *entry)
+{
+	list_del(&entry->list);
+}
+
+static unsigned long long phys_addr(struct dma_debug_entry *entry)
+{
+	if (entry->type == dma_debug_resource)
+		return __pfn_to_phys(entry->pfn) + entry->offset;
+
+	return page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;
+}
+
+/*
+ * Dump mapping entries for debugging purposes
+ */
+void debug_dma_dump_mappings(struct device *dev)
+{
+	int idx;
+
+	for (idx = 0; idx < HASH_SIZE; idx++) {
+		struct hash_bucket *bucket = &dma_entry_hash[idx];
+		struct dma_debug_entry *entry;
+		unsigned long flags;
+
+		spin_lock_irqsave(&bucket->lock, flags);
+
+		list_for_each_entry(entry, &bucket->list, list) {
+			if (!dev || dev == entry->dev) {
+				dev_info(entry->dev,
+					 "%s idx %d P=%Lx N=%lx D=%Lx L=%Lx %s %s\n",
+					 type2name[entry->type], idx,
+					 phys_addr(entry), entry->pfn,
+					 entry->dev_addr, entry->size,
+					 dir2name[entry->direction],
+					 maperr2str[entry->map_err_type]);
+			}
+		}
+
+		spin_unlock_irqrestore(&bucket->lock, flags);
+	}
+}
+
+/*
+ * For each mapping (initial cacheline in the case of
+ * dma_alloc_coherent/dma_map_page, initial cacheline in each page of a
+ * scatterlist, or the cacheline specified in dma_map_single) insert
+ * into this tree using the cacheline as the key. At
+ * dma_unmap_{single|sg|page} or dma_free_coherent delete the entry.  If
+ * the entry already exists at insertion time add a tag as a reference
+ * count for the overlapping mappings.  For now, the overlap tracking
+ * just ensures that 'unmaps' balance 'maps' before marking the
+ * cacheline idle, but we should also be flagging overlaps as an API
+ * violation.
+ *
+ * Memory usage is mostly constrained by the maximum number of available
+ * dma-debug entries in that we need a free dma_debug_entry before
+ * inserting into the tree.  In the case of dma_map_page and
+ * dma_alloc_coherent there is only one dma_debug_entry and one
+ * dma_active_cacheline entry to track per event.  dma_map_sg(), on the
+ * other hand, consumes a single dma_debug_entry, but inserts 'nents'
+ * entries into the tree.
+ *
+ * At any time debug_dma_assert_idle() can be called to trigger a
+ * warning if any cachelines in the given page are in the active set.
+ */
+static RADIX_TREE(dma_active_cacheline, GFP_NOWAIT);
+static DEFINE_SPINLOCK(radix_lock);
+#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)
+#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)
+#define CACHELINES_PER_PAGE (1 << CACHELINE_PER_PAGE_SHIFT)
+
+static phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)
+{
+	return (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +
+		(entry->offset >> L1_CACHE_SHIFT);
+}
+
+static int active_cacheline_read_overlap(phys_addr_t cln)
+{
+	int overlap = 0, i;
+
+	for (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)
+		if (radix_tree_tag_get(&dma_active_cacheline, cln, i))
+			overlap |= 1 << i;
+	return overlap;
+}
+
+static int active_cacheline_set_overlap(phys_addr_t cln, int overlap)
+{
+	int i;
+
+	if (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)
+		return overlap;
+
+	for (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)
+		if (overlap & 1 << i)
+			radix_tree_tag_set(&dma_active_cacheline, cln, i);
+		else
+			radix_tree_tag_clear(&dma_active_cacheline, cln, i);
+
+	return overlap;
+}
+
+static void active_cacheline_inc_overlap(phys_addr_t cln)
+{
+	int overlap = active_cacheline_read_overlap(cln);
+
+	overlap = active_cacheline_set_overlap(cln, ++overlap);
+
+	/* If we overflowed the overlap counter then we're potentially
+	 * leaking dma-mappings.  Otherwise, if maps and unmaps are
+	 * balanced then this overflow may cause false negatives in
+	 * debug_dma_assert_idle() as the cacheline may be marked idle
+	 * prematurely.
+	 */
+	WARN_ONCE(overlap > ACTIVE_CACHELINE_MAX_OVERLAP,
+		  "DMA-API: exceeded %d overlapping mappings of cacheline %pa\n",
+		  ACTIVE_CACHELINE_MAX_OVERLAP, &cln);
+}
+
+static int active_cacheline_dec_overlap(phys_addr_t cln)
+{
+	int overlap = active_cacheline_read_overlap(cln);
+
+	return active_cacheline_set_overlap(cln, --overlap);
+}
+
+static int active_cacheline_insert(struct dma_debug_entry *entry)
+{
+	phys_addr_t cln = to_cacheline_number(entry);
+	unsigned long flags;
+	int rc;
+
+	/* If the device is not writing memory then we don't have any
+	 * concerns about the cpu consuming stale data.  This mitigates
+	 * legitimate usages of overlapping mappings.
+	 */
+	if (entry->direction == DMA_TO_DEVICE)
+		return 0;
+
+	spin_lock_irqsave(&radix_lock, flags);
+	rc = radix_tree_insert(&dma_active_cacheline, cln, entry);
+	if (rc == -EEXIST)
+		active_cacheline_inc_overlap(cln);
+	spin_unlock_irqrestore(&radix_lock, flags);
+
+	return rc;
+}
+
+static void active_cacheline_remove(struct dma_debug_entry *entry)
+{
+	phys_addr_t cln = to_cacheline_number(entry);
+	unsigned long flags;
+
+	/* ...mirror the insert case */
+	if (entry->direction == DMA_TO_DEVICE)
+		return;
+
+	spin_lock_irqsave(&radix_lock, flags);
+	/* since we are counting overlaps the final put of the
+	 * cacheline will occur when the overlap count is 0.
+	 * active_cacheline_dec_overlap() returns -1 in that case
+	 */
+	if (active_cacheline_dec_overlap(cln) < 0)
+		radix_tree_delete(&dma_active_cacheline, cln);
+	spin_unlock_irqrestore(&radix_lock, flags);
+}
+
+/**
+ * debug_dma_assert_idle() - assert that a page is not undergoing dma
+ * @page: page to lookup in the dma_active_cacheline tree
+ *
+ * Place a call to this routine in cases where the cpu touching the page
+ * before the dma completes (page is dma_unmapped) will lead to data
+ * corruption.
+ */
+void debug_dma_assert_idle(struct page *page)
+{
+	static struct dma_debug_entry *ents[CACHELINES_PER_PAGE];
+	struct dma_debug_entry *entry = NULL;
+	void **results = (void **) &ents;
+	unsigned int nents, i;
+	unsigned long flags;
+	phys_addr_t cln;
+
+	if (dma_debug_disabled())
+		return;
+
+	if (!page)
+		return;
+
+	cln = (phys_addr_t) page_to_pfn(page) << CACHELINE_PER_PAGE_SHIFT;
+	spin_lock_irqsave(&radix_lock, flags);
+	nents = radix_tree_gang_lookup(&dma_active_cacheline, results, cln,
+				       CACHELINES_PER_PAGE);
+	for (i = 0; i < nents; i++) {
+		phys_addr_t ent_cln = to_cacheline_number(ents[i]);
+
+		if (ent_cln == cln) {
+			entry = ents[i];
+			break;
+		} else if (ent_cln >= cln + CACHELINES_PER_PAGE)
+			break;
+	}
+	spin_unlock_irqrestore(&radix_lock, flags);
+
+	if (!entry)
+		return;
+
+	cln = to_cacheline_number(entry);
+	err_printk(entry->dev, entry,
+		   "DMA-API: cpu touching an active dma mapped cacheline [cln=%pa]\n",
+		   &cln);
+}
+
+/*
+ * Wrapper function for adding an entry to the hash.
+ * This function takes care of locking itself.
+ */
+static void add_dma_entry(struct dma_debug_entry *entry)
+{
+	struct hash_bucket *bucket;
+	unsigned long flags;
+	int rc;
+
+	bucket = get_hash_bucket(entry, &flags);
+	hash_bucket_add(bucket, entry);
+	put_hash_bucket(bucket, &flags);
+
+	rc = active_cacheline_insert(entry);
+	if (rc == -ENOMEM) {
+		pr_err("DMA-API: cacheline tracking ENOMEM, dma-debug disabled\n");
+		global_disable = true;
+	}
+
+	/* TODO: report -EEXIST errors here as overlapping mappings are
+	 * not supported by the DMA API
+	 */
+}
+
+static struct dma_debug_entry *__dma_entry_alloc(void)
+{
+	struct dma_debug_entry *entry;
+
+	entry = list_entry(free_entries.next, struct dma_debug_entry, list);
+	list_del(&entry->list);
+	memset(entry, 0, sizeof(*entry));
+
+	num_free_entries -= 1;
+	if (num_free_entries < min_free_entries)
+		min_free_entries = num_free_entries;
+
+	return entry;
+}
+
+/* struct dma_entry allocator
+ *
+ * The next two functions implement the allocator for
+ * struct dma_debug_entries.
+ */
+static struct dma_debug_entry *dma_entry_alloc(void)
+{
+	struct dma_debug_entry *entry;
+	unsigned long flags;
+
+	spin_lock_irqsave(&free_entries_lock, flags);
+
+	if (list_empty(&free_entries)) {
+		global_disable = true;
+		spin_unlock_irqrestore(&free_entries_lock, flags);
+		pr_err("DMA-API: debugging out of memory - disabling\n");
+		return NULL;
+	}
+
+	entry = __dma_entry_alloc();
+
+	spin_unlock_irqrestore(&free_entries_lock, flags);
+
+#ifdef CONFIG_STACKTRACE
+	entry->stacktrace.max_entries = DMA_DEBUG_STACKTRACE_ENTRIES;
+	entry->stacktrace.entries = entry->st_entries;
+	entry->stacktrace.skip = 2;
+	save_stack_trace(&entry->stacktrace);
+#endif
+
+	return entry;
+}
+
+static void dma_entry_free(struct dma_debug_entry *entry)
+{
+	unsigned long flags;
+
+	active_cacheline_remove(entry);
+
+	/*
+	 * add to beginning of the list - this way the entries are
+	 * more likely cache hot when they are reallocated.
+	 */
+	spin_lock_irqsave(&free_entries_lock, flags);
+	list_add(&entry->list, &free_entries);
+	num_free_entries += 1;
+	spin_unlock_irqrestore(&free_entries_lock, flags);
+}
+
+int dma_debug_resize_entries(u32 num_entries)
+{
+	int i, delta, ret = 0;
+	unsigned long flags;
+	struct dma_debug_entry *entry;
+	LIST_HEAD(tmp);
+
+	spin_lock_irqsave(&free_entries_lock, flags);
+
+	if (nr_total_entries < num_entries) {
+		delta = num_entries - nr_total_entries;
+
+		spin_unlock_irqrestore(&free_entries_lock, flags);
+
+		for (i = 0; i < delta; i++) {
+			entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+			if (!entry)
+				break;
+
+			list_add_tail(&entry->list, &tmp);
+		}
+
+		spin_lock_irqsave(&free_entries_lock, flags);
+
+		list_splice(&tmp, &free_entries);
+		nr_total_entries += i;
+		num_free_entries += i;
+	} else {
+		delta = nr_total_entries - num_entries;
+
+		for (i = 0; i < delta && !list_empty(&free_entries); i++) {
+			entry = __dma_entry_alloc();
+			kfree(entry);
+		}
+
+		nr_total_entries -= i;
+	}
+
+	if (nr_total_entries != num_entries)
+		ret = 1;
+
+	spin_unlock_irqrestore(&free_entries_lock, flags);
+
+	return ret;
+}
+
+/*
+ * DMA-API debugging init code
+ *
+ * The init code does two things:
+ *   1. Initialize core data structures
+ *   2. Preallocate a given number of dma_debug_entry structs
+ */
+
+static int prealloc_memory(u32 num_entries)
+{
+	struct dma_debug_entry *entry, *next_entry;
+	int i;
+
+	for (i = 0; i < num_entries; ++i) {
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+		if (!entry)
+			goto out_err;
+
+		list_add_tail(&entry->list, &free_entries);
+	}
+
+	num_free_entries = num_entries;
+	min_free_entries = num_entries;
+
+	pr_info("DMA-API: preallocated %d debug entries\n", num_entries);
+
+	return 0;
+
+out_err:
+
+	list_for_each_entry_safe(entry, next_entry, &free_entries, list) {
+		list_del(&entry->list);
+		kfree(entry);
+	}
+
+	return -ENOMEM;
+}
+
+static ssize_t filter_read(struct file *file, char __user *user_buf,
+			   size_t count, loff_t *ppos)
+{
+	char buf[NAME_MAX_LEN + 1];
+	unsigned long flags;
+	int len;
+
+	if (!current_driver_name[0])
+		return 0;
+
+	/*
+	 * We can't copy to userspace directly because current_driver_name can
+	 * only be read under the driver_name_lock with irqs disabled. So
+	 * create a temporary copy first.
+	 */
+	read_lock_irqsave(&driver_name_lock, flags);
+	len = scnprintf(buf, NAME_MAX_LEN + 1, "%s\n", current_driver_name);
+	read_unlock_irqrestore(&driver_name_lock, flags);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t filter_write(struct file *file, const char __user *userbuf,
+			    size_t count, loff_t *ppos)
+{
+	char buf[NAME_MAX_LEN];
+	unsigned long flags;
+	size_t len;
+	int i;
+
+	/*
+	 * We can't copy from userspace directly. Access to
+	 * current_driver_name is protected with a write_lock with irqs
+	 * disabled. Since copy_from_user can fault and may sleep we
+	 * need to copy to temporary buffer first
+	 */
+	len = min(count, (size_t)(NAME_MAX_LEN - 1));
+	if (copy_from_user(buf, userbuf, len))
+		return -EFAULT;
+
+	buf[len] = 0;
+
+	write_lock_irqsave(&driver_name_lock, flags);
+
+	/*
+	 * Now handle the string we got from userspace very carefully.
+	 * The rules are:
+	 *         - only use the first token we got
+	 *         - token delimiter is everything looking like a space
+	 *           character (' ', '\n', '\t' ...)
+	 *
+	 */
+	if (!isalnum(buf[0])) {
+		/*
+		 * If the first character userspace gave us is not
+		 * alphanumerical then assume the filter should be
+		 * switched off.
+		 */
+		if (current_driver_name[0])
+			pr_info("DMA-API: switching off dma-debug driver filter\n");
+		current_driver_name[0] = 0;
+		current_driver = NULL;
+		goto out_unlock;
+	}
+
+	/*
+	 * Now parse out the first token and use it as the name for the
+	 * driver to filter for.
+	 */
+	for (i = 0; i < NAME_MAX_LEN - 1; ++i) {
+		current_driver_name[i] = buf[i];
+		if (isspace(buf[i]) || buf[i] == ' ' || buf[i] == 0)
+			break;
+	}
+	current_driver_name[i] = 0;
+	current_driver = NULL;
+
+	pr_info("DMA-API: enable driver filter for driver [%s]\n",
+		current_driver_name);
+
+out_unlock:
+	write_unlock_irqrestore(&driver_name_lock, flags);
+
+	return count;
+}
+
+static const struct file_operations filter_fops = {
+	.read  = filter_read,
+	.write = filter_write,
+	.llseek = default_llseek,
+};
+
+static int dma_debug_fs_init(void)
+{
+	dma_debug_dent = debugfs_create_dir("dma-api", NULL);
+	if (!dma_debug_dent) {
+		pr_err("DMA-API: can not create debugfs directory\n");
+		return -ENOMEM;
+	}
+
+	global_disable_dent = debugfs_create_bool("disabled", 0444,
+			dma_debug_dent,
+			&global_disable);
+	if (!global_disable_dent)
+		goto out_err;
+
+	error_count_dent = debugfs_create_u32("error_count", 0444,
+			dma_debug_dent, &error_count);
+	if (!error_count_dent)
+		goto out_err;
+
+	show_all_errors_dent = debugfs_create_u32("all_errors", 0644,
+			dma_debug_dent,
+			&show_all_errors);
+	if (!show_all_errors_dent)
+		goto out_err;
+
+	show_num_errors_dent = debugfs_create_u32("num_errors", 0644,
+			dma_debug_dent,
+			&show_num_errors);
+	if (!show_num_errors_dent)
+		goto out_err;
+
+	num_free_entries_dent = debugfs_create_u32("num_free_entries", 0444,
+			dma_debug_dent,
+			&num_free_entries);
+	if (!num_free_entries_dent)
+		goto out_err;
+
+	min_free_entries_dent = debugfs_create_u32("min_free_entries", 0444,
+			dma_debug_dent,
+			&min_free_entries);
+	if (!min_free_entries_dent)
+		goto out_err;
+
+	filter_dent = debugfs_create_file("driver_filter", 0644,
+					  dma_debug_dent, NULL, &filter_fops);
+	if (!filter_dent)
+		goto out_err;
+
+	return 0;
+
+out_err:
+	debugfs_remove_recursive(dma_debug_dent);
+
+	return -ENOMEM;
+}
+
+static int device_dma_allocations(struct device *dev, struct dma_debug_entry **out_entry)
+{
+	struct dma_debug_entry *entry;
+	unsigned long flags;
+	int count = 0, i;
+
+	for (i = 0; i < HASH_SIZE; ++i) {
+		spin_lock_irqsave(&dma_entry_hash[i].lock, flags);
+		list_for_each_entry(entry, &dma_entry_hash[i].list, list) {
+			if (entry->dev == dev) {
+				count += 1;
+				*out_entry = entry;
+			}
+		}
+		spin_unlock_irqrestore(&dma_entry_hash[i].lock, flags);
+	}
+
+	return count;
+}
+
+static int dma_debug_device_change(struct notifier_block *nb, unsigned long action, void *data)
+{
+	struct device *dev = data;
+	struct dma_debug_entry *uninitialized_var(entry);
+	int count;
+
+	if (dma_debug_disabled())
+		return 0;
+
+	switch (action) {
+	case BUS_NOTIFY_UNBOUND_DRIVER:
+		count = device_dma_allocations(dev, &entry);
+		if (count == 0)
+			break;
+		err_printk(dev, entry, "DMA-API: device driver has pending "
+				"DMA allocations while released from device "
+				"[count=%d]\n"
+				"One of leaked entries details: "
+				"[device address=0x%016llx] [size=%llu bytes] "
+				"[mapped with %s] [mapped as %s]\n",
+			count, entry->dev_addr, entry->size,
+			dir2name[entry->direction], type2name[entry->type]);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+void dma_debug_add_bus(struct bus_type *bus)
+{
+	struct notifier_block *nb;
+
+	if (dma_debug_disabled())
+		return;
+
+	nb = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);
+	if (nb == NULL) {
+		pr_err("dma_debug_add_bus: out of memory\n");
+		return;
+	}
+
+	nb->notifier_call = dma_debug_device_change;
+
+	bus_register_notifier(bus, nb);
+}
+
+static int dma_debug_init(void)
+{
+	int i;
+
+	/* Do not use dma_debug_initialized here, since we really want to be
+	 * called to set dma_debug_initialized
+	 */
+	if (global_disable)
+		return 0;
+
+	for (i = 0; i < HASH_SIZE; ++i) {
+		INIT_LIST_HEAD(&dma_entry_hash[i].list);
+		spin_lock_init(&dma_entry_hash[i].lock);
+	}
+
+	if (dma_debug_fs_init() != 0) {
+		pr_err("DMA-API: error creating debugfs entries - disabling\n");
+		global_disable = true;
+
+		return 0;
+	}
+
+	if (prealloc_memory(nr_prealloc_entries) != 0) {
+		pr_err("DMA-API: debugging out of memory error - disabled\n");
+		global_disable = true;
+
+		return 0;
+	}
+
+	nr_total_entries = num_free_entries;
+
+	dma_debug_initialized = true;
+
+	pr_info("DMA-API: debugging enabled by kernel config\n");
+	return 0;
+}
+core_initcall(dma_debug_init);
+
+static __init int dma_debug_cmdline(char *str)
+{
+	if (!str)
+		return -EINVAL;
+
+	if (strncmp(str, "off", 3) == 0) {
+		pr_info("DMA-API: debugging disabled on kernel command line\n");
+		global_disable = true;
+	}
+
+	return 0;
+}
+
+static __init int dma_debug_entries_cmdline(char *str)
+{
+	if (!str)
+		return -EINVAL;
+	if (!get_option(&str, &nr_prealloc_entries))
+		nr_prealloc_entries = PREALLOC_DMA_DEBUG_ENTRIES;
+	return 0;
+}
+
+__setup("dma_debug=", dma_debug_cmdline);
+__setup("dma_debug_entries=", dma_debug_entries_cmdline);
+
+static void check_unmap(struct dma_debug_entry *ref)
+{
+	struct dma_debug_entry *entry;
+	struct hash_bucket *bucket;
+	unsigned long flags;
+
+	bucket = get_hash_bucket(ref, &flags);
+	entry = bucket_find_exact(bucket, ref);
+
+	if (!entry) {
+		/* must drop lock before calling dma_mapping_error */
+		put_hash_bucket(bucket, &flags);
+
+		if (dma_mapping_error(ref->dev, ref->dev_addr)) {
+			err_printk(ref->dev, NULL,
+				   "DMA-API: device driver tries to free an "
+				   "invalid DMA memory address\n");
+		} else {
+			err_printk(ref->dev, NULL,
+				   "DMA-API: device driver tries to free DMA "
+				   "memory it has not allocated [device "
+				   "address=0x%016llx] [size=%llu bytes]\n",
+				   ref->dev_addr, ref->size);
+		}
+		return;
+	}
+
+	if (ref->size != entry->size) {
+		err_printk(ref->dev, entry, "DMA-API: device driver frees "
+			   "DMA memory with different size "
+			   "[device address=0x%016llx] [map size=%llu bytes] "
+			   "[unmap size=%llu bytes]\n",
+			   ref->dev_addr, entry->size, ref->size);
+	}
+
+	if (ref->type != entry->type) {
+		err_printk(ref->dev, entry, "DMA-API: device driver frees "
+			   "DMA memory with wrong function "
+			   "[device address=0x%016llx] [size=%llu bytes] "
+			   "[mapped as %s] [unmapped as %s]\n",
+			   ref->dev_addr, ref->size,
+			   type2name[entry->type], type2name[ref->type]);
+	} else if ((entry->type == dma_debug_coherent) &&
+		   (phys_addr(ref) != phys_addr(entry))) {
+		err_printk(ref->dev, entry, "DMA-API: device driver frees "
+			   "DMA memory with different CPU address "
+			   "[device address=0x%016llx] [size=%llu bytes] "
+			   "[cpu alloc address=0x%016llx] "
+			   "[cpu free address=0x%016llx]",
+			   ref->dev_addr, ref->size,
+			   phys_addr(entry),
+			   phys_addr(ref));
+	}
+
+	if (ref->sg_call_ents && ref->type == dma_debug_sg &&
+	    ref->sg_call_ents != entry->sg_call_ents) {
+		err_printk(ref->dev, entry, "DMA-API: device driver frees "
+			   "DMA sg list with different entry count "
+			   "[map count=%d] [unmap count=%d]\n",
+			   entry->sg_call_ents, ref->sg_call_ents);
+	}
+
+	/*
+	 * This may be no bug in reality - but most implementations of the
+	 * DMA API don't handle this properly, so check for it here
+	 */
+	if (ref->direction != entry->direction) {
+		err_printk(ref->dev, entry, "DMA-API: device driver frees "
+			   "DMA memory with different direction "
+			   "[device address=0x%016llx] [size=%llu bytes] "
+			   "[mapped with %s] [unmapped with %s]\n",
+			   ref->dev_addr, ref->size,
+			   dir2name[entry->direction],
+			   dir2name[ref->direction]);
+	}
+
+	/*
+	 * Drivers should use dma_mapping_error() to check the returned
+	 * addresses of dma_map_single() and dma_map_page().
+	 * If not, print this warning message. See Documentation/DMA-API.txt.
+	 */
+	if (entry->map_err_type == MAP_ERR_NOT_CHECKED) {
+		err_printk(ref->dev, entry,
+			   "DMA-API: device driver failed to check map error"
+			   "[device address=0x%016llx] [size=%llu bytes] "
+			   "[mapped as %s]",
+			   ref->dev_addr, ref->size,
+			   type2name[entry->type]);
+	}
+
+	hash_bucket_del(entry);
+	dma_entry_free(entry);
+
+	put_hash_bucket(bucket, &flags);
+}
+
+static void check_for_stack(struct device *dev,
+			    struct page *page, size_t offset)
+{
+	void *addr;
+	struct vm_struct *stack_vm_area = task_stack_vm_area(current);
+
+	if (!stack_vm_area) {
+		/* Stack is direct-mapped. */
+		if (PageHighMem(page))
+			return;
+		addr = page_address(page) + offset;
+		if (object_is_on_stack(addr))
+			err_printk(dev, NULL, "DMA-API: device driver maps memory from stack [addr=%p]\n", addr);
+	} else {
+		/* Stack is vmalloced. */
+		int i;
+
+		for (i = 0; i < stack_vm_area->nr_pages; i++) {
+			if (page != stack_vm_area->pages[i])
+				continue;
+
+			addr = (u8 *)current->stack + i * PAGE_SIZE + offset;
+			err_printk(dev, NULL, "DMA-API: device driver maps memory from stack [probable addr=%p]\n", addr);
+			break;
+		}
+	}
+}
+
+static inline bool overlap(void *addr, unsigned long len, void *start, void *end)
+{
+	unsigned long a1 = (unsigned long)addr;
+	unsigned long b1 = a1 + len;
+	unsigned long a2 = (unsigned long)start;
+	unsigned long b2 = (unsigned long)end;
+
+	return !(b1 <= a2 || a1 >= b2);
+}
+
+static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)
+{
+	if (overlap(addr, len, _stext, _etext) ||
+	    overlap(addr, len, __start_rodata, __end_rodata))
+		err_printk(dev, NULL, "DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\n", addr, len);
+}
+
+static void check_sync(struct device *dev,
+		       struct dma_debug_entry *ref,
+		       bool to_cpu)
+{
+	struct dma_debug_entry *entry;
+	struct hash_bucket *bucket;
+	unsigned long flags;
+
+	bucket = get_hash_bucket(ref, &flags);
+
+	entry = bucket_find_contain(&bucket, ref, &flags);
+
+	if (!entry) {
+		err_printk(dev, NULL, "DMA-API: device driver tries "
+				"to sync DMA memory it has not allocated "
+				"[device address=0x%016llx] [size=%llu bytes]\n",
+				(unsigned long long)ref->dev_addr, ref->size);
+		goto out;
+	}
+
+	if (ref->size > entry->size) {
+		err_printk(dev, entry, "DMA-API: device driver syncs"
+				" DMA memory outside allocated range "
+				"[device address=0x%016llx] "
+				"[allocation size=%llu bytes] "
+				"[sync offset+size=%llu]\n",
+				entry->dev_addr, entry->size,
+				ref->size);
+	}
+
+	if (entry->direction == DMA_BIDIRECTIONAL)
+		goto out;
+
+	if (ref->direction != entry->direction) {
+		err_printk(dev, entry, "DMA-API: device driver syncs "
+				"DMA memory with different direction "
+				"[device address=0x%016llx] [size=%llu bytes] "
+				"[mapped with %s] [synced with %s]\n",
+				(unsigned long long)ref->dev_addr, entry->size,
+				dir2name[entry->direction],
+				dir2name[ref->direction]);
+	}
+
+	if (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&
+		      !(ref->direction == DMA_TO_DEVICE))
+		err_printk(dev, entry, "DMA-API: device driver syncs "
+				"device read-only DMA memory for cpu "
+				"[device address=0x%016llx] [size=%llu bytes] "
+				"[mapped with %s] [synced with %s]\n",
+				(unsigned long long)ref->dev_addr, entry->size,
+				dir2name[entry->direction],
+				dir2name[ref->direction]);
+
+	if (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&
+		       !(ref->direction == DMA_FROM_DEVICE))
+		err_printk(dev, entry, "DMA-API: device driver syncs "
+				"device write-only DMA memory to device "
+				"[device address=0x%016llx] [size=%llu bytes] "
+				"[mapped with %s] [synced with %s]\n",
+				(unsigned long long)ref->dev_addr, entry->size,
+				dir2name[entry->direction],
+				dir2name[ref->direction]);
+
+	if (ref->sg_call_ents && ref->type == dma_debug_sg &&
+	    ref->sg_call_ents != entry->sg_call_ents) {
+		err_printk(ref->dev, entry, "DMA-API: device driver syncs "
+			   "DMA sg list with different entry count "
+			   "[map count=%d] [sync count=%d]\n",
+			   entry->sg_call_ents, ref->sg_call_ents);
+	}
+
+out:
+	put_hash_bucket(bucket, &flags);
+}
+
+void debug_dma_map_page(struct device *dev, struct page *page, size_t offset,
+			size_t size, int direction, dma_addr_t dma_addr,
+			bool map_single)
+{
+	struct dma_debug_entry *entry;
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	if (dma_mapping_error(dev, dma_addr))
+		return;
+
+	entry = dma_entry_alloc();
+	if (!entry)
+		return;
+
+	entry->dev       = dev;
+	entry->type      = dma_debug_page;
+	entry->pfn	 = page_to_pfn(page);
+	entry->offset	 = offset,
+	entry->dev_addr  = dma_addr;
+	entry->size      = size;
+	entry->direction = direction;
+	entry->map_err_type = MAP_ERR_NOT_CHECKED;
+
+	if (map_single)
+		entry->type = dma_debug_single;
+
+	check_for_stack(dev, page, offset);
+
+	if (!PageHighMem(page)) {
+		void *addr = page_address(page) + offset;
+
+		check_for_illegal_area(dev, addr, size);
+	}
+
+	add_dma_entry(entry);
+}
+EXPORT_SYMBOL(debug_dma_map_page);
+
+void debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
+{
+	struct dma_debug_entry ref;
+	struct dma_debug_entry *entry;
+	struct hash_bucket *bucket;
+	unsigned long flags;
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	ref.dev = dev;
+	ref.dev_addr = dma_addr;
+	bucket = get_hash_bucket(&ref, &flags);
+
+	list_for_each_entry(entry, &bucket->list, list) {
+		if (!exact_match(&ref, entry))
+			continue;
+
+		/*
+		 * The same physical address can be mapped multiple
+		 * times. Without a hardware IOMMU this results in the
+		 * same device addresses being put into the dma-debug
+		 * hash multiple times too. This can result in false
+		 * positives being reported. Therefore we implement a
+		 * best-fit algorithm here which updates the first entry
+		 * from the hash which fits the reference value and is
+		 * not currently listed as being checked.
+		 */
+		if (entry->map_err_type == MAP_ERR_NOT_CHECKED) {
+			entry->map_err_type = MAP_ERR_CHECKED;
+			break;
+		}
+	}
+
+	put_hash_bucket(bucket, &flags);
+}
+EXPORT_SYMBOL(debug_dma_mapping_error);
+
+void debug_dma_unmap_page(struct device *dev, dma_addr_t addr,
+			  size_t size, int direction, bool map_single)
+{
+	struct dma_debug_entry ref = {
+		.type           = dma_debug_page,
+		.dev            = dev,
+		.dev_addr       = addr,
+		.size           = size,
+		.direction      = direction,
+	};
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	if (map_single)
+		ref.type = dma_debug_single;
+
+	check_unmap(&ref);
+}
+EXPORT_SYMBOL(debug_dma_unmap_page);
+
+void debug_dma_map_sg(struct device *dev, struct scatterlist *sg,
+		      int nents, int mapped_ents, int direction)
+{
+	struct dma_debug_entry *entry;
+	struct scatterlist *s;
+	int i;
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	for_each_sg(sg, s, mapped_ents, i) {
+		entry = dma_entry_alloc();
+		if (!entry)
+			return;
+
+		entry->type           = dma_debug_sg;
+		entry->dev            = dev;
+		entry->pfn	      = page_to_pfn(sg_page(s));
+		entry->offset	      = s->offset,
+		entry->size           = sg_dma_len(s);
+		entry->dev_addr       = sg_dma_address(s);
+		entry->direction      = direction;
+		entry->sg_call_ents   = nents;
+		entry->sg_mapped_ents = mapped_ents;
+
+		check_for_stack(dev, sg_page(s), s->offset);
+
+		if (!PageHighMem(sg_page(s))) {
+			check_for_illegal_area(dev, sg_virt(s), sg_dma_len(s));
+		}
+
+		add_dma_entry(entry);
+	}
+}
+EXPORT_SYMBOL(debug_dma_map_sg);
+
+static int get_nr_mapped_entries(struct device *dev,
+				 struct dma_debug_entry *ref)
+{
+	struct dma_debug_entry *entry;
+	struct hash_bucket *bucket;
+	unsigned long flags;
+	int mapped_ents;
+
+	bucket       = get_hash_bucket(ref, &flags);
+	entry        = bucket_find_exact(bucket, ref);
+	mapped_ents  = 0;
+
+	if (entry)
+		mapped_ents = entry->sg_mapped_ents;
+	put_hash_bucket(bucket, &flags);
+
+	return mapped_ents;
+}
+
+void debug_dma_unmap_sg(struct device *dev, struct scatterlist *sglist,
+			int nelems, int dir)
+{
+	struct scatterlist *s;
+	int mapped_ents = 0, i;
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	for_each_sg(sglist, s, nelems, i) {
+
+		struct dma_debug_entry ref = {
+			.type           = dma_debug_sg,
+			.dev            = dev,
+			.pfn		= page_to_pfn(sg_page(s)),
+			.offset		= s->offset,
+			.dev_addr       = sg_dma_address(s),
+			.size           = sg_dma_len(s),
+			.direction      = dir,
+			.sg_call_ents   = nelems,
+		};
+
+		if (mapped_ents && i >= mapped_ents)
+			break;
+
+		if (!i)
+			mapped_ents = get_nr_mapped_entries(dev, &ref);
+
+		check_unmap(&ref);
+	}
+}
+EXPORT_SYMBOL(debug_dma_unmap_sg);
+
+void debug_dma_alloc_coherent(struct device *dev, size_t size,
+			      dma_addr_t dma_addr, void *virt)
+{
+	struct dma_debug_entry *entry;
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	if (unlikely(virt == NULL))
+		return;
+
+	/* handle vmalloc and linear addresses */
+	if (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))
+		return;
+
+	entry = dma_entry_alloc();
+	if (!entry)
+		return;
+
+	entry->type      = dma_debug_coherent;
+	entry->dev       = dev;
+	entry->offset	 = offset_in_page(virt);
+	entry->size      = size;
+	entry->dev_addr  = dma_addr;
+	entry->direction = DMA_BIDIRECTIONAL;
+
+	if (is_vmalloc_addr(virt))
+		entry->pfn = vmalloc_to_pfn(virt);
+	else
+		entry->pfn = page_to_pfn(virt_to_page(virt));
+
+	add_dma_entry(entry);
+}
+EXPORT_SYMBOL(debug_dma_alloc_coherent);
+
+void debug_dma_free_coherent(struct device *dev, size_t size,
+			 void *virt, dma_addr_t addr)
+{
+	struct dma_debug_entry ref = {
+		.type           = dma_debug_coherent,
+		.dev            = dev,
+		.offset		= offset_in_page(virt),
+		.dev_addr       = addr,
+		.size           = size,
+		.direction      = DMA_BIDIRECTIONAL,
+	};
+
+	/* handle vmalloc and linear addresses */
+	if (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))
+		return;
+
+	if (is_vmalloc_addr(virt))
+		ref.pfn = vmalloc_to_pfn(virt);
+	else
+		ref.pfn = page_to_pfn(virt_to_page(virt));
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	check_unmap(&ref);
+}
+EXPORT_SYMBOL(debug_dma_free_coherent);
+
+void debug_dma_map_resource(struct device *dev, phys_addr_t addr, size_t size,
+			    int direction, dma_addr_t dma_addr)
+{
+	struct dma_debug_entry *entry;
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	entry = dma_entry_alloc();
+	if (!entry)
+		return;
+
+	entry->type		= dma_debug_resource;
+	entry->dev		= dev;
+	entry->pfn		= PHYS_PFN(addr);
+	entry->offset		= offset_in_page(addr);
+	entry->size		= size;
+	entry->dev_addr		= dma_addr;
+	entry->direction	= direction;
+	entry->map_err_type	= MAP_ERR_NOT_CHECKED;
+
+	add_dma_entry(entry);
+}
+EXPORT_SYMBOL(debug_dma_map_resource);
+
+void debug_dma_unmap_resource(struct device *dev, dma_addr_t dma_addr,
+			      size_t size, int direction)
+{
+	struct dma_debug_entry ref = {
+		.type           = dma_debug_resource,
+		.dev            = dev,
+		.dev_addr       = dma_addr,
+		.size           = size,
+		.direction      = direction,
+	};
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	check_unmap(&ref);
+}
+EXPORT_SYMBOL(debug_dma_unmap_resource);
+
+void debug_dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,
+				   size_t size, int direction)
+{
+	struct dma_debug_entry ref;
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	ref.type         = dma_debug_single;
+	ref.dev          = dev;
+	ref.dev_addr     = dma_handle;
+	ref.size         = size;
+	ref.direction    = direction;
+	ref.sg_call_ents = 0;
+
+	check_sync(dev, &ref, true);
+}
+EXPORT_SYMBOL(debug_dma_sync_single_for_cpu);
+
+void debug_dma_sync_single_for_device(struct device *dev,
+				      dma_addr_t dma_handle, size_t size,
+				      int direction)
+{
+	struct dma_debug_entry ref;
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	ref.type         = dma_debug_single;
+	ref.dev          = dev;
+	ref.dev_addr     = dma_handle;
+	ref.size         = size;
+	ref.direction    = direction;
+	ref.sg_call_ents = 0;
+
+	check_sync(dev, &ref, false);
+}
+EXPORT_SYMBOL(debug_dma_sync_single_for_device);
+
+void debug_dma_sync_single_range_for_cpu(struct device *dev,
+					 dma_addr_t dma_handle,
+					 unsigned long offset, size_t size,
+					 int direction)
+{
+	struct dma_debug_entry ref;
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	ref.type         = dma_debug_single;
+	ref.dev          = dev;
+	ref.dev_addr     = dma_handle;
+	ref.size         = offset + size;
+	ref.direction    = direction;
+	ref.sg_call_ents = 0;
+
+	check_sync(dev, &ref, true);
+}
+EXPORT_SYMBOL(debug_dma_sync_single_range_for_cpu);
+
+void debug_dma_sync_single_range_for_device(struct device *dev,
+					    dma_addr_t dma_handle,
+					    unsigned long offset,
+					    size_t size, int direction)
+{
+	struct dma_debug_entry ref;
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	ref.type         = dma_debug_single;
+	ref.dev          = dev;
+	ref.dev_addr     = dma_handle;
+	ref.size         = offset + size;
+	ref.direction    = direction;
+	ref.sg_call_ents = 0;
+
+	check_sync(dev, &ref, false);
+}
+EXPORT_SYMBOL(debug_dma_sync_single_range_for_device);
+
+void debug_dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
+			       int nelems, int direction)
+{
+	struct scatterlist *s;
+	int mapped_ents = 0, i;
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	for_each_sg(sg, s, nelems, i) {
+
+		struct dma_debug_entry ref = {
+			.type           = dma_debug_sg,
+			.dev            = dev,
+			.pfn		= page_to_pfn(sg_page(s)),
+			.offset		= s->offset,
+			.dev_addr       = sg_dma_address(s),
+			.size           = sg_dma_len(s),
+			.direction      = direction,
+			.sg_call_ents   = nelems,
+		};
+
+		if (!i)
+			mapped_ents = get_nr_mapped_entries(dev, &ref);
+
+		if (i >= mapped_ents)
+			break;
+
+		check_sync(dev, &ref, true);
+	}
+}
+EXPORT_SYMBOL(debug_dma_sync_sg_for_cpu);
+
+void debug_dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
+				  int nelems, int direction)
+{
+	struct scatterlist *s;
+	int mapped_ents = 0, i;
+
+	if (unlikely(dma_debug_disabled()))
+		return;
+
+	for_each_sg(sg, s, nelems, i) {
+
+		struct dma_debug_entry ref = {
+			.type           = dma_debug_sg,
+			.dev            = dev,
+			.pfn		= page_to_pfn(sg_page(s)),
+			.offset		= s->offset,
+			.dev_addr       = sg_dma_address(s),
+			.size           = sg_dma_len(s),
+			.direction      = direction,
+			.sg_call_ents   = nelems,
+		};
+		if (!i)
+			mapped_ents = get_nr_mapped_entries(dev, &ref);
+
+		if (i >= mapped_ents)
+			break;
+
+		check_sync(dev, &ref, false);
+	}
+}
+EXPORT_SYMBOL(debug_dma_sync_sg_for_device);
+
+static int __init dma_debug_driver_setup(char *str)
+{
+	int i;
+
+	for (i = 0; i < NAME_MAX_LEN - 1; ++i, ++str) {
+		current_driver_name[i] = *str;
+		if (*str == 0)
+			break;
+	}
+
+	if (current_driver_name[0])
+		pr_info("DMA-API: enable driver filter for driver [%s]\n",
+			current_driver_name);
+
+
+	return 1;
+}
+__setup("dma_debug_driver=", dma_debug_driver_setup);
diff --git a/kernel/dma/direct.c b/kernel/dma/direct.c
new file mode 100644
index 00000000..0285e3fc
--- /dev/null
+++ b/kernel/dma/direct.c
@@ -0,0 +1,205 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * DMA operations that map physical memory directly without using an IOMMU or
+ * flushing caches.
+ */
+#include <linux/export.h>
+#include <linux/mm.h>
+#include <linux/dma-direct.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-contiguous.h>
+#include <linux/pfn.h>
+#include <linux/set_memory.h>
+
+#define DIRECT_MAPPING_ERROR		0
+
+/*
+ * Most architectures use ZONE_DMA for the first 16 Megabytes, but
+ * some use it for entirely different regions:
+ */
+#ifndef ARCH_ZONE_DMA_BITS
+#define ARCH_ZONE_DMA_BITS 24
+#endif
+
+/*
+ * For AMD SEV all DMA must be to unencrypted addresses.
+ */
+static inline bool force_dma_unencrypted(void)
+{
+	return sev_active();
+}
+
+static bool
+check_addr(struct device *dev, dma_addr_t dma_addr, size_t size,
+		const char *caller)
+{
+	if (unlikely(dev && !dma_capable(dev, dma_addr, size))) {
+		if (!dev->dma_mask) {
+			dev_err(dev,
+				"%s: call on device without dma_mask\n",
+				caller);
+			return false;
+		}
+
+		if (*dev->dma_mask >= DMA_BIT_MASK(32)) {
+			dev_err(dev,
+				"%s: overflow %pad+%zu of device mask %llx\n",
+				caller, &dma_addr, size, *dev->dma_mask);
+		}
+		return false;
+	}
+	return true;
+}
+
+static bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)
+{
+	dma_addr_t addr = force_dma_unencrypted() ?
+		__phys_to_dma(dev, phys) : phys_to_dma(dev, phys);
+	return addr + size - 1 <= dev->coherent_dma_mask;
+}
+
+void *dma_direct_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
+		gfp_t gfp, unsigned long attrs)
+{
+	unsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;
+	int page_order = get_order(size);
+	struct page *page = NULL;
+	void *ret;
+
+	/* we always manually zero the memory once we are done: */
+	gfp &= ~__GFP_ZERO;
+
+	/* GFP_DMA32 and GFP_DMA are no ops without the corresponding zones: */
+	if (dev->coherent_dma_mask <= DMA_BIT_MASK(ARCH_ZONE_DMA_BITS))
+		gfp |= GFP_DMA;
+	if (dev->coherent_dma_mask <= DMA_BIT_MASK(32) && !(gfp & GFP_DMA))
+		gfp |= GFP_DMA32;
+
+again:
+	/* CMA can be used only in the context which permits sleeping */
+	if (gfpflags_allow_blocking(gfp)) {
+		page = dma_alloc_from_contiguous(dev, count, page_order, gfp);
+		if (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {
+			dma_release_from_contiguous(dev, page, count);
+			page = NULL;
+		}
+	}
+	if (!page)
+		page = alloc_pages_node(dev_to_node(dev), gfp, page_order);
+
+	if (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {
+		__free_pages(page, page_order);
+		page = NULL;
+
+		if (IS_ENABLED(CONFIG_ZONE_DMA32) &&
+		    dev->coherent_dma_mask < DMA_BIT_MASK(64) &&
+		    !(gfp & (GFP_DMA32 | GFP_DMA))) {
+			gfp |= GFP_DMA32;
+			goto again;
+		}
+
+		if (IS_ENABLED(CONFIG_ZONE_DMA) &&
+		    dev->coherent_dma_mask < DMA_BIT_MASK(32) &&
+		    !(gfp & GFP_DMA)) {
+			gfp = (gfp & ~GFP_DMA32) | GFP_DMA;
+			goto again;
+		}
+	}
+
+	if (!page)
+		return NULL;
+	ret = page_address(page);
+	if (force_dma_unencrypted()) {
+		set_memory_decrypted((unsigned long)ret, 1 << page_order);
+		*dma_handle = __phys_to_dma(dev, page_to_phys(page));
+	} else {
+		*dma_handle = phys_to_dma(dev, page_to_phys(page));
+	}
+	memset(ret, 0, size);
+	return ret;
+}
+
+/*
+ * NOTE: this function must never look at the dma_addr argument, because we want
+ * to be able to use it as a helper for iommu implementations as well.
+ */
+void dma_direct_free(struct device *dev, size_t size, void *cpu_addr,
+		dma_addr_t dma_addr, unsigned long attrs)
+{
+	unsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;
+	unsigned int page_order = get_order(size);
+
+	if (force_dma_unencrypted())
+		set_memory_encrypted((unsigned long)cpu_addr, 1 << page_order);
+	if (!dma_release_from_contiguous(dev, virt_to_page(cpu_addr), count))
+		free_pages((unsigned long)cpu_addr, page_order);
+}
+
+dma_addr_t dma_direct_map_page(struct device *dev, struct page *page,
+		unsigned long offset, size_t size, enum dma_data_direction dir,
+		unsigned long attrs)
+{
+	dma_addr_t dma_addr = phys_to_dma(dev, page_to_phys(page)) + offset;
+
+	if (!check_addr(dev, dma_addr, size, __func__))
+		return DIRECT_MAPPING_ERROR;
+	return dma_addr;
+}
+
+int dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,
+		enum dma_data_direction dir, unsigned long attrs)
+{
+	int i;
+	struct scatterlist *sg;
+
+	for_each_sg(sgl, sg, nents, i) {
+		BUG_ON(!sg_page(sg));
+
+		sg_dma_address(sg) = phys_to_dma(dev, sg_phys(sg));
+		if (!check_addr(dev, sg_dma_address(sg), sg->length, __func__))
+			return 0;
+		sg_dma_len(sg) = sg->length;
+	}
+
+	return nents;
+}
+
+int dma_direct_supported(struct device *dev, u64 mask)
+{
+#ifdef CONFIG_ZONE_DMA
+	if (mask < DMA_BIT_MASK(ARCH_ZONE_DMA_BITS))
+		return 0;
+#else
+	/*
+	 * Because 32-bit DMA masks are so common we expect every architecture
+	 * to be able to satisfy them - either by not supporting more physical
+	 * memory, or by providing a ZONE_DMA32.  If neither is the case, the
+	 * architecture needs to use an IOMMU instead of the direct mapping.
+	 */
+	if (mask < DMA_BIT_MASK(32))
+		return 0;
+#endif
+	/*
+	 * Various PCI/PCIe bridges have broken support for > 32bit DMA even
+	 * if the device itself might support it.
+	 */
+	if (dev->dma_32bit_limit && mask > DMA_BIT_MASK(32))
+		return 0;
+	return 1;
+}
+
+int dma_direct_mapping_error(struct device *dev, dma_addr_t dma_addr)
+{
+	return dma_addr == DIRECT_MAPPING_ERROR;
+}
+
+const struct dma_map_ops dma_direct_ops = {
+	.alloc			= dma_direct_alloc,
+	.free			= dma_direct_free,
+	.map_page		= dma_direct_map_page,
+	.map_sg			= dma_direct_map_sg,
+	.dma_supported		= dma_direct_supported,
+	.mapping_error		= dma_direct_mapping_error,
+	.is_phys		= 1,
+};
+EXPORT_SYMBOL(dma_direct_ops);
diff --git a/kernel/dma/mapping.c b/kernel/dma/mapping.c
new file mode 100644
index 00000000..d2a92dda
--- /dev/null
+++ b/kernel/dma/mapping.c
@@ -0,0 +1,345 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * arch-independent dma-mapping routines
+ *
+ * Copyright (c) 2006  SUSE Linux Products GmbH
+ * Copyright (c) 2006  Tejun Heo <teheo@suse.de>
+ */
+
+#include <linux/acpi.h>
+#include <linux/dma-mapping.h>
+#include <linux/export.h>
+#include <linux/gfp.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+/*
+ * Managed DMA API
+ */
+struct dma_devres {
+	size_t		size;
+	void		*vaddr;
+	dma_addr_t	dma_handle;
+	unsigned long	attrs;
+};
+
+static void dmam_release(struct device *dev, void *res)
+{
+	struct dma_devres *this = res;
+
+	dma_free_attrs(dev, this->size, this->vaddr, this->dma_handle,
+			this->attrs);
+}
+
+static int dmam_match(struct device *dev, void *res, void *match_data)
+{
+	struct dma_devres *this = res, *match = match_data;
+
+	if (this->vaddr == match->vaddr) {
+		WARN_ON(this->size != match->size ||
+			this->dma_handle != match->dma_handle);
+		return 1;
+	}
+	return 0;
+}
+
+/**
+ * dmam_alloc_coherent - Managed dma_alloc_coherent()
+ * @dev: Device to allocate coherent memory for
+ * @size: Size of allocation
+ * @dma_handle: Out argument for allocated DMA handle
+ * @gfp: Allocation flags
+ *
+ * Managed dma_alloc_coherent().  Memory allocated using this function
+ * will be automatically released on driver detach.
+ *
+ * RETURNS:
+ * Pointer to allocated memory on success, NULL on failure.
+ */
+void *dmam_alloc_coherent(struct device *dev, size_t size,
+			   dma_addr_t *dma_handle, gfp_t gfp)
+{
+	struct dma_devres *dr;
+	void *vaddr;
+
+	dr = devres_alloc(dmam_release, sizeof(*dr), gfp);
+	if (!dr)
+		return NULL;
+
+	vaddr = dma_alloc_coherent(dev, size, dma_handle, gfp);
+	if (!vaddr) {
+		devres_free(dr);
+		return NULL;
+	}
+
+	dr->vaddr = vaddr;
+	dr->dma_handle = *dma_handle;
+	dr->size = size;
+
+	devres_add(dev, dr);
+
+	return vaddr;
+}
+EXPORT_SYMBOL(dmam_alloc_coherent);
+
+/**
+ * dmam_free_coherent - Managed dma_free_coherent()
+ * @dev: Device to free coherent memory for
+ * @size: Size of allocation
+ * @vaddr: Virtual address of the memory to free
+ * @dma_handle: DMA handle of the memory to free
+ *
+ * Managed dma_free_coherent().
+ */
+void dmam_free_coherent(struct device *dev, size_t size, void *vaddr,
+			dma_addr_t dma_handle)
+{
+	struct dma_devres match_data = { size, vaddr, dma_handle };
+
+	dma_free_coherent(dev, size, vaddr, dma_handle);
+	WARN_ON(devres_destroy(dev, dmam_release, dmam_match, &match_data));
+}
+EXPORT_SYMBOL(dmam_free_coherent);
+
+/**
+ * dmam_alloc_attrs - Managed dma_alloc_attrs()
+ * @dev: Device to allocate non_coherent memory for
+ * @size: Size of allocation
+ * @dma_handle: Out argument for allocated DMA handle
+ * @gfp: Allocation flags
+ * @attrs: Flags in the DMA_ATTR_* namespace.
+ *
+ * Managed dma_alloc_attrs().  Memory allocated using this function will be
+ * automatically released on driver detach.
+ *
+ * RETURNS:
+ * Pointer to allocated memory on success, NULL on failure.
+ */
+void *dmam_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,
+		gfp_t gfp, unsigned long attrs)
+{
+	struct dma_devres *dr;
+	void *vaddr;
+
+	dr = devres_alloc(dmam_release, sizeof(*dr), gfp);
+	if (!dr)
+		return NULL;
+
+	vaddr = dma_alloc_attrs(dev, size, dma_handle, gfp, attrs);
+	if (!vaddr) {
+		devres_free(dr);
+		return NULL;
+	}
+
+	dr->vaddr = vaddr;
+	dr->dma_handle = *dma_handle;
+	dr->size = size;
+	dr->attrs = attrs;
+
+	devres_add(dev, dr);
+
+	return vaddr;
+}
+EXPORT_SYMBOL(dmam_alloc_attrs);
+
+#ifdef CONFIG_HAVE_GENERIC_DMA_COHERENT
+
+static void dmam_coherent_decl_release(struct device *dev, void *res)
+{
+	dma_release_declared_memory(dev);
+}
+
+/**
+ * dmam_declare_coherent_memory - Managed dma_declare_coherent_memory()
+ * @dev: Device to declare coherent memory for
+ * @phys_addr: Physical address of coherent memory to be declared
+ * @device_addr: Device address of coherent memory to be declared
+ * @size: Size of coherent memory to be declared
+ * @flags: Flags
+ *
+ * Managed dma_declare_coherent_memory().
+ *
+ * RETURNS:
+ * 0 on success, -errno on failure.
+ */
+int dmam_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,
+				 dma_addr_t device_addr, size_t size, int flags)
+{
+	void *res;
+	int rc;
+
+	res = devres_alloc(dmam_coherent_decl_release, 0, GFP_KERNEL);
+	if (!res)
+		return -ENOMEM;
+
+	rc = dma_declare_coherent_memory(dev, phys_addr, device_addr, size,
+					 flags);
+	if (!rc)
+		devres_add(dev, res);
+	else
+		devres_free(res);
+
+	return rc;
+}
+EXPORT_SYMBOL(dmam_declare_coherent_memory);
+
+/**
+ * dmam_release_declared_memory - Managed dma_release_declared_memory().
+ * @dev: Device to release declared coherent memory for
+ *
+ * Managed dmam_release_declared_memory().
+ */
+void dmam_release_declared_memory(struct device *dev)
+{
+	WARN_ON(devres_destroy(dev, dmam_coherent_decl_release, NULL, NULL));
+}
+EXPORT_SYMBOL(dmam_release_declared_memory);
+
+#endif
+
+/*
+ * Create scatter-list for the already allocated DMA buffer.
+ */
+int dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,
+		 void *cpu_addr, dma_addr_t handle, size_t size)
+{
+	struct page *page = virt_to_page(cpu_addr);
+	int ret;
+
+	ret = sg_alloc_table(sgt, 1, GFP_KERNEL);
+	if (unlikely(ret))
+		return ret;
+
+	sg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);
+	return 0;
+}
+EXPORT_SYMBOL(dma_common_get_sgtable);
+
+/*
+ * Create userspace mapping for the DMA-coherent memory.
+ */
+int dma_common_mmap(struct device *dev, struct vm_area_struct *vma,
+		    void *cpu_addr, dma_addr_t dma_addr, size_t size)
+{
+	int ret = -ENXIO;
+#ifndef CONFIG_ARCH_NO_COHERENT_DMA_MMAP
+	unsigned long user_count = vma_pages(vma);
+	unsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;
+	unsigned long off = vma->vm_pgoff;
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	if (dma_mmap_from_dev_coherent(dev, vma, cpu_addr, size, &ret))
+		return ret;
+
+	if (off < count && user_count <= (count - off))
+		ret = remap_pfn_range(vma, vma->vm_start,
+				      page_to_pfn(virt_to_page(cpu_addr)) + off,
+				      user_count << PAGE_SHIFT,
+				      vma->vm_page_prot);
+#endif	/* !CONFIG_ARCH_NO_COHERENT_DMA_MMAP */
+
+	return ret;
+}
+EXPORT_SYMBOL(dma_common_mmap);
+
+#ifdef CONFIG_MMU
+static struct vm_struct *__dma_common_pages_remap(struct page **pages,
+			size_t size, unsigned long vm_flags, pgprot_t prot,
+			const void *caller)
+{
+	struct vm_struct *area;
+
+	area = get_vm_area_caller(size, vm_flags, caller);
+	if (!area)
+		return NULL;
+
+	if (map_vm_area(area, prot, pages)) {
+		vunmap(area->addr);
+		return NULL;
+	}
+
+	return area;
+}
+
+/*
+ * remaps an array of PAGE_SIZE pages into another vm_area
+ * Cannot be used in non-sleeping contexts
+ */
+void *dma_common_pages_remap(struct page **pages, size_t size,
+			unsigned long vm_flags, pgprot_t prot,
+			const void *caller)
+{
+	struct vm_struct *area;
+
+	area = __dma_common_pages_remap(pages, size, vm_flags, prot, caller);
+	if (!area)
+		return NULL;
+
+	area->pages = pages;
+
+	return area->addr;
+}
+
+/*
+ * remaps an allocated contiguous region into another vm_area.
+ * Cannot be used in non-sleeping contexts
+ */
+
+void *dma_common_contiguous_remap(struct page *page, size_t size,
+			unsigned long vm_flags,
+			pgprot_t prot, const void *caller)
+{
+	int i;
+	struct page **pages;
+	struct vm_struct *area;
+
+	pages = kmalloc(sizeof(struct page *) << get_order(size), GFP_KERNEL);
+	if (!pages)
+		return NULL;
+
+	for (i = 0; i < (size >> PAGE_SHIFT); i++)
+		pages[i] = nth_page(page, i);
+
+	area = __dma_common_pages_remap(pages, size, vm_flags, prot, caller);
+
+	kfree(pages);
+
+	if (!area)
+		return NULL;
+	return area->addr;
+}
+
+/*
+ * unmaps a range previously mapped by dma_common_*_remap
+ */
+void dma_common_free_remap(void *cpu_addr, size_t size, unsigned long vm_flags)
+{
+	struct vm_struct *area = find_vm_area(cpu_addr);
+
+	if (!area || (area->flags & vm_flags) != vm_flags) {
+		WARN(1, "trying to free invalid coherent area: %p\n", cpu_addr);
+		return;
+	}
+
+	unmap_kernel_range((unsigned long)cpu_addr, PAGE_ALIGN(size));
+	vunmap(cpu_addr);
+}
+#endif
+
+/*
+ * enables DMA API use for a device
+ */
+int dma_configure(struct device *dev)
+{
+	if (dev->bus->dma_configure)
+		return dev->bus->dma_configure(dev);
+	return 0;
+}
+
+void dma_deconfigure(struct device *dev)
+{
+	of_dma_deconfigure(dev);
+	acpi_dma_deconfigure(dev);
+}
diff --git a/kernel/dma/noncoherent.c b/kernel/dma/noncoherent.c
new file mode 100644
index 00000000..79e9a757
--- /dev/null
+++ b/kernel/dma/noncoherent.c
@@ -0,0 +1,102 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 Christoph Hellwig.
+ *
+ * DMA operations that map physical memory directly without providing cache
+ * coherence.
+ */
+#include <linux/export.h>
+#include <linux/mm.h>
+#include <linux/dma-direct.h>
+#include <linux/dma-noncoherent.h>
+#include <linux/scatterlist.h>
+
+static void dma_noncoherent_sync_single_for_device(struct device *dev,
+		dma_addr_t addr, size_t size, enum dma_data_direction dir)
+{
+	arch_sync_dma_for_device(dev, dma_to_phys(dev, addr), size, dir);
+}
+
+static void dma_noncoherent_sync_sg_for_device(struct device *dev,
+		struct scatterlist *sgl, int nents, enum dma_data_direction dir)
+{
+	struct scatterlist *sg;
+	int i;
+
+	for_each_sg(sgl, sg, nents, i)
+		arch_sync_dma_for_device(dev, sg_phys(sg), sg->length, dir);
+}
+
+static dma_addr_t dma_noncoherent_map_page(struct device *dev, struct page *page,
+		unsigned long offset, size_t size, enum dma_data_direction dir,
+		unsigned long attrs)
+{
+	dma_addr_t addr;
+
+	addr = dma_direct_map_page(dev, page, offset, size, dir, attrs);
+	if (!dma_mapping_error(dev, addr) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+		arch_sync_dma_for_device(dev, page_to_phys(page) + offset,
+				size, dir);
+	return addr;
+}
+
+static int dma_noncoherent_map_sg(struct device *dev, struct scatterlist *sgl,
+		int nents, enum dma_data_direction dir, unsigned long attrs)
+{
+	nents = dma_direct_map_sg(dev, sgl, nents, dir, attrs);
+	if (nents > 0 && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+		dma_noncoherent_sync_sg_for_device(dev, sgl, nents, dir);
+	return nents;
+}
+
+#ifdef CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU
+static void dma_noncoherent_sync_single_for_cpu(struct device *dev,
+		dma_addr_t addr, size_t size, enum dma_data_direction dir)
+{
+	arch_sync_dma_for_cpu(dev, dma_to_phys(dev, addr), size, dir);
+}
+
+static void dma_noncoherent_sync_sg_for_cpu(struct device *dev,
+		struct scatterlist *sgl, int nents, enum dma_data_direction dir)
+{
+	struct scatterlist *sg;
+	int i;
+
+	for_each_sg(sgl, sg, nents, i)
+		arch_sync_dma_for_cpu(dev, sg_phys(sg), sg->length, dir);
+}
+
+static void dma_noncoherent_unmap_page(struct device *dev, dma_addr_t addr,
+		size_t size, enum dma_data_direction dir, unsigned long attrs)
+{
+	if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+		dma_noncoherent_sync_single_for_cpu(dev, addr, size, dir);
+}
+
+static void dma_noncoherent_unmap_sg(struct device *dev, struct scatterlist *sgl,
+		int nents, enum dma_data_direction dir, unsigned long attrs)
+{
+	if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+		dma_noncoherent_sync_sg_for_cpu(dev, sgl, nents, dir);
+}
+#endif
+
+const struct dma_map_ops dma_noncoherent_ops = {
+	.alloc			= arch_dma_alloc,
+	.free			= arch_dma_free,
+	.mmap			= arch_dma_mmap,
+	.sync_single_for_device	= dma_noncoherent_sync_single_for_device,
+	.sync_sg_for_device	= dma_noncoherent_sync_sg_for_device,
+	.map_page		= dma_noncoherent_map_page,
+	.map_sg			= dma_noncoherent_map_sg,
+#ifdef CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU
+	.sync_single_for_cpu	= dma_noncoherent_sync_single_for_cpu,
+	.sync_sg_for_cpu	= dma_noncoherent_sync_sg_for_cpu,
+	.unmap_page		= dma_noncoherent_unmap_page,
+	.unmap_sg		= dma_noncoherent_unmap_sg,
+#endif
+	.dma_supported		= dma_direct_supported,
+	.mapping_error		= dma_direct_mapping_error,
+	.cache_sync		= arch_dma_cache_sync,
+};
+EXPORT_SYMBOL(dma_noncoherent_ops);
diff --git a/kernel/dma/swiotlb.c b/kernel/dma/swiotlb.c
new file mode 100644
index 00000000..90454105
--- /dev/null
+++ b/kernel/dma/swiotlb.c
@@ -0,0 +1,1088 @@
+/*
+ * Dynamic DMA mapping support.
+ *
+ * This implementation is a fallback for platforms that do not support
+ * I/O TLBs (aka DMA address translation hardware).
+ * Copyright (C) 2000 Asit Mallick <Asit.K.Mallick@intel.com>
+ * Copyright (C) 2000 Goutham Rao <goutham.rao@intel.com>
+ * Copyright (C) 2000, 2003 Hewlett-Packard Co
+ *	David Mosberger-Tang <davidm@hpl.hp.com>
+ *
+ * 03/05/07 davidm	Switch from PCI-DMA to generic device DMA API.
+ * 00/12/13 davidm	Rename to swiotlb.c and add mark_clean() to avoid
+ *			unnecessary i-cache flushing.
+ * 04/07/.. ak		Better overflow handling. Assorted fixes.
+ * 05/09/10 linville	Add support for syncing ranges, support syncing for
+ *			DMA_BIDIRECTIONAL mappings, miscellaneous cleanup.
+ * 08/12/11 beckyb	Add highmem support
+ */
+
+#include <linux/cache.h>
+#include <linux/dma-direct.h>
+#include <linux/mm.h>
+#include <linux/export.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/swiotlb.h>
+#include <linux/pfn.h>
+#include <linux/types.h>
+#include <linux/ctype.h>
+#include <linux/highmem.h>
+#include <linux/gfp.h>
+#include <linux/scatterlist.h>
+#include <linux/mem_encrypt.h>
+#include <linux/set_memory.h>
+
+#include <asm/io.h>
+#include <asm/dma.h>
+
+#include <linux/init.h>
+#include <linux/bootmem.h>
+#include <linux/iommu-helper.h>
+
+#define CREATE_TRACE_POINTS
+#include <trace/events/swiotlb.h>
+
+#define OFFSET(val,align) ((unsigned long)	\
+	                   ( (val) & ( (align) - 1)))
+
+#define SLABS_PER_PAGE (1 << (PAGE_SHIFT - IO_TLB_SHIFT))
+
+/*
+ * Minimum IO TLB size to bother booting with.  Systems with mainly
+ * 64bit capable cards will only lightly use the swiotlb.  If we can't
+ * allocate a contiguous 1MB, we're probably in trouble anyway.
+ */
+#define IO_TLB_MIN_SLABS ((1<<20) >> IO_TLB_SHIFT)
+
+enum swiotlb_force swiotlb_force;
+
+/*
+ * Used to do a quick range check in swiotlb_tbl_unmap_single and
+ * swiotlb_tbl_sync_single_*, to see if the memory was in fact allocated by this
+ * API.
+ */
+static phys_addr_t io_tlb_start, io_tlb_end;
+
+/*
+ * The number of IO TLB blocks (in groups of 64) between io_tlb_start and
+ * io_tlb_end.  This is command line adjustable via setup_io_tlb_npages.
+ */
+static unsigned long io_tlb_nslabs;
+
+/*
+ * When the IOMMU overflows we return a fallback buffer. This sets the size.
+ */
+static unsigned long io_tlb_overflow = 32*1024;
+
+static phys_addr_t io_tlb_overflow_buffer;
+
+/*
+ * This is a free list describing the number of free entries available from
+ * each index
+ */
+static unsigned int *io_tlb_list;
+static unsigned int io_tlb_index;
+
+/*
+ * Max segment that we can provide which (if pages are contingous) will
+ * not be bounced (unless SWIOTLB_FORCE is set).
+ */
+unsigned int max_segment;
+
+/*
+ * We need to save away the original address corresponding to a mapped entry
+ * for the sync operations.
+ */
+#define INVALID_PHYS_ADDR (~(phys_addr_t)0)
+static phys_addr_t *io_tlb_orig_addr;
+
+/*
+ * Protect the above data structures in the map and unmap calls
+ */
+static DEFINE_SPINLOCK(io_tlb_lock);
+
+static int late_alloc;
+
+static int __init
+setup_io_tlb_npages(char *str)
+{
+	if (isdigit(*str)) {
+		io_tlb_nslabs = simple_strtoul(str, &str, 0);
+		/* avoid tail segment of size < IO_TLB_SEGSIZE */
+		io_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);
+	}
+	if (*str == ',')
+		++str;
+	if (!strcmp(str, "force")) {
+		swiotlb_force = SWIOTLB_FORCE;
+	} else if (!strcmp(str, "noforce")) {
+		swiotlb_force = SWIOTLB_NO_FORCE;
+		io_tlb_nslabs = 1;
+	}
+
+	return 0;
+}
+early_param("swiotlb", setup_io_tlb_npages);
+/* make io_tlb_overflow tunable too? */
+
+unsigned long swiotlb_nr_tbl(void)
+{
+	return io_tlb_nslabs;
+}
+EXPORT_SYMBOL_GPL(swiotlb_nr_tbl);
+
+unsigned int swiotlb_max_segment(void)
+{
+	return max_segment;
+}
+EXPORT_SYMBOL_GPL(swiotlb_max_segment);
+
+void swiotlb_set_max_segment(unsigned int val)
+{
+	if (swiotlb_force == SWIOTLB_FORCE)
+		max_segment = 1;
+	else
+		max_segment = rounddown(val, PAGE_SIZE);
+}
+
+/* default to 64MB */
+#define IO_TLB_DEFAULT_SIZE (64UL<<20)
+unsigned long swiotlb_size_or_default(void)
+{
+	unsigned long size;
+
+	size = io_tlb_nslabs << IO_TLB_SHIFT;
+
+	return size ? size : (IO_TLB_DEFAULT_SIZE);
+}
+
+static bool no_iotlb_memory;
+
+void swiotlb_print_info(void)
+{
+	unsigned long bytes = io_tlb_nslabs << IO_TLB_SHIFT;
+	unsigned char *vstart, *vend;
+
+	if (no_iotlb_memory) {
+		pr_warn("software IO TLB: No low mem\n");
+		return;
+	}
+
+	vstart = phys_to_virt(io_tlb_start);
+	vend = phys_to_virt(io_tlb_end);
+
+	printk(KERN_INFO "software IO TLB [mem %#010llx-%#010llx] (%luMB) mapped at [%p-%p]\n",
+	       (unsigned long long)io_tlb_start,
+	       (unsigned long long)io_tlb_end,
+	       bytes >> 20, vstart, vend - 1);
+}
+
+/*
+ * Early SWIOTLB allocation may be too early to allow an architecture to
+ * perform the desired operations.  This function allows the architecture to
+ * call SWIOTLB when the operations are possible.  It needs to be called
+ * before the SWIOTLB memory is used.
+ */
+void __init swiotlb_update_mem_attributes(void)
+{
+	void *vaddr;
+	unsigned long bytes;
+
+	if (no_iotlb_memory || late_alloc)
+		return;
+
+	vaddr = phys_to_virt(io_tlb_start);
+	bytes = PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT);
+	set_memory_decrypted((unsigned long)vaddr, bytes >> PAGE_SHIFT);
+	memset(vaddr, 0, bytes);
+
+	vaddr = phys_to_virt(io_tlb_overflow_buffer);
+	bytes = PAGE_ALIGN(io_tlb_overflow);
+	set_memory_decrypted((unsigned long)vaddr, bytes >> PAGE_SHIFT);
+	memset(vaddr, 0, bytes);
+}
+
+int __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)
+{
+	void *v_overflow_buffer;
+	unsigned long i, bytes;
+
+	bytes = nslabs << IO_TLB_SHIFT;
+
+	io_tlb_nslabs = nslabs;
+	io_tlb_start = __pa(tlb);
+	io_tlb_end = io_tlb_start + bytes;
+
+	/*
+	 * Get the overflow emergency buffer
+	 */
+	v_overflow_buffer = memblock_virt_alloc_low_nopanic(
+						PAGE_ALIGN(io_tlb_overflow),
+						PAGE_SIZE);
+	if (!v_overflow_buffer)
+		return -ENOMEM;
+
+	io_tlb_overflow_buffer = __pa(v_overflow_buffer);
+
+	/*
+	 * Allocate and initialize the free list array.  This array is used
+	 * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE
+	 * between io_tlb_start and io_tlb_end.
+	 */
+	io_tlb_list = memblock_virt_alloc(
+				PAGE_ALIGN(io_tlb_nslabs * sizeof(int)),
+				PAGE_SIZE);
+	io_tlb_orig_addr = memblock_virt_alloc(
+				PAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)),
+				PAGE_SIZE);
+	for (i = 0; i < io_tlb_nslabs; i++) {
+		io_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);
+		io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;
+	}
+	io_tlb_index = 0;
+
+	if (verbose)
+		swiotlb_print_info();
+
+	swiotlb_set_max_segment(io_tlb_nslabs << IO_TLB_SHIFT);
+	return 0;
+}
+
+/*
+ * Statically reserve bounce buffer space and initialize bounce buffer data
+ * structures for the software IO TLB used to implement the DMA API.
+ */
+void  __init
+swiotlb_init(int verbose)
+{
+	size_t default_size = IO_TLB_DEFAULT_SIZE;
+	unsigned char *vstart;
+	unsigned long bytes;
+
+	if (!io_tlb_nslabs) {
+		io_tlb_nslabs = (default_size >> IO_TLB_SHIFT);
+		io_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);
+	}
+
+	bytes = io_tlb_nslabs << IO_TLB_SHIFT;
+
+	/* Get IO TLB memory from the low pages */
+	vstart = memblock_virt_alloc_low_nopanic(PAGE_ALIGN(bytes), PAGE_SIZE);
+	if (vstart && !swiotlb_init_with_tbl(vstart, io_tlb_nslabs, verbose))
+		return;
+
+	if (io_tlb_start)
+		memblock_free_early(io_tlb_start,
+				    PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT));
+	pr_warn("Cannot allocate SWIOTLB buffer");
+	no_iotlb_memory = true;
+}
+
+/*
+ * Systems with larger DMA zones (those that don't support ISA) can
+ * initialize the swiotlb later using the slab allocator if needed.
+ * This should be just like above, but with some error catching.
+ */
+int
+swiotlb_late_init_with_default_size(size_t default_size)
+{
+	unsigned long bytes, req_nslabs = io_tlb_nslabs;
+	unsigned char *vstart = NULL;
+	unsigned int order;
+	int rc = 0;
+
+	if (!io_tlb_nslabs) {
+		io_tlb_nslabs = (default_size >> IO_TLB_SHIFT);
+		io_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);
+	}
+
+	/*
+	 * Get IO TLB memory from the low pages
+	 */
+	order = get_order(io_tlb_nslabs << IO_TLB_SHIFT);
+	io_tlb_nslabs = SLABS_PER_PAGE << order;
+	bytes = io_tlb_nslabs << IO_TLB_SHIFT;
+
+	while ((SLABS_PER_PAGE << order) > IO_TLB_MIN_SLABS) {
+		vstart = (void *)__get_free_pages(GFP_DMA | __GFP_NOWARN,
+						  order);
+		if (vstart)
+			break;
+		order--;
+	}
+
+	if (!vstart) {
+		io_tlb_nslabs = req_nslabs;
+		return -ENOMEM;
+	}
+	if (order != get_order(bytes)) {
+		printk(KERN_WARNING "Warning: only able to allocate %ld MB "
+		       "for software IO TLB\n", (PAGE_SIZE << order) >> 20);
+		io_tlb_nslabs = SLABS_PER_PAGE << order;
+	}
+	rc = swiotlb_late_init_with_tbl(vstart, io_tlb_nslabs);
+	if (rc)
+		free_pages((unsigned long)vstart, order);
+
+	return rc;
+}
+
+int
+swiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)
+{
+	unsigned long i, bytes;
+	unsigned char *v_overflow_buffer;
+
+	bytes = nslabs << IO_TLB_SHIFT;
+
+	io_tlb_nslabs = nslabs;
+	io_tlb_start = virt_to_phys(tlb);
+	io_tlb_end = io_tlb_start + bytes;
+
+	set_memory_decrypted((unsigned long)tlb, bytes >> PAGE_SHIFT);
+	memset(tlb, 0, bytes);
+
+	/*
+	 * Get the overflow emergency buffer
+	 */
+	v_overflow_buffer = (void *)__get_free_pages(GFP_DMA,
+						     get_order(io_tlb_overflow));
+	if (!v_overflow_buffer)
+		goto cleanup2;
+
+	set_memory_decrypted((unsigned long)v_overflow_buffer,
+			io_tlb_overflow >> PAGE_SHIFT);
+	memset(v_overflow_buffer, 0, io_tlb_overflow);
+	io_tlb_overflow_buffer = virt_to_phys(v_overflow_buffer);
+
+	/*
+	 * Allocate and initialize the free list array.  This array is used
+	 * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE
+	 * between io_tlb_start and io_tlb_end.
+	 */
+	io_tlb_list = (unsigned int *)__get_free_pages(GFP_KERNEL,
+	                              get_order(io_tlb_nslabs * sizeof(int)));
+	if (!io_tlb_list)
+		goto cleanup3;
+
+	io_tlb_orig_addr = (phys_addr_t *)
+		__get_free_pages(GFP_KERNEL,
+				 get_order(io_tlb_nslabs *
+					   sizeof(phys_addr_t)));
+	if (!io_tlb_orig_addr)
+		goto cleanup4;
+
+	for (i = 0; i < io_tlb_nslabs; i++) {
+		io_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);
+		io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;
+	}
+	io_tlb_index = 0;
+
+	swiotlb_print_info();
+
+	late_alloc = 1;
+
+	swiotlb_set_max_segment(io_tlb_nslabs << IO_TLB_SHIFT);
+
+	return 0;
+
+cleanup4:
+	free_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *
+	                                                 sizeof(int)));
+	io_tlb_list = NULL;
+cleanup3:
+	free_pages((unsigned long)v_overflow_buffer,
+		   get_order(io_tlb_overflow));
+	io_tlb_overflow_buffer = 0;
+cleanup2:
+	io_tlb_end = 0;
+	io_tlb_start = 0;
+	io_tlb_nslabs = 0;
+	max_segment = 0;
+	return -ENOMEM;
+}
+
+void __init swiotlb_exit(void)
+{
+	if (!io_tlb_orig_addr)
+		return;
+
+	if (late_alloc) {
+		free_pages((unsigned long)phys_to_virt(io_tlb_overflow_buffer),
+			   get_order(io_tlb_overflow));
+		free_pages((unsigned long)io_tlb_orig_addr,
+			   get_order(io_tlb_nslabs * sizeof(phys_addr_t)));
+		free_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *
+								 sizeof(int)));
+		free_pages((unsigned long)phys_to_virt(io_tlb_start),
+			   get_order(io_tlb_nslabs << IO_TLB_SHIFT));
+	} else {
+		memblock_free_late(io_tlb_overflow_buffer,
+				   PAGE_ALIGN(io_tlb_overflow));
+		memblock_free_late(__pa(io_tlb_orig_addr),
+				   PAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)));
+		memblock_free_late(__pa(io_tlb_list),
+				   PAGE_ALIGN(io_tlb_nslabs * sizeof(int)));
+		memblock_free_late(io_tlb_start,
+				   PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT));
+	}
+	io_tlb_nslabs = 0;
+	max_segment = 0;
+}
+
+int is_swiotlb_buffer(phys_addr_t paddr)
+{
+	return paddr >= io_tlb_start && paddr < io_tlb_end;
+}
+
+/*
+ * Bounce: copy the swiotlb buffer back to the original dma location
+ */
+static void swiotlb_bounce(phys_addr_t orig_addr, phys_addr_t tlb_addr,
+			   size_t size, enum dma_data_direction dir)
+{
+	unsigned long pfn = PFN_DOWN(orig_addr);
+	unsigned char *vaddr = phys_to_virt(tlb_addr);
+
+	if (PageHighMem(pfn_to_page(pfn))) {
+		/* The buffer does not have a mapping.  Map it in and copy */
+		unsigned int offset = orig_addr & ~PAGE_MASK;
+		char *buffer;
+		unsigned int sz = 0;
+		unsigned long flags;
+
+		while (size) {
+			sz = min_t(size_t, PAGE_SIZE - offset, size);
+
+			local_irq_save(flags);
+			buffer = kmap_atomic(pfn_to_page(pfn));
+			if (dir == DMA_TO_DEVICE)
+				memcpy(vaddr, buffer + offset, sz);
+			else
+				memcpy(buffer + offset, vaddr, sz);
+			kunmap_atomic(buffer);
+			local_irq_restore(flags);
+
+			size -= sz;
+			pfn++;
+			vaddr += sz;
+			offset = 0;
+		}
+	} else if (dir == DMA_TO_DEVICE) {
+		memcpy(vaddr, phys_to_virt(orig_addr), size);
+	} else {
+		memcpy(phys_to_virt(orig_addr), vaddr, size);
+	}
+}
+
+phys_addr_t swiotlb_tbl_map_single(struct device *hwdev,
+				   dma_addr_t tbl_dma_addr,
+				   phys_addr_t orig_addr, size_t size,
+				   enum dma_data_direction dir,
+				   unsigned long attrs)
+{
+	unsigned long flags;
+	phys_addr_t tlb_addr;
+	unsigned int nslots, stride, index, wrap;
+	int i;
+	unsigned long mask;
+	unsigned long offset_slots;
+	unsigned long max_slots;
+
+	if (no_iotlb_memory)
+		panic("Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer");
+
+	if (mem_encrypt_active())
+		pr_warn_once("%s is active and system is using DMA bounce buffers\n",
+			     sme_active() ? "SME" : "SEV");
+
+	mask = dma_get_seg_boundary(hwdev);
+
+	tbl_dma_addr &= mask;
+
+	offset_slots = ALIGN(tbl_dma_addr, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;
+
+	/*
+ 	 * Carefully handle integer overflow which can occur when mask == ~0UL.
+ 	 */
+	max_slots = mask + 1
+		    ? ALIGN(mask + 1, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT
+		    : 1UL << (BITS_PER_LONG - IO_TLB_SHIFT);
+
+	/*
+	 * For mappings greater than or equal to a page, we limit the stride
+	 * (and hence alignment) to a page size.
+	 */
+	nslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;
+	if (size >= PAGE_SIZE)
+		stride = (1 << (PAGE_SHIFT - IO_TLB_SHIFT));
+	else
+		stride = 1;
+
+	BUG_ON(!nslots);
+
+	/*
+	 * Find suitable number of IO TLB entries size that will fit this
+	 * request and allocate a buffer from that IO TLB pool.
+	 */
+	spin_lock_irqsave(&io_tlb_lock, flags);
+	index = ALIGN(io_tlb_index, stride);
+	if (index >= io_tlb_nslabs)
+		index = 0;
+	wrap = index;
+
+	do {
+		while (iommu_is_span_boundary(index, nslots, offset_slots,
+					      max_slots)) {
+			index += stride;
+			if (index >= io_tlb_nslabs)
+				index = 0;
+			if (index == wrap)
+				goto not_found;
+		}
+
+		/*
+		 * If we find a slot that indicates we have 'nslots' number of
+		 * contiguous buffers, we allocate the buffers from that slot
+		 * and mark the entries as '0' indicating unavailable.
+		 */
+		if (io_tlb_list[index] >= nslots) {
+			int count = 0;
+
+			for (i = index; i < (int) (index + nslots); i++)
+				io_tlb_list[i] = 0;
+			for (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE - 1) && io_tlb_list[i]; i--)
+				io_tlb_list[i] = ++count;
+			tlb_addr = io_tlb_start + (index << IO_TLB_SHIFT);
+
+			/*
+			 * Update the indices to avoid searching in the next
+			 * round.
+			 */
+			io_tlb_index = ((index + nslots) < io_tlb_nslabs
+					? (index + nslots) : 0);
+
+			goto found;
+		}
+		index += stride;
+		if (index >= io_tlb_nslabs)
+			index = 0;
+	} while (index != wrap);
+
+not_found:
+	spin_unlock_irqrestore(&io_tlb_lock, flags);
+	if (!(attrs & DMA_ATTR_NO_WARN) && printk_ratelimit())
+		dev_warn(hwdev, "swiotlb buffer is full (sz: %zd bytes)\n", size);
+	return SWIOTLB_MAP_ERROR;
+found:
+	spin_unlock_irqrestore(&io_tlb_lock, flags);
+
+	/*
+	 * Save away the mapping from the original address to the DMA address.
+	 * This is needed when we sync the memory.  Then we sync the buffer if
+	 * needed.
+	 */
+	for (i = 0; i < nslots; i++)
+		io_tlb_orig_addr[index+i] = orig_addr + (i << IO_TLB_SHIFT);
+	if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&
+	    (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))
+		swiotlb_bounce(orig_addr, tlb_addr, size, DMA_TO_DEVICE);
+
+	return tlb_addr;
+}
+
+/*
+ * Allocates bounce buffer and returns its physical address.
+ */
+static phys_addr_t
+map_single(struct device *hwdev, phys_addr_t phys, size_t size,
+	   enum dma_data_direction dir, unsigned long attrs)
+{
+	dma_addr_t start_dma_addr;
+
+	if (swiotlb_force == SWIOTLB_NO_FORCE) {
+		dev_warn_ratelimited(hwdev, "Cannot do DMA to address %pa\n",
+				     &phys);
+		return SWIOTLB_MAP_ERROR;
+	}
+
+	start_dma_addr = __phys_to_dma(hwdev, io_tlb_start);
+	return swiotlb_tbl_map_single(hwdev, start_dma_addr, phys, size,
+				      dir, attrs);
+}
+
+/*
+ * tlb_addr is the physical address of the bounce buffer to unmap.
+ */
+void swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,
+			      size_t size, enum dma_data_direction dir,
+			      unsigned long attrs)
+{
+	unsigned long flags;
+	int i, count, nslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;
+	int index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;
+	phys_addr_t orig_addr = io_tlb_orig_addr[index];
+
+	/*
+	 * First, sync the memory before unmapping the entry
+	 */
+	if (orig_addr != INVALID_PHYS_ADDR &&
+	    !(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&
+	    ((dir == DMA_FROM_DEVICE) || (dir == DMA_BIDIRECTIONAL)))
+		swiotlb_bounce(orig_addr, tlb_addr, size, DMA_FROM_DEVICE);
+
+	/*
+	 * Return the buffer to the free list by setting the corresponding
+	 * entries to indicate the number of contiguous entries available.
+	 * While returning the entries to the free list, we merge the entries
+	 * with slots below and above the pool being returned.
+	 */
+	spin_lock_irqsave(&io_tlb_lock, flags);
+	{
+		count = ((index + nslots) < ALIGN(index + 1, IO_TLB_SEGSIZE) ?
+			 io_tlb_list[index + nslots] : 0);
+		/*
+		 * Step 1: return the slots to the free list, merging the
+		 * slots with superceeding slots
+		 */
+		for (i = index + nslots - 1; i >= index; i--) {
+			io_tlb_list[i] = ++count;
+			io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;
+		}
+		/*
+		 * Step 2: merge the returned slots with the preceding slots,
+		 * if available (non zero)
+		 */
+		for (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE -1) && io_tlb_list[i]; i--)
+			io_tlb_list[i] = ++count;
+	}
+	spin_unlock_irqrestore(&io_tlb_lock, flags);
+}
+
+void swiotlb_tbl_sync_single(struct device *hwdev, phys_addr_t tlb_addr,
+			     size_t size, enum dma_data_direction dir,
+			     enum dma_sync_target target)
+{
+	int index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;
+	phys_addr_t orig_addr = io_tlb_orig_addr[index];
+
+	if (orig_addr == INVALID_PHYS_ADDR)
+		return;
+	orig_addr += (unsigned long)tlb_addr & ((1 << IO_TLB_SHIFT) - 1);
+
+	switch (target) {
+	case SYNC_FOR_CPU:
+		if (likely(dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))
+			swiotlb_bounce(orig_addr, tlb_addr,
+				       size, DMA_FROM_DEVICE);
+		else
+			BUG_ON(dir != DMA_TO_DEVICE);
+		break;
+	case SYNC_FOR_DEVICE:
+		if (likely(dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))
+			swiotlb_bounce(orig_addr, tlb_addr,
+				       size, DMA_TO_DEVICE);
+		else
+			BUG_ON(dir != DMA_FROM_DEVICE);
+		break;
+	default:
+		BUG();
+	}
+}
+
+static inline bool dma_coherent_ok(struct device *dev, dma_addr_t addr,
+		size_t size)
+{
+	u64 mask = DMA_BIT_MASK(32);
+
+	if (dev && dev->coherent_dma_mask)
+		mask = dev->coherent_dma_mask;
+	return addr + size - 1 <= mask;
+}
+
+static void *
+swiotlb_alloc_buffer(struct device *dev, size_t size, dma_addr_t *dma_handle,
+		unsigned long attrs)
+{
+	phys_addr_t phys_addr;
+
+	if (swiotlb_force == SWIOTLB_NO_FORCE)
+		goto out_warn;
+
+	phys_addr = swiotlb_tbl_map_single(dev,
+			__phys_to_dma(dev, io_tlb_start),
+			0, size, DMA_FROM_DEVICE, attrs);
+	if (phys_addr == SWIOTLB_MAP_ERROR)
+		goto out_warn;
+
+	*dma_handle = __phys_to_dma(dev, phys_addr);
+	if (!dma_coherent_ok(dev, *dma_handle, size))
+		goto out_unmap;
+
+	memset(phys_to_virt(phys_addr), 0, size);
+	return phys_to_virt(phys_addr);
+
+out_unmap:
+	dev_warn(dev, "hwdev DMA mask = 0x%016Lx, dev_addr = 0x%016Lx\n",
+		(unsigned long long)dev->coherent_dma_mask,
+		(unsigned long long)*dma_handle);
+
+	/*
+	 * DMA_TO_DEVICE to avoid memcpy in unmap_single.
+	 * DMA_ATTR_SKIP_CPU_SYNC is optional.
+	 */
+	swiotlb_tbl_unmap_single(dev, phys_addr, size, DMA_TO_DEVICE,
+			DMA_ATTR_SKIP_CPU_SYNC);
+out_warn:
+	if (!(attrs & DMA_ATTR_NO_WARN) && printk_ratelimit()) {
+		dev_warn(dev,
+			"swiotlb: coherent allocation failed, size=%zu\n",
+			size);
+		dump_stack();
+	}
+	return NULL;
+}
+
+static bool swiotlb_free_buffer(struct device *dev, size_t size,
+		dma_addr_t dma_addr)
+{
+	phys_addr_t phys_addr = dma_to_phys(dev, dma_addr);
+
+	WARN_ON_ONCE(irqs_disabled());
+
+	if (!is_swiotlb_buffer(phys_addr))
+		return false;
+
+	/*
+	 * DMA_TO_DEVICE to avoid memcpy in swiotlb_tbl_unmap_single.
+	 * DMA_ATTR_SKIP_CPU_SYNC is optional.
+	 */
+	swiotlb_tbl_unmap_single(dev, phys_addr, size, DMA_TO_DEVICE,
+				 DMA_ATTR_SKIP_CPU_SYNC);
+	return true;
+}
+
+static void
+swiotlb_full(struct device *dev, size_t size, enum dma_data_direction dir,
+	     int do_panic)
+{
+	if (swiotlb_force == SWIOTLB_NO_FORCE)
+		return;
+
+	/*
+	 * Ran out of IOMMU space for this operation. This is very bad.
+	 * Unfortunately the drivers cannot handle this operation properly.
+	 * unless they check for dma_mapping_error (most don't)
+	 * When the mapping is small enough return a static buffer to limit
+	 * the damage, or panic when the transfer is too big.
+	 */
+	dev_err_ratelimited(dev, "DMA: Out of SW-IOMMU space for %zu bytes\n",
+			    size);
+
+	if (size <= io_tlb_overflow || !do_panic)
+		return;
+
+	if (dir == DMA_BIDIRECTIONAL)
+		panic("DMA: Random memory could be DMA accessed\n");
+	if (dir == DMA_FROM_DEVICE)
+		panic("DMA: Random memory could be DMA written\n");
+	if (dir == DMA_TO_DEVICE)
+		panic("DMA: Random memory could be DMA read\n");
+}
+
+/*
+ * Map a single buffer of the indicated size for DMA in streaming mode.  The
+ * physical address to use is returned.
+ *
+ * Once the device is given the dma address, the device owns this memory until
+ * either swiotlb_unmap_page or swiotlb_dma_sync_single is performed.
+ */
+dma_addr_t swiotlb_map_page(struct device *dev, struct page *page,
+			    unsigned long offset, size_t size,
+			    enum dma_data_direction dir,
+			    unsigned long attrs)
+{
+	phys_addr_t map, phys = page_to_phys(page) + offset;
+	dma_addr_t dev_addr = phys_to_dma(dev, phys);
+
+	BUG_ON(dir == DMA_NONE);
+	/*
+	 * If the address happens to be in the device's DMA window,
+	 * we can safely return the device addr and not worry about bounce
+	 * buffering it.
+	 */
+	if (dma_capable(dev, dev_addr, size) && swiotlb_force != SWIOTLB_FORCE)
+		return dev_addr;
+
+	trace_swiotlb_bounced(dev, dev_addr, size, swiotlb_force);
+
+	/* Oh well, have to allocate and map a bounce buffer. */
+	map = map_single(dev, phys, size, dir, attrs);
+	if (map == SWIOTLB_MAP_ERROR) {
+		swiotlb_full(dev, size, dir, 1);
+		return __phys_to_dma(dev, io_tlb_overflow_buffer);
+	}
+
+	dev_addr = __phys_to_dma(dev, map);
+
+	/* Ensure that the address returned is DMA'ble */
+	if (dma_capable(dev, dev_addr, size))
+		return dev_addr;
+
+	attrs |= DMA_ATTR_SKIP_CPU_SYNC;
+	swiotlb_tbl_unmap_single(dev, map, size, dir, attrs);
+
+	return __phys_to_dma(dev, io_tlb_overflow_buffer);
+}
+
+/*
+ * Unmap a single streaming mode DMA translation.  The dma_addr and size must
+ * match what was provided for in a previous swiotlb_map_page call.  All
+ * other usages are undefined.
+ *
+ * After this call, reads by the cpu to the buffer are guaranteed to see
+ * whatever the device wrote there.
+ */
+static void unmap_single(struct device *hwdev, dma_addr_t dev_addr,
+			 size_t size, enum dma_data_direction dir,
+			 unsigned long attrs)
+{
+	phys_addr_t paddr = dma_to_phys(hwdev, dev_addr);
+
+	BUG_ON(dir == DMA_NONE);
+
+	if (is_swiotlb_buffer(paddr)) {
+		swiotlb_tbl_unmap_single(hwdev, paddr, size, dir, attrs);
+		return;
+	}
+
+	if (dir != DMA_FROM_DEVICE)
+		return;
+
+	/*
+	 * phys_to_virt doesn't work with hihgmem page but we could
+	 * call dma_mark_clean() with hihgmem page here. However, we
+	 * are fine since dma_mark_clean() is null on POWERPC. We can
+	 * make dma_mark_clean() take a physical address if necessary.
+	 */
+	dma_mark_clean(phys_to_virt(paddr), size);
+}
+
+void swiotlb_unmap_page(struct device *hwdev, dma_addr_t dev_addr,
+			size_t size, enum dma_data_direction dir,
+			unsigned long attrs)
+{
+	unmap_single(hwdev, dev_addr, size, dir, attrs);
+}
+
+/*
+ * Make physical memory consistent for a single streaming mode DMA translation
+ * after a transfer.
+ *
+ * If you perform a swiotlb_map_page() but wish to interrogate the buffer
+ * using the cpu, yet do not wish to teardown the dma mapping, you must
+ * call this function before doing so.  At the next point you give the dma
+ * address back to the card, you must first perform a
+ * swiotlb_dma_sync_for_device, and then the device again owns the buffer
+ */
+static void
+swiotlb_sync_single(struct device *hwdev, dma_addr_t dev_addr,
+		    size_t size, enum dma_data_direction dir,
+		    enum dma_sync_target target)
+{
+	phys_addr_t paddr = dma_to_phys(hwdev, dev_addr);
+
+	BUG_ON(dir == DMA_NONE);
+
+	if (is_swiotlb_buffer(paddr)) {
+		swiotlb_tbl_sync_single(hwdev, paddr, size, dir, target);
+		return;
+	}
+
+	if (dir != DMA_FROM_DEVICE)
+		return;
+
+	dma_mark_clean(phys_to_virt(paddr), size);
+}
+
+void
+swiotlb_sync_single_for_cpu(struct device *hwdev, dma_addr_t dev_addr,
+			    size_t size, enum dma_data_direction dir)
+{
+	swiotlb_sync_single(hwdev, dev_addr, size, dir, SYNC_FOR_CPU);
+}
+
+void
+swiotlb_sync_single_for_device(struct device *hwdev, dma_addr_t dev_addr,
+			       size_t size, enum dma_data_direction dir)
+{
+	swiotlb_sync_single(hwdev, dev_addr, size, dir, SYNC_FOR_DEVICE);
+}
+
+/*
+ * Map a set of buffers described by scatterlist in streaming mode for DMA.
+ * This is the scatter-gather version of the above swiotlb_map_page
+ * interface.  Here the scatter gather list elements are each tagged with the
+ * appropriate dma address and length.  They are obtained via
+ * sg_dma_{address,length}(SG).
+ *
+ * NOTE: An implementation may be able to use a smaller number of
+ *       DMA address/length pairs than there are SG table elements.
+ *       (for example via virtual mapping capabilities)
+ *       The routine returns the number of addr/length pairs actually
+ *       used, at most nents.
+ *
+ * Device ownership issues as mentioned above for swiotlb_map_page are the
+ * same here.
+ */
+int
+swiotlb_map_sg_attrs(struct device *hwdev, struct scatterlist *sgl, int nelems,
+		     enum dma_data_direction dir, unsigned long attrs)
+{
+	struct scatterlist *sg;
+	int i;
+
+	BUG_ON(dir == DMA_NONE);
+
+	for_each_sg(sgl, sg, nelems, i) {
+		phys_addr_t paddr = sg_phys(sg);
+		dma_addr_t dev_addr = phys_to_dma(hwdev, paddr);
+
+		if (swiotlb_force == SWIOTLB_FORCE ||
+		    !dma_capable(hwdev, dev_addr, sg->length)) {
+			phys_addr_t map = map_single(hwdev, sg_phys(sg),
+						     sg->length, dir, attrs);
+			if (map == SWIOTLB_MAP_ERROR) {
+				/* Don't panic here, we expect map_sg users
+				   to do proper error handling. */
+				swiotlb_full(hwdev, sg->length, dir, 0);
+				attrs |= DMA_ATTR_SKIP_CPU_SYNC;
+				swiotlb_unmap_sg_attrs(hwdev, sgl, i, dir,
+						       attrs);
+				sg_dma_len(sgl) = 0;
+				return 0;
+			}
+			sg->dma_address = __phys_to_dma(hwdev, map);
+		} else
+			sg->dma_address = dev_addr;
+		sg_dma_len(sg) = sg->length;
+	}
+	return nelems;
+}
+
+/*
+ * Unmap a set of streaming mode DMA translations.  Again, cpu read rules
+ * concerning calls here are the same as for swiotlb_unmap_page() above.
+ */
+void
+swiotlb_unmap_sg_attrs(struct device *hwdev, struct scatterlist *sgl,
+		       int nelems, enum dma_data_direction dir,
+		       unsigned long attrs)
+{
+	struct scatterlist *sg;
+	int i;
+
+	BUG_ON(dir == DMA_NONE);
+
+	for_each_sg(sgl, sg, nelems, i)
+		unmap_single(hwdev, sg->dma_address, sg_dma_len(sg), dir,
+			     attrs);
+}
+
+/*
+ * Make physical memory consistent for a set of streaming mode DMA translations
+ * after a transfer.
+ *
+ * The same as swiotlb_sync_single_* but for a scatter-gather list, same rules
+ * and usage.
+ */
+static void
+swiotlb_sync_sg(struct device *hwdev, struct scatterlist *sgl,
+		int nelems, enum dma_data_direction dir,
+		enum dma_sync_target target)
+{
+	struct scatterlist *sg;
+	int i;
+
+	for_each_sg(sgl, sg, nelems, i)
+		swiotlb_sync_single(hwdev, sg->dma_address,
+				    sg_dma_len(sg), dir, target);
+}
+
+void
+swiotlb_sync_sg_for_cpu(struct device *hwdev, struct scatterlist *sg,
+			int nelems, enum dma_data_direction dir)
+{
+	swiotlb_sync_sg(hwdev, sg, nelems, dir, SYNC_FOR_CPU);
+}
+
+void
+swiotlb_sync_sg_for_device(struct device *hwdev, struct scatterlist *sg,
+			   int nelems, enum dma_data_direction dir)
+{
+	swiotlb_sync_sg(hwdev, sg, nelems, dir, SYNC_FOR_DEVICE);
+}
+
+int
+swiotlb_dma_mapping_error(struct device *hwdev, dma_addr_t dma_addr)
+{
+	return (dma_addr == __phys_to_dma(hwdev, io_tlb_overflow_buffer));
+}
+
+/*
+ * Return whether the given device DMA address mask can be supported
+ * properly.  For example, if your device can only drive the low 24-bits
+ * during bus mastering, then you would pass 0x00ffffff as the mask to
+ * this function.
+ */
+int
+swiotlb_dma_supported(struct device *hwdev, u64 mask)
+{
+	return __phys_to_dma(hwdev, io_tlb_end - 1) <= mask;
+}
+
+void *swiotlb_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
+		gfp_t gfp, unsigned long attrs)
+{
+	void *vaddr;
+
+	/* temporary workaround: */
+	if (gfp & __GFP_NOWARN)
+		attrs |= DMA_ATTR_NO_WARN;
+
+	/*
+	 * Don't print a warning when the first allocation attempt fails.
+	 * swiotlb_alloc_coherent() will print a warning when the DMA memory
+	 * allocation ultimately failed.
+	 */
+	gfp |= __GFP_NOWARN;
+
+	vaddr = dma_direct_alloc(dev, size, dma_handle, gfp, attrs);
+	if (!vaddr)
+		vaddr = swiotlb_alloc_buffer(dev, size, dma_handle, attrs);
+	return vaddr;
+}
+
+void swiotlb_free(struct device *dev, size_t size, void *vaddr,
+		dma_addr_t dma_addr, unsigned long attrs)
+{
+	if (!swiotlb_free_buffer(dev, size, dma_addr))
+		dma_direct_free(dev, size, vaddr, dma_addr, attrs);
+}
+
+const struct dma_map_ops swiotlb_dma_ops = {
+	.mapping_error		= swiotlb_dma_mapping_error,
+	.alloc			= swiotlb_alloc,
+	.free			= swiotlb_free,
+	.sync_single_for_cpu	= swiotlb_sync_single_for_cpu,
+	.sync_single_for_device	= swiotlb_sync_single_for_device,
+	.sync_sg_for_cpu	= swiotlb_sync_sg_for_cpu,
+	.sync_sg_for_device	= swiotlb_sync_sg_for_device,
+	.map_sg			= swiotlb_map_sg_attrs,
+	.unmap_sg		= swiotlb_unmap_sg_attrs,
+	.map_page		= swiotlb_map_page,
+	.unmap_page		= swiotlb_unmap_page,
+	.dma_supported		= dma_direct_supported,
+};
+EXPORT_SYMBOL(swiotlb_dma_ops);
diff --git a/kernel/dma/virt.c b/kernel/dma/virt.c
new file mode 100644
index 00000000..631ddec4
--- /dev/null
+++ b/kernel/dma/virt.c
@@ -0,0 +1,59 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * DMA operations that map to virtual addresses without flushing memory.
+ */
+#include <linux/export.h>
+#include <linux/mm.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+
+static void *dma_virt_alloc(struct device *dev, size_t size,
+			    dma_addr_t *dma_handle, gfp_t gfp,
+			    unsigned long attrs)
+{
+	void *ret;
+
+	ret = (void *)__get_free_pages(gfp, get_order(size));
+	if (ret)
+		*dma_handle = (uintptr_t)ret;
+	return ret;
+}
+
+static void dma_virt_free(struct device *dev, size_t size,
+			  void *cpu_addr, dma_addr_t dma_addr,
+			  unsigned long attrs)
+{
+	free_pages((unsigned long)cpu_addr, get_order(size));
+}
+
+static dma_addr_t dma_virt_map_page(struct device *dev, struct page *page,
+				    unsigned long offset, size_t size,
+				    enum dma_data_direction dir,
+				    unsigned long attrs)
+{
+	return (uintptr_t)(page_address(page) + offset);
+}
+
+static int dma_virt_map_sg(struct device *dev, struct scatterlist *sgl,
+			   int nents, enum dma_data_direction dir,
+			   unsigned long attrs)
+{
+	int i;
+	struct scatterlist *sg;
+
+	for_each_sg(sgl, sg, nents, i) {
+		BUG_ON(!sg_page(sg));
+		sg_dma_address(sg) = (uintptr_t)sg_virt(sg);
+		sg_dma_len(sg) = sg->length;
+	}
+
+	return nents;
+}
+
+const struct dma_map_ops dma_virt_ops = {
+	.alloc			= dma_virt_alloc,
+	.free			= dma_virt_free,
+	.map_page		= dma_virt_map_page,
+	.map_sg			= dma_virt_map_sg,
+};
+EXPORT_SYMBOL(dma_virt_ops);
diff --git a/kernel/irq/Kconfig b/kernel/irq/Kconfig
index c6766f32..5f3e2bae 100644
--- a/kernel/irq/Kconfig
+++ b/kernel/irq/Kconfig
@@ -134,7 +134,6 @@ config GENERIC_IRQ_DEBUGFS
 endmenu
 
 config GENERIC_IRQ_MULTI_HANDLER
-	depends on !MULTI_IRQ_HANDLER
 	bool
 	help
 	  Allow to specify the low level IRQ handler at run time.
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 6a78cf70..4ffb4d15 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -309,6 +309,15 @@ static int max_extfrag_threshold = 1000;
 #endif
 
 static struct ctl_table kern_table[] = {
+#ifdef CONFIG_ARCH_BINFMT_ELF_STATE
+	{
+		.procname	= "elf_attribute_checking",
+		.data		= &elf_hwcap,
+		.maxlen		= sizeof(unsigned int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+#endif
 	{
 		.procname	= "sched_child_runs_first",
 		.data		= &sysctl_sched_child_runs_first,
diff --git a/lib/.gitignore b/lib/.gitignore
deleted file mode 100644
index 09aae854..00000000
--- a/lib/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-#
-# Generated files
-#
-gen_crc32table
-crc32table.h
-oid_registry_data.c
diff --git a/lib/Kconfig b/lib/Kconfig
index 5fe57767..2fefeffe 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -420,24 +420,14 @@ config HAS_IOPORT_MAP
 	depends on HAS_IOMEM && !NO_IOPORT_MAP
 	default y
 
-config HAS_DMA
-	bool
-	depends on !NO_DMA
-	default y
+source "kernel/dma/Kconfig"
 
 config SGL_ALLOC
 	bool
 	default n
 
-config DMA_DIRECT_OPS
-	bool
-	depends on HAS_DMA && (!64BIT || ARCH_DMA_ADDR_T_64BIT)
-	default n
-
-config DMA_VIRT_OPS
+config IOMMU_HELPER
 	bool
-	depends on HAS_DMA && (!64BIT || ARCH_DMA_ADDR_T_64BIT)
-	default n
 
 config CHECK_SIGNATURE
 	bool
@@ -621,3 +611,6 @@ config GENERIC_CMPDI2
 
 config GENERIC_UCMPDI2
 	bool
+
+config GENERIC_UMODDI3
+	bool
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index c40c7b73..d5175eb7 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -1634,7 +1634,7 @@ config PROVIDE_OHCI1394_DMA_INIT
 
 config DMA_API_DEBUG
 	bool "Enable debugging of DMA-API usage"
-	depends on HAVE_DMA_API_DEBUG
+	select NEED_DMA_MAP_STATE
 	help
 	  Enable this option to debug the use of the DMA API by device drivers.
 	  With this option you will be able to detect common bugs in device
diff --git a/lib/Makefile b/lib/Makefile
index ce20696d..267bf215 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -29,8 +29,6 @@ lib-y := ctype.o string.o vsprintf.o cmdline.o \
 lib-$(CONFIG_PRINTK) += dump_stack.o
 lib-$(CONFIG_MMU) += ioremap.o
 lib-$(CONFIG_SMP) += cpumask.o
-lib-$(CONFIG_DMA_DIRECT_OPS) += dma-direct.o
-lib-$(CONFIG_DMA_VIRT_OPS) += dma-virt.o
 
 lib-y	+= kobject.o klist.o
 obj-y	+= lockref.o
@@ -146,8 +144,7 @@ obj-$(CONFIG_SMP) += percpu_counter.o
 obj-$(CONFIG_AUDIT_GENERIC) += audit.o
 obj-$(CONFIG_AUDIT_COMPAT_GENERIC) += compat_audit.o
 
-obj-$(CONFIG_SWIOTLB) += swiotlb.o
-obj-$(CONFIG_IOMMU_HELPER) += iommu-helper.o iommu-common.o
+obj-$(CONFIG_IOMMU_HELPER) += iommu-helper.o
 obj-$(CONFIG_FAULT_INJECTION) += fault-inject.o
 obj-$(CONFIG_NOTIFIER_ERROR_INJECTION) += notifier-error-inject.o
 obj-$(CONFIG_PM_NOTIFIER_ERROR_INJECT) += pm-notifier-error-inject.o
@@ -167,8 +164,6 @@ obj-$(CONFIG_NLATTR) += nlattr.o
 
 obj-$(CONFIG_LRU_CACHE) += lru_cache.o
 
-obj-$(CONFIG_DMA_API_DEBUG) += dma-debug.o
-
 obj-$(CONFIG_GENERIC_CSUM) += checksum.o
 
 obj-$(CONFIG_GENERIC_ATOMIC64) += atomic64.o
@@ -265,3 +260,4 @@ obj-$(CONFIG_GENERIC_LSHRDI3) += lshrdi3.o
 obj-$(CONFIG_GENERIC_MULDI3) += muldi3.o
 obj-$(CONFIG_GENERIC_CMPDI2) += cmpdi2.o
 obj-$(CONFIG_GENERIC_UCMPDI2) += ucmpdi2.o
+obj-$(CONFIG_GENERIC_UMODDI3) += umoddi3.o udivmoddi4.o
diff --git a/lib/dma-debug.c b/lib/dma-debug.c
deleted file mode 100644
index 7f5cdc1e..00000000
--- a/lib/dma-debug.c
+++ /dev/null
@@ -1,1752 +0,0 @@
-/*
- * Copyright (C) 2008 Advanced Micro Devices, Inc.
- *
- * Author: Joerg Roedel <joerg.roedel@amd.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-#include <linux/sched/task_stack.h>
-#include <linux/scatterlist.h>
-#include <linux/dma-mapping.h>
-#include <linux/sched/task.h>
-#include <linux/stacktrace.h>
-#include <linux/dma-debug.h>
-#include <linux/spinlock.h>
-#include <linux/vmalloc.h>
-#include <linux/debugfs.h>
-#include <linux/uaccess.h>
-#include <linux/export.h>
-#include <linux/device.h>
-#include <linux/types.h>
-#include <linux/sched.h>
-#include <linux/ctype.h>
-#include <linux/list.h>
-#include <linux/slab.h>
-
-#include <asm/sections.h>
-
-#define HASH_SIZE       1024ULL
-#define HASH_FN_SHIFT   13
-#define HASH_FN_MASK    (HASH_SIZE - 1)
-
-enum {
-	dma_debug_single,
-	dma_debug_page,
-	dma_debug_sg,
-	dma_debug_coherent,
-	dma_debug_resource,
-};
-
-enum map_err_types {
-	MAP_ERR_CHECK_NOT_APPLICABLE,
-	MAP_ERR_NOT_CHECKED,
-	MAP_ERR_CHECKED,
-};
-
-#define DMA_DEBUG_STACKTRACE_ENTRIES 5
-
-/**
- * struct dma_debug_entry - track a dma_map* or dma_alloc_coherent mapping
- * @list: node on pre-allocated free_entries list
- * @dev: 'dev' argument to dma_map_{page|single|sg} or dma_alloc_coherent
- * @type: single, page, sg, coherent
- * @pfn: page frame of the start address
- * @offset: offset of mapping relative to pfn
- * @size: length of the mapping
- * @direction: enum dma_data_direction
- * @sg_call_ents: 'nents' from dma_map_sg
- * @sg_mapped_ents: 'mapped_ents' from dma_map_sg
- * @map_err_type: track whether dma_mapping_error() was checked
- * @stacktrace: support backtraces when a violation is detected
- */
-struct dma_debug_entry {
-	struct list_head list;
-	struct device    *dev;
-	int              type;
-	unsigned long	 pfn;
-	size_t		 offset;
-	u64              dev_addr;
-	u64              size;
-	int              direction;
-	int		 sg_call_ents;
-	int		 sg_mapped_ents;
-	enum map_err_types  map_err_type;
-#ifdef CONFIG_STACKTRACE
-	struct		 stack_trace stacktrace;
-	unsigned long	 st_entries[DMA_DEBUG_STACKTRACE_ENTRIES];
-#endif
-};
-
-typedef bool (*match_fn)(struct dma_debug_entry *, struct dma_debug_entry *);
-
-struct hash_bucket {
-	struct list_head list;
-	spinlock_t lock;
-} ____cacheline_aligned_in_smp;
-
-/* Hash list to save the allocated dma addresses */
-static struct hash_bucket dma_entry_hash[HASH_SIZE];
-/* List of pre-allocated dma_debug_entry's */
-static LIST_HEAD(free_entries);
-/* Lock for the list above */
-static DEFINE_SPINLOCK(free_entries_lock);
-
-/* Global disable flag - will be set in case of an error */
-static bool global_disable __read_mostly;
-
-/* Early initialization disable flag, set at the end of dma_debug_init */
-static bool dma_debug_initialized __read_mostly;
-
-static inline bool dma_debug_disabled(void)
-{
-	return global_disable || !dma_debug_initialized;
-}
-
-/* Global error count */
-static u32 error_count;
-
-/* Global error show enable*/
-static u32 show_all_errors __read_mostly;
-/* Number of errors to show */
-static u32 show_num_errors = 1;
-
-static u32 num_free_entries;
-static u32 min_free_entries;
-static u32 nr_total_entries;
-
-/* number of preallocated entries requested by kernel cmdline */
-static u32 req_entries;
-
-/* debugfs dentry's for the stuff above */
-static struct dentry *dma_debug_dent        __read_mostly;
-static struct dentry *global_disable_dent   __read_mostly;
-static struct dentry *error_count_dent      __read_mostly;
-static struct dentry *show_all_errors_dent  __read_mostly;
-static struct dentry *show_num_errors_dent  __read_mostly;
-static struct dentry *num_free_entries_dent __read_mostly;
-static struct dentry *min_free_entries_dent __read_mostly;
-static struct dentry *filter_dent           __read_mostly;
-
-/* per-driver filter related state */
-
-#define NAME_MAX_LEN	64
-
-static char                  current_driver_name[NAME_MAX_LEN] __read_mostly;
-static struct device_driver *current_driver                    __read_mostly;
-
-static DEFINE_RWLOCK(driver_name_lock);
-
-static const char *const maperr2str[] = {
-	[MAP_ERR_CHECK_NOT_APPLICABLE] = "dma map error check not applicable",
-	[MAP_ERR_NOT_CHECKED] = "dma map error not checked",
-	[MAP_ERR_CHECKED] = "dma map error checked",
-};
-
-static const char *type2name[5] = { "single", "page",
-				    "scather-gather", "coherent",
-				    "resource" };
-
-static const char *dir2name[4] = { "DMA_BIDIRECTIONAL", "DMA_TO_DEVICE",
-				   "DMA_FROM_DEVICE", "DMA_NONE" };
-
-/*
- * The access to some variables in this macro is racy. We can't use atomic_t
- * here because all these variables are exported to debugfs. Some of them even
- * writeable. This is also the reason why a lock won't help much. But anyway,
- * the races are no big deal. Here is why:
- *
- *   error_count: the addition is racy, but the worst thing that can happen is
- *                that we don't count some errors
- *   show_num_errors: the subtraction is racy. Also no big deal because in
- *                    worst case this will result in one warning more in the
- *                    system log than the user configured. This variable is
- *                    writeable via debugfs.
- */
-static inline void dump_entry_trace(struct dma_debug_entry *entry)
-{
-#ifdef CONFIG_STACKTRACE
-	if (entry) {
-		pr_warning("Mapped at:\n");
-		print_stack_trace(&entry->stacktrace, 0);
-	}
-#endif
-}
-
-static bool driver_filter(struct device *dev)
-{
-	struct device_driver *drv;
-	unsigned long flags;
-	bool ret;
-
-	/* driver filter off */
-	if (likely(!current_driver_name[0]))
-		return true;
-
-	/* driver filter on and initialized */
-	if (current_driver && dev && dev->driver == current_driver)
-		return true;
-
-	/* driver filter on, but we can't filter on a NULL device... */
-	if (!dev)
-		return false;
-
-	if (current_driver || !current_driver_name[0])
-		return false;
-
-	/* driver filter on but not yet initialized */
-	drv = dev->driver;
-	if (!drv)
-		return false;
-
-	/* lock to protect against change of current_driver_name */
-	read_lock_irqsave(&driver_name_lock, flags);
-
-	ret = false;
-	if (drv->name &&
-	    strncmp(current_driver_name, drv->name, NAME_MAX_LEN - 1) == 0) {
-		current_driver = drv;
-		ret = true;
-	}
-
-	read_unlock_irqrestore(&driver_name_lock, flags);
-
-	return ret;
-}
-
-#define err_printk(dev, entry, format, arg...) do {			\
-		error_count += 1;					\
-		if (driver_filter(dev) &&				\
-		    (show_all_errors || show_num_errors > 0)) {		\
-			WARN(1, "%s %s: " format,			\
-			     dev ? dev_driver_string(dev) : "NULL",	\
-			     dev ? dev_name(dev) : "NULL", ## arg);	\
-			dump_entry_trace(entry);			\
-		}							\
-		if (!show_all_errors && show_num_errors > 0)		\
-			show_num_errors -= 1;				\
-	} while (0);
-
-/*
- * Hash related functions
- *
- * Every DMA-API request is saved into a struct dma_debug_entry. To
- * have quick access to these structs they are stored into a hash.
- */
-static int hash_fn(struct dma_debug_entry *entry)
-{
-	/*
-	 * Hash function is based on the dma address.
-	 * We use bits 20-27 here as the index into the hash
-	 */
-	return (entry->dev_addr >> HASH_FN_SHIFT) & HASH_FN_MASK;
-}
-
-/*
- * Request exclusive access to a hash bucket for a given dma_debug_entry.
- */
-static struct hash_bucket *get_hash_bucket(struct dma_debug_entry *entry,
-					   unsigned long *flags)
-	__acquires(&dma_entry_hash[idx].lock)
-{
-	int idx = hash_fn(entry);
-	unsigned long __flags;
-
-	spin_lock_irqsave(&dma_entry_hash[idx].lock, __flags);
-	*flags = __flags;
-	return &dma_entry_hash[idx];
-}
-
-/*
- * Give up exclusive access to the hash bucket
- */
-static void put_hash_bucket(struct hash_bucket *bucket,
-			    unsigned long *flags)
-	__releases(&bucket->lock)
-{
-	unsigned long __flags = *flags;
-
-	spin_unlock_irqrestore(&bucket->lock, __flags);
-}
-
-static bool exact_match(struct dma_debug_entry *a, struct dma_debug_entry *b)
-{
-	return ((a->dev_addr == b->dev_addr) &&
-		(a->dev == b->dev)) ? true : false;
-}
-
-static bool containing_match(struct dma_debug_entry *a,
-			     struct dma_debug_entry *b)
-{
-	if (a->dev != b->dev)
-		return false;
-
-	if ((b->dev_addr <= a->dev_addr) &&
-	    ((b->dev_addr + b->size) >= (a->dev_addr + a->size)))
-		return true;
-
-	return false;
-}
-
-/*
- * Search a given entry in the hash bucket list
- */
-static struct dma_debug_entry *__hash_bucket_find(struct hash_bucket *bucket,
-						  struct dma_debug_entry *ref,
-						  match_fn match)
-{
-	struct dma_debug_entry *entry, *ret = NULL;
-	int matches = 0, match_lvl, last_lvl = -1;
-
-	list_for_each_entry(entry, &bucket->list, list) {
-		if (!match(ref, entry))
-			continue;
-
-		/*
-		 * Some drivers map the same physical address multiple
-		 * times. Without a hardware IOMMU this results in the
-		 * same device addresses being put into the dma-debug
-		 * hash multiple times too. This can result in false
-		 * positives being reported. Therefore we implement a
-		 * best-fit algorithm here which returns the entry from
-		 * the hash which fits best to the reference value
-		 * instead of the first-fit.
-		 */
-		matches += 1;
-		match_lvl = 0;
-		entry->size         == ref->size         ? ++match_lvl : 0;
-		entry->type         == ref->type         ? ++match_lvl : 0;
-		entry->direction    == ref->direction    ? ++match_lvl : 0;
-		entry->sg_call_ents == ref->sg_call_ents ? ++match_lvl : 0;
-
-		if (match_lvl == 4) {
-			/* perfect-fit - return the result */
-			return entry;
-		} else if (match_lvl > last_lvl) {
-			/*
-			 * We found an entry that fits better then the
-			 * previous one or it is the 1st match.
-			 */
-			last_lvl = match_lvl;
-			ret      = entry;
-		}
-	}
-
-	/*
-	 * If we have multiple matches but no perfect-fit, just return
-	 * NULL.
-	 */
-	ret = (matches == 1) ? ret : NULL;
-
-	return ret;
-}
-
-static struct dma_debug_entry *bucket_find_exact(struct hash_bucket *bucket,
-						 struct dma_debug_entry *ref)
-{
-	return __hash_bucket_find(bucket, ref, exact_match);
-}
-
-static struct dma_debug_entry *bucket_find_contain(struct hash_bucket **bucket,
-						   struct dma_debug_entry *ref,
-						   unsigned long *flags)
-{
-
-	unsigned int max_range = dma_get_max_seg_size(ref->dev);
-	struct dma_debug_entry *entry, index = *ref;
-	unsigned int range = 0;
-
-	while (range <= max_range) {
-		entry = __hash_bucket_find(*bucket, ref, containing_match);
-
-		if (entry)
-			return entry;
-
-		/*
-		 * Nothing found, go back a hash bucket
-		 */
-		put_hash_bucket(*bucket, flags);
-		range          += (1 << HASH_FN_SHIFT);
-		index.dev_addr -= (1 << HASH_FN_SHIFT);
-		*bucket = get_hash_bucket(&index, flags);
-	}
-
-	return NULL;
-}
-
-/*
- * Add an entry to a hash bucket
- */
-static void hash_bucket_add(struct hash_bucket *bucket,
-			    struct dma_debug_entry *entry)
-{
-	list_add_tail(&entry->list, &bucket->list);
-}
-
-/*
- * Remove entry from a hash bucket list
- */
-static void hash_bucket_del(struct dma_debug_entry *entry)
-{
-	list_del(&entry->list);
-}
-
-static unsigned long long phys_addr(struct dma_debug_entry *entry)
-{
-	if (entry->type == dma_debug_resource)
-		return __pfn_to_phys(entry->pfn) + entry->offset;
-
-	return page_to_phys(pfn_to_page(entry->pfn)) + entry->offset;
-}
-
-/*
- * Dump mapping entries for debugging purposes
- */
-void debug_dma_dump_mappings(struct device *dev)
-{
-	int idx;
-
-	for (idx = 0; idx < HASH_SIZE; idx++) {
-		struct hash_bucket *bucket = &dma_entry_hash[idx];
-		struct dma_debug_entry *entry;
-		unsigned long flags;
-
-		spin_lock_irqsave(&bucket->lock, flags);
-
-		list_for_each_entry(entry, &bucket->list, list) {
-			if (!dev || dev == entry->dev) {
-				dev_info(entry->dev,
-					 "%s idx %d P=%Lx N=%lx D=%Lx L=%Lx %s %s\n",
-					 type2name[entry->type], idx,
-					 phys_addr(entry), entry->pfn,
-					 entry->dev_addr, entry->size,
-					 dir2name[entry->direction],
-					 maperr2str[entry->map_err_type]);
-			}
-		}
-
-		spin_unlock_irqrestore(&bucket->lock, flags);
-	}
-}
-EXPORT_SYMBOL(debug_dma_dump_mappings);
-
-/*
- * For each mapping (initial cacheline in the case of
- * dma_alloc_coherent/dma_map_page, initial cacheline in each page of a
- * scatterlist, or the cacheline specified in dma_map_single) insert
- * into this tree using the cacheline as the key. At
- * dma_unmap_{single|sg|page} or dma_free_coherent delete the entry.  If
- * the entry already exists at insertion time add a tag as a reference
- * count for the overlapping mappings.  For now, the overlap tracking
- * just ensures that 'unmaps' balance 'maps' before marking the
- * cacheline idle, but we should also be flagging overlaps as an API
- * violation.
- *
- * Memory usage is mostly constrained by the maximum number of available
- * dma-debug entries in that we need a free dma_debug_entry before
- * inserting into the tree.  In the case of dma_map_page and
- * dma_alloc_coherent there is only one dma_debug_entry and one
- * dma_active_cacheline entry to track per event.  dma_map_sg(), on the
- * other hand, consumes a single dma_debug_entry, but inserts 'nents'
- * entries into the tree.
- *
- * At any time debug_dma_assert_idle() can be called to trigger a
- * warning if any cachelines in the given page are in the active set.
- */
-static RADIX_TREE(dma_active_cacheline, GFP_NOWAIT);
-static DEFINE_SPINLOCK(radix_lock);
-#define ACTIVE_CACHELINE_MAX_OVERLAP ((1 << RADIX_TREE_MAX_TAGS) - 1)
-#define CACHELINE_PER_PAGE_SHIFT (PAGE_SHIFT - L1_CACHE_SHIFT)
-#define CACHELINES_PER_PAGE (1 << CACHELINE_PER_PAGE_SHIFT)
-
-static phys_addr_t to_cacheline_number(struct dma_debug_entry *entry)
-{
-	return (entry->pfn << CACHELINE_PER_PAGE_SHIFT) +
-		(entry->offset >> L1_CACHE_SHIFT);
-}
-
-static int active_cacheline_read_overlap(phys_addr_t cln)
-{
-	int overlap = 0, i;
-
-	for (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)
-		if (radix_tree_tag_get(&dma_active_cacheline, cln, i))
-			overlap |= 1 << i;
-	return overlap;
-}
-
-static int active_cacheline_set_overlap(phys_addr_t cln, int overlap)
-{
-	int i;
-
-	if (overlap > ACTIVE_CACHELINE_MAX_OVERLAP || overlap < 0)
-		return overlap;
-
-	for (i = RADIX_TREE_MAX_TAGS - 1; i >= 0; i--)
-		if (overlap & 1 << i)
-			radix_tree_tag_set(&dma_active_cacheline, cln, i);
-		else
-			radix_tree_tag_clear(&dma_active_cacheline, cln, i);
-
-	return overlap;
-}
-
-static void active_cacheline_inc_overlap(phys_addr_t cln)
-{
-	int overlap = active_cacheline_read_overlap(cln);
-
-	overlap = active_cacheline_set_overlap(cln, ++overlap);
-
-	/* If we overflowed the overlap counter then we're potentially
-	 * leaking dma-mappings.  Otherwise, if maps and unmaps are
-	 * balanced then this overflow may cause false negatives in
-	 * debug_dma_assert_idle() as the cacheline may be marked idle
-	 * prematurely.
-	 */
-	WARN_ONCE(overlap > ACTIVE_CACHELINE_MAX_OVERLAP,
-		  "DMA-API: exceeded %d overlapping mappings of cacheline %pa\n",
-		  ACTIVE_CACHELINE_MAX_OVERLAP, &cln);
-}
-
-static int active_cacheline_dec_overlap(phys_addr_t cln)
-{
-	int overlap = active_cacheline_read_overlap(cln);
-
-	return active_cacheline_set_overlap(cln, --overlap);
-}
-
-static int active_cacheline_insert(struct dma_debug_entry *entry)
-{
-	phys_addr_t cln = to_cacheline_number(entry);
-	unsigned long flags;
-	int rc;
-
-	/* If the device is not writing memory then we don't have any
-	 * concerns about the cpu consuming stale data.  This mitigates
-	 * legitimate usages of overlapping mappings.
-	 */
-	if (entry->direction == DMA_TO_DEVICE)
-		return 0;
-
-	spin_lock_irqsave(&radix_lock, flags);
-	rc = radix_tree_insert(&dma_active_cacheline, cln, entry);
-	if (rc == -EEXIST)
-		active_cacheline_inc_overlap(cln);
-	spin_unlock_irqrestore(&radix_lock, flags);
-
-	return rc;
-}
-
-static void active_cacheline_remove(struct dma_debug_entry *entry)
-{
-	phys_addr_t cln = to_cacheline_number(entry);
-	unsigned long flags;
-
-	/* ...mirror the insert case */
-	if (entry->direction == DMA_TO_DEVICE)
-		return;
-
-	spin_lock_irqsave(&radix_lock, flags);
-	/* since we are counting overlaps the final put of the
-	 * cacheline will occur when the overlap count is 0.
-	 * active_cacheline_dec_overlap() returns -1 in that case
-	 */
-	if (active_cacheline_dec_overlap(cln) < 0)
-		radix_tree_delete(&dma_active_cacheline, cln);
-	spin_unlock_irqrestore(&radix_lock, flags);
-}
-
-/**
- * debug_dma_assert_idle() - assert that a page is not undergoing dma
- * @page: page to lookup in the dma_active_cacheline tree
- *
- * Place a call to this routine in cases where the cpu touching the page
- * before the dma completes (page is dma_unmapped) will lead to data
- * corruption.
- */
-void debug_dma_assert_idle(struct page *page)
-{
-	static struct dma_debug_entry *ents[CACHELINES_PER_PAGE];
-	struct dma_debug_entry *entry = NULL;
-	void **results = (void **) &ents;
-	unsigned int nents, i;
-	unsigned long flags;
-	phys_addr_t cln;
-
-	if (dma_debug_disabled())
-		return;
-
-	if (!page)
-		return;
-
-	cln = (phys_addr_t) page_to_pfn(page) << CACHELINE_PER_PAGE_SHIFT;
-	spin_lock_irqsave(&radix_lock, flags);
-	nents = radix_tree_gang_lookup(&dma_active_cacheline, results, cln,
-				       CACHELINES_PER_PAGE);
-	for (i = 0; i < nents; i++) {
-		phys_addr_t ent_cln = to_cacheline_number(ents[i]);
-
-		if (ent_cln == cln) {
-			entry = ents[i];
-			break;
-		} else if (ent_cln >= cln + CACHELINES_PER_PAGE)
-			break;
-	}
-	spin_unlock_irqrestore(&radix_lock, flags);
-
-	if (!entry)
-		return;
-
-	cln = to_cacheline_number(entry);
-	err_printk(entry->dev, entry,
-		   "DMA-API: cpu touching an active dma mapped cacheline [cln=%pa]\n",
-		   &cln);
-}
-
-/*
- * Wrapper function for adding an entry to the hash.
- * This function takes care of locking itself.
- */
-static void add_dma_entry(struct dma_debug_entry *entry)
-{
-	struct hash_bucket *bucket;
-	unsigned long flags;
-	int rc;
-
-	bucket = get_hash_bucket(entry, &flags);
-	hash_bucket_add(bucket, entry);
-	put_hash_bucket(bucket, &flags);
-
-	rc = active_cacheline_insert(entry);
-	if (rc == -ENOMEM) {
-		pr_err("DMA-API: cacheline tracking ENOMEM, dma-debug disabled\n");
-		global_disable = true;
-	}
-
-	/* TODO: report -EEXIST errors here as overlapping mappings are
-	 * not supported by the DMA API
-	 */
-}
-
-static struct dma_debug_entry *__dma_entry_alloc(void)
-{
-	struct dma_debug_entry *entry;
-
-	entry = list_entry(free_entries.next, struct dma_debug_entry, list);
-	list_del(&entry->list);
-	memset(entry, 0, sizeof(*entry));
-
-	num_free_entries -= 1;
-	if (num_free_entries < min_free_entries)
-		min_free_entries = num_free_entries;
-
-	return entry;
-}
-
-/* struct dma_entry allocator
- *
- * The next two functions implement the allocator for
- * struct dma_debug_entries.
- */
-static struct dma_debug_entry *dma_entry_alloc(void)
-{
-	struct dma_debug_entry *entry;
-	unsigned long flags;
-
-	spin_lock_irqsave(&free_entries_lock, flags);
-
-	if (list_empty(&free_entries)) {
-		global_disable = true;
-		spin_unlock_irqrestore(&free_entries_lock, flags);
-		pr_err("DMA-API: debugging out of memory - disabling\n");
-		return NULL;
-	}
-
-	entry = __dma_entry_alloc();
-
-	spin_unlock_irqrestore(&free_entries_lock, flags);
-
-#ifdef CONFIG_STACKTRACE
-	entry->stacktrace.max_entries = DMA_DEBUG_STACKTRACE_ENTRIES;
-	entry->stacktrace.entries = entry->st_entries;
-	entry->stacktrace.skip = 2;
-	save_stack_trace(&entry->stacktrace);
-#endif
-
-	return entry;
-}
-
-static void dma_entry_free(struct dma_debug_entry *entry)
-{
-	unsigned long flags;
-
-	active_cacheline_remove(entry);
-
-	/*
-	 * add to beginning of the list - this way the entries are
-	 * more likely cache hot when they are reallocated.
-	 */
-	spin_lock_irqsave(&free_entries_lock, flags);
-	list_add(&entry->list, &free_entries);
-	num_free_entries += 1;
-	spin_unlock_irqrestore(&free_entries_lock, flags);
-}
-
-int dma_debug_resize_entries(u32 num_entries)
-{
-	int i, delta, ret = 0;
-	unsigned long flags;
-	struct dma_debug_entry *entry;
-	LIST_HEAD(tmp);
-
-	spin_lock_irqsave(&free_entries_lock, flags);
-
-	if (nr_total_entries < num_entries) {
-		delta = num_entries - nr_total_entries;
-
-		spin_unlock_irqrestore(&free_entries_lock, flags);
-
-		for (i = 0; i < delta; i++) {
-			entry = kzalloc(sizeof(*entry), GFP_KERNEL);
-			if (!entry)
-				break;
-
-			list_add_tail(&entry->list, &tmp);
-		}
-
-		spin_lock_irqsave(&free_entries_lock, flags);
-
-		list_splice(&tmp, &free_entries);
-		nr_total_entries += i;
-		num_free_entries += i;
-	} else {
-		delta = nr_total_entries - num_entries;
-
-		for (i = 0; i < delta && !list_empty(&free_entries); i++) {
-			entry = __dma_entry_alloc();
-			kfree(entry);
-		}
-
-		nr_total_entries -= i;
-	}
-
-	if (nr_total_entries != num_entries)
-		ret = 1;
-
-	spin_unlock_irqrestore(&free_entries_lock, flags);
-
-	return ret;
-}
-EXPORT_SYMBOL(dma_debug_resize_entries);
-
-/*
- * DMA-API debugging init code
- *
- * The init code does two things:
- *   1. Initialize core data structures
- *   2. Preallocate a given number of dma_debug_entry structs
- */
-
-static int prealloc_memory(u32 num_entries)
-{
-	struct dma_debug_entry *entry, *next_entry;
-	int i;
-
-	for (i = 0; i < num_entries; ++i) {
-		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
-		if (!entry)
-			goto out_err;
-
-		list_add_tail(&entry->list, &free_entries);
-	}
-
-	num_free_entries = num_entries;
-	min_free_entries = num_entries;
-
-	pr_info("DMA-API: preallocated %d debug entries\n", num_entries);
-
-	return 0;
-
-out_err:
-
-	list_for_each_entry_safe(entry, next_entry, &free_entries, list) {
-		list_del(&entry->list);
-		kfree(entry);
-	}
-
-	return -ENOMEM;
-}
-
-static ssize_t filter_read(struct file *file, char __user *user_buf,
-			   size_t count, loff_t *ppos)
-{
-	char buf[NAME_MAX_LEN + 1];
-	unsigned long flags;
-	int len;
-
-	if (!current_driver_name[0])
-		return 0;
-
-	/*
-	 * We can't copy to userspace directly because current_driver_name can
-	 * only be read under the driver_name_lock with irqs disabled. So
-	 * create a temporary copy first.
-	 */
-	read_lock_irqsave(&driver_name_lock, flags);
-	len = scnprintf(buf, NAME_MAX_LEN + 1, "%s\n", current_driver_name);
-	read_unlock_irqrestore(&driver_name_lock, flags);
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t filter_write(struct file *file, const char __user *userbuf,
-			    size_t count, loff_t *ppos)
-{
-	char buf[NAME_MAX_LEN];
-	unsigned long flags;
-	size_t len;
-	int i;
-
-	/*
-	 * We can't copy from userspace directly. Access to
-	 * current_driver_name is protected with a write_lock with irqs
-	 * disabled. Since copy_from_user can fault and may sleep we
-	 * need to copy to temporary buffer first
-	 */
-	len = min(count, (size_t)(NAME_MAX_LEN - 1));
-	if (copy_from_user(buf, userbuf, len))
-		return -EFAULT;
-
-	buf[len] = 0;
-
-	write_lock_irqsave(&driver_name_lock, flags);
-
-	/*
-	 * Now handle the string we got from userspace very carefully.
-	 * The rules are:
-	 *         - only use the first token we got
-	 *         - token delimiter is everything looking like a space
-	 *           character (' ', '\n', '\t' ...)
-	 *
-	 */
-	if (!isalnum(buf[0])) {
-		/*
-		 * If the first character userspace gave us is not
-		 * alphanumerical then assume the filter should be
-		 * switched off.
-		 */
-		if (current_driver_name[0])
-			pr_info("DMA-API: switching off dma-debug driver filter\n");
-		current_driver_name[0] = 0;
-		current_driver = NULL;
-		goto out_unlock;
-	}
-
-	/*
-	 * Now parse out the first token and use it as the name for the
-	 * driver to filter for.
-	 */
-	for (i = 0; i < NAME_MAX_LEN - 1; ++i) {
-		current_driver_name[i] = buf[i];
-		if (isspace(buf[i]) || buf[i] == ' ' || buf[i] == 0)
-			break;
-	}
-	current_driver_name[i] = 0;
-	current_driver = NULL;
-
-	pr_info("DMA-API: enable driver filter for driver [%s]\n",
-		current_driver_name);
-
-out_unlock:
-	write_unlock_irqrestore(&driver_name_lock, flags);
-
-	return count;
-}
-
-static const struct file_operations filter_fops = {
-	.read  = filter_read,
-	.write = filter_write,
-	.llseek = default_llseek,
-};
-
-static int dma_debug_fs_init(void)
-{
-	dma_debug_dent = debugfs_create_dir("dma-api", NULL);
-	if (!dma_debug_dent) {
-		pr_err("DMA-API: can not create debugfs directory\n");
-		return -ENOMEM;
-	}
-
-	global_disable_dent = debugfs_create_bool("disabled", 0444,
-			dma_debug_dent,
-			&global_disable);
-	if (!global_disable_dent)
-		goto out_err;
-
-	error_count_dent = debugfs_create_u32("error_count", 0444,
-			dma_debug_dent, &error_count);
-	if (!error_count_dent)
-		goto out_err;
-
-	show_all_errors_dent = debugfs_create_u32("all_errors", 0644,
-			dma_debug_dent,
-			&show_all_errors);
-	if (!show_all_errors_dent)
-		goto out_err;
-
-	show_num_errors_dent = debugfs_create_u32("num_errors", 0644,
-			dma_debug_dent,
-			&show_num_errors);
-	if (!show_num_errors_dent)
-		goto out_err;
-
-	num_free_entries_dent = debugfs_create_u32("num_free_entries", 0444,
-			dma_debug_dent,
-			&num_free_entries);
-	if (!num_free_entries_dent)
-		goto out_err;
-
-	min_free_entries_dent = debugfs_create_u32("min_free_entries", 0444,
-			dma_debug_dent,
-			&min_free_entries);
-	if (!min_free_entries_dent)
-		goto out_err;
-
-	filter_dent = debugfs_create_file("driver_filter", 0644,
-					  dma_debug_dent, NULL, &filter_fops);
-	if (!filter_dent)
-		goto out_err;
-
-	return 0;
-
-out_err:
-	debugfs_remove_recursive(dma_debug_dent);
-
-	return -ENOMEM;
-}
-
-static int device_dma_allocations(struct device *dev, struct dma_debug_entry **out_entry)
-{
-	struct dma_debug_entry *entry;
-	unsigned long flags;
-	int count = 0, i;
-
-	for (i = 0; i < HASH_SIZE; ++i) {
-		spin_lock_irqsave(&dma_entry_hash[i].lock, flags);
-		list_for_each_entry(entry, &dma_entry_hash[i].list, list) {
-			if (entry->dev == dev) {
-				count += 1;
-				*out_entry = entry;
-			}
-		}
-		spin_unlock_irqrestore(&dma_entry_hash[i].lock, flags);
-	}
-
-	return count;
-}
-
-static int dma_debug_device_change(struct notifier_block *nb, unsigned long action, void *data)
-{
-	struct device *dev = data;
-	struct dma_debug_entry *uninitialized_var(entry);
-	int count;
-
-	if (dma_debug_disabled())
-		return 0;
-
-	switch (action) {
-	case BUS_NOTIFY_UNBOUND_DRIVER:
-		count = device_dma_allocations(dev, &entry);
-		if (count == 0)
-			break;
-		err_printk(dev, entry, "DMA-API: device driver has pending "
-				"DMA allocations while released from device "
-				"[count=%d]\n"
-				"One of leaked entries details: "
-				"[device address=0x%016llx] [size=%llu bytes] "
-				"[mapped with %s] [mapped as %s]\n",
-			count, entry->dev_addr, entry->size,
-			dir2name[entry->direction], type2name[entry->type]);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-void dma_debug_add_bus(struct bus_type *bus)
-{
-	struct notifier_block *nb;
-
-	if (dma_debug_disabled())
-		return;
-
-	nb = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);
-	if (nb == NULL) {
-		pr_err("dma_debug_add_bus: out of memory\n");
-		return;
-	}
-
-	nb->notifier_call = dma_debug_device_change;
-
-	bus_register_notifier(bus, nb);
-}
-
-/*
- * Let the architectures decide how many entries should be preallocated.
- */
-void dma_debug_init(u32 num_entries)
-{
-	int i;
-
-	/* Do not use dma_debug_initialized here, since we really want to be
-	 * called to set dma_debug_initialized
-	 */
-	if (global_disable)
-		return;
-
-	for (i = 0; i < HASH_SIZE; ++i) {
-		INIT_LIST_HEAD(&dma_entry_hash[i].list);
-		spin_lock_init(&dma_entry_hash[i].lock);
-	}
-
-	if (dma_debug_fs_init() != 0) {
-		pr_err("DMA-API: error creating debugfs entries - disabling\n");
-		global_disable = true;
-
-		return;
-	}
-
-	if (req_entries)
-		num_entries = req_entries;
-
-	if (prealloc_memory(num_entries) != 0) {
-		pr_err("DMA-API: debugging out of memory error - disabled\n");
-		global_disable = true;
-
-		return;
-	}
-
-	nr_total_entries = num_free_entries;
-
-	dma_debug_initialized = true;
-
-	pr_info("DMA-API: debugging enabled by kernel config\n");
-}
-
-static __init int dma_debug_cmdline(char *str)
-{
-	if (!str)
-		return -EINVAL;
-
-	if (strncmp(str, "off", 3) == 0) {
-		pr_info("DMA-API: debugging disabled on kernel command line\n");
-		global_disable = true;
-	}
-
-	return 0;
-}
-
-static __init int dma_debug_entries_cmdline(char *str)
-{
-	int res;
-
-	if (!str)
-		return -EINVAL;
-
-	res = get_option(&str, &req_entries);
-
-	if (!res)
-		req_entries = 0;
-
-	return 0;
-}
-
-__setup("dma_debug=", dma_debug_cmdline);
-__setup("dma_debug_entries=", dma_debug_entries_cmdline);
-
-static void check_unmap(struct dma_debug_entry *ref)
-{
-	struct dma_debug_entry *entry;
-	struct hash_bucket *bucket;
-	unsigned long flags;
-
-	bucket = get_hash_bucket(ref, &flags);
-	entry = bucket_find_exact(bucket, ref);
-
-	if (!entry) {
-		/* must drop lock before calling dma_mapping_error */
-		put_hash_bucket(bucket, &flags);
-
-		if (dma_mapping_error(ref->dev, ref->dev_addr)) {
-			err_printk(ref->dev, NULL,
-				   "DMA-API: device driver tries to free an "
-				   "invalid DMA memory address\n");
-		} else {
-			err_printk(ref->dev, NULL,
-				   "DMA-API: device driver tries to free DMA "
-				   "memory it has not allocated [device "
-				   "address=0x%016llx] [size=%llu bytes]\n",
-				   ref->dev_addr, ref->size);
-		}
-		return;
-	}
-
-	if (ref->size != entry->size) {
-		err_printk(ref->dev, entry, "DMA-API: device driver frees "
-			   "DMA memory with different size "
-			   "[device address=0x%016llx] [map size=%llu bytes] "
-			   "[unmap size=%llu bytes]\n",
-			   ref->dev_addr, entry->size, ref->size);
-	}
-
-	if (ref->type != entry->type) {
-		err_printk(ref->dev, entry, "DMA-API: device driver frees "
-			   "DMA memory with wrong function "
-			   "[device address=0x%016llx] [size=%llu bytes] "
-			   "[mapped as %s] [unmapped as %s]\n",
-			   ref->dev_addr, ref->size,
-			   type2name[entry->type], type2name[ref->type]);
-	} else if ((entry->type == dma_debug_coherent) &&
-		   (phys_addr(ref) != phys_addr(entry))) {
-		err_printk(ref->dev, entry, "DMA-API: device driver frees "
-			   "DMA memory with different CPU address "
-			   "[device address=0x%016llx] [size=%llu bytes] "
-			   "[cpu alloc address=0x%016llx] "
-			   "[cpu free address=0x%016llx]",
-			   ref->dev_addr, ref->size,
-			   phys_addr(entry),
-			   phys_addr(ref));
-	}
-
-	if (ref->sg_call_ents && ref->type == dma_debug_sg &&
-	    ref->sg_call_ents != entry->sg_call_ents) {
-		err_printk(ref->dev, entry, "DMA-API: device driver frees "
-			   "DMA sg list with different entry count "
-			   "[map count=%d] [unmap count=%d]\n",
-			   entry->sg_call_ents, ref->sg_call_ents);
-	}
-
-	/*
-	 * This may be no bug in reality - but most implementations of the
-	 * DMA API don't handle this properly, so check for it here
-	 */
-	if (ref->direction != entry->direction) {
-		err_printk(ref->dev, entry, "DMA-API: device driver frees "
-			   "DMA memory with different direction "
-			   "[device address=0x%016llx] [size=%llu bytes] "
-			   "[mapped with %s] [unmapped with %s]\n",
-			   ref->dev_addr, ref->size,
-			   dir2name[entry->direction],
-			   dir2name[ref->direction]);
-	}
-
-	/*
-	 * Drivers should use dma_mapping_error() to check the returned
-	 * addresses of dma_map_single() and dma_map_page().
-	 * If not, print this warning message. See Documentation/DMA-API.txt.
-	 */
-	if (entry->map_err_type == MAP_ERR_NOT_CHECKED) {
-		err_printk(ref->dev, entry,
-			   "DMA-API: device driver failed to check map error"
-			   "[device address=0x%016llx] [size=%llu bytes] "
-			   "[mapped as %s]",
-			   ref->dev_addr, ref->size,
-			   type2name[entry->type]);
-	}
-
-	hash_bucket_del(entry);
-	dma_entry_free(entry);
-
-	put_hash_bucket(bucket, &flags);
-}
-
-static void check_for_stack(struct device *dev,
-			    struct page *page, size_t offset)
-{
-	void *addr;
-	struct vm_struct *stack_vm_area = task_stack_vm_area(current);
-
-	if (!stack_vm_area) {
-		/* Stack is direct-mapped. */
-		if (PageHighMem(page))
-			return;
-		addr = page_address(page) + offset;
-		if (object_is_on_stack(addr))
-			err_printk(dev, NULL, "DMA-API: device driver maps memory from stack [addr=%p]\n", addr);
-	} else {
-		/* Stack is vmalloced. */
-		int i;
-
-		for (i = 0; i < stack_vm_area->nr_pages; i++) {
-			if (page != stack_vm_area->pages[i])
-				continue;
-
-			addr = (u8 *)current->stack + i * PAGE_SIZE + offset;
-			err_printk(dev, NULL, "DMA-API: device driver maps memory from stack [probable addr=%p]\n", addr);
-			break;
-		}
-	}
-}
-
-static inline bool overlap(void *addr, unsigned long len, void *start, void *end)
-{
-	unsigned long a1 = (unsigned long)addr;
-	unsigned long b1 = a1 + len;
-	unsigned long a2 = (unsigned long)start;
-	unsigned long b2 = (unsigned long)end;
-
-	return !(b1 <= a2 || a1 >= b2);
-}
-
-static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)
-{
-	if (overlap(addr, len, _stext, _etext) ||
-	    overlap(addr, len, __start_rodata, __end_rodata))
-		err_printk(dev, NULL, "DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\n", addr, len);
-}
-
-static void check_sync(struct device *dev,
-		       struct dma_debug_entry *ref,
-		       bool to_cpu)
-{
-	struct dma_debug_entry *entry;
-	struct hash_bucket *bucket;
-	unsigned long flags;
-
-	bucket = get_hash_bucket(ref, &flags);
-
-	entry = bucket_find_contain(&bucket, ref, &flags);
-
-	if (!entry) {
-		err_printk(dev, NULL, "DMA-API: device driver tries "
-				"to sync DMA memory it has not allocated "
-				"[device address=0x%016llx] [size=%llu bytes]\n",
-				(unsigned long long)ref->dev_addr, ref->size);
-		goto out;
-	}
-
-	if (ref->size > entry->size) {
-		err_printk(dev, entry, "DMA-API: device driver syncs"
-				" DMA memory outside allocated range "
-				"[device address=0x%016llx] "
-				"[allocation size=%llu bytes] "
-				"[sync offset+size=%llu]\n",
-				entry->dev_addr, entry->size,
-				ref->size);
-	}
-
-	if (entry->direction == DMA_BIDIRECTIONAL)
-		goto out;
-
-	if (ref->direction != entry->direction) {
-		err_printk(dev, entry, "DMA-API: device driver syncs "
-				"DMA memory with different direction "
-				"[device address=0x%016llx] [size=%llu bytes] "
-				"[mapped with %s] [synced with %s]\n",
-				(unsigned long long)ref->dev_addr, entry->size,
-				dir2name[entry->direction],
-				dir2name[ref->direction]);
-	}
-
-	if (to_cpu && !(entry->direction == DMA_FROM_DEVICE) &&
-		      !(ref->direction == DMA_TO_DEVICE))
-		err_printk(dev, entry, "DMA-API: device driver syncs "
-				"device read-only DMA memory for cpu "
-				"[device address=0x%016llx] [size=%llu bytes] "
-				"[mapped with %s] [synced with %s]\n",
-				(unsigned long long)ref->dev_addr, entry->size,
-				dir2name[entry->direction],
-				dir2name[ref->direction]);
-
-	if (!to_cpu && !(entry->direction == DMA_TO_DEVICE) &&
-		       !(ref->direction == DMA_FROM_DEVICE))
-		err_printk(dev, entry, "DMA-API: device driver syncs "
-				"device write-only DMA memory to device "
-				"[device address=0x%016llx] [size=%llu bytes] "
-				"[mapped with %s] [synced with %s]\n",
-				(unsigned long long)ref->dev_addr, entry->size,
-				dir2name[entry->direction],
-				dir2name[ref->direction]);
-
-	if (ref->sg_call_ents && ref->type == dma_debug_sg &&
-	    ref->sg_call_ents != entry->sg_call_ents) {
-		err_printk(ref->dev, entry, "DMA-API: device driver syncs "
-			   "DMA sg list with different entry count "
-			   "[map count=%d] [sync count=%d]\n",
-			   entry->sg_call_ents, ref->sg_call_ents);
-	}
-
-out:
-	put_hash_bucket(bucket, &flags);
-}
-
-void debug_dma_map_page(struct device *dev, struct page *page, size_t offset,
-			size_t size, int direction, dma_addr_t dma_addr,
-			bool map_single)
-{
-	struct dma_debug_entry *entry;
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	if (dma_mapping_error(dev, dma_addr))
-		return;
-
-	entry = dma_entry_alloc();
-	if (!entry)
-		return;
-
-	entry->dev       = dev;
-	entry->type      = dma_debug_page;
-	entry->pfn	 = page_to_pfn(page);
-	entry->offset	 = offset,
-	entry->dev_addr  = dma_addr;
-	entry->size      = size;
-	entry->direction = direction;
-	entry->map_err_type = MAP_ERR_NOT_CHECKED;
-
-	if (map_single)
-		entry->type = dma_debug_single;
-
-	check_for_stack(dev, page, offset);
-
-	if (!PageHighMem(page)) {
-		void *addr = page_address(page) + offset;
-
-		check_for_illegal_area(dev, addr, size);
-	}
-
-	add_dma_entry(entry);
-}
-EXPORT_SYMBOL(debug_dma_map_page);
-
-void debug_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
-{
-	struct dma_debug_entry ref;
-	struct dma_debug_entry *entry;
-	struct hash_bucket *bucket;
-	unsigned long flags;
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	ref.dev = dev;
-	ref.dev_addr = dma_addr;
-	bucket = get_hash_bucket(&ref, &flags);
-
-	list_for_each_entry(entry, &bucket->list, list) {
-		if (!exact_match(&ref, entry))
-			continue;
-
-		/*
-		 * The same physical address can be mapped multiple
-		 * times. Without a hardware IOMMU this results in the
-		 * same device addresses being put into the dma-debug
-		 * hash multiple times too. This can result in false
-		 * positives being reported. Therefore we implement a
-		 * best-fit algorithm here which updates the first entry
-		 * from the hash which fits the reference value and is
-		 * not currently listed as being checked.
-		 */
-		if (entry->map_err_type == MAP_ERR_NOT_CHECKED) {
-			entry->map_err_type = MAP_ERR_CHECKED;
-			break;
-		}
-	}
-
-	put_hash_bucket(bucket, &flags);
-}
-EXPORT_SYMBOL(debug_dma_mapping_error);
-
-void debug_dma_unmap_page(struct device *dev, dma_addr_t addr,
-			  size_t size, int direction, bool map_single)
-{
-	struct dma_debug_entry ref = {
-		.type           = dma_debug_page,
-		.dev            = dev,
-		.dev_addr       = addr,
-		.size           = size,
-		.direction      = direction,
-	};
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	if (map_single)
-		ref.type = dma_debug_single;
-
-	check_unmap(&ref);
-}
-EXPORT_SYMBOL(debug_dma_unmap_page);
-
-void debug_dma_map_sg(struct device *dev, struct scatterlist *sg,
-		      int nents, int mapped_ents, int direction)
-{
-	struct dma_debug_entry *entry;
-	struct scatterlist *s;
-	int i;
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	for_each_sg(sg, s, mapped_ents, i) {
-		entry = dma_entry_alloc();
-		if (!entry)
-			return;
-
-		entry->type           = dma_debug_sg;
-		entry->dev            = dev;
-		entry->pfn	      = page_to_pfn(sg_page(s));
-		entry->offset	      = s->offset,
-		entry->size           = sg_dma_len(s);
-		entry->dev_addr       = sg_dma_address(s);
-		entry->direction      = direction;
-		entry->sg_call_ents   = nents;
-		entry->sg_mapped_ents = mapped_ents;
-
-		check_for_stack(dev, sg_page(s), s->offset);
-
-		if (!PageHighMem(sg_page(s))) {
-			check_for_illegal_area(dev, sg_virt(s), sg_dma_len(s));
-		}
-
-		add_dma_entry(entry);
-	}
-}
-EXPORT_SYMBOL(debug_dma_map_sg);
-
-static int get_nr_mapped_entries(struct device *dev,
-				 struct dma_debug_entry *ref)
-{
-	struct dma_debug_entry *entry;
-	struct hash_bucket *bucket;
-	unsigned long flags;
-	int mapped_ents;
-
-	bucket       = get_hash_bucket(ref, &flags);
-	entry        = bucket_find_exact(bucket, ref);
-	mapped_ents  = 0;
-
-	if (entry)
-		mapped_ents = entry->sg_mapped_ents;
-	put_hash_bucket(bucket, &flags);
-
-	return mapped_ents;
-}
-
-void debug_dma_unmap_sg(struct device *dev, struct scatterlist *sglist,
-			int nelems, int dir)
-{
-	struct scatterlist *s;
-	int mapped_ents = 0, i;
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	for_each_sg(sglist, s, nelems, i) {
-
-		struct dma_debug_entry ref = {
-			.type           = dma_debug_sg,
-			.dev            = dev,
-			.pfn		= page_to_pfn(sg_page(s)),
-			.offset		= s->offset,
-			.dev_addr       = sg_dma_address(s),
-			.size           = sg_dma_len(s),
-			.direction      = dir,
-			.sg_call_ents   = nelems,
-		};
-
-		if (mapped_ents && i >= mapped_ents)
-			break;
-
-		if (!i)
-			mapped_ents = get_nr_mapped_entries(dev, &ref);
-
-		check_unmap(&ref);
-	}
-}
-EXPORT_SYMBOL(debug_dma_unmap_sg);
-
-void debug_dma_alloc_coherent(struct device *dev, size_t size,
-			      dma_addr_t dma_addr, void *virt)
-{
-	struct dma_debug_entry *entry;
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	if (unlikely(virt == NULL))
-		return;
-
-	/* handle vmalloc and linear addresses */
-	if (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))
-		return;
-
-	entry = dma_entry_alloc();
-	if (!entry)
-		return;
-
-	entry->type      = dma_debug_coherent;
-	entry->dev       = dev;
-	entry->offset	 = offset_in_page(virt);
-	entry->size      = size;
-	entry->dev_addr  = dma_addr;
-	entry->direction = DMA_BIDIRECTIONAL;
-
-	if (is_vmalloc_addr(virt))
-		entry->pfn = vmalloc_to_pfn(virt);
-	else
-		entry->pfn = page_to_pfn(virt_to_page(virt));
-
-	add_dma_entry(entry);
-}
-EXPORT_SYMBOL(debug_dma_alloc_coherent);
-
-void debug_dma_free_coherent(struct device *dev, size_t size,
-			 void *virt, dma_addr_t addr)
-{
-	struct dma_debug_entry ref = {
-		.type           = dma_debug_coherent,
-		.dev            = dev,
-		.offset		= offset_in_page(virt),
-		.dev_addr       = addr,
-		.size           = size,
-		.direction      = DMA_BIDIRECTIONAL,
-	};
-
-	/* handle vmalloc and linear addresses */
-	if (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))
-		return;
-
-	if (is_vmalloc_addr(virt))
-		ref.pfn = vmalloc_to_pfn(virt);
-	else
-		ref.pfn = page_to_pfn(virt_to_page(virt));
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	check_unmap(&ref);
-}
-EXPORT_SYMBOL(debug_dma_free_coherent);
-
-void debug_dma_map_resource(struct device *dev, phys_addr_t addr, size_t size,
-			    int direction, dma_addr_t dma_addr)
-{
-	struct dma_debug_entry *entry;
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	entry = dma_entry_alloc();
-	if (!entry)
-		return;
-
-	entry->type		= dma_debug_resource;
-	entry->dev		= dev;
-	entry->pfn		= PHYS_PFN(addr);
-	entry->offset		= offset_in_page(addr);
-	entry->size		= size;
-	entry->dev_addr		= dma_addr;
-	entry->direction	= direction;
-	entry->map_err_type	= MAP_ERR_NOT_CHECKED;
-
-	add_dma_entry(entry);
-}
-EXPORT_SYMBOL(debug_dma_map_resource);
-
-void debug_dma_unmap_resource(struct device *dev, dma_addr_t dma_addr,
-			      size_t size, int direction)
-{
-	struct dma_debug_entry ref = {
-		.type           = dma_debug_resource,
-		.dev            = dev,
-		.dev_addr       = dma_addr,
-		.size           = size,
-		.direction      = direction,
-	};
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	check_unmap(&ref);
-}
-EXPORT_SYMBOL(debug_dma_unmap_resource);
-
-void debug_dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,
-				   size_t size, int direction)
-{
-	struct dma_debug_entry ref;
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	ref.type         = dma_debug_single;
-	ref.dev          = dev;
-	ref.dev_addr     = dma_handle;
-	ref.size         = size;
-	ref.direction    = direction;
-	ref.sg_call_ents = 0;
-
-	check_sync(dev, &ref, true);
-}
-EXPORT_SYMBOL(debug_dma_sync_single_for_cpu);
-
-void debug_dma_sync_single_for_device(struct device *dev,
-				      dma_addr_t dma_handle, size_t size,
-				      int direction)
-{
-	struct dma_debug_entry ref;
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	ref.type         = dma_debug_single;
-	ref.dev          = dev;
-	ref.dev_addr     = dma_handle;
-	ref.size         = size;
-	ref.direction    = direction;
-	ref.sg_call_ents = 0;
-
-	check_sync(dev, &ref, false);
-}
-EXPORT_SYMBOL(debug_dma_sync_single_for_device);
-
-void debug_dma_sync_single_range_for_cpu(struct device *dev,
-					 dma_addr_t dma_handle,
-					 unsigned long offset, size_t size,
-					 int direction)
-{
-	struct dma_debug_entry ref;
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	ref.type         = dma_debug_single;
-	ref.dev          = dev;
-	ref.dev_addr     = dma_handle;
-	ref.size         = offset + size;
-	ref.direction    = direction;
-	ref.sg_call_ents = 0;
-
-	check_sync(dev, &ref, true);
-}
-EXPORT_SYMBOL(debug_dma_sync_single_range_for_cpu);
-
-void debug_dma_sync_single_range_for_device(struct device *dev,
-					    dma_addr_t dma_handle,
-					    unsigned long offset,
-					    size_t size, int direction)
-{
-	struct dma_debug_entry ref;
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	ref.type         = dma_debug_single;
-	ref.dev          = dev;
-	ref.dev_addr     = dma_handle;
-	ref.size         = offset + size;
-	ref.direction    = direction;
-	ref.sg_call_ents = 0;
-
-	check_sync(dev, &ref, false);
-}
-EXPORT_SYMBOL(debug_dma_sync_single_range_for_device);
-
-void debug_dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
-			       int nelems, int direction)
-{
-	struct scatterlist *s;
-	int mapped_ents = 0, i;
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	for_each_sg(sg, s, nelems, i) {
-
-		struct dma_debug_entry ref = {
-			.type           = dma_debug_sg,
-			.dev            = dev,
-			.pfn		= page_to_pfn(sg_page(s)),
-			.offset		= s->offset,
-			.dev_addr       = sg_dma_address(s),
-			.size           = sg_dma_len(s),
-			.direction      = direction,
-			.sg_call_ents   = nelems,
-		};
-
-		if (!i)
-			mapped_ents = get_nr_mapped_entries(dev, &ref);
-
-		if (i >= mapped_ents)
-			break;
-
-		check_sync(dev, &ref, true);
-	}
-}
-EXPORT_SYMBOL(debug_dma_sync_sg_for_cpu);
-
-void debug_dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
-				  int nelems, int direction)
-{
-	struct scatterlist *s;
-	int mapped_ents = 0, i;
-
-	if (unlikely(dma_debug_disabled()))
-		return;
-
-	for_each_sg(sg, s, nelems, i) {
-
-		struct dma_debug_entry ref = {
-			.type           = dma_debug_sg,
-			.dev            = dev,
-			.pfn		= page_to_pfn(sg_page(s)),
-			.offset		= s->offset,
-			.dev_addr       = sg_dma_address(s),
-			.size           = sg_dma_len(s),
-			.direction      = direction,
-			.sg_call_ents   = nelems,
-		};
-		if (!i)
-			mapped_ents = get_nr_mapped_entries(dev, &ref);
-
-		if (i >= mapped_ents)
-			break;
-
-		check_sync(dev, &ref, false);
-	}
-}
-EXPORT_SYMBOL(debug_dma_sync_sg_for_device);
-
-static int __init dma_debug_driver_setup(char *str)
-{
-	int i;
-
-	for (i = 0; i < NAME_MAX_LEN - 1; ++i, ++str) {
-		current_driver_name[i] = *str;
-		if (*str == 0)
-			break;
-	}
-
-	if (current_driver_name[0])
-		pr_info("DMA-API: enable driver filter for driver [%s]\n",
-			current_driver_name);
-
-
-	return 1;
-}
-__setup("dma_debug_driver=", dma_debug_driver_setup);
diff --git a/lib/dma-direct.c b/lib/dma-direct.c
deleted file mode 100644
index bbfb229a..00000000
--- a/lib/dma-direct.c
+++ /dev/null
@@ -1,185 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * DMA operations that map physical memory directly without using an IOMMU or
- * flushing caches.
- */
-#include <linux/export.h>
-#include <linux/mm.h>
-#include <linux/dma-direct.h>
-#include <linux/scatterlist.h>
-#include <linux/dma-contiguous.h>
-#include <linux/pfn.h>
-#include <linux/set_memory.h>
-
-#define DIRECT_MAPPING_ERROR		0
-
-/*
- * Most architectures use ZONE_DMA for the first 16 Megabytes, but
- * some use it for entirely different regions:
- */
-#ifndef ARCH_ZONE_DMA_BITS
-#define ARCH_ZONE_DMA_BITS 24
-#endif
-
-/*
- * For AMD SEV all DMA must be to unencrypted addresses.
- */
-static inline bool force_dma_unencrypted(void)
-{
-	return sev_active();
-}
-
-static bool
-check_addr(struct device *dev, dma_addr_t dma_addr, size_t size,
-		const char *caller)
-{
-	if (unlikely(dev && !dma_capable(dev, dma_addr, size))) {
-		if (*dev->dma_mask >= DMA_BIT_MASK(32)) {
-			dev_err(dev,
-				"%s: overflow %pad+%zu of device mask %llx\n",
-				caller, &dma_addr, size, *dev->dma_mask);
-		}
-		return false;
-	}
-	return true;
-}
-
-static bool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)
-{
-	dma_addr_t addr = force_dma_unencrypted() ?
-		__phys_to_dma(dev, phys) : phys_to_dma(dev, phys);
-	return addr + size - 1 <= dev->coherent_dma_mask;
-}
-
-void *dma_direct_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
-		gfp_t gfp, unsigned long attrs)
-{
-	unsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;
-	int page_order = get_order(size);
-	struct page *page = NULL;
-	void *ret;
-
-	/* we always manually zero the memory once we are done: */
-	gfp &= ~__GFP_ZERO;
-
-	/* GFP_DMA32 and GFP_DMA are no ops without the corresponding zones: */
-	if (dev->coherent_dma_mask <= DMA_BIT_MASK(ARCH_ZONE_DMA_BITS))
-		gfp |= GFP_DMA;
-	if (dev->coherent_dma_mask <= DMA_BIT_MASK(32) && !(gfp & GFP_DMA))
-		gfp |= GFP_DMA32;
-
-again:
-	/* CMA can be used only in the context which permits sleeping */
-	if (gfpflags_allow_blocking(gfp)) {
-		page = dma_alloc_from_contiguous(dev, count, page_order, gfp);
-		if (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {
-			dma_release_from_contiguous(dev, page, count);
-			page = NULL;
-		}
-	}
-	if (!page)
-		page = alloc_pages_node(dev_to_node(dev), gfp, page_order);
-
-	if (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {
-		__free_pages(page, page_order);
-		page = NULL;
-
-		if (IS_ENABLED(CONFIG_ZONE_DMA) &&
-		    dev->coherent_dma_mask < DMA_BIT_MASK(32) &&
-		    !(gfp & GFP_DMA)) {
-			gfp = (gfp & ~GFP_DMA32) | GFP_DMA;
-			goto again;
-		}
-	}
-
-	if (!page)
-		return NULL;
-	ret = page_address(page);
-	if (force_dma_unencrypted()) {
-		set_memory_decrypted((unsigned long)ret, 1 << page_order);
-		*dma_handle = __phys_to_dma(dev, page_to_phys(page));
-	} else {
-		*dma_handle = phys_to_dma(dev, page_to_phys(page));
-	}
-	memset(ret, 0, size);
-	return ret;
-}
-
-/*
- * NOTE: this function must never look at the dma_addr argument, because we want
- * to be able to use it as a helper for iommu implementations as well.
- */
-void dma_direct_free(struct device *dev, size_t size, void *cpu_addr,
-		dma_addr_t dma_addr, unsigned long attrs)
-{
-	unsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;
-	unsigned int page_order = get_order(size);
-
-	if (force_dma_unencrypted())
-		set_memory_encrypted((unsigned long)cpu_addr, 1 << page_order);
-	if (!dma_release_from_contiguous(dev, virt_to_page(cpu_addr), count))
-		free_pages((unsigned long)cpu_addr, page_order);
-}
-
-static dma_addr_t dma_direct_map_page(struct device *dev, struct page *page,
-		unsigned long offset, size_t size, enum dma_data_direction dir,
-		unsigned long attrs)
-{
-	dma_addr_t dma_addr = phys_to_dma(dev, page_to_phys(page)) + offset;
-
-	if (!check_addr(dev, dma_addr, size, __func__))
-		return DIRECT_MAPPING_ERROR;
-	return dma_addr;
-}
-
-static int dma_direct_map_sg(struct device *dev, struct scatterlist *sgl,
-		int nents, enum dma_data_direction dir, unsigned long attrs)
-{
-	int i;
-	struct scatterlist *sg;
-
-	for_each_sg(sgl, sg, nents, i) {
-		BUG_ON(!sg_page(sg));
-
-		sg_dma_address(sg) = phys_to_dma(dev, sg_phys(sg));
-		if (!check_addr(dev, sg_dma_address(sg), sg->length, __func__))
-			return 0;
-		sg_dma_len(sg) = sg->length;
-	}
-
-	return nents;
-}
-
-int dma_direct_supported(struct device *dev, u64 mask)
-{
-#ifdef CONFIG_ZONE_DMA
-	if (mask < DMA_BIT_MASK(ARCH_ZONE_DMA_BITS))
-		return 0;
-#else
-	/*
-	 * Because 32-bit DMA masks are so common we expect every architecture
-	 * to be able to satisfy them - either by not supporting more physical
-	 * memory, or by providing a ZONE_DMA32.  If neither is the case, the
-	 * architecture needs to use an IOMMU instead of the direct mapping.
-	 */
-	if (mask < DMA_BIT_MASK(32))
-		return 0;
-#endif
-	return 1;
-}
-
-static int dma_direct_mapping_error(struct device *dev, dma_addr_t dma_addr)
-{
-	return dma_addr == DIRECT_MAPPING_ERROR;
-}
-
-const struct dma_map_ops dma_direct_ops = {
-	.alloc			= dma_direct_alloc,
-	.free			= dma_direct_free,
-	.map_page		= dma_direct_map_page,
-	.map_sg			= dma_direct_map_sg,
-	.dma_supported		= dma_direct_supported,
-	.mapping_error		= dma_direct_mapping_error,
-	.is_phys		= 1,
-};
-EXPORT_SYMBOL(dma_direct_ops);
diff --git a/lib/dma-virt.c b/lib/dma-virt.c
deleted file mode 100644
index 8e61a02e..00000000
--- a/lib/dma-virt.c
+++ /dev/null
@@ -1,61 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *	lib/dma-virt.c
- *
- * DMA operations that map to virtual addresses without flushing memory.
- */
-#include <linux/export.h>
-#include <linux/mm.h>
-#include <linux/dma-mapping.h>
-#include <linux/scatterlist.h>
-
-static void *dma_virt_alloc(struct device *dev, size_t size,
-			    dma_addr_t *dma_handle, gfp_t gfp,
-			    unsigned long attrs)
-{
-	void *ret;
-
-	ret = (void *)__get_free_pages(gfp, get_order(size));
-	if (ret)
-		*dma_handle = (uintptr_t)ret;
-	return ret;
-}
-
-static void dma_virt_free(struct device *dev, size_t size,
-			  void *cpu_addr, dma_addr_t dma_addr,
-			  unsigned long attrs)
-{
-	free_pages((unsigned long)cpu_addr, get_order(size));
-}
-
-static dma_addr_t dma_virt_map_page(struct device *dev, struct page *page,
-				    unsigned long offset, size_t size,
-				    enum dma_data_direction dir,
-				    unsigned long attrs)
-{
-	return (uintptr_t)(page_address(page) + offset);
-}
-
-static int dma_virt_map_sg(struct device *dev, struct scatterlist *sgl,
-			   int nents, enum dma_data_direction dir,
-			   unsigned long attrs)
-{
-	int i;
-	struct scatterlist *sg;
-
-	for_each_sg(sgl, sg, nents, i) {
-		BUG_ON(!sg_page(sg));
-		sg_dma_address(sg) = (uintptr_t)sg_virt(sg);
-		sg_dma_len(sg) = sg->length;
-	}
-
-	return nents;
-}
-
-const struct dma_map_ops dma_virt_ops = {
-	.alloc			= dma_virt_alloc,
-	.free			= dma_virt_free,
-	.map_page		= dma_virt_map_page,
-	.map_sg			= dma_virt_map_sg,
-};
-EXPORT_SYMBOL(dma_virt_ops);
diff --git a/lib/iommu-common.c b/lib/iommu-common.c
deleted file mode 100644
index 55b00de1..00000000
--- a/lib/iommu-common.c
+++ /dev/null
@@ -1,267 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * IOMMU mmap management and range allocation functions.
- * Based almost entirely upon the powerpc iommu allocator.
- */
-
-#include <linux/export.h>
-#include <linux/bitmap.h>
-#include <linux/bug.h>
-#include <linux/iommu-helper.h>
-#include <linux/iommu-common.h>
-#include <linux/dma-mapping.h>
-#include <linux/hash.h>
-
-static unsigned long iommu_large_alloc = 15;
-
-static	DEFINE_PER_CPU(unsigned int, iommu_hash_common);
-
-static inline bool need_flush(struct iommu_map_table *iommu)
-{
-	return ((iommu->flags & IOMMU_NEED_FLUSH) != 0);
-}
-
-static inline void set_flush(struct iommu_map_table *iommu)
-{
-	iommu->flags |= IOMMU_NEED_FLUSH;
-}
-
-static inline void clear_flush(struct iommu_map_table *iommu)
-{
-	iommu->flags &= ~IOMMU_NEED_FLUSH;
-}
-
-static void setup_iommu_pool_hash(void)
-{
-	unsigned int i;
-	static bool do_once;
-
-	if (do_once)
-		return;
-	do_once = true;
-	for_each_possible_cpu(i)
-		per_cpu(iommu_hash_common, i) = hash_32(i, IOMMU_POOL_HASHBITS);
-}
-
-/*
- * Initialize iommu_pool entries for the iommu_map_table. `num_entries'
- * is the number of table entries. If `large_pool' is set to true,
- * the top 1/4 of the table will be set aside for pool allocations
- * of more than iommu_large_alloc pages.
- */
-void iommu_tbl_pool_init(struct iommu_map_table *iommu,
-			 unsigned long num_entries,
-			 u32 table_shift,
-			 void (*lazy_flush)(struct iommu_map_table *),
-			 bool large_pool, u32 npools,
-			 bool skip_span_boundary_check)
-{
-	unsigned int start, i;
-	struct iommu_pool *p = &(iommu->large_pool);
-
-	setup_iommu_pool_hash();
-	if (npools == 0)
-		iommu->nr_pools = IOMMU_NR_POOLS;
-	else
-		iommu->nr_pools = npools;
-	BUG_ON(npools > IOMMU_NR_POOLS);
-
-	iommu->table_shift = table_shift;
-	iommu->lazy_flush = lazy_flush;
-	start = 0;
-	if (skip_span_boundary_check)
-		iommu->flags |= IOMMU_NO_SPAN_BOUND;
-	if (large_pool)
-		iommu->flags |= IOMMU_HAS_LARGE_POOL;
-
-	if (!large_pool)
-		iommu->poolsize = num_entries/iommu->nr_pools;
-	else
-		iommu->poolsize = (num_entries * 3 / 4)/iommu->nr_pools;
-	for (i = 0; i < iommu->nr_pools; i++) {
-		spin_lock_init(&(iommu->pools[i].lock));
-		iommu->pools[i].start = start;
-		iommu->pools[i].hint = start;
-		start += iommu->poolsize; /* start for next pool */
-		iommu->pools[i].end = start - 1;
-	}
-	if (!large_pool)
-		return;
-	/* initialize large_pool */
-	spin_lock_init(&(p->lock));
-	p->start = start;
-	p->hint = p->start;
-	p->end = num_entries;
-}
-EXPORT_SYMBOL(iommu_tbl_pool_init);
-
-unsigned long iommu_tbl_range_alloc(struct device *dev,
-				struct iommu_map_table *iommu,
-				unsigned long npages,
-				unsigned long *handle,
-				unsigned long mask,
-				unsigned int align_order)
-{
-	unsigned int pool_hash = __this_cpu_read(iommu_hash_common);
-	unsigned long n, end, start, limit, boundary_size;
-	struct iommu_pool *pool;
-	int pass = 0;
-	unsigned int pool_nr;
-	unsigned int npools = iommu->nr_pools;
-	unsigned long flags;
-	bool large_pool = ((iommu->flags & IOMMU_HAS_LARGE_POOL) != 0);
-	bool largealloc = (large_pool && npages > iommu_large_alloc);
-	unsigned long shift;
-	unsigned long align_mask = 0;
-
-	if (align_order > 0)
-		align_mask = ~0ul >> (BITS_PER_LONG - align_order);
-
-	/* Sanity check */
-	if (unlikely(npages == 0)) {
-		WARN_ON_ONCE(1);
-		return IOMMU_ERROR_CODE;
-	}
-
-	if (largealloc) {
-		pool = &(iommu->large_pool);
-		pool_nr = 0; /* to keep compiler happy */
-	} else {
-		/* pick out pool_nr */
-		pool_nr =  pool_hash & (npools - 1);
-		pool = &(iommu->pools[pool_nr]);
-	}
-	spin_lock_irqsave(&pool->lock, flags);
-
- again:
-	if (pass == 0 && handle && *handle &&
-	    (*handle >= pool->start) && (*handle < pool->end))
-		start = *handle;
-	else
-		start = pool->hint;
-
-	limit = pool->end;
-
-	/* The case below can happen if we have a small segment appended
-	 * to a large, or when the previous alloc was at the very end of
-	 * the available space. If so, go back to the beginning. If a
-	 * flush is needed, it will get done based on the return value
-	 * from iommu_area_alloc() below.
-	 */
-	if (start >= limit)
-		start = pool->start;
-	shift = iommu->table_map_base >> iommu->table_shift;
-	if (limit + shift > mask) {
-		limit = mask - shift + 1;
-		/* If we're constrained on address range, first try
-		 * at the masked hint to avoid O(n) search complexity,
-		 * but on second pass, start at 0 in pool 0.
-		 */
-		if ((start & mask) >= limit || pass > 0) {
-			spin_unlock(&(pool->lock));
-			pool = &(iommu->pools[0]);
-			spin_lock(&(pool->lock));
-			start = pool->start;
-		} else {
-			start &= mask;
-		}
-	}
-
-	if (dev)
-		boundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,
-				      1 << iommu->table_shift);
-	else
-		boundary_size = ALIGN(1ULL << 32, 1 << iommu->table_shift);
-
-	boundary_size = boundary_size >> iommu->table_shift;
-	/*
-	 * if the skip_span_boundary_check had been set during init, we set
-	 * things up so that iommu_is_span_boundary() merely checks if the
-	 * (index + npages) < num_tsb_entries
-	 */
-	if ((iommu->flags & IOMMU_NO_SPAN_BOUND) != 0) {
-		shift = 0;
-		boundary_size = iommu->poolsize * iommu->nr_pools;
-	}
-	n = iommu_area_alloc(iommu->map, limit, start, npages, shift,
-			     boundary_size, align_mask);
-	if (n == -1) {
-		if (likely(pass == 0)) {
-			/* First failure, rescan from the beginning.  */
-			pool->hint = pool->start;
-			set_flush(iommu);
-			pass++;
-			goto again;
-		} else if (!largealloc && pass <= iommu->nr_pools) {
-			spin_unlock(&(pool->lock));
-			pool_nr = (pool_nr + 1) & (iommu->nr_pools - 1);
-			pool = &(iommu->pools[pool_nr]);
-			spin_lock(&(pool->lock));
-			pool->hint = pool->start;
-			set_flush(iommu);
-			pass++;
-			goto again;
-		} else {
-			/* give up */
-			n = IOMMU_ERROR_CODE;
-			goto bail;
-		}
-	}
-	if (iommu->lazy_flush &&
-	    (n < pool->hint || need_flush(iommu))) {
-		clear_flush(iommu);
-		iommu->lazy_flush(iommu);
-	}
-
-	end = n + npages;
-	pool->hint = end;
-
-	/* Update handle for SG allocations */
-	if (handle)
-		*handle = end;
-bail:
-	spin_unlock_irqrestore(&(pool->lock), flags);
-
-	return n;
-}
-EXPORT_SYMBOL(iommu_tbl_range_alloc);
-
-static struct iommu_pool *get_pool(struct iommu_map_table *tbl,
-				   unsigned long entry)
-{
-	struct iommu_pool *p;
-	unsigned long largepool_start = tbl->large_pool.start;
-	bool large_pool = ((tbl->flags & IOMMU_HAS_LARGE_POOL) != 0);
-
-	/* The large pool is the last pool at the top of the table */
-	if (large_pool && entry >= largepool_start) {
-		p = &tbl->large_pool;
-	} else {
-		unsigned int pool_nr = entry / tbl->poolsize;
-
-		BUG_ON(pool_nr >= tbl->nr_pools);
-		p = &tbl->pools[pool_nr];
-	}
-	return p;
-}
-
-/* Caller supplies the index of the entry into the iommu map table
- * itself when the mapping from dma_addr to the entry is not the
- * default addr->entry mapping below.
- */
-void iommu_tbl_range_free(struct iommu_map_table *iommu, u64 dma_addr,
-			  unsigned long npages, unsigned long entry)
-{
-	struct iommu_pool *pool;
-	unsigned long flags;
-	unsigned long shift = iommu->table_shift;
-
-	if (entry == IOMMU_ERROR_CODE) /* use default addr->entry mapping */
-		entry = (dma_addr - iommu->table_map_base) >> shift;
-	pool = get_pool(iommu, entry);
-
-	spin_lock_irqsave(&(pool->lock), flags);
-	bitmap_clear(iommu->map, entry, npages);
-	spin_unlock_irqrestore(&(pool->lock), flags);
-}
-EXPORT_SYMBOL(iommu_tbl_range_free);
diff --git a/lib/iommu-helper.c b/lib/iommu-helper.c
index 23633c0f..92a9f243 100644
--- a/lib/iommu-helper.c
+++ b/lib/iommu-helper.c
@@ -3,19 +3,8 @@
  * IOMMU helper functions for the free area management
  */
 
-#include <linux/export.h>
 #include <linux/bitmap.h>
-#include <linux/bug.h>
-
-int iommu_is_span_boundary(unsigned int index, unsigned int nr,
-			   unsigned long shift,
-			   unsigned long boundary_size)
-{
-	BUG_ON(!is_power_of_2(boundary_size));
-
-	shift = (shift + index) & (boundary_size - 1);
-	return shift + nr > boundary_size;
-}
+#include <linux/iommu-helper.h>
 
 unsigned long iommu_area_alloc(unsigned long *map, unsigned long size,
 			       unsigned long start, unsigned int nr,
@@ -38,4 +27,3 @@ unsigned long iommu_area_alloc(unsigned long *map, unsigned long size,
 	}
 	return -1;
 }
-EXPORT_SYMBOL(iommu_area_alloc);
diff --git a/lib/raid6/.gitignore b/lib/raid6/.gitignore
deleted file mode 100644
index 3de0d892..00000000
--- a/lib/raid6/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-mktables
-altivec*.c
-int*.c
-tables.c
-neon?.c
-s390vx?.c
-vpermxor*.c
diff --git a/lib/swiotlb.c b/lib/swiotlb.c
deleted file mode 100644
index cc640588..00000000
--- a/lib/swiotlb.c
+++ /dev/null
@@ -1,1092 +0,0 @@
-/*
- * Dynamic DMA mapping support.
- *
- * This implementation is a fallback for platforms that do not support
- * I/O TLBs (aka DMA address translation hardware).
- * Copyright (C) 2000 Asit Mallick <Asit.K.Mallick@intel.com>
- * Copyright (C) 2000 Goutham Rao <goutham.rao@intel.com>
- * Copyright (C) 2000, 2003 Hewlett-Packard Co
- *	David Mosberger-Tang <davidm@hpl.hp.com>
- *
- * 03/05/07 davidm	Switch from PCI-DMA to generic device DMA API.
- * 00/12/13 davidm	Rename to swiotlb.c and add mark_clean() to avoid
- *			unnecessary i-cache flushing.
- * 04/07/.. ak		Better overflow handling. Assorted fixes.
- * 05/09/10 linville	Add support for syncing ranges, support syncing for
- *			DMA_BIDIRECTIONAL mappings, miscellaneous cleanup.
- * 08/12/11 beckyb	Add highmem support
- */
-
-#include <linux/cache.h>
-#include <linux/dma-direct.h>
-#include <linux/mm.h>
-#include <linux/export.h>
-#include <linux/spinlock.h>
-#include <linux/string.h>
-#include <linux/swiotlb.h>
-#include <linux/pfn.h>
-#include <linux/types.h>
-#include <linux/ctype.h>
-#include <linux/highmem.h>
-#include <linux/gfp.h>
-#include <linux/scatterlist.h>
-#include <linux/mem_encrypt.h>
-#include <linux/set_memory.h>
-
-#include <asm/io.h>
-#include <asm/dma.h>
-
-#include <linux/init.h>
-#include <linux/bootmem.h>
-#include <linux/iommu-helper.h>
-
-#define CREATE_TRACE_POINTS
-#include <trace/events/swiotlb.h>
-
-#define OFFSET(val,align) ((unsigned long)	\
-	                   ( (val) & ( (align) - 1)))
-
-#define SLABS_PER_PAGE (1 << (PAGE_SHIFT - IO_TLB_SHIFT))
-
-/*
- * Minimum IO TLB size to bother booting with.  Systems with mainly
- * 64bit capable cards will only lightly use the swiotlb.  If we can't
- * allocate a contiguous 1MB, we're probably in trouble anyway.
- */
-#define IO_TLB_MIN_SLABS ((1<<20) >> IO_TLB_SHIFT)
-
-enum swiotlb_force swiotlb_force;
-
-/*
- * Used to do a quick range check in swiotlb_tbl_unmap_single and
- * swiotlb_tbl_sync_single_*, to see if the memory was in fact allocated by this
- * API.
- */
-static phys_addr_t io_tlb_start, io_tlb_end;
-
-/*
- * The number of IO TLB blocks (in groups of 64) between io_tlb_start and
- * io_tlb_end.  This is command line adjustable via setup_io_tlb_npages.
- */
-static unsigned long io_tlb_nslabs;
-
-/*
- * When the IOMMU overflows we return a fallback buffer. This sets the size.
- */
-static unsigned long io_tlb_overflow = 32*1024;
-
-static phys_addr_t io_tlb_overflow_buffer;
-
-/*
- * This is a free list describing the number of free entries available from
- * each index
- */
-static unsigned int *io_tlb_list;
-static unsigned int io_tlb_index;
-
-/*
- * Max segment that we can provide which (if pages are contingous) will
- * not be bounced (unless SWIOTLB_FORCE is set).
- */
-unsigned int max_segment;
-
-/*
- * We need to save away the original address corresponding to a mapped entry
- * for the sync operations.
- */
-#define INVALID_PHYS_ADDR (~(phys_addr_t)0)
-static phys_addr_t *io_tlb_orig_addr;
-
-/*
- * Protect the above data structures in the map and unmap calls
- */
-static DEFINE_SPINLOCK(io_tlb_lock);
-
-static int late_alloc;
-
-static int __init
-setup_io_tlb_npages(char *str)
-{
-	if (isdigit(*str)) {
-		io_tlb_nslabs = simple_strtoul(str, &str, 0);
-		/* avoid tail segment of size < IO_TLB_SEGSIZE */
-		io_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);
-	}
-	if (*str == ',')
-		++str;
-	if (!strcmp(str, "force")) {
-		swiotlb_force = SWIOTLB_FORCE;
-	} else if (!strcmp(str, "noforce")) {
-		swiotlb_force = SWIOTLB_NO_FORCE;
-		io_tlb_nslabs = 1;
-	}
-
-	return 0;
-}
-early_param("swiotlb", setup_io_tlb_npages);
-/* make io_tlb_overflow tunable too? */
-
-unsigned long swiotlb_nr_tbl(void)
-{
-	return io_tlb_nslabs;
-}
-EXPORT_SYMBOL_GPL(swiotlb_nr_tbl);
-
-unsigned int swiotlb_max_segment(void)
-{
-	return max_segment;
-}
-EXPORT_SYMBOL_GPL(swiotlb_max_segment);
-
-void swiotlb_set_max_segment(unsigned int val)
-{
-	if (swiotlb_force == SWIOTLB_FORCE)
-		max_segment = 1;
-	else
-		max_segment = rounddown(val, PAGE_SIZE);
-}
-
-/* default to 64MB */
-#define IO_TLB_DEFAULT_SIZE (64UL<<20)
-unsigned long swiotlb_size_or_default(void)
-{
-	unsigned long size;
-
-	size = io_tlb_nslabs << IO_TLB_SHIFT;
-
-	return size ? size : (IO_TLB_DEFAULT_SIZE);
-}
-
-static bool no_iotlb_memory;
-
-void swiotlb_print_info(void)
-{
-	unsigned long bytes = io_tlb_nslabs << IO_TLB_SHIFT;
-	unsigned char *vstart, *vend;
-
-	if (no_iotlb_memory) {
-		pr_warn("software IO TLB: No low mem\n");
-		return;
-	}
-
-	vstart = phys_to_virt(io_tlb_start);
-	vend = phys_to_virt(io_tlb_end);
-
-	printk(KERN_INFO "software IO TLB [mem %#010llx-%#010llx] (%luMB) mapped at [%p-%p]\n",
-	       (unsigned long long)io_tlb_start,
-	       (unsigned long long)io_tlb_end,
-	       bytes >> 20, vstart, vend - 1);
-}
-
-/*
- * Early SWIOTLB allocation may be too early to allow an architecture to
- * perform the desired operations.  This function allows the architecture to
- * call SWIOTLB when the operations are possible.  It needs to be called
- * before the SWIOTLB memory is used.
- */
-void __init swiotlb_update_mem_attributes(void)
-{
-	void *vaddr;
-	unsigned long bytes;
-
-	if (no_iotlb_memory || late_alloc)
-		return;
-
-	vaddr = phys_to_virt(io_tlb_start);
-	bytes = PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT);
-	set_memory_decrypted((unsigned long)vaddr, bytes >> PAGE_SHIFT);
-	memset(vaddr, 0, bytes);
-
-	vaddr = phys_to_virt(io_tlb_overflow_buffer);
-	bytes = PAGE_ALIGN(io_tlb_overflow);
-	set_memory_decrypted((unsigned long)vaddr, bytes >> PAGE_SHIFT);
-	memset(vaddr, 0, bytes);
-}
-
-int __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)
-{
-	void *v_overflow_buffer;
-	unsigned long i, bytes;
-
-	bytes = nslabs << IO_TLB_SHIFT;
-
-	io_tlb_nslabs = nslabs;
-	io_tlb_start = __pa(tlb);
-	io_tlb_end = io_tlb_start + bytes;
-
-	/*
-	 * Get the overflow emergency buffer
-	 */
-	v_overflow_buffer = memblock_virt_alloc_low_nopanic(
-						PAGE_ALIGN(io_tlb_overflow),
-						PAGE_SIZE);
-	if (!v_overflow_buffer)
-		return -ENOMEM;
-
-	io_tlb_overflow_buffer = __pa(v_overflow_buffer);
-
-	/*
-	 * Allocate and initialize the free list array.  This array is used
-	 * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE
-	 * between io_tlb_start and io_tlb_end.
-	 */
-	io_tlb_list = memblock_virt_alloc(
-				PAGE_ALIGN(io_tlb_nslabs * sizeof(int)),
-				PAGE_SIZE);
-	io_tlb_orig_addr = memblock_virt_alloc(
-				PAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)),
-				PAGE_SIZE);
-	for (i = 0; i < io_tlb_nslabs; i++) {
-		io_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);
-		io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;
-	}
-	io_tlb_index = 0;
-
-	if (verbose)
-		swiotlb_print_info();
-
-	swiotlb_set_max_segment(io_tlb_nslabs << IO_TLB_SHIFT);
-	return 0;
-}
-
-/*
- * Statically reserve bounce buffer space and initialize bounce buffer data
- * structures for the software IO TLB used to implement the DMA API.
- */
-void  __init
-swiotlb_init(int verbose)
-{
-	size_t default_size = IO_TLB_DEFAULT_SIZE;
-	unsigned char *vstart;
-	unsigned long bytes;
-
-	if (!io_tlb_nslabs) {
-		io_tlb_nslabs = (default_size >> IO_TLB_SHIFT);
-		io_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);
-	}
-
-	bytes = io_tlb_nslabs << IO_TLB_SHIFT;
-
-	/* Get IO TLB memory from the low pages */
-	vstart = memblock_virt_alloc_low_nopanic(PAGE_ALIGN(bytes), PAGE_SIZE);
-	if (vstart && !swiotlb_init_with_tbl(vstart, io_tlb_nslabs, verbose))
-		return;
-
-	if (io_tlb_start)
-		memblock_free_early(io_tlb_start,
-				    PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT));
-	pr_warn("Cannot allocate SWIOTLB buffer");
-	no_iotlb_memory = true;
-}
-
-/*
- * Systems with larger DMA zones (those that don't support ISA) can
- * initialize the swiotlb later using the slab allocator if needed.
- * This should be just like above, but with some error catching.
- */
-int
-swiotlb_late_init_with_default_size(size_t default_size)
-{
-	unsigned long bytes, req_nslabs = io_tlb_nslabs;
-	unsigned char *vstart = NULL;
-	unsigned int order;
-	int rc = 0;
-
-	if (!io_tlb_nslabs) {
-		io_tlb_nslabs = (default_size >> IO_TLB_SHIFT);
-		io_tlb_nslabs = ALIGN(io_tlb_nslabs, IO_TLB_SEGSIZE);
-	}
-
-	/*
-	 * Get IO TLB memory from the low pages
-	 */
-	order = get_order(io_tlb_nslabs << IO_TLB_SHIFT);
-	io_tlb_nslabs = SLABS_PER_PAGE << order;
-	bytes = io_tlb_nslabs << IO_TLB_SHIFT;
-
-	while ((SLABS_PER_PAGE << order) > IO_TLB_MIN_SLABS) {
-		vstart = (void *)__get_free_pages(GFP_DMA | __GFP_NOWARN,
-						  order);
-		if (vstart)
-			break;
-		order--;
-	}
-
-	if (!vstart) {
-		io_tlb_nslabs = req_nslabs;
-		return -ENOMEM;
-	}
-	if (order != get_order(bytes)) {
-		printk(KERN_WARNING "Warning: only able to allocate %ld MB "
-		       "for software IO TLB\n", (PAGE_SIZE << order) >> 20);
-		io_tlb_nslabs = SLABS_PER_PAGE << order;
-	}
-	rc = swiotlb_late_init_with_tbl(vstart, io_tlb_nslabs);
-	if (rc)
-		free_pages((unsigned long)vstart, order);
-
-	return rc;
-}
-
-int
-swiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)
-{
-	unsigned long i, bytes;
-	unsigned char *v_overflow_buffer;
-
-	bytes = nslabs << IO_TLB_SHIFT;
-
-	io_tlb_nslabs = nslabs;
-	io_tlb_start = virt_to_phys(tlb);
-	io_tlb_end = io_tlb_start + bytes;
-
-	set_memory_decrypted((unsigned long)tlb, bytes >> PAGE_SHIFT);
-	memset(tlb, 0, bytes);
-
-	/*
-	 * Get the overflow emergency buffer
-	 */
-	v_overflow_buffer = (void *)__get_free_pages(GFP_DMA,
-						     get_order(io_tlb_overflow));
-	if (!v_overflow_buffer)
-		goto cleanup2;
-
-	set_memory_decrypted((unsigned long)v_overflow_buffer,
-			io_tlb_overflow >> PAGE_SHIFT);
-	memset(v_overflow_buffer, 0, io_tlb_overflow);
-	io_tlb_overflow_buffer = virt_to_phys(v_overflow_buffer);
-
-	/*
-	 * Allocate and initialize the free list array.  This array is used
-	 * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE
-	 * between io_tlb_start and io_tlb_end.
-	 */
-	io_tlb_list = (unsigned int *)__get_free_pages(GFP_KERNEL,
-	                              get_order(io_tlb_nslabs * sizeof(int)));
-	if (!io_tlb_list)
-		goto cleanup3;
-
-	io_tlb_orig_addr = (phys_addr_t *)
-		__get_free_pages(GFP_KERNEL,
-				 get_order(io_tlb_nslabs *
-					   sizeof(phys_addr_t)));
-	if (!io_tlb_orig_addr)
-		goto cleanup4;
-
-	for (i = 0; i < io_tlb_nslabs; i++) {
-		io_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);
-		io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;
-	}
-	io_tlb_index = 0;
-
-	swiotlb_print_info();
-
-	late_alloc = 1;
-
-	swiotlb_set_max_segment(io_tlb_nslabs << IO_TLB_SHIFT);
-
-	return 0;
-
-cleanup4:
-	free_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *
-	                                                 sizeof(int)));
-	io_tlb_list = NULL;
-cleanup3:
-	free_pages((unsigned long)v_overflow_buffer,
-		   get_order(io_tlb_overflow));
-	io_tlb_overflow_buffer = 0;
-cleanup2:
-	io_tlb_end = 0;
-	io_tlb_start = 0;
-	io_tlb_nslabs = 0;
-	max_segment = 0;
-	return -ENOMEM;
-}
-
-void __init swiotlb_exit(void)
-{
-	if (!io_tlb_orig_addr)
-		return;
-
-	if (late_alloc) {
-		free_pages((unsigned long)phys_to_virt(io_tlb_overflow_buffer),
-			   get_order(io_tlb_overflow));
-		free_pages((unsigned long)io_tlb_orig_addr,
-			   get_order(io_tlb_nslabs * sizeof(phys_addr_t)));
-		free_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *
-								 sizeof(int)));
-		free_pages((unsigned long)phys_to_virt(io_tlb_start),
-			   get_order(io_tlb_nslabs << IO_TLB_SHIFT));
-	} else {
-		memblock_free_late(io_tlb_overflow_buffer,
-				   PAGE_ALIGN(io_tlb_overflow));
-		memblock_free_late(__pa(io_tlb_orig_addr),
-				   PAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)));
-		memblock_free_late(__pa(io_tlb_list),
-				   PAGE_ALIGN(io_tlb_nslabs * sizeof(int)));
-		memblock_free_late(io_tlb_start,
-				   PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT));
-	}
-	io_tlb_nslabs = 0;
-	max_segment = 0;
-}
-
-int is_swiotlb_buffer(phys_addr_t paddr)
-{
-	return paddr >= io_tlb_start && paddr < io_tlb_end;
-}
-
-/*
- * Bounce: copy the swiotlb buffer back to the original dma location
- */
-static void swiotlb_bounce(phys_addr_t orig_addr, phys_addr_t tlb_addr,
-			   size_t size, enum dma_data_direction dir)
-{
-	unsigned long pfn = PFN_DOWN(orig_addr);
-	unsigned char *vaddr = phys_to_virt(tlb_addr);
-
-	if (PageHighMem(pfn_to_page(pfn))) {
-		/* The buffer does not have a mapping.  Map it in and copy */
-		unsigned int offset = orig_addr & ~PAGE_MASK;
-		char *buffer;
-		unsigned int sz = 0;
-		unsigned long flags;
-
-		while (size) {
-			sz = min_t(size_t, PAGE_SIZE - offset, size);
-
-			local_irq_save(flags);
-			buffer = kmap_atomic(pfn_to_page(pfn));
-			if (dir == DMA_TO_DEVICE)
-				memcpy(vaddr, buffer + offset, sz);
-			else
-				memcpy(buffer + offset, vaddr, sz);
-			kunmap_atomic(buffer);
-			local_irq_restore(flags);
-
-			size -= sz;
-			pfn++;
-			vaddr += sz;
-			offset = 0;
-		}
-	} else if (dir == DMA_TO_DEVICE) {
-		memcpy(vaddr, phys_to_virt(orig_addr), size);
-	} else {
-		memcpy(phys_to_virt(orig_addr), vaddr, size);
-	}
-}
-
-phys_addr_t swiotlb_tbl_map_single(struct device *hwdev,
-				   dma_addr_t tbl_dma_addr,
-				   phys_addr_t orig_addr, size_t size,
-				   enum dma_data_direction dir,
-				   unsigned long attrs)
-{
-	unsigned long flags;
-	phys_addr_t tlb_addr;
-	unsigned int nslots, stride, index, wrap;
-	int i;
-	unsigned long mask;
-	unsigned long offset_slots;
-	unsigned long max_slots;
-
-	if (no_iotlb_memory)
-		panic("Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer");
-
-	if (mem_encrypt_active())
-		pr_warn_once("%s is active and system is using DMA bounce buffers\n",
-			     sme_active() ? "SME" : "SEV");
-
-	mask = dma_get_seg_boundary(hwdev);
-
-	tbl_dma_addr &= mask;
-
-	offset_slots = ALIGN(tbl_dma_addr, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;
-
-	/*
- 	 * Carefully handle integer overflow which can occur when mask == ~0UL.
- 	 */
-	max_slots = mask + 1
-		    ? ALIGN(mask + 1, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT
-		    : 1UL << (BITS_PER_LONG - IO_TLB_SHIFT);
-
-	/*
-	 * For mappings greater than or equal to a page, we limit the stride
-	 * (and hence alignment) to a page size.
-	 */
-	nslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;
-	if (size >= PAGE_SIZE)
-		stride = (1 << (PAGE_SHIFT - IO_TLB_SHIFT));
-	else
-		stride = 1;
-
-	BUG_ON(!nslots);
-
-	/*
-	 * Find suitable number of IO TLB entries size that will fit this
-	 * request and allocate a buffer from that IO TLB pool.
-	 */
-	spin_lock_irqsave(&io_tlb_lock, flags);
-	index = ALIGN(io_tlb_index, stride);
-	if (index >= io_tlb_nslabs)
-		index = 0;
-	wrap = index;
-
-	do {
-		while (iommu_is_span_boundary(index, nslots, offset_slots,
-					      max_slots)) {
-			index += stride;
-			if (index >= io_tlb_nslabs)
-				index = 0;
-			if (index == wrap)
-				goto not_found;
-		}
-
-		/*
-		 * If we find a slot that indicates we have 'nslots' number of
-		 * contiguous buffers, we allocate the buffers from that slot
-		 * and mark the entries as '0' indicating unavailable.
-		 */
-		if (io_tlb_list[index] >= nslots) {
-			int count = 0;
-
-			for (i = index; i < (int) (index + nslots); i++)
-				io_tlb_list[i] = 0;
-			for (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE - 1) && io_tlb_list[i]; i--)
-				io_tlb_list[i] = ++count;
-			tlb_addr = io_tlb_start + (index << IO_TLB_SHIFT);
-
-			/*
-			 * Update the indices to avoid searching in the next
-			 * round.
-			 */
-			io_tlb_index = ((index + nslots) < io_tlb_nslabs
-					? (index + nslots) : 0);
-
-			goto found;
-		}
-		index += stride;
-		if (index >= io_tlb_nslabs)
-			index = 0;
-	} while (index != wrap);
-
-not_found:
-	spin_unlock_irqrestore(&io_tlb_lock, flags);
-	if (!(attrs & DMA_ATTR_NO_WARN) && printk_ratelimit())
-		dev_warn(hwdev, "swiotlb buffer is full (sz: %zd bytes)\n", size);
-	return SWIOTLB_MAP_ERROR;
-found:
-	spin_unlock_irqrestore(&io_tlb_lock, flags);
-
-	/*
-	 * Save away the mapping from the original address to the DMA address.
-	 * This is needed when we sync the memory.  Then we sync the buffer if
-	 * needed.
-	 */
-	for (i = 0; i < nslots; i++)
-		io_tlb_orig_addr[index+i] = orig_addr + (i << IO_TLB_SHIFT);
-	if (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&
-	    (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))
-		swiotlb_bounce(orig_addr, tlb_addr, size, DMA_TO_DEVICE);
-
-	return tlb_addr;
-}
-
-/*
- * Allocates bounce buffer and returns its kernel virtual address.
- */
-
-static phys_addr_t
-map_single(struct device *hwdev, phys_addr_t phys, size_t size,
-	   enum dma_data_direction dir, unsigned long attrs)
-{
-	dma_addr_t start_dma_addr;
-
-	if (swiotlb_force == SWIOTLB_NO_FORCE) {
-		dev_warn_ratelimited(hwdev, "Cannot do DMA to address %pa\n",
-				     &phys);
-		return SWIOTLB_MAP_ERROR;
-	}
-
-	start_dma_addr = __phys_to_dma(hwdev, io_tlb_start);
-	return swiotlb_tbl_map_single(hwdev, start_dma_addr, phys, size,
-				      dir, attrs);
-}
-
-/*
- * dma_addr is the kernel virtual address of the bounce buffer to unmap.
- */
-void swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,
-			      size_t size, enum dma_data_direction dir,
-			      unsigned long attrs)
-{
-	unsigned long flags;
-	int i, count, nslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;
-	int index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;
-	phys_addr_t orig_addr = io_tlb_orig_addr[index];
-
-	/*
-	 * First, sync the memory before unmapping the entry
-	 */
-	if (orig_addr != INVALID_PHYS_ADDR &&
-	    !(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&
-	    ((dir == DMA_FROM_DEVICE) || (dir == DMA_BIDIRECTIONAL)))
-		swiotlb_bounce(orig_addr, tlb_addr, size, DMA_FROM_DEVICE);
-
-	/*
-	 * Return the buffer to the free list by setting the corresponding
-	 * entries to indicate the number of contiguous entries available.
-	 * While returning the entries to the free list, we merge the entries
-	 * with slots below and above the pool being returned.
-	 */
-	spin_lock_irqsave(&io_tlb_lock, flags);
-	{
-		count = ((index + nslots) < ALIGN(index + 1, IO_TLB_SEGSIZE) ?
-			 io_tlb_list[index + nslots] : 0);
-		/*
-		 * Step 1: return the slots to the free list, merging the
-		 * slots with superceeding slots
-		 */
-		for (i = index + nslots - 1; i >= index; i--) {
-			io_tlb_list[i] = ++count;
-			io_tlb_orig_addr[i] = INVALID_PHYS_ADDR;
-		}
-		/*
-		 * Step 2: merge the returned slots with the preceding slots,
-		 * if available (non zero)
-		 */
-		for (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE -1) && io_tlb_list[i]; i--)
-			io_tlb_list[i] = ++count;
-	}
-	spin_unlock_irqrestore(&io_tlb_lock, flags);
-}
-
-void swiotlb_tbl_sync_single(struct device *hwdev, phys_addr_t tlb_addr,
-			     size_t size, enum dma_data_direction dir,
-			     enum dma_sync_target target)
-{
-	int index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;
-	phys_addr_t orig_addr = io_tlb_orig_addr[index];
-
-	if (orig_addr == INVALID_PHYS_ADDR)
-		return;
-	orig_addr += (unsigned long)tlb_addr & ((1 << IO_TLB_SHIFT) - 1);
-
-	switch (target) {
-	case SYNC_FOR_CPU:
-		if (likely(dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))
-			swiotlb_bounce(orig_addr, tlb_addr,
-				       size, DMA_FROM_DEVICE);
-		else
-			BUG_ON(dir != DMA_TO_DEVICE);
-		break;
-	case SYNC_FOR_DEVICE:
-		if (likely(dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))
-			swiotlb_bounce(orig_addr, tlb_addr,
-				       size, DMA_TO_DEVICE);
-		else
-			BUG_ON(dir != DMA_FROM_DEVICE);
-		break;
-	default:
-		BUG();
-	}
-}
-
-#ifdef CONFIG_DMA_DIRECT_OPS
-static inline bool dma_coherent_ok(struct device *dev, dma_addr_t addr,
-		size_t size)
-{
-	u64 mask = DMA_BIT_MASK(32);
-
-	if (dev && dev->coherent_dma_mask)
-		mask = dev->coherent_dma_mask;
-	return addr + size - 1 <= mask;
-}
-
-static void *
-swiotlb_alloc_buffer(struct device *dev, size_t size, dma_addr_t *dma_handle,
-		unsigned long attrs)
-{
-	phys_addr_t phys_addr;
-
-	if (swiotlb_force == SWIOTLB_NO_FORCE)
-		goto out_warn;
-
-	phys_addr = swiotlb_tbl_map_single(dev,
-			__phys_to_dma(dev, io_tlb_start),
-			0, size, DMA_FROM_DEVICE, attrs);
-	if (phys_addr == SWIOTLB_MAP_ERROR)
-		goto out_warn;
-
-	*dma_handle = __phys_to_dma(dev, phys_addr);
-	if (!dma_coherent_ok(dev, *dma_handle, size))
-		goto out_unmap;
-
-	memset(phys_to_virt(phys_addr), 0, size);
-	return phys_to_virt(phys_addr);
-
-out_unmap:
-	dev_warn(dev, "hwdev DMA mask = 0x%016Lx, dev_addr = 0x%016Lx\n",
-		(unsigned long long)(dev ? dev->coherent_dma_mask : 0),
-		(unsigned long long)*dma_handle);
-
-	/*
-	 * DMA_TO_DEVICE to avoid memcpy in unmap_single.
-	 * DMA_ATTR_SKIP_CPU_SYNC is optional.
-	 */
-	swiotlb_tbl_unmap_single(dev, phys_addr, size, DMA_TO_DEVICE,
-			DMA_ATTR_SKIP_CPU_SYNC);
-out_warn:
-	if (!(attrs & DMA_ATTR_NO_WARN) && printk_ratelimit()) {
-		dev_warn(dev,
-			"swiotlb: coherent allocation failed, size=%zu\n",
-			size);
-		dump_stack();
-	}
-	return NULL;
-}
-
-static bool swiotlb_free_buffer(struct device *dev, size_t size,
-		dma_addr_t dma_addr)
-{
-	phys_addr_t phys_addr = dma_to_phys(dev, dma_addr);
-
-	WARN_ON_ONCE(irqs_disabled());
-
-	if (!is_swiotlb_buffer(phys_addr))
-		return false;
-
-	/*
-	 * DMA_TO_DEVICE to avoid memcpy in swiotlb_tbl_unmap_single.
-	 * DMA_ATTR_SKIP_CPU_SYNC is optional.
-	 */
-	swiotlb_tbl_unmap_single(dev, phys_addr, size, DMA_TO_DEVICE,
-				 DMA_ATTR_SKIP_CPU_SYNC);
-	return true;
-}
-#endif
-
-static void
-swiotlb_full(struct device *dev, size_t size, enum dma_data_direction dir,
-	     int do_panic)
-{
-	if (swiotlb_force == SWIOTLB_NO_FORCE)
-		return;
-
-	/*
-	 * Ran out of IOMMU space for this operation. This is very bad.
-	 * Unfortunately the drivers cannot handle this operation properly.
-	 * unless they check for dma_mapping_error (most don't)
-	 * When the mapping is small enough return a static buffer to limit
-	 * the damage, or panic when the transfer is too big.
-	 */
-	dev_err_ratelimited(dev, "DMA: Out of SW-IOMMU space for %zu bytes\n",
-			    size);
-
-	if (size <= io_tlb_overflow || !do_panic)
-		return;
-
-	if (dir == DMA_BIDIRECTIONAL)
-		panic("DMA: Random memory could be DMA accessed\n");
-	if (dir == DMA_FROM_DEVICE)
-		panic("DMA: Random memory could be DMA written\n");
-	if (dir == DMA_TO_DEVICE)
-		panic("DMA: Random memory could be DMA read\n");
-}
-
-/*
- * Map a single buffer of the indicated size for DMA in streaming mode.  The
- * physical address to use is returned.
- *
- * Once the device is given the dma address, the device owns this memory until
- * either swiotlb_unmap_page or swiotlb_dma_sync_single is performed.
- */
-dma_addr_t swiotlb_map_page(struct device *dev, struct page *page,
-			    unsigned long offset, size_t size,
-			    enum dma_data_direction dir,
-			    unsigned long attrs)
-{
-	phys_addr_t map, phys = page_to_phys(page) + offset;
-	dma_addr_t dev_addr = phys_to_dma(dev, phys);
-
-	BUG_ON(dir == DMA_NONE);
-	/*
-	 * If the address happens to be in the device's DMA window,
-	 * we can safely return the device addr and not worry about bounce
-	 * buffering it.
-	 */
-	if (dma_capable(dev, dev_addr, size) && swiotlb_force != SWIOTLB_FORCE)
-		return dev_addr;
-
-	trace_swiotlb_bounced(dev, dev_addr, size, swiotlb_force);
-
-	/* Oh well, have to allocate and map a bounce buffer. */
-	map = map_single(dev, phys, size, dir, attrs);
-	if (map == SWIOTLB_MAP_ERROR) {
-		swiotlb_full(dev, size, dir, 1);
-		return __phys_to_dma(dev, io_tlb_overflow_buffer);
-	}
-
-	dev_addr = __phys_to_dma(dev, map);
-
-	/* Ensure that the address returned is DMA'ble */
-	if (dma_capable(dev, dev_addr, size))
-		return dev_addr;
-
-	attrs |= DMA_ATTR_SKIP_CPU_SYNC;
-	swiotlb_tbl_unmap_single(dev, map, size, dir, attrs);
-
-	return __phys_to_dma(dev, io_tlb_overflow_buffer);
-}
-
-/*
- * Unmap a single streaming mode DMA translation.  The dma_addr and size must
- * match what was provided for in a previous swiotlb_map_page call.  All
- * other usages are undefined.
- *
- * After this call, reads by the cpu to the buffer are guaranteed to see
- * whatever the device wrote there.
- */
-static void unmap_single(struct device *hwdev, dma_addr_t dev_addr,
-			 size_t size, enum dma_data_direction dir,
-			 unsigned long attrs)
-{
-	phys_addr_t paddr = dma_to_phys(hwdev, dev_addr);
-
-	BUG_ON(dir == DMA_NONE);
-
-	if (is_swiotlb_buffer(paddr)) {
-		swiotlb_tbl_unmap_single(hwdev, paddr, size, dir, attrs);
-		return;
-	}
-
-	if (dir != DMA_FROM_DEVICE)
-		return;
-
-	/*
-	 * phys_to_virt doesn't work with hihgmem page but we could
-	 * call dma_mark_clean() with hihgmem page here. However, we
-	 * are fine since dma_mark_clean() is null on POWERPC. We can
-	 * make dma_mark_clean() take a physical address if necessary.
-	 */
-	dma_mark_clean(phys_to_virt(paddr), size);
-}
-
-void swiotlb_unmap_page(struct device *hwdev, dma_addr_t dev_addr,
-			size_t size, enum dma_data_direction dir,
-			unsigned long attrs)
-{
-	unmap_single(hwdev, dev_addr, size, dir, attrs);
-}
-
-/*
- * Make physical memory consistent for a single streaming mode DMA translation
- * after a transfer.
- *
- * If you perform a swiotlb_map_page() but wish to interrogate the buffer
- * using the cpu, yet do not wish to teardown the dma mapping, you must
- * call this function before doing so.  At the next point you give the dma
- * address back to the card, you must first perform a
- * swiotlb_dma_sync_for_device, and then the device again owns the buffer
- */
-static void
-swiotlb_sync_single(struct device *hwdev, dma_addr_t dev_addr,
-		    size_t size, enum dma_data_direction dir,
-		    enum dma_sync_target target)
-{
-	phys_addr_t paddr = dma_to_phys(hwdev, dev_addr);
-
-	BUG_ON(dir == DMA_NONE);
-
-	if (is_swiotlb_buffer(paddr)) {
-		swiotlb_tbl_sync_single(hwdev, paddr, size, dir, target);
-		return;
-	}
-
-	if (dir != DMA_FROM_DEVICE)
-		return;
-
-	dma_mark_clean(phys_to_virt(paddr), size);
-}
-
-void
-swiotlb_sync_single_for_cpu(struct device *hwdev, dma_addr_t dev_addr,
-			    size_t size, enum dma_data_direction dir)
-{
-	swiotlb_sync_single(hwdev, dev_addr, size, dir, SYNC_FOR_CPU);
-}
-
-void
-swiotlb_sync_single_for_device(struct device *hwdev, dma_addr_t dev_addr,
-			       size_t size, enum dma_data_direction dir)
-{
-	swiotlb_sync_single(hwdev, dev_addr, size, dir, SYNC_FOR_DEVICE);
-}
-
-/*
- * Map a set of buffers described by scatterlist in streaming mode for DMA.
- * This is the scatter-gather version of the above swiotlb_map_page
- * interface.  Here the scatter gather list elements are each tagged with the
- * appropriate dma address and length.  They are obtained via
- * sg_dma_{address,length}(SG).
- *
- * NOTE: An implementation may be able to use a smaller number of
- *       DMA address/length pairs than there are SG table elements.
- *       (for example via virtual mapping capabilities)
- *       The routine returns the number of addr/length pairs actually
- *       used, at most nents.
- *
- * Device ownership issues as mentioned above for swiotlb_map_page are the
- * same here.
- */
-int
-swiotlb_map_sg_attrs(struct device *hwdev, struct scatterlist *sgl, int nelems,
-		     enum dma_data_direction dir, unsigned long attrs)
-{
-	struct scatterlist *sg;
-	int i;
-
-	BUG_ON(dir == DMA_NONE);
-
-	for_each_sg(sgl, sg, nelems, i) {
-		phys_addr_t paddr = sg_phys(sg);
-		dma_addr_t dev_addr = phys_to_dma(hwdev, paddr);
-
-		if (swiotlb_force == SWIOTLB_FORCE ||
-		    !dma_capable(hwdev, dev_addr, sg->length)) {
-			phys_addr_t map = map_single(hwdev, sg_phys(sg),
-						     sg->length, dir, attrs);
-			if (map == SWIOTLB_MAP_ERROR) {
-				/* Don't panic here, we expect map_sg users
-				   to do proper error handling. */
-				swiotlb_full(hwdev, sg->length, dir, 0);
-				attrs |= DMA_ATTR_SKIP_CPU_SYNC;
-				swiotlb_unmap_sg_attrs(hwdev, sgl, i, dir,
-						       attrs);
-				sg_dma_len(sgl) = 0;
-				return 0;
-			}
-			sg->dma_address = __phys_to_dma(hwdev, map);
-		} else
-			sg->dma_address = dev_addr;
-		sg_dma_len(sg) = sg->length;
-	}
-	return nelems;
-}
-
-/*
- * Unmap a set of streaming mode DMA translations.  Again, cpu read rules
- * concerning calls here are the same as for swiotlb_unmap_page() above.
- */
-void
-swiotlb_unmap_sg_attrs(struct device *hwdev, struct scatterlist *sgl,
-		       int nelems, enum dma_data_direction dir,
-		       unsigned long attrs)
-{
-	struct scatterlist *sg;
-	int i;
-
-	BUG_ON(dir == DMA_NONE);
-
-	for_each_sg(sgl, sg, nelems, i)
-		unmap_single(hwdev, sg->dma_address, sg_dma_len(sg), dir,
-			     attrs);
-}
-
-/*
- * Make physical memory consistent for a set of streaming mode DMA translations
- * after a transfer.
- *
- * The same as swiotlb_sync_single_* but for a scatter-gather list, same rules
- * and usage.
- */
-static void
-swiotlb_sync_sg(struct device *hwdev, struct scatterlist *sgl,
-		int nelems, enum dma_data_direction dir,
-		enum dma_sync_target target)
-{
-	struct scatterlist *sg;
-	int i;
-
-	for_each_sg(sgl, sg, nelems, i)
-		swiotlb_sync_single(hwdev, sg->dma_address,
-				    sg_dma_len(sg), dir, target);
-}
-
-void
-swiotlb_sync_sg_for_cpu(struct device *hwdev, struct scatterlist *sg,
-			int nelems, enum dma_data_direction dir)
-{
-	swiotlb_sync_sg(hwdev, sg, nelems, dir, SYNC_FOR_CPU);
-}
-
-void
-swiotlb_sync_sg_for_device(struct device *hwdev, struct scatterlist *sg,
-			   int nelems, enum dma_data_direction dir)
-{
-	swiotlb_sync_sg(hwdev, sg, nelems, dir, SYNC_FOR_DEVICE);
-}
-
-int
-swiotlb_dma_mapping_error(struct device *hwdev, dma_addr_t dma_addr)
-{
-	return (dma_addr == __phys_to_dma(hwdev, io_tlb_overflow_buffer));
-}
-
-/*
- * Return whether the given device DMA address mask can be supported
- * properly.  For example, if your device can only drive the low 24-bits
- * during bus mastering, then you would pass 0x00ffffff as the mask to
- * this function.
- */
-int
-swiotlb_dma_supported(struct device *hwdev, u64 mask)
-{
-	return __phys_to_dma(hwdev, io_tlb_end - 1) <= mask;
-}
-
-#ifdef CONFIG_DMA_DIRECT_OPS
-void *swiotlb_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
-		gfp_t gfp, unsigned long attrs)
-{
-	void *vaddr;
-
-	/* temporary workaround: */
-	if (gfp & __GFP_NOWARN)
-		attrs |= DMA_ATTR_NO_WARN;
-
-	/*
-	 * Don't print a warning when the first allocation attempt fails.
-	 * swiotlb_alloc_coherent() will print a warning when the DMA memory
-	 * allocation ultimately failed.
-	 */
-	gfp |= __GFP_NOWARN;
-
-	vaddr = dma_direct_alloc(dev, size, dma_handle, gfp, attrs);
-	if (!vaddr)
-		vaddr = swiotlb_alloc_buffer(dev, size, dma_handle, attrs);
-	return vaddr;
-}
-
-void swiotlb_free(struct device *dev, size_t size, void *vaddr,
-		dma_addr_t dma_addr, unsigned long attrs)
-{
-	if (!swiotlb_free_buffer(dev, size, dma_addr))
-		dma_direct_free(dev, size, vaddr, dma_addr, attrs);
-}
-
-const struct dma_map_ops swiotlb_dma_ops = {
-	.mapping_error		= swiotlb_dma_mapping_error,
-	.alloc			= swiotlb_alloc,
-	.free			= swiotlb_free,
-	.sync_single_for_cpu	= swiotlb_sync_single_for_cpu,
-	.sync_single_for_device	= swiotlb_sync_single_for_device,
-	.sync_sg_for_cpu	= swiotlb_sync_sg_for_cpu,
-	.sync_sg_for_device	= swiotlb_sync_sg_for_device,
-	.map_sg			= swiotlb_map_sg_attrs,
-	.unmap_sg		= swiotlb_unmap_sg_attrs,
-	.map_page		= swiotlb_map_page,
-	.unmap_page		= swiotlb_unmap_page,
-	.dma_supported		= dma_direct_supported,
-};
-#endif /* CONFIG_DMA_DIRECT_OPS */
diff --git a/lib/udivmoddi4.c b/lib/udivmoddi4.c
new file mode 100644
index 00000000..c08bc8a5
--- /dev/null
+++ b/lib/udivmoddi4.c
@@ -0,0 +1,310 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.
+ */
+
+#include <linux/libgcc.h>
+
+#define count_leading_zeros(COUNT, X)   ((COUNT) = __builtin_clz(X))
+
+#define W_TYPE_SIZE 32
+
+#define __ll_B ((unsigned long) 1 << (W_TYPE_SIZE / 2))
+#define __ll_lowpart(t) ((unsigned long) (t) & (__ll_B - 1))
+#define __ll_highpart(t) ((unsigned long) (t) >> (W_TYPE_SIZE / 2))
+
+/* If we still don't have umul_ppmm, define it using plain C. */
+#if !defined(umul_ppmm)
+#define umul_ppmm(w1, w0, u, v)						\
+	do {								\
+		unsigned long __x0, __x1, __x2, __x3;			\
+		unsigned short __ul, __vl, __uh, __vh;			\
+									\
+		__ul = __ll_lowpart(u);					\
+		__uh = __ll_highpart(u);				\
+		__vl = __ll_lowpart(v);					\
+		__vh = __ll_highpart(v);				\
+									\
+		__x0 = (unsigned long) __ul * __vl;			\
+		__x1 = (unsigned long) __ul * __vh;			\
+		__x2 = (unsigned long) __uh * __vl;			\
+		__x3 = (unsigned long) __uh * __vh;			\
+									\
+		__x1 += __ll_highpart(__x0);				\
+		__x1 += __x2;						\
+		if (__x1 < __x2)					\
+			__x3 += __ll_B;					\
+									\
+		(w1) = __x3 + __ll_highpart(__x1);			\
+		(w0) = __ll_lowpart(__x1) * __ll_B + __ll_lowpart(__x0);\
+	} while (0)
+#endif
+
+#if !defined(sub_ddmmss)
+#define sub_ddmmss(sh, sl, ah, al, bh, bl)				\
+	do {								\
+		unsigned long __x;					\
+		__x = (al) - (bl);					\
+		(sh) = (ah) - (bh) - (__x > (al));			\
+		(sl) = __x;						\
+	} while (0)
+#endif
+
+/* Define this unconditionally, so it can be used for debugging. */
+#define __udiv_qrnnd_c(q, r, n1, n0, d)					\
+	do {								\
+		unsigned long __d1, __d0, __q1, __q0;			\
+		unsigned long __r1, __r0, __m;				\
+		__d1 = __ll_highpart(d);				\
+		__d0 = __ll_lowpart(d);				\
+									\
+		__r1 = (n1) % __d1;					\
+		__q1 = (n1) / __d1;					\
+		__m = (unsigned long) __q1 * __d0;			\
+		__r1 = __r1 * __ll_B | __ll_highpart(n0);		\
+		if (__r1 < __m) {					\
+			__q1--, __r1 += (d);				\
+			if (__r1 >= (d))				\
+				if (__r1 < __m)				\
+					__q1--, __r1 += (d);		\
+		}							\
+		__r1 -= __m;						\
+									\
+		__r0 = __r1 % __d1;					\
+		__q0 = __r1 / __d1;					\
+		__m = (unsigned long) __q0 * __d0;			\
+		__r0 = __r0 * __ll_B | __ll_lowpart(n0);		\
+		if (__r0 < __m) {					\
+			__q0--, __r0 += (d);				\
+			if (__r0 >= (d))				\
+				if (__r0 < __m)				\
+					__q0--, __r0 += (d);		\
+		}							\
+		__r0 -= __m;						\
+									\
+		(q) = (unsigned long) __q1 * __ll_B | __q0;		\
+		(r) = __r0;						\
+	} while (0)
+
+/* If udiv_qrnnd was not defined for this processor, use __udiv_qrnnd_c. */
+#if !defined(udiv_qrnnd)
+#define UDIV_NEEDS_NORMALIZATION 1
+#define udiv_qrnnd __udiv_qrnnd_c
+#endif
+
+unsigned long long __udivmoddi4(unsigned long long u, unsigned long long v,
+				unsigned long long *rp)
+{
+	const DWunion nn = {.ll = u };
+	const DWunion dd = {.ll = v };
+	DWunion rr, ww;
+	unsigned long d0, d1, n0, n1, n2;
+	unsigned long q0 = 0, q1 = 0;
+	unsigned long b, bm;
+
+	d0 = dd.s.low;
+	d1 = dd.s.high;
+	n0 = nn.s.low;
+	n1 = nn.s.high;
+
+#if !UDIV_NEEDS_NORMALIZATION
+
+	if (d1 == 0) {
+		if (d0 > n1) {
+			/* 0q = nn / 0D */
+
+			udiv_qrnnd(q0, n0, n1, n0, d0);
+			q1 = 0;
+
+			/* Remainder in n0. */
+		} else {
+			/* qq = NN / 0d */
+
+			if (d0 == 0)
+				/* Divide intentionally by zero. */
+				d0 = 1 / d0;
+
+			udiv_qrnnd(q1, n1, 0, n1, d0);
+			udiv_qrnnd(q0, n0, n1, n0, d0);
+
+			/* Remainder in n0. */
+		}
+
+		if (rp != 0) {
+			rr.s.low = n0;
+			rr.s.high = 0;
+			*rp = rr.ll;
+		}
+
+#else /* UDIV_NEEDS_NORMALIZATION */
+
+	if (d1 == 0) {
+		if (d0 > n1) {
+			/* 0q = nn / 0D */
+
+			count_leading_zeros(bm, d0);
+
+			if (bm != 0) {
+				/*
+				 * Normalize, i.e. make the most significant bit
+				 * of the denominator set.
+				 */
+
+				d0 = d0 << bm;
+				n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
+				n0 = n0 << bm;
+			}
+
+			udiv_qrnnd(q0, n0, n1, n0, d0);
+			q1 = 0;
+
+			/* Remainder in n0 >> bm. */
+		} else {
+			/* qq = NN / 0d */
+
+			if (d0 == 0)
+				/* Divide intentionally by zero. */
+				d0 = 1 / d0;
+
+			count_leading_zeros(bm, d0);
+
+			if (bm == 0) {
+				/*
+				 * From (n1 >= d0) /\ (the most significant bit
+				 * of d0 is set), conclude (the most significant
+				 * bit of n1 is set) /\ (theleading quotient
+				 * digit q1 = 1).
+				 *
+				 * This special case is necessary, not an
+				 * optimization. (Shifts counts of W_TYPE_SIZE
+				 * are undefined.)
+				 */
+
+				n1 -= d0;
+				q1 = 1;
+			} else {
+				/* Normalize. */
+
+				b = W_TYPE_SIZE - bm;
+
+				d0 = d0 << bm;
+				n2 = n1 >> b;
+				n1 = (n1 << bm) | (n0 >> b);
+				n0 = n0 << bm;
+
+				udiv_qrnnd(q1, n1, n2, n1, d0);
+			}
+
+			/* n1 != d0... */
+
+			udiv_qrnnd(q0, n0, n1, n0, d0);
+
+			/* Remainder in n0 >> bm. */
+		}
+
+		if (rp != 0) {
+			rr.s.low = n0 >> bm;
+			rr.s.high = 0;
+			*rp = rr.ll;
+		}
+
+#endif /* UDIV_NEEDS_NORMALIZATION */
+
+	} else {
+		if (d1 > n1) {
+			/* 00 = nn / DD */
+
+			q0 = 0;
+			q1 = 0;
+
+			/* Remainder in n1n0. */
+			if (rp != 0) {
+				rr.s.low = n0;
+				rr.s.high = n1;
+				*rp = rr.ll;
+			}
+		} else {
+			/* 0q = NN / dd */
+
+			count_leading_zeros(bm, d1);
+			if (bm == 0) {
+				/*
+				 * From (n1 >= d1) /\ (the most significant bit
+				 * of d1 is set), conclude (the most significant
+				 * bit of n1 is set) /\ (the quotient digit q0 =
+				 * 0 or 1).
+				 *
+				 * This special case is necessary, not an
+				 * optimization.
+				 */
+
+				/*
+				 * The condition on the next line takes
+				 * advantage of that n1 >= d1 (true due to
+				 * program flow).
+				 */
+				if (n1 > d1 || n0 >= d0) {
+					q0 = 1;
+					sub_ddmmss(n1, n0, n1, n0, d1, d0);
+				} else {
+					q0 = 0;
+				}
+
+				q1 = 0;
+
+				if (rp != 0) {
+					rr.s.low = n0;
+					rr.s.high = n1;
+					*rp = rr.ll;
+				}
+			} else {
+				unsigned long m1, m0;
+				/* Normalize. */
+
+				b = W_TYPE_SIZE - bm;
+
+				d1 = (d1 << bm) | (d0 >> b);
+				d0 = d0 << bm;
+				n2 = n1 >> b;
+				n1 = (n1 << bm) | (n0 >> b);
+				n0 = n0 << bm;
+
+				udiv_qrnnd(q0, n1, n2, n1, d1);
+				umul_ppmm(m1, m0, q0, d0);
+
+				if (m1 > n1 || (m1 == n1 && m0 > n0)) {
+					q0--;
+					sub_ddmmss(m1, m0, m1, m0, d1, d0);
+				}
+
+				q1 = 0;
+
+				/* Remainder in (n1n0 - m1m0) >> bm. */
+				if (rp != 0) {
+					sub_ddmmss(n1, n0, n1, n0, m1, m0);
+					rr.s.low = (n1 << b) | (n0 >> bm);
+					rr.s.high = n1 >> bm;
+					*rp = rr.ll;
+				}
+			}
+		}
+	}
+
+	ww.s.low = q0;
+	ww.s.high = q1;
+
+	return ww.ll;
+}
diff --git a/lib/umoddi3.c b/lib/umoddi3.c
new file mode 100644
index 00000000..d7bbf0f8
--- /dev/null
+++ b/lib/umoddi3.c
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/libgcc.h>
+
+extern unsigned long long __udivmoddi4(unsigned long long u,
+				       unsigned long long v,
+				       unsigned long long *rp);
+
+unsigned long long __umoddi3(unsigned long long u, unsigned long long v)
+{
+	unsigned long long w;
+	(void)__udivmoddi4(u, v, &w);
+	return w;
+}
+EXPORT_SYMBOL(__umoddi3);
diff --git a/mm/Kconfig b/mm/Kconfig
index e14c0151..9673e7fb 100644
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@ -266,7 +266,7 @@ config ARCH_ENABLE_THP_MIGRATION
 	bool
 
 config PHYS_ADDR_T_64BIT
-	def_bool 64BIT || ARCH_PHYS_ADDR_T_64BIT
+	def_bool 64BIT
 
 config BOUNCE
 	bool "Enable bounce buffers"
diff --git a/net/wireless/.gitignore b/net/wireless/.gitignore
deleted file mode 100644
index 61cbc304..00000000
--- a/net/wireless/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-shipped-certs.c
-extra-certs.c
diff --git a/samples/auxdisplay/.gitignore b/samples/auxdisplay/.gitignore
deleted file mode 100644
index 7af22286..00000000
--- a/samples/auxdisplay/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-cfag12864b-example
diff --git a/samples/connector/.gitignore b/samples/connector/.gitignore
deleted file mode 100644
index d2b9c32a..00000000
--- a/samples/connector/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-ucon
diff --git a/samples/hidraw/.gitignore b/samples/hidraw/.gitignore
deleted file mode 100644
index 05e51a68..00000000
--- a/samples/hidraw/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-hid-example
diff --git a/samples/mei/.gitignore b/samples/mei/.gitignore
deleted file mode 100644
index f356b81c..00000000
--- a/samples/mei/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-mei-amt-version
diff --git a/samples/mic/mpssd/.gitignore b/samples/mic/mpssd/.gitignore
deleted file mode 100644
index 8b7c72f0..00000000
--- a/samples/mic/mpssd/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-mpssd
diff --git a/samples/seccomp/.gitignore b/samples/seccomp/.gitignore
deleted file mode 100644
index 78fb7818..00000000
--- a/samples/seccomp/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-bpf-direct
-bpf-fancy
-dropper
diff --git a/samples/timers/.gitignore b/samples/timers/.gitignore
deleted file mode 100644
index c5c45d7e..00000000
--- a/samples/timers/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-hpet_example
diff --git a/samples/watchdog/.gitignore b/samples/watchdog/.gitignore
deleted file mode 100644
index ff0ebb54..00000000
--- a/samples/watchdog/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-watchdog-simple
diff --git a/scripts/.gitignore b/scripts/.gitignore
deleted file mode 100644
index 0442c06e..00000000
--- a/scripts/.gitignore
+++ /dev/null
@@ -1,15 +0,0 @@
-#
-# Generated files
-#
-conmakehash
-kallsyms
-pnmtologo
-unifdef
-ihex2fw
-recordmcount
-check-lc_ctype
-sortextable
-asn1_compiler
-extract-cert
-sign-file
-insert-sys-cert
diff --git a/scripts/basic/.gitignore b/scripts/basic/.gitignore
deleted file mode 100644
index 9528ec9e..00000000
--- a/scripts/basic/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-fixdep
-bin2c
diff --git a/scripts/dtc/.gitignore b/scripts/dtc/.gitignore
deleted file mode 100644
index 2e6e60d6..00000000
--- a/scripts/dtc/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-dtc
diff --git a/scripts/gcc-plugins/.gitignore b/scripts/gcc-plugins/.gitignore
deleted file mode 100644
index de92ed9e..00000000
--- a/scripts/gcc-plugins/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-randomize_layout_seed.h
diff --git a/scripts/gdb/linux/.gitignore b/scripts/gdb/linux/.gitignore
deleted file mode 100644
index 25735438..00000000
--- a/scripts/gdb/linux/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-*.pyc
-*.pyo
-constants.py
diff --git a/scripts/genksyms/.gitignore b/scripts/genksyms/.gitignore
deleted file mode 100644
index b119c7da..00000000
--- a/scripts/genksyms/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-genksyms
diff --git a/scripts/kconfig/.gitignore b/scripts/kconfig/.gitignore
deleted file mode 100644
index 2da579ed..00000000
--- a/scripts/kconfig/.gitignore
+++ /dev/null
@@ -1,17 +0,0 @@
-#
-# Generated files
-#
-*.moc
-gconf.glade.h
-*.pot
-*.mo
-
-#
-# configuration programs
-#
-conf
-mconf
-nconf
-qconf
-gconf
-kxgettext
diff --git a/scripts/kconfig/lxdialog/.gitignore b/scripts/kconfig/lxdialog/.gitignore
deleted file mode 100644
index 90b08ff0..00000000
--- a/scripts/kconfig/lxdialog/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-#
-# Generated files
-#
-lxdialog
diff --git a/scripts/mod/.gitignore b/scripts/mod/.gitignore
deleted file mode 100644
index 3bd11b60..00000000
--- a/scripts/mod/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-elfconfig.h
-mk_elfconfig
-modpost
-devicetable-offsets.h
diff --git a/scripts/selinux/genheaders/.gitignore b/scripts/selinux/genheaders/.gitignore
deleted file mode 100644
index 4c0b646f..00000000
--- a/scripts/selinux/genheaders/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-genheaders
diff --git a/scripts/selinux/mdp/.gitignore b/scripts/selinux/mdp/.gitignore
deleted file mode 100644
index 654546d8..00000000
--- a/scripts/selinux/mdp/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-# Generated file
-mdp
diff --git a/security/apparmor/.gitignore b/security/apparmor/.gitignore
deleted file mode 100644
index d5b291e9..00000000
--- a/security/apparmor/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-#
-# Generated include files
-#
-net_names.h
-capability_names.h
-rlim_names.h
diff --git a/security/selinux/.gitignore b/security/selinux/.gitignore
deleted file mode 100644
index 2e5040a3..00000000
--- a/security/selinux/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-av_permissions.h
-flask.h
diff --git a/security/tomoyo/.gitignore b/security/tomoyo/.gitignore
deleted file mode 100644
index dc0f220a..00000000
--- a/security/tomoyo/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-builtin-policy.h
-policy/*.conf
diff --git a/sound/Kconfig b/sound/Kconfig
index 6833db90..27fb8fd7 100644
--- a/sound/Kconfig
+++ b/sound/Kconfig
@@ -76,6 +76,8 @@ source "sound/mips/Kconfig"
 
 source "sound/sh/Kconfig"
 
+source "sound/v5/Kconfig"
+
 # the following will depend on the order of config.
 # here assuming USB is defined before ALSA
 source "sound/usb/Kconfig"
diff --git a/sound/Makefile b/sound/Makefile
index 99d8c312..d4e85d66 100644
--- a/sound/Makefile
+++ b/sound/Makefile
@@ -5,7 +5,7 @@
 obj-$(CONFIG_SOUND) += soundcore.o
 obj-$(CONFIG_DMASOUND) += oss/dmasound/
 obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ \
-	firewire/ sparc/ spi/ parisc/ pcmcia/ mips/ soc/ atmel/ hda/ x86/
+	firewire/ sparc/ spi/ parisc/ pcmcia/ mips/ soc/ atmel/ hda/ x86/ v5/
 obj-$(CONFIG_SND_AOA) += aoa/
 
 # This one must be compilable even if sound is configured out
diff --git a/sound/oss/.gitignore b/sound/oss/.gitignore
deleted file mode 100644
index 12a3920d..00000000
--- a/sound/oss/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-#Ignore generated files
-pss_boot.h
-trix_boot.h
diff --git a/sound/v5/FTSSP010_ALSA.c b/sound/v5/FTSSP010_ALSA.c
new file mode 100644
index 00000000..ec3d1e30
--- /dev/null
+++ b/sound/v5/FTSSP010_ALSA.c
@@ -0,0 +1,1457 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 Andes Technology Corporation
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <asm/dmad.h>
+#include <linux/dma-mapping.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/asound.h>
+#include <linux/i2c.h>
+#include <sound/control.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include "FTSSP010_UDA1345TS.h"
+
+struct alc5630_data;
+int init_hw(unsigned int cardno,unsigned int ac97, struct i2c_client *client);
+
+#if (!defined(CONFIG_PLATFORM_AHBDMA))
+#warning needs ahb dma to wrok
+#endif
+
+/* ---------------------------------------------------------------------------
+ * Define the debug level of FTSSP_DEBUG
+ */
+#define FTSSP_DEBUG     	0
+#define FTSSP_DEBUG_VERBOSE	0
+#define FTSSP_PROC_FS   	0
+
+#undef VVDBG
+#if (FTSSP_DEBUG_VERBOSE)
+#define VVDBG(vvar...)	(void)0
+//#define VVDBG(vvar...)	printk(KERN_INFO vvar)
+#else
+#define VVDBG(vvar...)	(void)0
+#endif
+
+#undef ERR
+#define ERR(vvar...)	printk(KERN_ERR vvar)
+
+#undef INFO
+#define INFO(vvar...)	printk(KERN_INFO vvar)
+
+#if (FTSSP_DEBUG)
+#undef DBG
+#define DBG(vvar...)	printk(KERN_INFO vvar)
+#else
+#define DBG(vvar...)	(void)0
+#endif
+
+#if (FTSSP_DEBUG_VERBOSE)
+#undef VDBG
+#define VDBG(vvar...)	printk(KERN_INFO vvar)
+#else
+#define VDBG(vvar...)	(void)0
+#endif
+
+/* ---------------------------------------------------------------------------
+ * Preserved size of memory space for audio DMA ring
+ */
+#define FTSSP_HW_DMA_SIZE		(512 * 1024)
+
+/* Buffer sizes reported to ALSA layer - AC97 mode */
+
+/* ring size, exported to application */
+#define AC97_HW_BUFFER_BYTES_MAX	(42 * 1024)
+/* should not exceed AC97_HW_PERIOD_BYTES_MAX */
+#define AC97_HW_PERIOD_BYTES_MIN	(2 * 1024)
+/* AC97_HW_PERIOD_BYTES_MAX * AC97_HW_PERIODS_MAX <= AC97_HW_BUFFER_SIZE */
+#define AC97_HW_PERIOD_BYTES_MAX	(8 * 1024)
+/* 3 <= AC97_HW_PERIODS_MIN <= AC97_HW_PERIODS_MAX */
+#define AC97_HW_PERIODS_MIN		3
+/* AC97_HW_PERIOD_BYTES_MAX * AC97_HW_PERIODS_MAX <= AC97_HW_BUFFER_SIZE */
+#define AC97_HW_PERIODS_MAX		5
+
+/* Driver internal dma buffer size, x2 for S16_LE(16-bits) to AC97 (20-bits),
+ * x6 for sampling rate converion from minimum 8k to AC97 48k.
+ *
+ * Note that AC97 mode cannot do playback and recording simultaneouly. So we
+ * use up all FTSSP_HW_DMA_SIZE of memory.
+ */
+#define AC97_HW_DMA_SIZE		(AC97_HW_BUFFER_BYTES_MAX * 2 * 6)
+
+/* Buffer sizes reported to ALSA layer - I2S mode */
+
+/* ring size, exported to application */
+#define I2S_HW_BUFFER_BYTES_MAX		(256 * 1024)
+/* should not exceed I2S_HW_PERIOD_BYTES_MAX */
+#define I2S_HW_PERIOD_BYTES_MIN		(2 * 1024)
+/* I2S_HW_PERIOD_BYTES_MAX * I2S_HW_PERIODS_MAX <= I2S_HW_BUFFER_SIZE */
+#define I2S_HW_PERIOD_BYTES_MAX		(32 * 1024)
+/* 3 <= I2S_HW_PERIODS_MIN <= I2S_HW_PERIODS_MAX */
+#define I2S_HW_PERIODS_MIN		3
+/* I2S_HW_PERIOD_BYTES_MAX * I2S_HW_PERIODS_MAX <= I2S_HW_BUFFER_SIZE */
+#define I2S_HW_PERIODS_MAX		8
+
+/* Page-in size for playback and capture each.  Note that I2S mode can do
+ * playback and recording simultaneouly, so this size should be less than or
+ * equal to FTSSP_HW_DMA_SIZE/2
+ */
+#define I2S_HW_DMA_SIZE			(I2S_HW_BUFFER_BYTES_MAX)
+
+/* ---------------------------------------------------------------------------
+ * Audio formats
+ */
+#define AC97_CODEC_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE)
+#define AC97_CODEC_SAMPLE_RATES		(SNDRV_PCM_RATE_48000 | \
+					 SNDRV_PCM_RATE_44100 | \
+					 SNDRV_PCM_RATE_32000 | \
+					 SNDRV_PCM_RATE_16000 | \
+					 SNDRV_PCM_RATE_8000)
+
+#define AC97_CODEC_SAMPLE_RATE_MIN	(8000)
+#define AC97_CODEC_SAMPLE_RATE_MAX	(48000)
+
+#define I2S_CODEC_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE)
+#define I2S_CODEC_SAMPLE_RATES		(SNDRV_PCM_RATE_48000 | \
+					 SNDRV_PCM_RATE_44100 | \
+					 SNDRV_PCM_RATE_32000 | \
+					 SNDRV_PCM_RATE_22050 | \
+					 SNDRV_PCM_RATE_16000 | \
+					 SNDRV_PCM_RATE_11025 | \
+					 SNDRV_PCM_RATE_8000)
+#define I2S_CODEC_SAMPLE_RATE_MIN	(8000)
+#define I2S_CODEC_SAMPLE_RATE_MAX	(48000)
+
+
+/* ---------------------------------------------------------------------------
+ * Configuration
+ */
+#if (CONFIG_PROC_FS == 0)
+#undef FTSSP_PROC_FS
+#define FTSSP_PROC_FS 0
+#else
+#if (FTSSP_PROC_FS)
+#include <sound/info.h>
+#endif  /* FTSSP_PROC_FS */
+#endif  /* CONFIG_PROC_FS */
+
+#define FTSSP_CARD_ID		"ftssp010"
+#define FTSSP_DRIVER_NAME	"ftssp"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Faraday Technology Corp.");
+MODULE_DESCRIPTION("FTSSP010 Linux 2.6 Driver");
+
+static int cardno = 0;
+/* Driver mode */
+#ifdef CONFIG_SND_FTSSP010_AC97
+static int ac97 = 1;
+#else
+static int ac97 = 0;
+#endif
+
+// ----------------------------------------------
+module_param(cardno, int, 0);
+MODULE_PARM_DESC(cardno, "FTSSP No.");
+
+module_param(ac97, int, 0);
+MODULE_PARM_DESC(ac97, "AC97 mode");
+// ----------------------------------------------
+
+/* ---------------------------------------------------------------------------
+ * Structures
+ */
+
+/* private data for card */
+typedef struct {
+	struct platform_device	*pdev;
+	struct snd_card *card;
+	struct snd_pcm  *pcm;
+	struct snd_pcm_substream *substream_tx;
+	struct snd_pcm_substream *substream_rx;
+#if (FTSSP_PROC_FS)
+	struct snd_info_entry *info_buf_max;
+	struct snd_info_entry *info_period_min;
+	struct snd_info_entry *info_period_max;
+	struct snd_info_entry *info_periods_min;
+	struct snd_info_entry *info_periods_max;
+#endif
+} ftssp_chip;
+
+/* dma request descriptors */
+dmad_chreq dma_chreq_tx = {
+	.channel = -1,
+	.drq     = NULL,
+};
+
+dmad_chreq dma_chreq_rx = {
+	.channel = -1,
+	.drq     = NULL,
+};
+
+/* Holds ALSA card instance pointers */
+struct snd_card *ftssp_cards[SSP_FTSSP010_COUNT];
+
+/* snd_pcm_hardware */
+static struct snd_pcm_hardware snd_ftssp_pcm_hw =
+{
+	.info               = SNDRV_PCM_INFO_INTERLEAVED,
+	.formats            = I2S_CODEC_FORMATS,
+	.rates              = I2S_CODEC_SAMPLE_RATES,
+	.rate_min           = I2S_CODEC_SAMPLE_RATE_MIN,
+	.rate_max           = I2S_CODEC_SAMPLE_RATE_MAX,
+	.channels_min       = 1,
+	.channels_max       = 2,
+	.buffer_bytes_max   = I2S_HW_BUFFER_BYTES_MAX,
+	.period_bytes_min   = I2S_HW_PERIOD_BYTES_MIN,
+	.period_bytes_max   = I2S_HW_PERIOD_BYTES_MAX,
+	.periods_min        = I2S_HW_PERIODS_MIN,
+	.periods_max        = I2S_HW_PERIODS_MAX,
+};
+
+/* private data for a substream (playback or capture) */
+/* function pointer for set up AHBDMA for this substream */
+typedef void (*start_t)(int cardno, unsigned use_dma);
+typedef void (*pmu_set_clocking_t)(unsigned int);
+typedef void (*ftssp010_config_t)(int cardno, unsigned is_stereo,
+				  unsigned speed, int use8bit);
+
+typedef struct {
+	u32                busy;
+	spinlock_t         dma_lock;
+	unsigned long	dma_area_va;
+
+	int                dma_width;
+	unsigned int       tx_period;
+	unsigned int       rx_period;
+
+	start_t            start;
+	pmu_set_clocking_t pmu_set_clocking;
+	ftssp010_config_t  hw_config;
+} ftssp_substream;
+
+static ftssp_substream ftssp010_substreams[2] = {
+	/* Playback substream */
+	{
+		busy             : 0,
+		start            : ftssp010_start_tx,
+		pmu_set_clocking : pmu_set_i2s_clocking,
+		hw_config        : ftssp010_config_tx,
+	},
+	/* Capture substream */
+	{
+		busy             : 0,
+		start            : ftssp010_start_rx,
+		pmu_set_clocking : pmu_set_i2s_clocking,
+		hw_config        : ftssp010_config_rx,
+	}
+};
+
+/* (AC97 only) Convert 16 bits PCM data in user buffer to/from 20 bits PCM data
+ * (32 bits actaully in dma buffer) for AC97 codec.
+ */
+static int snd_ftssp_playback_copy(struct snd_pcm_substream *substream,
+	int channel, snd_pcm_uframes_t pos, void *usr_buf,
+	snd_pcm_uframes_t count)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	ftssp_substream *ftssp010_substream =
+		(ftssp_substream *) runtime->private_data;
+
+	u32 *dma_va = NULL;
+	u16 *usr_va = usr_buf;
+	int copy_words;
+	int pcm_data;
+	dmad_chreq *dma_chreq;
+	u32 sw_ptr;
+
+	/* convert to frames */
+	pos = bytes_to_frames(substream->runtime, pos);
+	count = bytes_to_frames(substream->runtime, count);
+
+	/* frames_to_bytes(runtime, pos + count) * 2(bytes/per pcm) /
+	 * 4(bytes per dma unit) */
+	sw_ptr = (u32)frames_to_bytes(runtime, pos + count) >> 1;
+
+	switch (runtime->rate) {
+	case 8000:
+		sw_ptr *= 6;
+		dma_va = (unsigned *)(ftssp010_substream->dma_area_va +
+				frames_to_bytes(runtime, pos * 6) * 2);
+
+		VVDBG("%s: pos(0x%08x) count(0x%08x) next_pos(0x%08x)\n",
+			__func__, (u32)pos, (u32)count, (u32)(pos + count));
+		VVDBG("%s: va base(0x%08x) range (0x%08x ~ 0x%08x)\n",
+			__func__, (u32)ftssp010_substream->dma_area_va,
+			(u32)dma_va,
+			(u32)dma_va +
+			(u32)2 * frames_to_bytes(runtime, count * 6));
+
+		if (runtime->channels == 1) {
+			while (count--) {
+				pcm_data=0;
+				get_user(pcm_data, usr_va++);
+				dma_va[0] = (pcm_data & 0xffff) << 4;
+				dma_va[1] = dma_va[2] = dma_va[3] =
+				dma_va[4] = dma_va[5] = dma_va[0];
+				//memcpy(&dma_va[1], &dma_va[0], 5 * 4 * 1);
+				dma_va += 6;
+			}
+		} else {  // assume 2 channels
+			while (count--) {
+				pcm_data=0;
+				get_user(pcm_data, usr_va++);
+				dma_va[0] = (pcm_data & 0xffff) << 4;
+
+				pcm_data=0;
+				get_user(pcm_data, usr_va++);
+				dma_va[1] = (pcm_data & 0xffff) << 4;
+
+				dma_va[2] = dma_va[4] = dma_va[6] =
+				dma_va[8] = dma_va[10] = dma_va[0];
+				dma_va[3] = dma_va[5] = dma_va[7] =
+				dma_va[9] = dma_va[11] = dma_va[0];
+				//memcpy(&dma_va[2], &dma_va[0], 5 * 4 * 2);
+				dma_va += 12;
+			}
+		}
+		break;
+
+	case 16000:
+		sw_ptr *= 3;
+
+		dma_va = (unsigned *)(ftssp010_substream->dma_area_va +
+				frames_to_bytes(runtime, pos * 3) * 2);
+
+		VVDBG("%s: pos(0x%08x) count(0x%08x) next_pos(0x%08x)\n",
+			__func__, (u32)pos, (u32)count, (u32)(pos + count));
+		VVDBG("%s: va base(0x%08x) range (0x%08x ~ 0x%08x)\n",
+			__func__, (u32)ftssp010_substream->dma_area_va,
+			(u32)dma_va,
+			(u32)dma_va +
+			(u32)2 * frames_to_bytes(runtime, count * 3));
+
+		if (runtime->channels == 1) {
+			while (count--) {
+				pcm_data=0;
+				get_user(pcm_data, usr_va++);
+				dma_va[0] = (pcm_data & 0xffff) << 4;
+				dma_va[1] = dma_va[2] = dma_va[0];
+				//memcpy(&dma_va[1], &dma_va[0], 2 * 4 * 1);
+				dma_va += 3;
+			}
+		} else {  // assume 2 channels
+			while (count--) {
+				pcm_data=0;
+				get_user(pcm_data, usr_va++);
+				dma_va[0] = (pcm_data & 0xffff) << 4;
+
+				pcm_data=0;
+				get_user(pcm_data, usr_va++);
+				dma_va[1] = (pcm_data & 0xffff) << 4;
+
+				dma_va[2] = dma_va[4] = dma_va[0];
+				dma_va[3] = dma_va[5] = dma_va[1];
+				//memcpy(&dma_va[2], &dma_va[0], 2 * 4 * 2);
+				dma_va += 6;
+			}
+		}
+		break;
+
+	case 48000:
+	default:
+		dma_va = (unsigned *)(ftssp010_substream->dma_area_va +
+				frames_to_bytes(runtime, pos) * 2);
+		copy_words = 2 * frames_to_bytes(runtime, count) / sizeof(u32);
+
+		VVDBG("%s: pos(0x%08x) count(0x%08x) next_pos(0x%08x)\n",
+			__func__, (u32)pos, (u32)count, (u32)(pos + count));
+		VVDBG("%s: va base(0x%08x) range (0x%08x ~ 0x%08x)\n",
+			__func__, (u32)ftssp010_substream->dma_area_va,
+			(u32)dma_va,
+			(u32)dma_va + (u32)copy_words*4);
+
+		while (copy_words--) {
+			get_user(pcm_data, usr_va++);
+			*dma_va++= (pcm_data & 0xffff) << 4;
+		}
+		break;
+	}
+
+	dma_chreq = &dma_chreq_tx;
+
+	if (dmad_update_ring_sw_ptr(dma_chreq, sw_ptr,
+		(runtime->status->state == SNDRV_PCM_STATE_RUNNING) ? 1:0) != 0)
+	{
+		ERR("%s: failed to update sw-pointer!\n", __func__);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int snd_ftssp_capture_copy(struct snd_pcm_substream *substream,
+	int channel, snd_pcm_uframes_t pos, void *usr_buf,
+	snd_pcm_uframes_t count)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	ftssp_substream *ftssp010_substream =
+		(ftssp_substream *) runtime->private_data;
+
+	u32 *dma_va = NULL;
+	u16 *usr_va = usr_buf;
+
+	switch (runtime->rate) {
+	case 8000:
+		dma_va = (unsigned *)(ftssp010_substream->dma_area_va +
+				 frames_to_bytes(runtime, pos * 6) * 2);
+
+		VVDBG("%s: pos(0x%08x) count(0x%08x) next_pos(0x%08x)\n",
+			__func__, (u32)pos, (u32)count, (u32)(pos + count));
+		VVDBG("%s: va base(0x%08x) range (0x%08x ~ 0x%08x)\n",
+			__func__, (u32)ftssp010_substream->dma_area_va,
+			(u32)dma_va,
+			(u32)dma_va +
+			(u32)2 * frames_to_bytes(runtime, count * 6));
+
+		if (runtime->channels == 1) {
+			while (count--) {
+				put_user((u16)(dma_va[0] >> 4),usr_va++);
+				dma_va += 6;
+			}
+		} else {
+			while (count--) {
+				put_user((u16)(dma_va[0] >> 4),usr_va);
+				usr_va++;
+				put_user((u16)(dma_va[0] >> 4),usr_va);
+
+				/* [hw-limit] only slot-3 has valid data in
+				 *   recording mode -- check TAG_DATA_MONO
+				 *   defined in "FTSSP010_lib.c".  Mask out
+				 *   one channel to avoid hi-freq noise.
+				 */
+				usr_va += 2;
+				dma_va += 12;
+			}
+		}
+		break;
+
+	case 16000:
+		dma_va = (unsigned *)(ftssp010_substream->dma_area_va +
+				 frames_to_bytes(runtime, pos * 3) * 2);
+
+		VVDBG("%s: pos(0x%08x) count(0x%08x) next_pos(0x%08x)\n",
+			__func__, (u32)pos, (u32)count, (u32)(pos + count));
+		VVDBG("%s: va base(0x%08x) range (0x%08x ~ 0x%08x)\n",
+			__func__, (u32)ftssp010_substream->dma_area_va,
+			(u32)dma_va,
+			(u32)dma_va +
+			(u32)2 * frames_to_bytes(runtime, count * 3));
+
+		if (runtime->channels == 1) {
+			while (count--) {
+				put_user((u16)(dma_va[0] >> 4),usr_va++);	
+				dma_va += 3;
+			}
+		} else {
+			while (count--) {
+				put_user((u16)(dma_va[0] >> 4),usr_va);	
+				usr_va++;
+				put_user((u16)(dma_va[0] >> 4),usr_va);	
+
+				/* [hw-limit] only slot-3 has valid data in
+				 *   recording mode -- check TAG_DATA_MONO
+				 *   defined in "FTSSP010_lib.c".  Mask out
+				 *   one channel to avoid hi-freq noise.
+				 */
+				usr_va += 2;
+				dma_va += 6;
+			}
+		}
+		break;
+
+	case 48000:
+	default:
+		dma_va = (unsigned *)(ftssp010_substream->dma_area_va +
+				frames_to_bytes(runtime, pos) * 2);
+
+		VVDBG("%s: pos(0x%08x) count(0x%08x) next_pos(0x%08x)\n",
+			__func__, (u32)pos, (u32)count, (u32)(pos + count));
+		VVDBG("%s: va base(0x%08x) range (0x%08x ~ 0x%08x)\n",
+			__func__, (u32)ftssp010_substream->dma_area_va,
+			(u32)dma_va,
+			(u32)dma_va +
+			(u32)2 * frames_to_bytes(runtime, count));
+
+		if (runtime->channels == 1) {
+			while (count--) {
+				 put_user((u16)(dma_va[0] >> 4),usr_va++);	
+			}
+		} else {
+			while (count--) {
+				put_user((u16)(dma_va[0] >> 4),usr_va);
+				usr_va++;
+				put_user((u16)(dma_va[0] >> 4),usr_va);	
+		
+				/* [hw-limit] only slot-3 has valid data in
+				 *   recording mode -- check TAG_DATA_MONO
+				 *   defined in "FTSSP010_lib.c".  Mask out
+				 *   one channel to avoid hi-freq noise.
+				 */
+				usr_va += 2;
+				dma_va += 2;
+			}
+		}
+		break;
+	}
+
+	return 0;
+}
+
+/**
+ * These dma callbacks are called in interrupt context.
+ * @data: pointer to the chip-wide structure.
+ *        TODO: use stream-specifc data
+ */
+__attribute__((__unused__))
+static void ftssp_dma_callback_tx(int ch, u16 int_status, void *data)
+{
+	ftssp_chip *chip = (ftssp_chip *)data;
+
+	if (!ac97) {
+		/* in i2s mode, no indication to driver for user data length.
+		 * For simplicity, just go ahead by one period */
+
+		struct snd_pcm_runtime *runtime = chip->substream_tx->runtime;
+		ftssp_substream *ftssp010_substream =
+			(ftssp_substream *)runtime->private_data;
+		u32 sw_ptr;
+		u32 tx_period = ftssp010_substream->tx_period + 1;
+
+		if (tx_period == runtime->periods)
+			sw_ptr = runtime->buffer_size;
+		else
+			sw_ptr = tx_period * runtime->period_size;
+
+		sw_ptr = (u32)frames_to_bytes(runtime, sw_ptr) >> 1;
+
+		if (dmad_update_ring_sw_ptr(&dma_chreq_tx, (u32)sw_ptr, 0)) {
+			ERR("%s: failed to update sw-pointer!\n", __func__);
+		}
+
+		ftssp010_substream->tx_period = tx_period % runtime->periods;
+	}
+
+	snd_pcm_period_elapsed(chip->substream_tx);
+}
+
+__attribute__((__unused__))
+static void ftssp_dma_callback_rx(int ch, u16 int_status, void *data)
+{
+	ftssp_chip *chip = (ftssp_chip *)data;
+	struct snd_pcm_runtime *runtime = chip->substream_rx->runtime;
+	ftssp_substream *ftssp010_substream =
+		(ftssp_substream *)runtime->private_data;
+
+	u32 sw_ptr;
+	u32 rx_period = ftssp010_substream->rx_period + 1;
+
+	if (rx_period == runtime->periods)
+		sw_ptr = runtime->buffer_size;
+	else
+		sw_ptr = rx_period * runtime->period_size;
+
+	if (ac97) {
+		switch (runtime->rate) {
+		case 8000:
+			sw_ptr = sw_ptr * 6;
+			break;
+		case 16000:
+			sw_ptr = sw_ptr * 3;
+			break;
+		case 48000:
+		default:
+			break;
+		}
+	}
+	sw_ptr = (u32)frames_to_bytes(runtime, sw_ptr) >> 1;
+
+	if (dmad_update_ring_sw_ptr(&dma_chreq_rx, (u32)sw_ptr, 0) != 0) {
+		ERR("%s: failed to update sw-pointer!\n", __func__);
+	}
+
+	ftssp010_substream->rx_period = rx_period % runtime->periods;
+
+	snd_pcm_period_elapsed(chip->substream_rx);
+}
+
+static inline int snd_ftssp_dma_ch_alloc(struct snd_pcm_substream *substream)
+{
+	dmad_chreq *ch_req __attribute__((__unused__)) = 0;
+
+#ifdef CONFIG_PLATFORM_AHBDMA
+	if (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		ch_req = &dma_chreq_tx;
+		ch_req->completion_cb    = ftssp_dma_callback_tx;
+		ch_req->ahb_req.tx_dir   = DMAD_DIR_A0_TO_A1;
+#if defined(CONFIG_PLAT_AG101P)
+		if((inl(PMU_BASE) & AMERALD_MASK) == AMERALD_PRODUCT_ID)
+		{
+			ch_req->ahb_req.dev_reqn = DMAC_REQN_I2SAC97TX_AMERALD;
+		}
+		else
+#endif
+			/*TX DST handshake mode addr0 --> addr1
+			 * tx_dir == 0, addr1 set handshake ID*/
+			ch_req->ahb_req.dev_reqn = DMAC_REQN_I2SAC97TX;
+	} else {
+		ch_req = &dma_chreq_rx;
+		ch_req->completion_cb    = ftssp_dma_callback_rx;
+		ch_req->ahb_req.tx_dir   = DMAD_DIR_A1_TO_A0;
+#if defined(CONFIG_PLAT_AG101P)
+		if((inl(PMU_BASE) & AMERALD_MASK) == AMERALD_PRODUCT_ID)
+		{
+			ch_req->ahb_req.dev_reqn = DMAC_REQN_I2SAC97RX_AMERALD;
+		}
+		else
+#endif
+			/*RX SRC handshake mode, addr1 --> addr0
+			 *tx_dir == 1, addr1 set handshake ID*/
+			ch_req->ahb_req.dev_reqn  = DMAC_REQN_I2SAC97RX;
+	}
+
+	ch_req->controller           = DMAD_DMAC_AHB_CORE;
+	ch_req->flags                = DMAD_FLAGS_RING_MODE;
+	ch_req->ring_base            = 0;
+	ch_req->dev_addr             = (dma_addr_t)FTSSP010_DATA_PA(cardno);
+	ch_req->periods              = 0;
+	ch_req->period_size          = 0;
+
+	ch_req->ahb_req.sync         = 1;
+	ch_req->ahb_req.priority     = DMAC_CSR_CHPRI_2;
+	ch_req->ahb_req.hw_handshake = 1;
+	ch_req->ahb_req.burst_size   = DMAC_CSR_SIZE_1;
+
+	if (ac97) {
+		ch_req->ahb_req.ring_width   = DMAC_CSR_WIDTH_32;
+		ch_req->ahb_req.ring_ctrl    = DMAC_CSR_AD_INC;
+		ch_req->ahb_req.ring_reqn    = DMAC_REQN_NONE;
+		ch_req->ahb_req.dev_width    = DMAC_CSR_WIDTH_32;
+		ch_req->ahb_req.dev_ctrl     = DMAC_CSR_AD_FIX;
+	} else {
+		ch_req->ahb_req.ring_width   = DMAC_CSR_WIDTH_16;
+		ch_req->ahb_req.ring_ctrl    = DMAC_CSR_AD_INC;
+		ch_req->ahb_req.ring_reqn    = DMAC_REQN_NONE;
+		ch_req->ahb_req.dev_width    = DMAC_CSR_WIDTH_16;
+		ch_req->ahb_req.dev_ctrl     = DMAC_CSR_AD_FIX;
+	}
+
+	ch_req->completion_data = (void *)snd_pcm_substream_chip(substream);
+
+	if (dmad_channel_alloc(ch_req) != 0) {
+		ERR("%s: AHBDMA channel allocation failed\n", __func__);
+		goto _err_exit;
+	}
+
+	DBG("%s: AHBDMA channel allocated (ch: %d) ring_mode\n",
+		__func__, ch_req->channel);
+
+	return 0;
+
+_err_exit:
+
+#endif /* CONFIG_PLATFORM_AHBDMA */
+
+	return -ENODEV;
+}
+
+static inline ftssp_substream *ftssp010_substream_new(int stream_id)
+{
+	ftssp_substream *s = NULL;
+
+	switch (stream_id) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		s = &ftssp010_substreams[0];
+		break;
+	case SNDRV_PCM_STREAM_CAPTURE:
+		s = &ftssp010_substreams[1];
+		break;
+	default:
+		ERR("%s: wrong stream type (%d)\n", __func__, stream_id);
+		return NULL;
+	}
+
+	if (s->busy) {
+		ERR("%s: device busy!\n", __func__);
+		return NULL;
+	}
+	s->busy = 1;
+
+	spin_lock_init(&s->dma_lock);
+
+	return s;
+}
+
+static int snd_ftssp_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int stream_id = substream->pstr->stream;
+
+	VDBG("%s, %s\n", __func__,
+		(substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+		"playback" : "capture");
+
+	/* Both playback and capture share a hardware description */
+	runtime->hw = snd_ftssp_pcm_hw;
+
+	/* Allocate & Initialize stream-specific data */
+	runtime->private_data = ftssp010_substream_new(stream_id);
+
+	if (runtime->private_data) {
+		return snd_ftssp_dma_ch_alloc(substream);
+    }
+	else
+		return -EBUSY;
+}
+
+static int snd_ftssp_pcm_close(struct snd_pcm_substream *substream)
+{
+	int stream_id = substream->pstr->stream;
+	ftssp_substream *ftssp010_substream =
+		(ftssp_substream *)substream->runtime->private_data;
+
+	VDBG("%s, %s\n", __func__,
+		(substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+		"playback" : "capture");
+
+	if (stream_id == SNDRV_PCM_STREAM_PLAYBACK)
+		dmad_channel_free(&dma_chreq_tx);
+	else
+		dmad_channel_free(&dma_chreq_rx);
+
+	ftssp010_substream->busy = 0;
+	return 0;
+}
+
+static int snd_ftssp_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *hw_params)
+{
+	VDBG("%s, %s\n", __func__,
+		(substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+		"playback" : "capture");
+
+	if (ac97)
+		return snd_pcm_lib_malloc_pages(substream, AC97_HW_DMA_SIZE);
+	else
+		return snd_pcm_lib_malloc_pages(substream, I2S_HW_DMA_SIZE);
+}
+
+static int snd_ftssp_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	VDBG("%s, %s\n", __func__,
+		(substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+		"playback" : "capture");
+
+	if (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dmad_drain_requests(&dma_chreq_tx, 1);
+	else
+		dmad_drain_requests(&dma_chreq_rx, 1);
+
+	return snd_pcm_lib_free_pages(substream);
+}
+
+/* Prepare FTSSP010 AHBDMA for playback & capture */
+static int snd_ftssp_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	ftssp_chip *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	ftssp_substream *ftssp010_substream =
+		(ftssp_substream *)runtime->private_data;
+
+	int stream_id = substream->pstr->stream;
+	dmad_chreq *dma_chreq;
+	unsigned period_size, buffer_size;
+
+	if (stream_id == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_chreq = &dma_chreq_tx;
+	else
+		dma_chreq = &dma_chreq_rx;
+
+	period_size = frames_to_bytes(runtime, runtime->period_size);
+	buffer_size = frames_to_bytes(runtime, runtime->buffer_size);
+
+	if (runtime->format != SNDRV_PCM_FORMAT_S16_LE)
+		return -ENODEV;
+
+	if (ac97) {
+		switch (runtime->rate) {
+		case 8000:
+			period_size *= 12;
+			buffer_size *= 12;
+			break;
+		case 16000:
+			period_size *= 6;
+			buffer_size *= 6;
+			break;
+		case 48000:
+		default:
+			period_size *= 2;
+			buffer_size *= 2;
+			break;
+		}
+
+		ftssp010_substream->dma_width = 4;
+	} else {
+		ftssp010_substream->dma_width = 2;
+	}
+
+	dmad_drain_requests(dma_chreq, 1);
+
+	dma_chreq->ring_base   = (dma_addr_t)runtime->dma_addr;
+	dma_chreq->periods     = (dma_addr_t)runtime->periods;
+	if (ac97) {
+		dma_chreq->period_size = (dma_addr_t)(period_size >> 2);
+		dma_chreq->ring_size   = (dma_addr_t)(buffer_size >> 2);
+	} else {
+		dma_chreq->period_size = (dma_addr_t)(period_size >> 1);
+		dma_chreq->ring_size   = (dma_addr_t)(buffer_size >> 1);
+	}
+	dmad_update_ring(dma_chreq);
+
+	/* Set PMU, FTSSP010, and DMA */
+	spin_lock(&ftssp010_substream->dma_lock);
+
+	/* keep DMA buffer VA for copy() callback */
+	// todo: support playback/capture simultaneously
+	ftssp010_substream->dma_area_va = (unsigned long)runtime->dma_area;
+
+	if (ac97) {
+		ftssp010_substream->pmu_set_clocking(48000);
+		ftssp010_substream->hw_config(cardno,
+			runtime->channels > 1 ? 1 : 0, /* 1: stereo, 0: mono */
+			runtime->rate, ftssp010_substream->dma_width);
+	} else {
+		ftssp010_substream->pmu_set_clocking(runtime->rate);
+		ftssp010_substream->hw_config(cardno,
+			runtime->channels > 1 ? 1 : 0, /* 1: stereo, 0: mono */
+			runtime->rate, ftssp010_substream->dma_width);
+	}
+
+	if (stream_id == SNDRV_PCM_STREAM_PLAYBACK) {
+		ftssp010_substream->tx_period = 0;
+		chip->substream_tx = substream;
+	} else {
+		ftssp010_substream->rx_period = 0;
+		chip->substream_rx = substream;
+	}
+
+	spin_unlock(&ftssp010_substream->dma_lock);
+
+	VVDBG("%s <<\n", __func__);
+
+	return 0;
+}
+
+static inline int snd_ftssp_start_play(ftssp_substream *ftssp010_substream,
+	struct snd_pcm_runtime *runtime)
+{
+	int err = 0;
+
+	if (ac97) {
+		/* in ac97 mode, user data was fed to dma buffer through
+		 * driver-provided copy callback */
+		err = dmad_kickoff_requests(&dma_chreq_tx);
+		if (err != 0) {
+			ERR("%s: failed to kickoff dma!\n", __func__);
+			return err;
+		}
+	} else {
+		/* in i2s mode, no indication to driver for user data length
+		 * (except start threshold). For simplicity at start, just go
+		 * ahead by one cycle */
+
+		u32 sw_ptr =
+			(u32)frames_to_bytes(runtime, runtime->buffer_size) >>1;
+
+		err = dmad_update_ring_sw_ptr(&dma_chreq_tx, sw_ptr, 0);
+		if (err != 0) {
+			ERR("%s: failed to update sw-pointer!\n", __func__);
+			return err;
+		}
+
+		err = dmad_kickoff_requests(&dma_chreq_tx);
+		if (err != 0) {
+			ERR("%s: failed to kickoff dma!\n", __func__);
+			return err;
+		}
+	}
+	ftssp010_substream->start(cardno, 1);
+
+	return 0;
+}
+
+static inline int snd_ftssp_start_record(ftssp_substream *ftssp010_substream,
+	struct snd_pcm_runtime *runtime)
+{
+	int err = 0;
+	u32 sw_ptr = (u32)frames_to_bytes(runtime, runtime->buffer_size);
+
+	if (ac97) {
+		switch (runtime->rate) {
+		case 8000:
+			sw_ptr = (sw_ptr * 3);
+			break;
+		case 16000:
+			sw_ptr = (sw_ptr * 3) >> 1;
+			break;
+		case 48000:
+		default:
+			sw_ptr = sw_ptr >> 1;
+			break;
+		}
+	} else {
+		sw_ptr = sw_ptr >> 1;
+	}
+
+	err = dmad_update_ring_sw_ptr(&dma_chreq_rx, sw_ptr, 0);
+	if (err != 0) {
+		ERR("%s: failed to update sw-pointer!\n", __func__);
+		return err;
+	}
+
+	err = dmad_kickoff_requests(&dma_chreq_rx);
+	if (err != 0) {
+		ERR("%s: failed to kickoff dma!\n", __func__);
+		return err;
+	}
+
+	ftssp010_substream->start(cardno, 1);
+
+	return 0;
+}
+
+/* Triggers AHBDMA for playback & capture */
+static int snd_ftssp_pcm_trigger(struct snd_pcm_substream * substream, int cmd)
+{
+	ftssp_substream *ftssp010_substream =
+		(ftssp_substream *)substream->runtime->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err = 0;
+	int stream_id = substream->pstr->stream;
+
+	/* note local interrupts are already disabled in the midlevel code */
+	spin_lock(&ftssp010_substream->dma_lock);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+
+		VDBG("%s: SNDRV_PCM_TRIGGER_START state(0x%08x)\n",
+			__func__, (u32)runtime->status->state);
+
+		if (stream_id == SNDRV_PCM_STREAM_PLAYBACK) {
+			err = snd_ftssp_start_play(ftssp010_substream, runtime);
+		} else {
+			err = snd_ftssp_start_record(ftssp010_substream,
+				runtime);
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+
+		VDBG("%s: SNDRV_PCM_TRIGGER_STOP state(0x%08x)\n",
+			__func__, (u32)substream->runtime->status->state);
+
+		if (stream_id == SNDRV_PCM_STREAM_PLAYBACK) {
+			ftssp010_stop_tx(cardno);
+			dmad_drain_requests(&dma_chreq_tx, 1);
+		} else {
+			ftssp010_stop_rx(cardno);
+			dmad_drain_requests(&dma_chreq_rx, 1);
+		}
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&ftssp010_substream->dma_lock);
+	return err;
+}
+
+// pcm middle-layer call this function within irq (snd_pcm_period_elapsed) or
+// with local irq disabled (snd_pcm_lib_write1)
+static snd_pcm_uframes_t snd_ftssp_pcm_pointer(
+	struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	u32 hw_ptr;
+	snd_pcm_uframes_t ret;
+	int stream_id = substream->pstr->stream;
+
+
+	/* Fetch DMA pointer, with spin lock */
+	//spin_lock_irqsave(&ftssp010_substream->dma_lock, flags);
+
+	if (stream_id == SNDRV_PCM_STREAM_PLAYBACK) {
+		hw_ptr = dmad_probe_ring_hw_ptr(&dma_chreq_tx);
+	} else {
+		hw_ptr = dmad_probe_ring_hw_ptr(&dma_chreq_rx);
+	}
+
+	//spin_unlock_irqrestore(&ftssp010_substream->dma_lock, flags);
+
+	if (ac97) {
+		ret = bytes_to_frames(runtime, hw_ptr << 1);
+
+		switch (runtime->rate) {
+		case 8000:
+			ret = ret / 6;
+			break;
+		case 16000:
+			ret = ret / 3;
+			break;
+		case 48000:
+		default:
+			break;
+		}
+	} else {
+		ret = bytes_to_frames(runtime, hw_ptr << 1);
+	}
+
+
+	VVDBG("%s: hw_ptr(0x%08x) ret(0x%08x)\n",
+		(stream_id == SNDRV_PCM_STREAM_PLAYBACK) ? "p" : "c",
+		(u32)hw_ptr, (u32)ret);
+
+	/* ALSA requires return value 0 <= ret < buffer_size */
+	if (ret >= runtime->buffer_size)
+		return 0;
+	return ret;
+}
+
+/* For FTSSP010 driver, operations are shared among playback & capture */
+static struct snd_pcm_ops snd_ftssp_playback_ops = {
+	.open      = snd_ftssp_pcm_open,
+	.close     = snd_ftssp_pcm_close,
+	.ioctl     = snd_pcm_lib_ioctl,
+	.hw_params = snd_ftssp_pcm_hw_params,
+	.hw_free   = snd_ftssp_pcm_hw_free,
+	.prepare   = snd_ftssp_pcm_prepare,
+	.trigger   = snd_ftssp_pcm_trigger,
+	.pointer   = snd_ftssp_pcm_pointer,
+};
+
+static struct snd_pcm_ops snd_ftssp_capture_ops = {
+	.open      = snd_ftssp_pcm_open,
+	.close     = snd_ftssp_pcm_close,
+	.ioctl     = snd_pcm_lib_ioctl,
+	.hw_params = snd_ftssp_pcm_hw_params,
+	.hw_free   = snd_ftssp_pcm_hw_free,
+	.prepare   = snd_ftssp_pcm_prepare,
+	.trigger   = snd_ftssp_pcm_trigger,
+	.pointer   = snd_ftssp_pcm_pointer,
+};
+
+/* ALSA PCM constructor */
+static int snd_ftssp_new_pcm(ftssp_chip *chip)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	/* PCM device #0 with 1 playback and 1 capture */
+	if ((err = snd_pcm_new(chip->card, "ftssp_pcm", 0, 1, 1, &pcm)) < 0)
+		return err;
+
+	pcm->private_data = chip;
+	strcpy(pcm->name, "ftssp_pcm device");
+	chip->pcm = pcm;
+
+	/* set operators for playback and capture*/
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+		&snd_ftssp_playback_ops);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+		&snd_ftssp_capture_ops);
+
+	/* Pre-allocate buffer, as suggested by ALSA driver document */
+	// todo: support playback/capture simultaneously
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+	&chip->pdev->dev, FTSSP_HW_DMA_SIZE, FTSSP_HW_DMA_SIZE);
+
+	/* Force half-duplex (on A320D, or AC97 mode) */
+	if (ac97)
+		pcm->info_flags |= SNDRV_PCM_INFO_HALF_DUPLEX;
+
+	return 0;
+}
+
+#if (FTSSP_PROC_FS)
+static void snd_ftssp_buf_max_read(struct snd_info_entry *entry,
+	struct snd_info_buffer *buffer)
+{
+	snd_iprintf(buffer, "%d\n", snd_ftssp_pcm_hw.buffer_bytes_max);
+}
+
+static void snd_ftssp_buf_max_write(struct snd_info_entry *entry,
+	struct snd_info_buffer *buffer)
+{
+	char tmp[128];
+	char *ptr_e;
+	u32 val;
+
+	if (buffer->size == 0)
+		return;
+
+	memset(tmp, 0, 128);
+	snd_info_get_str(tmp, buffer->buffer, 127);
+
+	val = simple_strtoul(tmp, &ptr_e, 10);
+	if (*ptr_e == 'k')
+		val *= 1024;
+	else if (*ptr_e == 'm')
+		val *= 1024 * 1024;
+
+	if (ac97) {
+		if (val > AC97_HW_BUFFER_BYTES_MAX)
+			val = AC97_HW_BUFFER_BYTES_MAX;
+	} else {
+		if (val > I2S_HW_BUFFER_BYTES_MAX)
+			val = I2S_HW_BUFFER_BYTES_MAX;
+	}
+
+	snd_ftssp_pcm_hw.buffer_bytes_max = (size_t)val;
+}
+
+static void snd_ftssp_period_min_read(struct snd_info_entry *entry,
+	struct snd_info_buffer *buffer)
+{
+	snd_iprintf(buffer, "%d\n", snd_ftssp_pcm_hw.period_bytes_min);
+}
+
+static void snd_ftssp_period_min_write(struct snd_info_entry *entry,
+	struct snd_info_buffer *buffer)
+{
+	char tmp[128];
+	char *ptr_e;
+	u32 val;
+
+	if (buffer->size == 0)
+		return;
+
+	memset(tmp, 0, 128);
+	snd_info_get_str(tmp, buffer->buffer, 127);
+
+	val = simple_strtoul(tmp, &ptr_e, 10);
+	if (*ptr_e == 'k')
+		val *= 1024;
+	else if (*ptr_e == 'm')
+		val *= 1024 * 1024;
+
+	snd_ftssp_pcm_hw.period_bytes_min = (size_t)val;
+
+	if ((val * snd_ftssp_pcm_hw.periods_max) >
+	    snd_ftssp_pcm_hw.buffer_bytes_max) {
+		INFO("\nWarning: period_bytes(%d) * periods(%d) exceeds "
+			"hw_buffer_size(%d).\n",
+			snd_ftssp_pcm_hw.period_bytes_min,
+			snd_ftssp_pcm_hw.periods_max,
+			snd_ftssp_pcm_hw.buffer_bytes_max);
+		INFO("         Unexpected access violation may occur!\n");
+	}
+}
+
+static void snd_ftssp_period_max_read(struct snd_info_entry *entry,
+	struct snd_info_buffer *buffer)
+{
+	snd_iprintf(buffer, "%d\n", snd_ftssp_pcm_hw.period_bytes_max);
+}
+
+static void snd_ftssp_period_max_write(struct snd_info_entry *entry,
+	struct snd_info_buffer *buffer)
+{
+	char tmp[128];
+	char *ptr_e;
+	u32 val;
+
+	if (buffer->size == 0)
+		return;
+
+	memset(tmp, 0, 128);
+	snd_info_get_str(tmp, buffer->buffer, 127);
+
+	val = simple_strtoul(tmp, &ptr_e, 10);
+	if (*ptr_e == 'k')
+		val *= 1024;
+	else if (*ptr_e == 'm')
+		val *= 1024 * 1024;
+
+	snd_ftssp_pcm_hw.period_bytes_max = (size_t)val;
+
+	if ((val * snd_ftssp_pcm_hw.periods_max) >
+	    snd_ftssp_pcm_hw.buffer_bytes_max) {
+		INFO("\nWarning: period_bytes(%d) * periods(%d) exceeds "
+			"hw_buffer_size(%d).\n",
+			snd_ftssp_pcm_hw.period_bytes_max,
+			snd_ftssp_pcm_hw.periods_max,
+			snd_ftssp_pcm_hw.buffer_bytes_max);
+		INFO("         Unexpected access violation may occur!\n");
+	}
+}
+
+static void snd_ftssp_periods_min_read(struct snd_info_entry *entry,
+	struct snd_info_buffer *buffer)
+{
+	snd_iprintf(buffer, "%d\n", snd_ftssp_pcm_hw.periods_min);
+}
+
+static void snd_ftssp_periods_min_write(struct snd_info_entry *entry,
+	struct snd_info_buffer *buffer)
+{
+	char tmp[128];
+	char *ptr_e;
+	u32 val;
+
+	if (buffer->size == 0)
+		return;
+
+	memset(tmp, 0, 128);
+	snd_info_get_str(tmp, buffer->buffer, 127);
+
+	val = simple_strtoul(tmp, &ptr_e, 10);
+	if (*ptr_e == 'k')
+		val *= 1024;
+	else if (*ptr_e == 'm')
+		val *= 1024 * 1024;
+
+	snd_ftssp_pcm_hw.periods_min = (size_t)val;
+
+	if ((val * snd_ftssp_pcm_hw.period_bytes_max) >
+	    snd_ftssp_pcm_hw.buffer_bytes_max) {
+		INFO("\nWarning: period_bytes(%d) * periods(%d) exceeds "
+			"hw_buffer_size(%d).\n",
+			snd_ftssp_pcm_hw.period_bytes_max,
+			snd_ftssp_pcm_hw.periods_min,
+			snd_ftssp_pcm_hw.buffer_bytes_max);
+		INFO("         Unexpected access violation may occur!\n");
+	}
+}
+
+static void snd_ftssp_periods_max_read(struct snd_info_entry *entry,
+	struct snd_info_buffer *buffer)
+{
+	snd_iprintf(buffer, "%d\n", snd_ftssp_pcm_hw.periods_max);
+}
+
+static void snd_ftssp_periods_max_write(struct snd_info_entry *entry,
+	struct snd_info_buffer *buffer)
+{
+	char tmp[128];
+	char *ptr_e;
+	u32 val;
+
+	if (buffer->size == 0)
+		return;
+
+	memset(tmp, 0, 128);
+	snd_info_get_str(tmp, buffer->buffer, 127);
+
+	val = simple_strtoul(tmp, &ptr_e, 10);
+	if (*ptr_e == 'k')
+		val *= 1024;
+	else if (*ptr_e == 'm')
+		val *= 1024 * 1024;
+
+	snd_ftssp_pcm_hw.periods_max = (size_t)val;
+
+	if ((val * snd_ftssp_pcm_hw.period_bytes_max) >
+	    snd_ftssp_pcm_hw.buffer_bytes_max) {
+		INFO("\nWarning: period_bytes(%d) * periods(%d) exceeds "
+			"hw_buffer_size(%d).\n",
+			snd_ftssp_pcm_hw.period_bytes_max,
+			snd_ftssp_pcm_hw.periods_max,
+			snd_ftssp_pcm_hw.buffer_bytes_max);
+		INFO("         Unexpected access violation may occur!\n");
+	}
+}
+#endif  //FTSSP_PROC_FS
+
+static inline void ftssp_ac97_init(void)
+{
+	/* Change codec-dependent callbacks to AC97 */
+	ftssp010_substreams[0].pmu_set_clocking = pmu_set_ac97_clocking;
+	ftssp010_substreams[0].hw_config        = ftssp010_config_ac97_play;
+	ftssp010_substreams[1].pmu_set_clocking = pmu_set_ac97_clocking;
+	ftssp010_substreams[1].hw_config        = ftssp010_config_ac97_rec;
+
+	snd_ftssp_playback_ops.copy_user = snd_ftssp_playback_copy;
+	snd_ftssp_playback_ops.copy_kernel = snd_ftssp_playback_copy;
+	snd_ftssp_capture_ops.copy_user  = snd_ftssp_capture_copy;
+	snd_ftssp_capture_ops.copy_kernel  = snd_ftssp_capture_copy;
+
+	snd_ftssp_pcm_hw.rates    		= AC97_CODEC_SAMPLE_RATES;
+	snd_ftssp_pcm_hw.rate_min 		= AC97_CODEC_SAMPLE_RATE_MIN;
+	snd_ftssp_pcm_hw.rate_max 		= AC97_CODEC_SAMPLE_RATE_MAX;
+	snd_ftssp_pcm_hw.formats		= AC97_CODEC_FORMATS;
+	snd_ftssp_pcm_hw.buffer_bytes_max	= AC97_HW_BUFFER_BYTES_MAX;
+	snd_ftssp_pcm_hw.period_bytes_min	= AC97_HW_PERIOD_BYTES_MIN;
+	snd_ftssp_pcm_hw.period_bytes_max	= AC97_HW_PERIOD_BYTES_MAX;
+	snd_ftssp_pcm_hw.periods_min		= AC97_HW_PERIODS_MIN;
+	snd_ftssp_pcm_hw.periods_max		= AC97_HW_PERIODS_MAX;
+}
+
+static int ftssp_alsa_init(struct platform_device *pdev)
+{
+	ftssp_chip *chip;
+	int err;
+
+	if(init_hw(cardno, ac97, NULL))
+		return -EIO;
+
+	if (ac97)
+		ftssp_ac97_init();
+
+	DBG("%s: FTSSP010 #%d (Physical Addr=0x%08X), mode: %s\n",
+		__func__,
+		cardno, SSP_FTSSP010_pa_base[cardno],
+		ac97 ? "ac97" : "i2s");
+
+	err = snd_card_new(&pdev->dev, SNDRV_DEFAULT_IDX1, FTSSP_CARD_ID,
+			THIS_MODULE, sizeof(ftssp_chip), &ftssp_cards[cardno]);
+
+	if (err < 0)
+		return err;
+
+	if (ac97) {
+		sprintf(ftssp_cards[cardno]->driver, FTSSP_DRIVER_NAME);
+		sprintf(ftssp_cards[cardno]->shortname,
+			FTSSP_DRIVER_NAME "_ac97");
+		sprintf(ftssp_cards[cardno]->longname,
+			FTSSP_DRIVER_NAME "_ac97 controller");
+	} else {
+		sprintf(ftssp_cards[cardno]->driver, FTSSP_DRIVER_NAME);
+		sprintf(ftssp_cards[cardno]->shortname,
+			FTSSP_DRIVER_NAME "_i2s");
+		sprintf(ftssp_cards[cardno]->longname,
+			FTSSP_DRIVER_NAME "_i2s controller");
+	}
+
+	// PCM
+	chip = (ftssp_chip *)(ftssp_cards[cardno]->private_data);
+	chip->pdev = pdev;
+	chip->card = ftssp_cards[cardno];
+
+	if ((err = snd_ftssp_new_pcm(chip))) {
+		ERR("%s, Can't new PCM devices\n",__func__);
+		return -ENODEV;
+	}
+
+#if (FTSSP_PROC_FS)
+	// new a proc entries subordinate to card->proc_root for debugging
+	// /proc/card#/buf_max
+	snd_card_proc_new(chip->card, "buf_max", &chip->info_buf_max);
+	if (chip->info_buf_max) {
+		chip->info_buf_max->c.text.read = snd_ftssp_buf_max_read;
+		chip->info_buf_max->c.text.write = snd_ftssp_buf_max_write;
+	}
+	// /proc/card#/period_min
+	snd_card_proc_new(chip->card, "period_size_min",
+		&chip->info_period_min);
+	if (chip->info_period_min) {
+		chip->info_period_min->c.text.read = snd_ftssp_period_min_read;
+		chip->info_period_min->c.text.write =
+			snd_ftssp_period_min_write;
+	}
+	// /proc/card#/period_max
+	snd_card_proc_new(chip->card, "period_size_max",
+		&chip->info_period_max);
+	if (chip->info_period_max) {
+		chip->info_period_max->c.text.read = snd_ftssp_period_max_read;
+		chip->info_period_max->c.text.write =
+			snd_ftssp_period_max_write;
+	}
+	// /proc/card#/periods_min
+	snd_card_proc_new(chip->card, "periods_min", &chip->info_periods_min);
+	if (chip->info_periods_min) {
+		chip->info_periods_min->c.text.read =
+			snd_ftssp_periods_min_read;
+		chip->info_periods_min->c.text.write =
+			snd_ftssp_periods_min_write;
+	}
+	// /proc/card#/periods_max
+	snd_card_proc_new(chip->card, "periods_max", &chip->info_periods_max);
+	if (chip->info_periods_max) {
+		chip->info_periods_max->c.text.read =
+			snd_ftssp_periods_max_read;
+		chip->info_periods_max->c.text.write =
+			snd_ftssp_periods_max_write;
+	}
+#endif
+
+	// Register the card to ALSA
+	if ((err = snd_card_register(chip->card)) == 0) {
+		INFO("%s card registered!\n", FTSSP_CARD_ID);
+	}
+	return err;
+}
+
+static int ftssp_alsa_i2c_i2s_exit(void)
+{
+	DBG("%s, cleaning up\n",__func__);
+
+	#ifndef CONFIG_SND_FTSSP010_AC97
+		i2c_del_driver(&alc5630_driver);
+	#endif
+
+	dmad_channel_free(&dma_chreq_tx);
+	dmad_channel_free(&dma_chreq_rx);
+	snd_card_free(ftssp_cards[cardno]);
+
+	return 0;
+}
+
+static int atf_ac97_probe(struct platform_device *pdev)
+{
+	struct resource *r, *mem = NULL;
+	size_t mem_size;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ssp2_pbase = r->start;
+	mem_size = resource_size(r);
+	mem = request_mem_region(r->start, mem_size, pdev->name);
+	ssp2_vbase = (resource_size_t) ioremap(mem->start, mem_size);
+
+	return ftssp_alsa_init(pdev);
+}
+
+static int atf_ac97_remove(struct platform_device *pdev)
+{
+	return ftssp_alsa_i2c_i2s_exit();
+}
+
+static const struct of_device_id atf_ac97_of_match[] = {
+	{ .compatible = "andestech,atfac97", },
+	{},
+};
+
+static struct platform_driver atf_ac97_driver = {
+	.driver = {
+		.name = "atfssp",
+		.owner = THIS_MODULE,
+		.of_match_table = atf_ac97_of_match,
+	},
+	.probe = atf_ac97_probe,
+	.remove = atf_ac97_remove,
+};
+module_platform_driver(atf_ac97_driver);
diff --git a/sound/v5/FTSSP010_UDA1345TS.h b/sound/v5/FTSSP010_UDA1345TS.h
new file mode 100644
index 00000000..cc80c362
--- /dev/null
+++ b/sound/v5/FTSSP010_UDA1345TS.h
@@ -0,0 +1,86 @@
+/* FTSSP010 - UDA1345TS supporting library header */
+/*
+ *
+ *      $log$
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+
+/* Programming sequence:
+ *	Suppose your playback format is 44.1KHz, 16 bit stereo
+ *	PIO mode:
+ *		pmu_set_i2s_clocking(44100);
+ *		ftssp010_config(1, 44100, 0);
+ *		ftssp010_start_tx(0);
+ *		while(ftssp010_tx_fifo_not_full()) {
+ *			Poke_your_PCM_data_to_FTSSP_data_port
+ *
+ *	DMA mode:
+ *		pmu_set_i2s_clocking(44100);
+ *		ftssp010_config(1, 44100);
+ *		<setup DMA controller, acquire DMA channel>
+ *		pmu_set_i2s_dma_channel(ch);
+ *		ftssp010_start_tx(1);
+ *		<wait DMA to complete..>
+ *		ftssp010_stop_tx();
+ */
+
+extern  resource_size_t	ssp2_pbase;
+extern  resource_size_t	ssp2_vbase;
+
+#define SSP_FTSSP010_COUNT	1
+#define PMU_BASE			(pmu_base)
+#define FTSSP010_DATA(x)		(ssp2_vbase+0x18)
+#define FTSSP010_DATA_PA(x)		(ssp2_pbase+0x18)
+
+/* Initialize FTSSP010 to output to UDA1345TS via I2S */
+#define FTSSP010_CONTROL0(x)		(ssp2_vbase+0x0)
+#define FTSSP010_CONTROL0_OPM_STEREO	0xC
+#define FTSSP010_CONTROL0_OPM_MONO	0x8
+
+#define FTSSP010_CONTROL1(x)		(ssp2_vbase+0x4)
+#define FTSSP010_CONTROL2(x)		(ssp2_vbase+0x8)
+
+#define FTSSP010_INT_CONTROL(x)		(ssp2_vbase+0x10)
+#define FTSSP010_STATUS(x)		(ssp2_vbase+0xC)
+#define FTSSP010_INT_STATUS(x)		(ssp2_vbase+0x14)
+#define FTSSP010_DATA(x)		(ssp2_vbase+0x18)
+#define FTSSP010_INFO(x)		(ssp2_vbase+0x1C)
+#define FTSSP010_ACLINK_SLOT_VALID(x)	(ssp2_vbase+0x20)
+#define FTSSP010_ACLINK_CMD(x)		(ssp2_vbase+0x28)
+#define FTSSP010_ACLINK_CMD_DATA(x)	(ssp2_vbase+0x2c)
+
+
+/* Drive PMU to generate I2S main clocking signal. Also configures PMU to set correct DMA REQ/ACK pair */
+extern void pmu_set_i2s_clocking(unsigned int speed);
+/* Programs PMU to set I2S/AC97 DMA Channel, ch=0-7 */
+extern void pmu_set_i2s_dma_channel(unsigned ch);
+
+/* Drive PMU to generate AC97 main clocking signal. Also configures PMU to set correct DMA REQ/ACK pair */
+extern void pmu_set_ac97_clocking(unsigned int speed);
+
+/* Returns FTSSP010 status */
+extern void ftssp010_set_int_control(int cardno, unsigned val);
+extern int ftssp010_get_status(int cardno);
+extern unsigned ftssp010_get_int_status(int cardno);
+/* Polls FIFO full register */
+extern int  ftssp010_tx_fifo_not_full(int cardno);
+/* Configure FTSSP010 to a given sampling rate and channel number */
+extern void ftssp010_config_tx(int cardno, unsigned is_stereo, unsigned speed, int use8bit);
+extern void ftssp010_config_rx(int cardno, unsigned is_stereo, unsigned speed, int use8bit);
+
+/* Configure FTSSP010 to a given sampling rate and channel number */
+extern void ftssp010_config_ac97_play(int cardno, unsigned is_stereo, unsigned speed, int use8bit);
+
+extern void ftssp010_config_ac97_rec(int cardno, unsigned is_stereo, unsigned speed, int use8bit);
+
+/* Initialize FTSSP010 to output to UDA1345TS via I2S */
+extern void ftssp010_start_tx(int cardno, unsigned use_dma);
+extern void ftssp010_start_rx(int cardno, unsigned use_dma);
+extern void ftssp010_stop_tx(int cardno);
+extern void ftssp010_stop_rx(int cardno);
+
diff --git a/sound/v5/FTSSP010_W83972D.h b/sound/v5/FTSSP010_W83972D.h
new file mode 100644
index 00000000..ed72b919
--- /dev/null
+++ b/sound/v5/FTSSP010_W83972D.h
@@ -0,0 +1,17 @@
+/* AC97 Codec related */
+
+
+/* Register Index for Winbond W83972D AC97 Codec */
+#define W83972D_RESET			0x0
+#define W83972D_STEREO_OUTPUT_CONTROL	0x2
+#define W83972D_MIC_VOLUME		0xE
+#define W83972D_LINE_IN_VOLUME		0x10
+#define W83972D_AUX_INPUT_CONTROL	0x16
+#define W83972D_PCM_OUTPUT_CONTROL	0x18
+#define W83972D_RECORD_SELECT		0x1A
+#define W83972D_RECORD_GAIN		0x1C
+#define W83972D_RECORD_GAIN_MIC		0x1E
+#define W83972D_EXT_AUDIO_CONTROL	0x2A
+#define W83972D_DAC_SAMPLE_RATE_CONTROL	0x2C
+#define W83972D_VER1			0x7C
+#define W83972D_VER2			0x7E
diff --git a/sound/v5/FTSSP010_lib.c b/sound/v5/FTSSP010_lib.c
new file mode 100644
index 00000000..12dbc712
--- /dev/null
+++ b/sound/v5/FTSSP010_lib.c
@@ -0,0 +1,538 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 Andes Technology Corporation
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <asm/dmad.h>
+#include <linux/dma-mapping.h>
+#include "FTSSP010_UDA1345TS.h"
+
+/* control0 register */
+#define NACK		0x40000000
+/* control2 register value */
+#define SSP_ACCRST                  0x20    /* AC-Link Cold Reset Enable */
+#define SSP_ACWRST                  0x10    /* AC-Link Warm Reset Enable */
+#define SSP_TXFCLR                  0x8     /* TX FIFO Clear */
+#define SSP_RXFCLR                  0x4     /* RX FIFO Clear */
+#define SSP_TXDOE                   0x2     /* TX Data Output Enable */
+#define SSP_SSPEN                   0x1     /* SSP Enable */
+#define SSP_TFVE                    0x1f000 /* TX FIFO Valid Entries */
+#define SSP_RFVE                    0x1f0   /* RX FIFO Valid Entries */
+#define SSP_FIFO_THOD               0xc400
+/* status register */
+#define WBUSY			    0x08000000
+#define ACTXDATA		    0x01000000
+#define SSP_BUSY                    0x4
+
+resource_size_t	ssp2_vbase;
+resource_size_t	ssp2_pbase;
+
+#ifdef CONFIG_PLAT_AG101P
+#define PMU_PDLLCR1		(pmu_base+0x34)
+#define PMU_MFPSR		(pmu_base+0x28)
+#define PMU_I2SAC97_REQACKCFG	(pmu_base+0xbc)
+#define PMU_C4			(pmu_base+0xc4)
+#endif
+#define SSPCLK_TO_SCLKDIV(sspclk_div2,bps)	((sspclk_div2)/(bps)-1)
+
+// Each client has this additional data
+struct alc5630_data {
+	struct i2c_client *client;
+	struct delayed_work     work;
+	unsigned long gpio2_value;
+	struct mutex mtx;
+};
+
+static int i2s_alc5630_read(unsigned int raddr, char *data, struct i2c_client *client)
+{
+#ifndef CONFIG_SND_FTSSP010_AC97
+	struct i2c_adapter *adap =  client->adapter;
+	int ret;
+#endif
+	struct i2c_msg msg;
+	int i2c_value;
+
+	//Reading ALC5630 register
+	msg.addr = raddr;
+	msg.flags = (client->flags & I2C_M_TEN) | I2C_M_RD;
+	msg.len = 1;
+	msg.buf = (char *)data;
+
+	//ret = i2c_transfer(adap, &msg, 1);
+#ifndef CONFIG_SND_FTSSP010_AC97
+	ret = i2c_transfer(adap, &msg, 1);
+	if (ret != 0) {
+		printk("i2c read failed\n");
+		return -1;
+	}
+	else
+#endif
+	{
+		i2c_value = (data[0]&0xff) << 8 | (data[1]&0xff);
+		return i2c_value;
+	}
+}
+
+static void i2s_alc5630_write(unsigned int raddr, unsigned int data, struct i2c_client *client)
+{
+#ifndef CONFIG_SND_FTSSP010_AC97
+	struct i2c_adapter *adap =  client->adapter;
+	int ret;
+#endif
+	struct i2c_msg msg;
+	char buf[3];
+	//Writing ALC5630 register
+	msg.addr = raddr;
+	msg.flags = (client->flags & I2C_M_TEN) | ~I2C_M_RD;
+	msg.len = 1;
+	buf[0] = (data >> 8) & 0xff;
+	buf[1] =  data & 0xff;
+	msg.buf = (char *)buf;
+	//ret = i2c_transfer(adap, &msg, 1);
+#ifndef CONFIG_SND_FTSSP010_AC97
+	ret = i2c_transfer(adap, &msg, 1);
+	if (ret != 0)
+	{
+		printk("i2c write failed\n");
+	}
+#endif
+}
+
+static void i2s_al5630_slave_stereo_mode(struct i2c_client *client)
+{
+	i2s_alc5630_write(0x34, 0x8000, client); // codec slave mode
+	i2s_alc5630_write(0x0c, 0x1010, client);
+	i2s_alc5630_write(0x10, 0xee03, client);
+	i2s_alc5630_write(0x1c, 0x0748, client);
+	i2s_alc5630_write(0x62, 0x0000, client);
+}
+
+//End ADD by river 2011.01.26
+
+
+/* Drive PMU to generate I2S main clocking signal. Also configures PMU to set correct DMA REQ/ACK pair */
+void pmu_set_i2s_clocking(unsigned int speed)
+{
+	unsigned int pmu_pdllcr1; /* PLL/DLL Control Register 1 */
+	/* Configure PMU to generate I2S main clock */
+	#ifdef CONFIG_PLAT_AG101
+	pmu_pdllcr1 = inl(PMU_PDLLCR1)&0xfff0ffff; /* Bit 19-16 are relevent */
+	#endif
+
+	switch (speed) {
+	case 8000:
+		pmu_pdllcr1 |= 0x00000000; /* 2.048MHz x2 */
+		break;
+	case 11025:
+		pmu_pdllcr1 |= 0x00010000; /* 2.8224MHz x2 */
+		break;
+	case 16000:
+		pmu_pdllcr1 |= 0x00020000; /* 4.096MHz x2 */
+		break;
+	case 22050:
+		pmu_pdllcr1 |= 0x00030000; /* 5.6448MHz x2 */
+		break;
+	case 32000:
+		pmu_pdllcr1 |= 0x00040000; /* 8.192MHz x2 */
+		break;
+	case 44100:
+		pmu_pdllcr1 |= 0x00050000; /* 11.2896Mhz x2 */
+		break;
+	case 48000:
+		pmu_pdllcr1 |= 0x00060000; /* 12.2880MHz x2 */
+		break;
+	default:
+		printk("%s: Unknown i2s speed %d\n",__func__,speed);
+	};
+
+	#ifdef CONFIG_PLAT_AG101
+	outl(pmu_pdllcr1, PMU_PDLLCR1);
+	/* Configure PMU to select I2S output (instead of AC97) */
+	outl(inl(PMU_MFPSR)&(~(1<<3)), PMU_MFPSR); /* clear bit 3 of MFPSR*/
+	#endif
+}
+
+/* Drive PMU to generate AC97 main clocking signal. Also configures PMU to set correct DMA REQ/ACK pair */
+void pmu_set_ac97_clocking(unsigned int speed)
+{
+	/* do nothing here */
+}
+
+/* Programs PMU to set I2S/AC97 DMA Channel, ch=0-7 */
+void pmu_set_i2s_dma_channel(unsigned ch)
+{
+	#ifdef CONFIG_PLAT_AG101
+	ch&=0x7;
+	//outl((inl(PMU_I2SAC97_REQACKCFG)&(~0x7))|ch, PMU_I2SAC97_REQACKCFG);
+	outl(0xa, PMU_I2SAC97_REQACKCFG);
+	outl(0xb, PMU_C4);
+	#endif
+}
+
+static struct i2c_client *g_i2c_client;
+void ftssp010_set_int_control(int cardno, unsigned val)
+{
+	outl(val, FTSSP010_INT_CONTROL(cardno));
+}
+
+unsigned ftssp010_get_int_status(int cardno)
+{
+	return (inl(FTSSP010_INT_STATUS(cardno)));
+}
+
+int ftssp010_get_status(int cardno)
+{
+	return (inl(FTSSP010_STATUS(cardno)));
+}
+
+int  ftssp010_tx_fifo_not_full(int cardno)
+{
+	return (inl(FTSSP010_STATUS(cardno))&0x2)==0x2;
+}
+
+int ftssp010_tx_fifo_vaild_entries(int cardno)
+{
+	return (inl(FTSSP010_STATUS(cardno))>>12) & 0x1f;
+}
+
+#include "FTSSP010_W83972D.h"
+
+// AC97 codec tags
+#define TAG_COMMAND	0xe000
+#define TAG_DATA	0x9800 /* Slot 3/4 */
+#define TAG_DATA_MONO	0x9000 /* Slot 3 */
+//#define TAG_DATA_LINE_IN	0x9000	/* Slot 3 */
+
+void ftssp010_ac97_write_codec(unsigned int reg,unsigned int data)
+{
+	int cnt = 0x1000000;
+
+	while((inl(FTSSP010_STATUS(0))&ACTXDATA) && cnt--);
+	if(!cnt)
+		printk("wait transfer buffer timeout\n");
+
+	outl(0x0,  FTSSP010_INT_CONTROL(0));/*Disable interrupts & DMA req */
+	outl(inl(FTSSP010_CONTROL2(0)) | (SSP_TXFCLR|SSP_RXFCLR), FTSSP010_CONTROL2(0));
+	outl(TAG_COMMAND, FTSSP010_ACLINK_SLOT_VALID(0));
+	outl(((reg<<16)|data), FTSSP010_ACLINK_CMD(0));
+	outl(inl(FTSSP010_CONTROL2(0)) | (SSP_SSPEN|SSP_TXDOE), FTSSP010_CONTROL2(0));
+	cnt = 0x1000000;
+	while((inl(FTSSP010_STATUS(0))&WBUSY) && cnt--);
+	if(!cnt)
+		printk("write ac97 timeout\n");
+	outl(inl(FTSSP010_CONTROL2(0)) & (~(SSP_SSPEN|SSP_TXDOE)), FTSSP010_CONTROL2(0));
+}
+
+/*	Configure FTSSP010 to a given sampling rate and channel number
+ *	for AC97 mode in playback mode
+ */
+int init_hw(unsigned int cardno,unsigned int ac97, struct i2c_client *client)
+{
+	int cnt = 0x1000000;
+	g_i2c_client = client;
+
+	if(ac97)
+	{
+		// Clear FFMT
+		outl(inl(FTSSP010_CONTROL0(cardno))&0xfff, FTSSP010_CONTROL0(cardno));
+		// AC_link
+		outl(inl(FTSSP010_CONTROL0(cardno))|0x4000, FTSSP010_CONTROL0(cardno));
+
+		outl(0xc400,  FTSSP010_INT_CONTROL(cardno));
+		if((inl(FTSSP010_INT_CONTROL(cardno)))!=0xc400){
+			return -EIO;
+		}
+		outl(0x20, FTSSP010_CONTROL2(cardno));  /* Cold Reset AC-Link */
+		while(inl(FTSSP010_CONTROL2(cardno))&&cnt--);
+		if(!cnt){
+			return -EIO;
+		}
+	}
+	else
+	{
+		#ifdef CONFIG_PLAT_AG101
+		outl(inl(PMU_MFPSR)&(~(1<<3)), PMU_MFPSR); /* clear bit 3 of MFPSR*/
+		outl(0xa, PMU_I2SAC97_REQACKCFG);
+		outl(0xb, PMU_C4);
+		#endif
+
+		i2s_al5630_slave_stereo_mode(client);
+		outl(0x311c, FTSSP010_CONTROL0(cardno));	/* I2S Master */
+		outl(0, FTSSP010_CONTROL1(cardno));	        /* I2S Master */
+		outl(0xc400, FTSSP010_INT_CONTROL(cardno));	/* I2S Master */
+		outl(0x40, FTSSP010_CONTROL2(cardno));  	/* Reset AC-Link */
+	}
+	return 0;
+}
+static void _ftssp010_config_ac97(int cardno, unsigned is_stereo, unsigned speed, int is_rec)
+{
+	int cnt = 0x1000000;
+	/* Codec initialization */
+	outl(inl(FTSSP010_CONTROL0(cardno))|NACK, FTSSP010_CONTROL0(cardno));
+	ftssp010_ac97_write_codec(W83972D_RESET, 0);
+
+	if (is_rec) {	/* Recording */
+		/* Mute output */
+		//ftssp010_ac97_write_codec(W83972D_STEREO_OUTPUT_CONTROL, 0x8000);
+		/* Mute PCM */
+		//ftssp010_ac97_write_codec(W83972D_PCM_OUTPUT_CONTROL, 0x8000);
+
+		/* Register 0x10, Line-In/Mic Gain */
+		ftssp010_ac97_write_codec(W83972D_LINE_IN_VOLUME, 0x808);
+		//ftssp010_ac97_write_codec(W83972D_AUX_INPUT_CONTROL, 0x808);
+		ftssp010_ac97_write_codec(W83972D_MIC_VOLUME, 0x8);
+		/* FIXME: REC from line-in only */
+
+		/* Register 0x1A, Record Select=StereoMix */
+		ftssp010_ac97_write_codec(W83972D_RECORD_SELECT, 0x505 /*404*/);
+		/* Register 0x1C, Record Gain=0db */
+		ftssp010_ac97_write_codec(W83972D_RECORD_GAIN, 0x808);
+		ftssp010_ac97_write_codec(W83972D_RECORD_GAIN_MIC, 0x8);
+	} else {	/* Playback */
+		/* Register 0x10, Mute Line-In/Mic Gain */
+		ftssp010_ac97_write_codec(W83972D_LINE_IN_VOLUME, 0x8000);
+		ftssp010_ac97_write_codec(W83972D_MIC_VOLUME, 0x8000);
+
+		/* Register 0x1A, Mute Record Gains */
+		ftssp010_ac97_write_codec(W83972D_RECORD_GAIN, 0x8000);
+		ftssp010_ac97_write_codec(W83972D_RECORD_GAIN_MIC, 0x8000);
+
+		/* Output */
+		ftssp010_ac97_write_codec(W83972D_STEREO_OUTPUT_CONTROL, 0);
+		ftssp010_ac97_write_codec(W83972D_PCM_OUTPUT_CONTROL, 0x808);
+	}
+
+#if 1
+	ftssp010_ac97_write_codec(W83972D_EXT_AUDIO_CONTROL, 0x1);
+	ftssp010_ac97_write_codec(W83972D_DAC_SAMPLE_RATE_CONTROL, speed);
+#endif
+
+	outl(inl(FTSSP010_CONTROL0(cardno))&~NACK, FTSSP010_CONTROL0(cardno));
+
+	/* Start data transfer */
+//	if(is_rec) {
+//		outl(TAG_DATA_LINE_IN, FTSSP010_ACLINK_SLOT_VALID(cardno));
+//	} else {
+		if(is_stereo)
+			outl(TAG_DATA, FTSSP010_ACLINK_SLOT_VALID(cardno));
+		else
+			outl(TAG_DATA_MONO, FTSSP010_ACLINK_SLOT_VALID(cardno));
+//	}
+	while((inl(FTSSP010_INT_STATUS(cardno))&0x3)&&cnt--);
+}
+
+void ftssp010_config_ac97_play(int cardno, unsigned is_stereo, unsigned speed, int use8bit)
+{
+	_ftssp010_config_ac97(cardno, is_stereo, speed, 0);
+}
+
+void ftssp010_config_ac97_rec(int cardno, unsigned is_stereo, unsigned speed, int use8bit)
+{
+	_ftssp010_config_ac97(cardno, is_stereo, speed, 1);
+}
+
+/*
+ *	Configure FTSSP010 to a given sampling rate and channel number
+ *	for I2S mode
+ */
+void ftssp010_config(int cardno, unsigned is_stereo, unsigned speed, int width, int is_rec)
+{
+	int use8bit = (width == 1 ? 1 : 0);
+	unsigned opm, bps = 2 * (use8bit ? 8 : 16);	/* bits per 1 second audio data. */
+	unsigned fpclkdiv = 0;
+
+	struct alc5630_data *alc5630;
+	char data[3];
+	opm = is_stereo ? FTSSP010_CONTROL0_OPM_STEREO : FTSSP010_CONTROL0_OPM_MONO;
+	outl(0x3100 | opm, FTSSP010_CONTROL0(cardno));	/* I2S Master */
+
+	/* configures CONTROL1 to use suitable clock divider.
+	the I2S clock is generated from PMU. */
+	bps *= speed;
+	switch(speed) {
+	case 8000:	/* SCLK : 256KHZ */
+		i2s_alc5630_write(0x44, 0x3ea0, g_i2c_client);
+		i2s_alc5630_write(0x60, 0x3174, g_i2c_client);
+		i2s_alc5630_write(0x62, 0x1010, g_i2c_client);
+		fpclkdiv = 0xBB;
+		break;
+	case 11025:	/* SCLK : 352.8KHZ */
+		i2s_alc5630_write(0x44, 0x3ea0, g_i2c_client);
+		i2s_alc5630_write(0x60, 0x3174, g_i2c_client);
+		i2s_alc5630_write(0x62, 0x1010, g_i2c_client);
+		fpclkdiv = 0x88;
+		break;
+	case 16000:	/* SCLK : 512KHZ */
+		i2s_alc5630_write(0x44, 0x3ea0, g_i2c_client);
+		i2s_alc5630_write(0x60, 0x3174, g_i2c_client);
+		i2s_alc5630_write(0x62, 0x1010, g_i2c_client);
+		fpclkdiv = 0x5f;
+		break;
+	case 22050:	/* SCLK : 705.6KHZ */
+		i2s_alc5630_write(0x44, 0x3ea0, g_i2c_client);
+		i2s_alc5630_write(0x60, 0x3174, g_i2c_client);
+		i2s_alc5630_write(0x62, 0x1010, g_i2c_client);
+		fpclkdiv = 0x45;
+		break;
+	case 24000:	/* SCLK : 768KHZ */
+		i2s_alc5630_write(0x44, 0x3ea0, g_i2c_client);
+		i2s_alc5630_write(0x60, 0x3174, g_i2c_client);
+		i2s_alc5630_write(0x62, 0x1010, g_i2c_client);
+		fpclkdiv = 0x3e;
+		break;
+	case 32000:	/* SCLK : 1024KHZ */
+		i2s_alc5630_write(0x44, 0x3ea0, g_i2c_client);
+		i2s_alc5630_write(0x60, 0x3174, g_i2c_client);
+		i2s_alc5630_write(0x62, 0x1010, g_i2c_client);
+		fpclkdiv = 0x2f;
+		break;
+	case 44100:	/* SCLK : 1.4112 MHZ */ /* 96 MHZ */
+		i2s_alc5630_write(0x44, 0x3ea0, g_i2c_client);
+		i2s_alc5630_write(0x60, 0x3174, g_i2c_client);
+		i2s_alc5630_write(0x62, 0x1010, g_i2c_client);
+		fpclkdiv = 0x22;
+		break;
+	case 48000: /* SCLK : 1.536 MHZ */
+		i2s_alc5630_write(0x44, 0x3ea0, g_i2c_client);
+		i2s_alc5630_write(0x60, 0x3174, g_i2c_client);
+		i2s_alc5630_write(0x62, 0x1010, g_i2c_client);
+		fpclkdiv = 0x1f;
+		break;
+	default:
+		printk("%s: unsupported speed %d\n", __func__,speed);
+		return;
+	};
+
+	if(!use8bit) {
+		outl(0xf0000|fpclkdiv, FTSSP010_CONTROL1(cardno));	/*  16bits */
+	} else {
+		outl(0x70000|fpclkdiv, FTSSP010_CONTROL1(cardno));	/*  8bits */
+	}
+
+	if(is_rec)
+		outl(inl(FTSSP010_INT_CONTROL(cardno))&(~0x0f15),  FTSSP010_INT_CONTROL(cardno));		/* Disable all interrupts */
+	else
+		outl(inl(FTSSP010_INT_CONTROL(cardno))&(~0xf02a) ,  FTSSP010_INT_CONTROL(cardno));		/* Disable all interrupts */
+
+	outl(0xc, FTSSP010_CONTROL2(cardno));	/* clear FIFOs */
+	alc5630 = i2c_get_clientdata(g_i2c_client);
+
+	if(is_rec) {
+		printk("ftssp010_config() for I2S mode in record.\n");
+		i2s_alc5630_write(0x0e, 0x0808, g_i2c_client);
+		i2s_alc5630_write(0x10, 0xee03, g_i2c_client);
+		i2s_alc5630_write(0x22, 0x0500, g_i2c_client);
+		i2s_alc5630_write(0x1c, 0x0748, g_i2c_client);
+		i2s_alc5630_write(0x14, 0x1f1f, g_i2c_client);
+		i2s_alc5630_write(0x12, 0xdfdf, g_i2c_client);
+		i2s_alc5630_write(0x26, 0x000f, g_i2c_client);
+		i2s_alc5630_write(0x3a, 0xffff, g_i2c_client);
+		i2s_alc5630_write(0x3c, 0xffff, g_i2c_client);
+		i2s_alc5630_write(0x3e, 0x80cf, g_i2c_client);
+		i2s_alc5630_write(0x44, 0x3ea0, g_i2c_client);
+		i2s_alc5630_write(0x42, 0x2000, g_i2c_client);
+		i2s_alc5630_write(0x40, 0x8c0a, g_i2c_client);
+		i2s_alc5630_write(0x02, 0x8080, g_i2c_client);
+		i2s_alc5630_write(0x04, 0x0000, g_i2c_client);
+    }
+    else {
+		i2s_alc5630_write(0x0e, 0x0808, g_i2c_client);
+		i2s_alc5630_write(0x12, 0xcbcb, g_i2c_client);
+		i2s_alc5630_write(0x14, 0x7f7f, g_i2c_client);
+		i2s_alc5630_write(0x22, 0x0000, g_i2c_client);
+		i2s_alc5630_write(0x3e, 0x8000, g_i2c_client);
+		i2s_alc5630_write(0x40, 0x0c0a, g_i2c_client);
+		i2s_alc5630_write(0x42, 0x0000, g_i2c_client);
+		i2s_alc5630_write(0x26, 0x0000, g_i2c_client);
+		i2s_alc5630_write(0x3c, 0x2000, g_i2c_client);
+		i2s_alc5630_write(0x3a, 0x0002, g_i2c_client);
+		i2s_alc5630_write(0x3c, 0xa330, g_i2c_client);
+		i2s_alc5630_write(0x3a, 0xc843, g_i2c_client);
+		i2s_alc5630_write(0x3A, i2s_alc5630_read(0x3A, data,g_i2c_client)|0x0002 , g_i2c_client);
+		i2s_alc5630_write(0x04, i2s_alc5630_read(0x04, data,g_i2c_client)|0x8080 , g_i2c_client);
+		i2s_alc5630_write(0x3A, i2s_alc5630_read(0x3A, data,g_i2c_client)|0x0040 , g_i2c_client);
+		i2s_alc5630_write(0x3c, i2s_alc5630_read(0x3C, data,g_i2c_client)|0x2000 , g_i2c_client);
+		i2s_alc5630_write(0x3E, i2s_alc5630_read(0x3E, data,g_i2c_client)|0xfC00 , g_i2c_client);
+		i2s_alc5630_write(0x5E, i2s_alc5630_read(0x5E, data,g_i2c_client)|0x0100 , g_i2c_client);
+		i2s_alc5630_write(0x3A, i2s_alc5630_read(0x3A, data,g_i2c_client)|0x0200 , g_i2c_client);
+		i2s_alc5630_write(0x3A, i2s_alc5630_read(0x3A, data,g_i2c_client)|0x0100 , g_i2c_client);
+		i2s_alc5630_write(0x5E, i2s_alc5630_read(0x5E, data,g_i2c_client)& 0xfeff ,g_i2c_client);
+		i2s_alc5630_write(0x1c, 0x0748, g_i2c_client);
+		i2s_alc5630_write(0x26, 0x000f, g_i2c_client);
+
+		if (alc5630->gpio2_value==0x0)
+		    i2s_alc5630_write(0x3A, (i2s_alc5630_read(0x3A, data,g_i2c_client) & 0xFBFF)|0x0040 , g_i2c_client);
+		else
+			i2s_alc5630_write(0x3A, i2s_alc5630_read(0x3A, data,g_i2c_client)|0x0440 , g_i2c_client);
+
+		i2s_alc5630_write(0x5E, i2s_alc5630_read(0x5E, data,g_i2c_client)|0x0020 , g_i2c_client);
+		i2s_alc5630_write(0x5E, i2s_alc5630_read(0x5E, data,g_i2c_client)|0x00c0 , g_i2c_client);
+		i2s_alc5630_write(0x04, i2s_alc5630_read(0x04, data,g_i2c_client)& 0x7f7f , g_i2c_client);
+		if (alc5630->gpio2_value==0x0) {
+			i2s_alc5630_write(0x02, 0x5F5F, g_i2c_client);
+	    }
+		else  {
+			i2s_alc5630_write(0x02, 0x0000, g_i2c_client);
+	    }
+    }
+}
+
+void ftssp010_config_tx(int cardno, unsigned is_stereo, unsigned speed, int width)
+{
+	return ftssp010_config(cardno, is_stereo, speed, width, 0);
+}
+
+void ftssp010_config_rx(int cardno, unsigned is_stereo, unsigned speed, int width)
+{
+	return ftssp010_config(cardno, is_stereo, speed, width, 1);
+}
+
+/* Configures FTSSP010 to start TX. If use_dma being nonzero,
+ * FTSSP010 will use hardware handshake for DMA */
+void ftssp010_start_tx(int cardno, unsigned use_dma)
+{
+	unsigned bogus=0x800*3;
+	if(use_dma) {
+		/* Enable H/W DMA Request and set TX DMA threshold to 12*/
+                outl(inl(FTSSP010_INT_CONTROL(cardno)) | 0xc422, FTSSP010_INT_CONTROL(cardno));
+	}
+        outl(inl(FTSSP010_CONTROL2(cardno)) | (SSP_SSPEN|SSP_TXDOE), FTSSP010_CONTROL2(cardno));
+	if(!use_dma) {
+		while(bogus>0) {
+			while(!ftssp010_tx_fifo_not_full(cardno))
+				udelay(50);
+			outl(0, FTSSP010_DATA(cardno));
+			bogus--;
+		}
+	}
+}
+
+/* Configures FTSSP010 to start RX. If use_dma being nonzero,
+ * FTSSP010 will use hardware handshake for DMA */
+void ftssp010_start_rx(int cardno, unsigned use_dma)
+{
+        if(use_dma) {
+                /* Enable H/W DMA Request and set RX DMA threshold to 2*/
+                outl(inl(FTSSP010_INT_CONTROL(cardno)) | 0xc411, FTSSP010_INT_CONTROL(cardno));
+        }
+        outl(inl(FTSSP010_CONTROL2(cardno)) | 0x3, FTSSP010_CONTROL2(cardno));
+
+}
+
+void ftssp010_stop_tx(int cardno)
+{
+	outl(inl(FTSSP010_INT_CONTROL(cardno)) & (~0x22), FTSSP010_INT_CONTROL(cardno));
+	outl(inl(FTSSP010_CONTROL2(0)) & (~(SSP_SSPEN|SSP_TXDOE)), FTSSP010_CONTROL2(0));
+}
+
+void ftssp010_stop_rx(int cardno)
+{
+	outl(inl(FTSSP010_INT_CONTROL(cardno)) & (~0x11), FTSSP010_INT_CONTROL(cardno));
+}
+
diff --git a/sound/v5/Kconfig b/sound/v5/Kconfig
new file mode 100644
index 00000000..d5353b99
--- /dev/null
+++ b/sound/v5/Kconfig
@@ -0,0 +1,22 @@
+menu "ALSA RISCV devices"
+	depends on SND!=n && RISCV
+
+config SND_FTSSP010
+	tristate "Faraday FTSSP010 audio Driver"
+	depends on SND && RISCV
+	select SND_PCM
+#	select SND_AC97_CODEC
+
+choice
+	prompt "AC97/I2S/HDA selection"
+	depends on SND_FTSSP010
+	default SND_FTSSP010_AC97
+config SND_FTSSP010_AC97
+	bool "AC97"
+config SND_FTSSP010_I2S
+	bool "I2S"
+config SND_FTSSP010_HDA
+	bool "HDA"
+endchoice
+endmenu
+
diff --git a/sound/v5/Makefile b/sound/v5/Makefile
new file mode 100644
index 00000000..716a62f7
--- /dev/null
+++ b/sound/v5/Makefile
@@ -0,0 +1,10 @@
+ifeq ($(CONFIG_SND_FTSSP010_AC97),y)
+snd-ftssp010-objs := FTSSP010_ALSA.o FTSSP010_lib.o
+endif
+ifeq ($(CONFIG_SND_FTSSP010_I2S),y)
+snd-ftssp010-objs := FTSSP010_ALSA.o FTSSP010_lib.o
+endif
+ifeq ($(CONFIG_SND_FTSSP010_HDA),y)
+snd-ftssp010-objs := FTSSP010_HDA.o FTSSP010_HDA_lib.o
+endif
+obj-$(CONFIG_SND_FTSSP010) += snd-ftssp010.o
diff --git a/tools/accounting/.gitignore b/tools/accounting/.gitignore
deleted file mode 100644
index 86485203..00000000
--- a/tools/accounting/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-getdelays
diff --git a/tools/build/.gitignore b/tools/build/.gitignore
deleted file mode 100644
index a776371a..00000000
--- a/tools/build/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-fixdep
diff --git a/tools/build/feature/.gitignore b/tools/build/feature/.gitignore
deleted file mode 100644
index 09b335b9..00000000
--- a/tools/build/feature/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-*.d
-*.bin
-*.output
diff --git a/tools/cgroup/.gitignore b/tools/cgroup/.gitignore
deleted file mode 100644
index 633cd9b8..00000000
--- a/tools/cgroup/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-cgroup_event_listener
diff --git a/tools/gpio/.gitignore b/tools/gpio/.gitignore
deleted file mode 100644
index 9e9dd4b6..00000000
--- a/tools/gpio/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-gpio-event-mon
-gpio-hammer
-lsgpio
-
diff --git a/tools/include/asm/barrier.h b/tools/include/asm/barrier.h
index 391d9425..b47814a0 100644
--- a/tools/include/asm/barrier.h
+++ b/tools/include/asm/barrier.h
@@ -23,6 +23,8 @@
 #include "../../arch/ia64/include/asm/barrier.h"
 #elif defined(__xtensa__)
 #include "../../arch/xtensa/include/asm/barrier.h"
+#elif defined(__riscv__)
+#include "../../arch/riscv/include/asm/barrier.h"
 #else
 #include <asm-generic/barrier.h>
 #endif
diff --git a/tools/include/uapi/linux/perf_event.h b/tools/include/uapi/linux/perf_event.h
index b8e288a1..5012ecac 100644
--- a/tools/include/uapi/linux/perf_event.h
+++ b/tools/include/uapi/linux/perf_event.h
@@ -337,6 +337,7 @@ struct perf_event_attr {
 				exclude_user   :  1, /* don't count user      */
 				exclude_kernel :  1, /* ditto kernel          */
 				exclude_hv     :  1, /* ditto hypervisor      */
+				exclude_machine :  1, /* ditto machine      */
 				exclude_idle   :  1, /* don't count when idle */
 				mmap           :  1, /* include mmap data     */
 				comm	       :  1, /* include comm data     */
@@ -370,7 +371,7 @@ struct perf_event_attr {
 				context_switch :  1, /* context switch data */
 				write_backward :  1, /* Write ring buffer from end to beginning */
 				namespaces     :  1, /* include namespaces data */
-				__reserved_1   : 35;
+				__reserved_1   : 34;
 
 	union {
 		__u32		wakeup_events;	  /* wakeup every n events */
diff --git a/tools/laptop/dslm/.gitignore b/tools/laptop/dslm/.gitignore
deleted file mode 100644
index 9fc984e6..00000000
--- a/tools/laptop/dslm/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-dslm
diff --git a/tools/leds/.gitignore b/tools/leds/.gitignore
deleted file mode 100644
index ac96d9f5..00000000
--- a/tools/leds/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-uledmon
diff --git a/tools/lib/bpf/.gitignore b/tools/lib/bpf/.gitignore
deleted file mode 100644
index f81e549d..00000000
--- a/tools/lib/bpf/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-libbpf_version.h
-FEATURE-DUMP.libbpf
diff --git a/tools/lib/lockdep/.gitignore b/tools/lib/lockdep/.gitignore
deleted file mode 100644
index cc0e7a9f..00000000
--- a/tools/lib/lockdep/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-liblockdep.so.*
diff --git a/tools/lib/traceevent/.gitignore b/tools/lib/traceevent/.gitignore
deleted file mode 100644
index 9e9f25fb..00000000
--- a/tools/lib/traceevent/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-TRACEEVENT-CFLAGS
-libtraceevent-dynamic-list
-libtraceevent.so.*
diff --git a/tools/objtool/.gitignore b/tools/objtool/.gitignore
deleted file mode 100644
index 914cff12..00000000
--- a/tools/objtool/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-arch/x86/lib/inat-tables.c
-objtool
-fixdep
diff --git a/tools/pcmcia/.gitignore b/tools/pcmcia/.gitignore
deleted file mode 100644
index 53d08133..00000000
--- a/tools/pcmcia/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-crc32hash
diff --git a/tools/perf/.gitignore b/tools/perf/.gitignore
deleted file mode 100644
index 3e5135dd..00000000
--- a/tools/perf/.gitignore
+++ /dev/null
@@ -1,36 +0,0 @@
-PERF-CFLAGS
-PERF-GUI-VARS
-PERF-VERSION-FILE
-FEATURE-DUMP
-perf
-perf-read-vdso32
-perf-read-vdsox32
-perf-help
-perf-record
-perf-report
-perf-stat
-perf-top
-perf*.1
-perf*.xml
-perf*.html
-common-cmds.h
-perf.data
-perf.data.old
-output.svg
-perf-archive
-perf-with-kcore
-tags
-TAGS
-cscope*
-config.mak
-config.mak.autogen
-*-bison.*
-*-flex.*
-*.pyc
-*.pyo
-.config-detected
-util/intel-pt-decoder/inat-tables.c
-arch/*/include/generated/
-trace/beauty/generated/
-pmu-events/pmu-events.c
-pmu-events/jevents
diff --git a/tools/perf/arch/riscv/Build b/tools/perf/arch/riscv/Build
new file mode 100644
index 00000000..54afe4a4
--- /dev/null
+++ b/tools/perf/arch/riscv/Build
@@ -0,0 +1 @@
+libperf-y += util/
diff --git a/tools/perf/arch/riscv/util/Build b/tools/perf/arch/riscv/util/Build
new file mode 100644
index 00000000..ca623bbf
--- /dev/null
+++ b/tools/perf/arch/riscv/util/Build
@@ -0,0 +1 @@
+libperf-y += header.o
diff --git a/tools/perf/arch/riscv/util/header.c b/tools/perf/arch/riscv/util/header.c
new file mode 100644
index 00000000..09c93791
--- /dev/null
+++ b/tools/perf/arch/riscv/util/header.c
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2005-2017 Andes Technology Corporation
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <api/fs/fs.h>
+#include "header.h"
+
+#define STR_LEN 1024
+#define COMPATIBLE_STR "/sys/devices/platform/pmu/of_node/compatible"
+
+char *get_cpuid_str(struct perf_pmu *pmu)
+{
+	char *buf = NULL, *ret = NULL, *tmp=NULL, *saveptr = NULL;
+	const char *delim = ",";
+	const char *sysfs = sysfs__mountpoint();
+	FILE *compatible;
+
+	if (!sysfs || !pmu || !pmu->cpus)
+		return NULL;
+
+	buf = malloc(STR_LEN);
+	ret = malloc(STR_LEN);
+	if (!buf || !ret)
+		return NULL;
+
+	compatible = fopen(COMPATIBLE_STR, "r");
+	if (!compatible) {
+		printf("Open pmu file failed:%s\n", __FILE__);
+		return NULL;
+	}
+
+	if (fgets(buf, STR_LEN, compatible) == NULL){
+		printf("Read pmu file failed:%s\n", __FILE__);
+		return NULL;
+	}
+	tmp = strtok_r(buf, delim, &saveptr);
+	tmp = strtok_r(NULL, delim, &saveptr);
+	strcpy(ret, tmp);
+	free(buf);
+	fclose(compatible);
+	return ret;
+}
diff --git a/tools/perf/pmu-events/arch/riscv/AX25/l2c.json b/tools/perf/pmu-events/arch/riscv/AX25/l2c.json
new file mode 100644
index 00000000..678ce454
--- /dev/null
+++ b/tools/perf/pmu-events/arch/riscv/AX25/l2c.json
@@ -0,0 +1,122 @@
+[
+	{
+        "EventCode": "0xff00",
+        "EventName": "total_cn_access",
+        "BriefDescription": "Core N total access count"
+        },
+	{
+        "EventCode": "0xff03",
+        "EventName": "cn_trans_snoop",
+        "BriefDescription": "Core N transmit snoop data count"
+        },
+        {
+        "EventCode": "0xff04",
+        "EventName": "cn_recv_snoop",
+        "BriefDescription": "Core N receive snoop data count"
+        },
+	{
+        "EventCode": "0xff40",
+        "EventName": "total_m4_access",
+        "BriefDescription": "Master 4 total access count"
+        },
+        {
+        "EventCode": "0xff41",
+        "EventName": "l2c_m4_access",
+        "BriefDescription": "Master 4 L2 cache access count"
+        },
+        {
+        "EventCode": "0xff42",
+        "EventName": "l2c_m4_miss",
+        "BriefDescription": "Master 4 L2 cache miss count"
+        },
+        {
+        "EventCode": "0xff44",
+        "EventName": "m4_recv_snoop",
+        "BriefDescription": "Master 4 receive snoop data count"
+        },
+        {
+        "EventCode": "0xff50",
+        "EventName": "sys_bus_access",
+        "BriefDescription": "System bus access count"
+        },
+        {
+        "EventCode": "0xff70",
+        "EventName": "l2_way_0_eviction_count",
+        "BriefDescription": "L2 way 0 eviction count"
+        },
+        {
+        "EventCode": "0xff71",
+        "EventName": "l2_way_1_eviction_count",
+        "BriefDescription": "L2 way 1 eviction count"
+        },
+        {
+        "EventCode": "0xff72",
+        "EventName": "l2_way_2_eviction_count",
+        "BriefDescription": "L2 way 2 eviction count"
+        },
+        {
+        "EventCode": "0xff73",
+        "EventName": "l2_way_3_eviction_count",
+        "BriefDescription": "L2 way 3 eviction count"
+        },
+	{
+        "EventCode": "0xff74",
+        "EventName": "l2_way_4_eviction_count",
+        "BriefDescription": "L2 way 4 eviction count"
+        },
+        {
+        "EventCode": "0xff75",
+        "EventName": "l2_way_5_eviction_count",
+        "BriefDescription": "L2 way 5 eviction count"
+        },
+        {
+        "EventCode": "0xff76",
+        "EventName": "l2_way_6_eviction_count",
+        "BriefDescription": "L2 way 6 eviction count"
+        },
+        {
+        "EventCode": "0xff77",
+        "EventName": "l2_way_7_eviction_count",
+        "BriefDescription": "L2 way 7 eviction count"
+        },
+        {
+        "EventCode": "0xff78",
+        "EventName": "l2_way_8_eviction_count",
+        "BriefDescription": "L2 way 8 eviction count"
+        },
+        {
+        "EventCode": "0xff79",
+        "EventName": "l2_way_9_eviction_count",
+        "BriefDescription": "L2 way 9 eviction count"
+        },
+        {
+        "EventCode": "0xff7a",
+        "EventName": "l2_way_10_eviction_count",
+        "BriefDescription": "L2 way 10 eviction count"
+        },
+        {
+        "EventCode": "0xff7b",
+        "EventName": "l2_way_11_eviction_count",
+        "BriefDescription": "L2 way 11 eviction count"
+        },
+        {
+        "EventCode": "0xff7c",
+        "EventName": "l2_way_12_eviction_count",
+        "BriefDescription": "L2 way 12 eviction count"
+        },
+        {
+        "EventCode": "0xff7d",
+        "EventName": "l2_way_13_eviction_count",
+        "BriefDescription": "L2 way 13 eviction count"
+        },
+	{
+        "EventCode": "0xff7e",
+        "EventName": "l2_way_14_eviction_count",
+        "BriefDescription": "L2 way 14 eviction count"
+        },
+        {
+        "EventCode": "0xff7f",
+        "EventName": "l2_way_15_eviction_count",
+        "BriefDescription": "L2 way 15 eviction count"
+        },
+]
diff --git a/tools/perf/pmu-events/arch/riscv/AX25/riscvstd.json b/tools/perf/pmu-events/arch/riscv/AX25/riscvstd.json
new file mode 100644
index 00000000..56e3e57b
--- /dev/null
+++ b/tools/perf/pmu-events/arch/riscv/AX25/riscvstd.json
@@ -0,0 +1,252 @@
+[
+	{
+	"EventCode": "0x10",
+	"EventName": "cycle_count",
+	"BriefDescription": "Cycle counts"
+	},
+	{
+	"EventCode": "0x20",
+	"EventName": "inst_count",
+	"BriefDescription": "Retired instruction counts"
+	},
+	{
+	"EventCode": "0x30",
+	"EventName": "int_load_inst",
+	"BriefDescription": "Integer load instructions"
+	},
+	{
+	"EventCode": "0x40",
+	"EventName": "int_store_inst",
+	"BriefDescription": "Integer store instructions"
+	},
+	{
+	"EventCode": "0x50",
+	"EventName": "atomic_mem_op",
+	"BriefDescription": "Atomic memory operation"
+	},
+	{
+	"EventCode": "0x60",
+	"EventName": "sys_inst",
+	"BriefDescription": "System instructions"
+	},
+	{
+	"EventCode": "0x70",
+	"EventName": "int_compute_inst",
+	"BriefDescription": "Integer computational instruction"
+	},
+	{
+	"EventCode": "0x80",
+	"EventName": "condition_br",
+	"BriefDescription": "Conditional branch"
+	},
+	{
+	"EventCode": "0x90",
+	"EventName": "taken_condition_br",
+	"BriefDescription": "Taken conditional branch"
+	},
+	{
+	"EventCode": "0xA0",
+	"EventName": "jal_inst",
+	"BriefDescription": "JAL instruction"
+	},
+	{
+	"EventCode": "0xB0",
+	"EventName": "jalr_inst",
+	"BriefDescription": "JALR instruction"
+	},
+	{
+	"EventCode": "0xC0",
+	"EventName": "ret_inst",
+	"BriefDescription": "Return instruction"
+	},
+	{
+	"EventCode": "0xD0",
+	"EventName": "control_trans_inst",
+	"BriefDescription": "Control transfer instruction"
+	},
+	{
+	"EventCode": "0xE0",
+	"EventName": "ex9_inst",
+	"BriefDescription": "EX9 instruction"
+	},
+	{
+	"EventCode": "0xF0",
+	"EventName": "int_mul_inst",
+	"BriefDescription": "Integer multiplication instruction"
+	},
+	{
+	"EventCode": "0x100",
+	"EventName": "int_div_rem_inst",
+	"BriefDescription": "Integer division/remainder instruction"
+	},
+	{
+	"EventCode": "0x110",
+	"EventName": "float_load_inst",
+	"BriefDescription": "Floating-point load instruction"
+	},
+	{
+	"EventCode": "0x120",
+	"EventName": "float_store_inst",
+	"BriefDescription": "Floating-point store instruction"
+	},
+	{
+	"EventCode": "0x130",
+	"EventName": "float_add_sub_inst",
+	"BriefDescription": "Floating-point addition/subtraction"
+	},
+	{
+	"EventCode": "0x140",
+	"EventName": "float_mul_inst",
+	"BriefDescription": "Floating-point multiplication"
+	},
+	{
+	"EventCode": "0x150",
+	"EventName": "float_fused_muladd_inst",
+	"BriefDescription": "Floating-point fused multiply-add"
+	},
+	{
+	"EventCode": "0x160",
+	"EventName": "float_div_sqrt_inst",
+	"BriefDescription": "Floating-point division or square-root"
+	},
+	{
+	"EventCode": "0x170",
+	"EventName": "other_float_inst",
+	"BriefDescription": "Other floating-point instruction"
+	},
+	{
+	"EventCode": "0x01",
+	"EventName": "ilm_access",
+	"BriefDescription": "ILM access"
+	},
+	{
+	"EventCode": "0x11",
+	"EventName": "dlm_access",
+	"BriefDescription": "DLM access"
+	},
+	{
+	"EventCode": "0x21",
+	"EventName": "icache_access",
+	"BriefDescription": "ICACHE access"
+	},
+	{
+	"EventCode": "0x31",
+	"EventName": "icache_miss",
+	"BriefDescription": "ICACHE miss"
+	},
+	{
+	"EventCode": "0x41",
+	"EventName": "dcache_access",
+	"BriefDescription": "DCACHE access"
+	},
+	{
+	"EventCode": "0x51",
+	"EventName": "dcache_miss",
+	"BriefDescription": "DCACHE miss"
+	},
+	{
+	"EventCode": "0x61",
+	"EventName": "dcache_load_access",
+	"BriefDescription": "DCACHE load access"
+	},
+	{
+	"EventCode": "0x71",
+	"EventName": "dcache_load_miss",
+	"BriefDescription": "DCACHE load miss"
+	},
+	{
+	"EventCode": "0x81",
+	"EventName": "dcache_store_access",
+	"BriefDescription": "DCACHE store access"
+	},
+	{
+	"EventCode": "0x91",
+	"EventName": "dcache_store_miss",
+	"BriefDescription": "DCACHE store miss"
+	},
+	{
+	"EventCode": "0xA1",
+	"EventName": "dcache_wb",
+	"BriefDescription": "DCACHE writeback"
+	},
+	{
+	"EventCode": "0xB1",
+	"EventName": "cycle_wait_icache_fill",
+	"BriefDescription": "Cycles waiting for ICACHE fill data"
+	},
+	{
+	"EventCode": "0xC1",
+	"EventName": "cycle_wait_dcache_fill",
+	"BriefDescription": "Cycles waiting for DCACHE fill data"
+	},
+	{
+	"EventCode": "0xD1",
+	"EventName": "uncached_ifetch_from_bus",
+	"BriefDescription": "Uncached ifetch data access from bus"
+	},
+	{
+	"EventCode": "0xE1",
+	"EventName": "uncached_load_from_bus",
+	"BriefDescription": "Uncached load data access from bus"
+	},
+	{
+	"EventCode": "0xF1",
+	"EventName": "cycle_wait_uncached_ifetch",
+	"BriefDescription": "Cycles waiting for uncached ifetch data from bus"
+	},
+	{
+	"EventCode": "0x101",
+	"EventName": "cycle_wait_uncached_load",
+	"BriefDescription": "Cycles waiting for uncached load data from bus"
+	},
+	{
+	"EventCode": "0x111",
+	"EventName": "main_itlb_access",
+	"BriefDescription": "Main ITLB access"
+	},
+	{
+	"EventCode": "0x121",
+	"EventName": "main_itlb_miss",
+	"BriefDescription": "Main ITLB miss"
+	},
+	{
+	"EventCode": "0x131",
+	"EventName": "main_dtlb_access",
+	"BriefDescription": "Main DTLB access"
+	},
+	{
+	"EventCode": "0x141",
+	"EventName": "main_dtlb_miss",
+	"BriefDescription": "Main DTLB miss"
+	},
+	{
+	"EventCode": "0x151",
+	"EventName": "cycle_wait_itlb_fill",
+	"BriefDescription": "Cycles waiting for Main ITLB fill data"
+	},
+	{
+	"EventCode": "0x161",
+	"EventName": "pipe_stall_cycle_dtlb_miss",
+	"BriefDescription": "Pipeline stall cycles caused by Main DTLB miss"
+	},
+	{
+	"EventCode": "0x02",
+	"EventName": "mispredict_condition_br",
+	"BriefDescription": "Misprediction of conditional branches"
+	},
+	{
+	"EventCode": "0x12",
+	"EventName": "mispredict_take_condition_br",
+	"BriefDescription": "Misprediction of taken conditional branches"
+	},
+	{
+	"EventCode": "0x22",
+	"EventName": "mispredict_target_ret_inst",
+	"BriefDescription": "Misprediction of targets of Return instructions"
+	},
+	{
+	"EventCode": "0x32",
+	"EventName": "replay_las_sas",
+	"BriefDescription": "Replay for load-after-store or store-after-store cases"
+	},
+]
diff --git a/tools/perf/pmu-events/arch/riscv/mapfile.csv b/tools/perf/pmu-events/arch/riscv/mapfile.csv
new file mode 100644
index 00000000..019f479c
--- /dev/null
+++ b/tools/perf/pmu-events/arch/riscv/mapfile.csv
@@ -0,0 +1,15 @@
+# Format:
+#	MIDR,Version,JSON/file/pathname,Type
+#
+# where
+#	MIDR	Processor version
+#		Variant[23:20] and Revision [3:0] should be zero.
+#	Version could be used to track version of of JSON file
+#		but currently unused.
+#	JSON/file/pathname is the path to JSON file, relative
+#		to tools/perf/pmu-events/arch/arm64/.
+#	Type is core, uncore etc
+#
+#
+#Family-model,Version,Filename,EventType
+andes-pmu,v5,AX25,core
diff --git a/tools/perf/tests/.gitignore b/tools/perf/tests/.gitignore
deleted file mode 100644
index 8cc30e73..00000000
--- a/tools/perf/tests/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-llvm-src-base.c
-llvm-src-kbuild.c
-llvm-src-prologue.c
-llvm-src-relocation.c
diff --git a/tools/perf/util/parse-events.c b/tools/perf/util/parse-events.c
index 2fc4ee8b..2bc14be3 100644
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@ -1494,6 +1494,7 @@ struct event_modifier {
 	int eu;
 	int ek;
 	int eh;
+	int em;
 	int eH;
 	int eG;
 	int eI;
@@ -1511,6 +1512,7 @@ static int get_event_modifier(struct event_modifier *mod, char *str,
 	int eu = evsel ? evsel->attr.exclude_user : 0;
 	int ek = evsel ? evsel->attr.exclude_kernel : 0;
 	int eh = evsel ? evsel->attr.exclude_hv : 0;
+	int em = evsel ? evsel->attr.exclude_machine : 0;
 	int eH = evsel ? evsel->attr.exclude_host : 0;
 	int eG = evsel ? evsel->attr.exclude_guest : 0;
 	int eI = evsel ? evsel->attr.exclude_idle : 0;
@@ -1519,7 +1521,7 @@ static int get_event_modifier(struct event_modifier *mod, char *str,
 	int sample_read = 0;
 	int pinned = evsel ? evsel->attr.pinned : 0;
 
-	int exclude = eu | ek | eh;
+	int exclude = eu | ek | eh | em;
 	int exclude_GH = evsel ? evsel->exclude_GH : 0;
 	int weak = 0;
 
@@ -1528,16 +1530,20 @@ static int get_event_modifier(struct event_modifier *mod, char *str,
 	while (*str) {
 		if (*str == 'u') {
 			if (!exclude)
-				exclude = eu = ek = eh = 1;
+				exclude = eu = ek = eh = em = 1;
 			eu = 0;
 		} else if (*str == 'k') {
 			if (!exclude)
-				exclude = eu = ek = eh = 1;
+				exclude = eu = ek = eh = em = 1;
 			ek = 0;
 		} else if (*str == 'h') {
 			if (!exclude)
-				exclude = eu = ek = eh = 1;
+				exclude = eu = ek = eh = em = 1;
 			eh = 0;
+		} else if (*str == 'm') {
+			if (!exclude)
+				exclude = eu = ek = eh = em = 1;
+			em = 0;
 		} else if (*str == 'G') {
 			if (!exclude_GH)
 				exclude_GH = eG = eH = 1;
@@ -1583,6 +1589,7 @@ static int get_event_modifier(struct event_modifier *mod, char *str,
 	mod->eu = eu;
 	mod->ek = ek;
 	mod->eh = eh;
+	mod->em = em;
 	mod->eH = eH;
 	mod->eG = eG;
 	mod->eI = eI;
@@ -1605,7 +1612,7 @@ static int check_modifier(char *str)
 	char *p = str;
 
 	/* The sizeof includes 0 byte as well. */
-	if (strlen(str) > (sizeof("ukhGHpppPSDIW") - 1))
+	if (strlen(str) > (sizeof("ukhmGHpppPSDIW") - 1))
 		return -1;
 
 	while (*p) {
@@ -1638,6 +1645,7 @@ int parse_events__modifier_event(struct list_head *list, char *str, bool add)
 		evsel->attr.exclude_user   = mod.eu;
 		evsel->attr.exclude_kernel = mod.ek;
 		evsel->attr.exclude_hv     = mod.eh;
+		evsel->attr.exclude_machine = mod.em;
 		evsel->attr.precise_ip     = mod.precise;
 		evsel->attr.exclude_host   = mod.eH;
 		evsel->attr.exclude_guest  = mod.eG;
diff --git a/tools/perf/util/parse-events.l b/tools/perf/util/parse-events.l
index a1a01b1a..7fe164f4 100644
--- a/tools/perf/util/parse-events.l
+++ b/tools/perf/util/parse-events.l
@@ -179,7 +179,7 @@ name		[a-zA-Z_*?\[\]][a-zA-Z0-9_*?.\[\]]*
 name_minus	[a-zA-Z_*?][a-zA-Z0-9\-_*?.:]*
 drv_cfg_term	[a-zA-Z0-9_\.]+(=[a-zA-Z0-9_*?\.:]+)?
 /* If you add a modifier you need to update check_modifier() */
-modifier_event	[ukhpPGHSDIW]+
+modifier_event	[ukhmpPGHSDIW]+
 modifier_bp	[rwx]{1,3}
 
 %%
diff --git a/tools/perf/util/symbol-elf.c b/tools/perf/util/symbol-elf.c
index 2de77051..3334bef1 100644
--- a/tools/perf/util/symbol-elf.c
+++ b/tools/perf/util/symbol-elf.c
@@ -43,7 +43,7 @@ static inline char *bfd_demangle(void __maybe_unused *v,
 #endif
 
 #ifndef HAVE_ELF_GETPHDRNUM_SUPPORT
-static int elf_getphdrnum(Elf *elf, size_t *dst)
+int elf_getphdrnum(Elf *elf, size_t *dst)
 {
 	GElf_Ehdr gehdr;
 	GElf_Ehdr *ehdr;
@@ -59,7 +59,7 @@ static int elf_getphdrnum(Elf *elf, size_t *dst)
 #endif
 
 #ifndef HAVE_ELF_GETSHDRSTRNDX_SUPPORT
-static int elf_getshdrstrndx(Elf *elf __maybe_unused, size_t *dst __maybe_unused)
+int elf_getshdrstrndx(Elf *elf __maybe_unused, size_t *dst __maybe_unused)
 {
 	pr_err("%s: update your libelf to > 0.140, this one lacks elf_getshdrstrndx().\n", __func__);
 	return -1;
diff --git a/tools/power/acpi/.gitignore b/tools/power/acpi/.gitignore
deleted file mode 100644
index cba3d994..00000000
--- a/tools/power/acpi/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-acpidbg
-acpidump
-ec
-include
diff --git a/tools/power/cpupower/.gitignore b/tools/power/cpupower/.gitignore
deleted file mode 100644
index 1f9977cc..00000000
--- a/tools/power/cpupower/.gitignore
+++ /dev/null
@@ -1,28 +0,0 @@
-.libs
-libcpupower.so
-libcpupower.so.*
-build/ccdv
-cpufreq-info
-cpufreq-set
-cpufreq-aperf
-lib/.libs
-lib/cpufreq.lo
-lib/cpufreq.o
-lib/proc.lo
-lib/proc.o
-lib/sysfs.lo
-lib/sysfs.o
-po/cpupowerutils.pot
-po/*.gmo
-utils/cpufreq-info.o
-utils/cpufreq-set.o
-utils/cpufreq-aperf.o
-cpupower
-bench/cpufreq-bench
-debug/kernel/Module.symvers
-debug/i386/centrino-decode
-debug/i386/dump_psb
-debug/i386/intel_gsic
-debug/i386/powernow-k8-decode
-debug/x86_64/centrino-decode
-debug/x86_64/powernow-k8-decode
diff --git a/tools/power/x86/turbostat/.gitignore b/tools/power/x86/turbostat/.gitignore
deleted file mode 100644
index 7521370d..00000000
--- a/tools/power/x86/turbostat/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-turbostat
diff --git a/tools/spi/.gitignore b/tools/spi/.gitignore
deleted file mode 100644
index 42805763..00000000
--- a/tools/spi/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-spidev_fdx
-spidev_test
diff --git a/tools/testing/radix-tree/.gitignore b/tools/testing/radix-tree/.gitignore
deleted file mode 100644
index d4706c0f..00000000
--- a/tools/testing/radix-tree/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-generated/map-shift.h
-idr.c
-idr-test
-main
-multiorder
-radix-tree.c
diff --git a/tools/testing/selftests/.gitignore b/tools/testing/selftests/.gitignore
deleted file mode 100644
index 91750352..00000000
--- a/tools/testing/selftests/.gitignore
+++ /dev/null
@@ -1,5 +0,0 @@
-kselftest
-gpiogpio-event-mon
-gpiogpio-hammer
-gpioinclude/
-gpiolsgpio
diff --git a/tools/testing/selftests/android/ion/.gitignore b/tools/testing/selftests/android/ion/.gitignore
deleted file mode 100644
index 95e8f456..00000000
--- a/tools/testing/selftests/android/ion/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-ionapp_export
-ionapp_import
-ionmap_test
diff --git a/tools/testing/selftests/bpf/.gitignore b/tools/testing/selftests/bpf/.gitignore
deleted file mode 100644
index 5e1ab2f0..00000000
--- a/tools/testing/selftests/bpf/.gitignore
+++ /dev/null
@@ -1,17 +0,0 @@
-test_verifier
-test_maps
-test_lru_map
-test_lpm_map
-test_tag
-FEATURE-DUMP.libbpf
-fixdep
-test_align
-test_dev_cgroup
-test_progs
-test_tcpbpf_user
-test_verifier_log
-feature
-test_libbpf_open
-test_sock
-test_sock_addr
-urandom_read
diff --git a/tools/testing/selftests/breakpoints/.gitignore b/tools/testing/selftests/breakpoints/.gitignore
deleted file mode 100644
index a23bb4a6..00000000
--- a/tools/testing/selftests/breakpoints/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-breakpoint_test
-step_after_suspend_test
diff --git a/tools/testing/selftests/capabilities/.gitignore b/tools/testing/selftests/capabilities/.gitignore
deleted file mode 100644
index b732dd0d..00000000
--- a/tools/testing/selftests/capabilities/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-test_execve
-validate_cap
diff --git a/tools/testing/selftests/efivarfs/.gitignore b/tools/testing/selftests/efivarfs/.gitignore
deleted file mode 100644
index 33618493..00000000
--- a/tools/testing/selftests/efivarfs/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-create-read
-open-unlink
diff --git a/tools/testing/selftests/exec/.gitignore b/tools/testing/selftests/exec/.gitignore
deleted file mode 100644
index 64073e05..00000000
--- a/tools/testing/selftests/exec/.gitignore
+++ /dev/null
@@ -1,9 +0,0 @@
-subdir*
-script*
-execveat
-execveat.symlink
-execveat.moved
-execveat.path.ephemeral
-execveat.ephemeral
-execveat.denatured
-xxxxxxxx*
\ No newline at end of file
diff --git a/tools/testing/selftests/filesystems/.gitignore b/tools/testing/selftests/filesystems/.gitignore
deleted file mode 100644
index 8449cf67..00000000
--- a/tools/testing/selftests/filesystems/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-dnotify_test
-devpts_pts
diff --git a/tools/testing/selftests/ftrace/.gitignore b/tools/testing/selftests/ftrace/.gitignore
deleted file mode 100644
index 98d8a5a6..00000000
--- a/tools/testing/selftests/ftrace/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-logs
diff --git a/tools/testing/selftests/futex/functional/.gitignore b/tools/testing/selftests/futex/functional/.gitignore
deleted file mode 100644
index a09f5706..00000000
--- a/tools/testing/selftests/futex/functional/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-futex_requeue_pi
-futex_requeue_pi_mismatched_ops
-futex_requeue_pi_signal_restart
-futex_wait_private_mapped_file
-futex_wait_timeout
-futex_wait_uninitialized_heap
-futex_wait_wouldblock
diff --git a/tools/testing/selftests/gpio/.gitignore b/tools/testing/selftests/gpio/.gitignore
deleted file mode 100644
index 7d14f743..00000000
--- a/tools/testing/selftests/gpio/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-gpio-mockup-chardev
diff --git a/tools/testing/selftests/ia64/.gitignore b/tools/testing/selftests/ia64/.gitignore
deleted file mode 100644
index ab806edc..00000000
--- a/tools/testing/selftests/ia64/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-aliasing-test
diff --git a/tools/testing/selftests/intel_pstate/.gitignore b/tools/testing/selftests/intel_pstate/.gitignore
deleted file mode 100644
index 3bfcbae5..00000000
--- a/tools/testing/selftests/intel_pstate/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-aperf
-msr
diff --git a/tools/testing/selftests/ipc/.gitignore b/tools/testing/selftests/ipc/.gitignore
deleted file mode 100644
index 9af04c93..00000000
--- a/tools/testing/selftests/ipc/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-msgque_test
-msgque
diff --git a/tools/testing/selftests/kcmp/.gitignore b/tools/testing/selftests/kcmp/.gitignore
deleted file mode 100644
index 5a9b3732..00000000
--- a/tools/testing/selftests/kcmp/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-kcmp_test
-kcmp-test-file
diff --git a/tools/testing/selftests/media_tests/.gitignore b/tools/testing/selftests/media_tests/.gitignore
deleted file mode 100644
index 8745eba3..00000000
--- a/tools/testing/selftests/media_tests/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-media_device_test
-media_device_open
-video_device_test
diff --git a/tools/testing/selftests/membarrier/.gitignore b/tools/testing/selftests/membarrier/.gitignore
deleted file mode 100644
index 020c44f4..00000000
--- a/tools/testing/selftests/membarrier/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-membarrier_test
diff --git a/tools/testing/selftests/memfd/.gitignore b/tools/testing/selftests/memfd/.gitignore
deleted file mode 100644
index afe87c40..00000000
--- a/tools/testing/selftests/memfd/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-fuse_mnt
-fuse_test
-memfd_test
-memfd-test-file
diff --git a/tools/testing/selftests/mount/.gitignore b/tools/testing/selftests/mount/.gitignore
deleted file mode 100644
index 856ad410..00000000
--- a/tools/testing/selftests/mount/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-unprivileged-remount-test
diff --git a/tools/testing/selftests/mqueue/.gitignore b/tools/testing/selftests/mqueue/.gitignore
deleted file mode 100644
index d8d42377..00000000
--- a/tools/testing/selftests/mqueue/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-mq_open_tests
-mq_perf_tests
diff --git a/tools/testing/selftests/net/.gitignore b/tools/testing/selftests/net/.gitignore
deleted file mode 100644
index c612d6e3..00000000
--- a/tools/testing/selftests/net/.gitignore
+++ /dev/null
@@ -1,9 +0,0 @@
-msg_zerocopy
-socket
-psock_fanout
-psock_tpacket
-reuseport_bpf
-reuseport_bpf_cpu
-reuseport_bpf_numa
-reuseport_dualstack
-reuseaddr_conflict
diff --git a/tools/testing/selftests/net/forwarding/.gitignore b/tools/testing/selftests/net/forwarding/.gitignore
deleted file mode 100644
index a793eef5..00000000
--- a/tools/testing/selftests/net/forwarding/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-forwarding.config
diff --git a/tools/testing/selftests/networking/timestamping/.gitignore b/tools/testing/selftests/networking/timestamping/.gitignore
deleted file mode 100644
index d9355035..00000000
--- a/tools/testing/selftests/networking/timestamping/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-timestamping
-rxtimestamp
-txtimestamp
-hwtstamp_config
diff --git a/tools/testing/selftests/nsfs/.gitignore b/tools/testing/selftests/nsfs/.gitignore
deleted file mode 100644
index 2ab2c824..00000000
--- a/tools/testing/selftests/nsfs/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-owner
-pidns
diff --git a/tools/testing/selftests/powerpc/alignment/.gitignore b/tools/testing/selftests/powerpc/alignment/.gitignore
deleted file mode 100644
index 1d980e3d..00000000
--- a/tools/testing/selftests/powerpc/alignment/.gitignore
+++ /dev/null
@@ -1,5 +0,0 @@
-copy_unaligned
-copy_first_unaligned
-paste_unaligned
-paste_last_unaligned
-copy_paste_unaligned_common
diff --git a/tools/testing/selftests/powerpc/benchmarks/.gitignore b/tools/testing/selftests/powerpc/benchmarks/.gitignore
deleted file mode 100644
index 9161679b..00000000
--- a/tools/testing/selftests/powerpc/benchmarks/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-gettimeofday
-context_switch
-fork
-exec_target
-mmap_bench
-futex_bench
-null_syscall
diff --git a/tools/testing/selftests/powerpc/cache_shape/.gitignore b/tools/testing/selftests/powerpc/cache_shape/.gitignore
deleted file mode 100644
index ec184843..00000000
--- a/tools/testing/selftests/powerpc/cache_shape/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-cache_shape
diff --git a/tools/testing/selftests/powerpc/context_switch/.gitignore b/tools/testing/selftests/powerpc/context_switch/.gitignore
deleted file mode 100644
index c1431af7..00000000
--- a/tools/testing/selftests/powerpc/context_switch/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-cp_abort
diff --git a/tools/testing/selftests/powerpc/copyloops/.gitignore b/tools/testing/selftests/powerpc/copyloops/.gitignore
deleted file mode 100644
index 25a192f6..00000000
--- a/tools/testing/selftests/powerpc/copyloops/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-copyuser_64
-copyuser_power7
-memcpy_64
-memcpy_power7
diff --git a/tools/testing/selftests/powerpc/dscr/.gitignore b/tools/testing/selftests/powerpc/dscr/.gitignore
deleted file mode 100644
index b585c6c1..00000000
--- a/tools/testing/selftests/powerpc/dscr/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-dscr_default_test
-dscr_explicit_test
-dscr_inherit_exec_test
-dscr_inherit_test
-dscr_sysfs_test
-dscr_sysfs_thread_test
-dscr_user_test
diff --git a/tools/testing/selftests/powerpc/math/.gitignore b/tools/testing/selftests/powerpc/math/.gitignore
deleted file mode 100644
index 50ded63e..00000000
--- a/tools/testing/selftests/powerpc/math/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-fpu_syscall
-vmx_syscall
-fpu_preempt
-vmx_preempt
-fpu_signal
-vmx_signal
-vsx_preempt
diff --git a/tools/testing/selftests/powerpc/mm/.gitignore b/tools/testing/selftests/powerpc/mm/.gitignore
deleted file mode 100644
index 7d7c42ed..00000000
--- a/tools/testing/selftests/powerpc/mm/.gitignore
+++ /dev/null
@@ -1,5 +0,0 @@
-hugetlb_vs_thp_test
-subpage_prot
-tempfile
-prot_sao
-segv_errors
\ No newline at end of file
diff --git a/tools/testing/selftests/powerpc/pmu/.gitignore b/tools/testing/selftests/powerpc/pmu/.gitignore
deleted file mode 100644
index e748f336..00000000
--- a/tools/testing/selftests/powerpc/pmu/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-count_instructions
-l3_bank_test
-per_event_excludes
diff --git a/tools/testing/selftests/powerpc/pmu/ebb/.gitignore b/tools/testing/selftests/powerpc/pmu/ebb/.gitignore
deleted file mode 100644
index 42bddbed..00000000
--- a/tools/testing/selftests/powerpc/pmu/ebb/.gitignore
+++ /dev/null
@@ -1,22 +0,0 @@
-reg_access_test
-event_attributes_test
-cycles_test
-cycles_with_freeze_test
-pmc56_overflow_test
-ebb_vs_cpu_event_test
-cpu_event_vs_ebb_test
-cpu_event_pinned_vs_ebb_test
-task_event_vs_ebb_test
-task_event_pinned_vs_ebb_test
-multi_ebb_procs_test
-multi_counter_test
-pmae_handling_test
-close_clears_pmcc_test
-instruction_count_test
-fork_cleanup_test
-ebb_on_child_test
-ebb_on_willing_child_test
-back_to_back_ebbs_test
-lost_exception_test
-no_handler_test
-cycles_with_mmcr2_test
diff --git a/tools/testing/selftests/powerpc/primitives/.gitignore b/tools/testing/selftests/powerpc/primitives/.gitignore
deleted file mode 100644
index 4cc4e31b..00000000
--- a/tools/testing/selftests/powerpc/primitives/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-load_unaligned_zeropad
diff --git a/tools/testing/selftests/powerpc/ptrace/.gitignore b/tools/testing/selftests/powerpc/ptrace/.gitignore
deleted file mode 100644
index 349acfaf..00000000
--- a/tools/testing/selftests/powerpc/ptrace/.gitignore
+++ /dev/null
@@ -1,10 +0,0 @@
-ptrace-gpr
-ptrace-tm-gpr
-ptrace-tm-spd-gpr
-ptrace-tar
-ptrace-tm-tar
-ptrace-tm-spd-tar
-ptrace-vsx
-ptrace-tm-vsx
-ptrace-tm-spd-vsx
-ptrace-tm-spr
diff --git a/tools/testing/selftests/powerpc/signal/.gitignore b/tools/testing/selftests/powerpc/signal/.gitignore
deleted file mode 100644
index 1b89224a..00000000
--- a/tools/testing/selftests/powerpc/signal/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-signal
-signal_tm
diff --git a/tools/testing/selftests/powerpc/stringloops/.gitignore b/tools/testing/selftests/powerpc/stringloops/.gitignore
deleted file mode 100644
index 0b43da74..00000000
--- a/tools/testing/selftests/powerpc/stringloops/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-memcmp
diff --git a/tools/testing/selftests/powerpc/switch_endian/.gitignore b/tools/testing/selftests/powerpc/switch_endian/.gitignore
deleted file mode 100644
index 89e762ea..00000000
--- a/tools/testing/selftests/powerpc/switch_endian/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-switch_endian_test
-check-reversed.S
diff --git a/tools/testing/selftests/powerpc/syscalls/.gitignore b/tools/testing/selftests/powerpc/syscalls/.gitignore
deleted file mode 100644
index f0f3fcc9..00000000
--- a/tools/testing/selftests/powerpc/syscalls/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-ipc_unmuxed
diff --git a/tools/testing/selftests/powerpc/tm/.gitignore b/tools/testing/selftests/powerpc/tm/.gitignore
deleted file mode 100644
index bb90d4b7..00000000
--- a/tools/testing/selftests/powerpc/tm/.gitignore
+++ /dev/null
@@ -1,16 +0,0 @@
-tm-resched-dscr
-tm-syscall
-tm-signal-msr-resv
-tm-signal-stack
-tm-vmxcopy
-tm-fork
-tm-tar
-tm-tmspr
-tm-exec
-tm-signal-context-chk-fpu
-tm-signal-context-chk-gpr
-tm-signal-context-chk-vmx
-tm-signal-context-chk-vsx
-tm-vmx-unavail
-tm-unavailable
-tm-trap
diff --git a/tools/testing/selftests/powerpc/vphn/.gitignore b/tools/testing/selftests/powerpc/vphn/.gitignore
deleted file mode 100644
index 7c043950..00000000
--- a/tools/testing/selftests/powerpc/vphn/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-test-vphn
diff --git a/tools/testing/selftests/prctl/.gitignore b/tools/testing/selftests/prctl/.gitignore
deleted file mode 100644
index 0b5c2744..00000000
--- a/tools/testing/selftests/prctl/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-disable-tsc-ctxt-sw-stress-test
-disable-tsc-on-off-stress-test
-disable-tsc-test
diff --git a/tools/testing/selftests/proc/.gitignore b/tools/testing/selftests/proc/.gitignore
deleted file mode 100644
index 6c16f77c..00000000
--- a/tools/testing/selftests/proc/.gitignore
+++ /dev/null
@@ -1,8 +0,0 @@
-/proc-loadavg-001
-/proc-self-map-files-001
-/proc-self-map-files-002
-/proc-self-syscall
-/proc-self-wchan
-/proc-uptime-001
-/proc-uptime-002
-/read
diff --git a/tools/testing/selftests/pstore/.gitignore b/tools/testing/selftests/pstore/.gitignore
deleted file mode 100644
index 5a4a26e5..00000000
--- a/tools/testing/selftests/pstore/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-logs
-*uuid
diff --git a/tools/testing/selftests/ptp/.gitignore b/tools/testing/selftests/ptp/.gitignore
deleted file mode 100644
index f562e49d..00000000
--- a/tools/testing/selftests/ptp/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-testptp
diff --git a/tools/testing/selftests/ptrace/.gitignore b/tools/testing/selftests/ptrace/.gitignore
deleted file mode 100644
index b3e59d41..00000000
--- a/tools/testing/selftests/ptrace/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-peeksiginfo
diff --git a/tools/testing/selftests/rcutorture/.gitignore b/tools/testing/selftests/rcutorture/.gitignore
deleted file mode 100644
index ccc24027..00000000
--- a/tools/testing/selftests/rcutorture/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-initrd
-b[0-9]*
-res
-*.swp
diff --git a/tools/testing/selftests/rcutorture/formal/srcu-cbmc/.gitignore b/tools/testing/selftests/rcutorture/formal/srcu-cbmc/.gitignore
deleted file mode 100644
index 712a3d41..00000000
--- a/tools/testing/selftests/rcutorture/formal/srcu-cbmc/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-srcu.c
diff --git a/tools/testing/selftests/rcutorture/formal/srcu-cbmc/include/linux/.gitignore b/tools/testing/selftests/rcutorture/formal/srcu-cbmc/include/linux/.gitignore
deleted file mode 100644
index 1d016e66..00000000
--- a/tools/testing/selftests/rcutorture/formal/srcu-cbmc/include/linux/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-srcu.h
diff --git a/tools/testing/selftests/rcutorture/formal/srcu-cbmc/tests/store_buffering/.gitignore b/tools/testing/selftests/rcutorture/formal/srcu-cbmc/tests/store_buffering/.gitignore
deleted file mode 100644
index f47cb204..00000000
--- a/tools/testing/selftests/rcutorture/formal/srcu-cbmc/tests/store_buffering/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-*.out
diff --git a/tools/testing/selftests/seccomp/.gitignore b/tools/testing/selftests/seccomp/.gitignore
deleted file mode 100644
index 5af29d3a..00000000
--- a/tools/testing/selftests/seccomp/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-seccomp_bpf
-seccomp_benchmark
diff --git a/tools/testing/selftests/sigaltstack/.gitignore b/tools/testing/selftests/sigaltstack/.gitignore
deleted file mode 100644
index 35897b0a..00000000
--- a/tools/testing/selftests/sigaltstack/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-sas
diff --git a/tools/testing/selftests/size/.gitignore b/tools/testing/selftests/size/.gitignore
deleted file mode 100644
index 189b7818..00000000
--- a/tools/testing/selftests/size/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-get_size
diff --git a/tools/testing/selftests/splice/.gitignore b/tools/testing/selftests/splice/.gitignore
deleted file mode 100644
index 1e23fefd..00000000
--- a/tools/testing/selftests/splice/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-default_file_splice_read
diff --git a/tools/testing/selftests/sync/.gitignore b/tools/testing/selftests/sync/.gitignore
deleted file mode 100644
index f5091e77..00000000
--- a/tools/testing/selftests/sync/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-sync_test
diff --git a/tools/testing/selftests/tc-testing/.gitignore b/tools/testing/selftests/tc-testing/.gitignore
deleted file mode 100644
index 7a60b85e..00000000
--- a/tools/testing/selftests/tc-testing/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-__pycache__/
-*.pyc
diff --git a/tools/testing/selftests/timers/.gitignore b/tools/testing/selftests/timers/.gitignore
deleted file mode 100644
index 2c8ac841..00000000
--- a/tools/testing/selftests/timers/.gitignore
+++ /dev/null
@@ -1,22 +0,0 @@
-alarmtimer-suspend
-change_skew
-clocksource-switch
-inconsistency-check
-leap-a-day
-leapcrash
-mqueue-lat
-nanosleep
-nsleep-lat
-posix_timers
-raw_skew
-rtctest
-set-2038
-set-tai
-set-timer-lat
-skew_consistency
-threadtest
-valid-adjtimex
-adjtick
-set-tz
-freq-step
-rtctest_setdate
diff --git a/tools/testing/selftests/vDSO/.gitignore b/tools/testing/selftests/vDSO/.gitignore
deleted file mode 100644
index 133bf9ee..00000000
--- a/tools/testing/selftests/vDSO/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-vdso_test
-vdso_standalone_test_x86
diff --git a/tools/testing/selftests/vm/.gitignore b/tools/testing/selftests/vm/.gitignore
deleted file mode 100644
index 342c7bc9..00000000
--- a/tools/testing/selftests/vm/.gitignore
+++ /dev/null
@@ -1,14 +0,0 @@
-hugepage-mmap
-hugepage-shm
-map_hugetlb
-thuge-gen
-compaction_test
-mlock2-tests
-on-fault-limit
-transhuge-stress
-userfaultfd
-mlock-intersect-test
-mlock-random-test
-virtual_address_range
-gup_benchmark
-va_128TBswitch
diff --git a/tools/testing/selftests/watchdog/.gitignore b/tools/testing/selftests/watchdog/.gitignore
deleted file mode 100644
index 5aac5157..00000000
--- a/tools/testing/selftests/watchdog/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-watchdog-test
diff --git a/tools/testing/selftests/x86/.gitignore b/tools/testing/selftests/x86/.gitignore
deleted file mode 100644
index 7757f73f..00000000
--- a/tools/testing/selftests/x86/.gitignore
+++ /dev/null
@@ -1,15 +0,0 @@
-*_32
-*_64
-single_step_syscall
-sysret_ss_attrs
-syscall_nt
-ptrace_syscall
-test_mremap_vdso
-check_initial_reg_state
-sigreturn
-ldt_gdt
-iopl
-mpx-mini-test
-ioperm
-protection_keys
-test_vdso
diff --git a/tools/testing/vsock/.gitignore b/tools/testing/vsock/.gitignore
deleted file mode 100644
index dc5f11fa..00000000
--- a/tools/testing/vsock/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-*.d
-vsock_diag_test
diff --git a/tools/thermal/tmon/.gitignore b/tools/thermal/tmon/.gitignore
deleted file mode 100644
index 06e96be6..00000000
--- a/tools/thermal/tmon/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/tmon
diff --git a/tools/usb/.gitignore b/tools/usb/.gitignore
deleted file mode 100644
index 1b744898..00000000
--- a/tools/usb/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-ffs-test
-testusb
diff --git a/tools/usb/usbip/.gitignore b/tools/usb/usbip/.gitignore
deleted file mode 100644
index 03b892c8..00000000
--- a/tools/usb/usbip/.gitignore
+++ /dev/null
@@ -1,32 +0,0 @@
-Makefile
-Makefile.in
-aclocal.m4
-autom4te.cache/
-compile
-config.guess
-config.h
-config.h.in
-config.log
-config.status
-config.sub
-configure
-depcomp
-install-sh
-libsrc/Makefile
-libsrc/Makefile.in
-libtool
-ltmain.sh
-missing
-src/Makefile
-src/Makefile.in
-stamp-h1
-libsrc/libusbip.la
-libsrc/libusbip_la-names.lo
-libsrc/libusbip_la-sysfs_utils.lo
-libsrc/libusbip_la-usbip_common.lo
-libsrc/libusbip_la-usbip_device_driver.lo
-libsrc/libusbip_la-usbip_host_common.lo
-libsrc/libusbip_la-usbip_host_driver.lo
-libsrc/libusbip_la-vhci_driver.lo
-src/usbip
-src/usbipd
diff --git a/tools/virtio/.gitignore b/tools/virtio/.gitignore
deleted file mode 100644
index 1cfbb015..00000000
--- a/tools/virtio/.gitignore
+++ /dev/null
@@ -1,3 +0,0 @@
-*.d
-virtio_test
-vringh_test
diff --git a/tools/vm/.gitignore b/tools/vm/.gitignore
deleted file mode 100644
index 44f095fa..00000000
--- a/tools/vm/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-slabinfo
-page-types
diff --git a/usr/.gitignore b/usr/.gitignore
deleted file mode 100644
index 8e48117a..00000000
--- a/usr/.gitignore
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# Generated files
-#
-gen_init_cpio
-initramfs_data.cpio
-initramfs_data.cpio.gz
-initramfs_data.cpio.bz2
-initramfs_data.cpio.lzma
-initramfs_list
-include
-- 
2.17.1

